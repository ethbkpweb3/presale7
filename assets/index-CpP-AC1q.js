const __vite__mapDeps = (
  i,
  m = __vite__mapDeps,
  d = m.f ||
    (m.f = [
      "assets/index-0e7SkSfJ.js",
      "assets/number-nqXiOzZ1.js",
      "assets/index-DcXKPjle.js",
      "assets/index-40a497ea-B-e4dja1.js",
      "assets/index-021f6a62-BcF70HI7.js",
      "assets/torus.esm-DhhKzN1Z.js",
      "assets/index-CVIP3emZ.js",
      "assets/events-sPNiP9gX.js",
      "assets/index.es-CXxqt0IP.js",
      "assets/_commonjs-dynamic-modules-TDtrdbi3.js",
      "assets/index-BQ3hr_zk.js",
      "assets/index-YFI_ZhEv.js",
      "assets/solanaEmbed.esm-XgTVzOa-.js",
    ])
) => i.map((i) => d[i]);
var Ppe = Object.defineProperty;
var Lpe = (e, t, n) =>
  t in e
    ? Ppe(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
    : (e[t] = n);
var Ls = (e, t, n) => Lpe(e, typeof t != "symbol" ? t + "" : t, n);
function yq(e, t) {
  for (var n = 0; n < t.length; n++) {
    const r = t[n];
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const i in r)
        if (i !== "default" && !(i in e)) {
          const s = Object.getOwnPropertyDescriptor(r, i);
          s &&
            Object.defineProperty(
              e,
              i,
              s.get ? s : { enumerable: !0, get: () => r[i] }
            );
        }
    }
  }
  return Object.freeze(
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" })
  );
}
(function () {
  const t = document.createElement("link").relList;
  if (t && t.supports && t.supports("modulepreload")) return;
  for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i);
  new MutationObserver((i) => {
    for (const s of i)
      if (s.type === "childList")
        for (const o of s.addedNodes)
          o.tagName === "LINK" && o.rel === "modulepreload" && r(o);
  }).observe(document, { childList: !0, subtree: !0 });
  function n(i) {
    const s = {};
    return (
      i.integrity && (s.integrity = i.integrity),
      i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy),
      i.crossOrigin === "use-credentials"
        ? (s.credentials = "include")
        : i.crossOrigin === "anonymous"
        ? (s.credentials = "omit")
        : (s.credentials = "same-origin"),
      s
    );
  }
  function r(i) {
    if (i.ep) return;
    i.ep = !0;
    const s = n(i);
    fetch(i.href, s);
  }
})();
var Bn =
  typeof globalThis < "u"
    ? globalThis
    : typeof window < "u"
    ? window
    : typeof global < "u"
    ? global
    : typeof self < "u"
    ? self
    : {};
function Gi(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default")
    ? e.default
    : e;
}
function ix(e) {
  if (e.__esModule) return e;
  var t = e.default;
  if (typeof t == "function") {
    var n = function r() {
      return this instanceof r
        ? Reflect.construct(t, arguments, this.constructor)
        : t.apply(this, arguments);
    };
    n.prototype = t.prototype;
  } else n = {};
  return (
    Object.defineProperty(n, "__esModule", { value: !0 }),
    Object.keys(e).forEach(function (r) {
      var i = Object.getOwnPropertyDescriptor(e, r);
      Object.defineProperty(
        n,
        r,
        i.get
          ? i
          : {
              enumerable: !0,
              get: function () {
                return e[r];
              },
            }
      );
    }),
    n
  );
}
var vq = { exports: {} },
  OS = {},
  wq = { exports: {} },
  yr = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var sx = Symbol.for("react.element"),
  jpe = Symbol.for("react.portal"),
  Dpe = Symbol.for("react.fragment"),
  Bpe = Symbol.for("react.strict_mode"),
  Fpe = Symbol.for("react.profiler"),
  Upe = Symbol.for("react.provider"),
  $pe = Symbol.for("react.context"),
  zpe = Symbol.for("react.forward_ref"),
  Wpe = Symbol.for("react.suspense"),
  Hpe = Symbol.for("react.memo"),
  Vpe = Symbol.for("react.lazy"),
  KD = Symbol.iterator;
function Gpe(e) {
  return e === null || typeof e != "object"
    ? null
    : ((e = (KD && e[KD]) || e["@@iterator"]),
      typeof e == "function" ? e : null);
}
var bq = {
    isMounted: function () {
      return !1;
    },
    enqueueForceUpdate: function () {},
    enqueueReplaceState: function () {},
    enqueueSetState: function () {},
  },
  xq = Object.assign,
  _q = {};
function tv(e, t, n) {
  (this.props = e),
    (this.context = t),
    (this.refs = _q),
    (this.updater = n || bq);
}
tv.prototype.isReactComponent = {};
tv.prototype.setState = function (e, t) {
  if (typeof e != "object" && typeof e != "function" && e != null)
    throw Error(
      "setState(...): takes an object of state variables to update or a function which returns an object of state variables."
    );
  this.updater.enqueueSetState(this, e, t, "setState");
};
tv.prototype.forceUpdate = function (e) {
  this.updater.enqueueForceUpdate(this, e, "forceUpdate");
};
function Sq() {}
Sq.prototype = tv.prototype;
function DI(e, t, n) {
  (this.props = e),
    (this.context = t),
    (this.refs = _q),
    (this.updater = n || bq);
}
var BI = (DI.prototype = new Sq());
BI.constructor = DI;
xq(BI, tv.prototype);
BI.isPureReactComponent = !0;
var YD = Array.isArray,
  Eq = Object.prototype.hasOwnProperty,
  FI = { current: null },
  Aq = { key: !0, ref: !0, __self: !0, __source: !0 };
function Cq(e, t, n) {
  var r,
    i = {},
    s = null,
    o = null;
  if (t != null)
    for (r in (t.ref !== void 0 && (o = t.ref),
    t.key !== void 0 && (s = "" + t.key),
    t))
      Eq.call(t, r) && !Aq.hasOwnProperty(r) && (i[r] = t[r]);
  var a = arguments.length - 2;
  if (a === 1) i.children = n;
  else if (1 < a) {
    for (var l = Array(a), c = 0; c < a; c++) l[c] = arguments[c + 2];
    i.children = l;
  }
  if (e && e.defaultProps)
    for (r in ((a = e.defaultProps), a)) i[r] === void 0 && (i[r] = a[r]);
  return {
    $$typeof: sx,
    type: e,
    key: s,
    ref: o,
    props: i,
    _owner: FI.current,
  };
}
function qpe(e, t) {
  return {
    $$typeof: sx,
    type: e.type,
    key: t,
    ref: e.ref,
    props: e.props,
    _owner: e._owner,
  };
}
function UI(e) {
  return typeof e == "object" && e !== null && e.$$typeof === sx;
}
function Kpe(e) {
  var t = { "=": "=0", ":": "=2" };
  return (
    "$" +
    e.replace(/[=:]/g, function (n) {
      return t[n];
    })
  );
}
var ZD = /\/+/g;
function tA(e, t) {
  return typeof e == "object" && e !== null && e.key != null
    ? Kpe("" + e.key)
    : t.toString(36);
}
function u4(e, t, n, r, i) {
  var s = typeof e;
  (s === "undefined" || s === "boolean") && (e = null);
  var o = !1;
  if (e === null) o = !0;
  else
    switch (s) {
      case "string":
      case "number":
        o = !0;
        break;
      case "object":
        switch (e.$$typeof) {
          case sx:
          case jpe:
            o = !0;
        }
    }
  if (o)
    return (
      (o = e),
      (i = i(o)),
      (e = r === "" ? "." + tA(o, 0) : r),
      YD(i)
        ? ((n = ""),
          e != null && (n = e.replace(ZD, "$&/") + "/"),
          u4(i, t, n, "", function (c) {
            return c;
          }))
        : i != null &&
          (UI(i) &&
            (i = qpe(
              i,
              n +
                (!i.key || (o && o.key === i.key)
                  ? ""
                  : ("" + i.key).replace(ZD, "$&/") + "/") +
                e
            )),
          t.push(i)),
      1
    );
  if (((o = 0), (r = r === "" ? "." : r + ":"), YD(e)))
    for (var a = 0; a < e.length; a++) {
      s = e[a];
      var l = r + tA(s, a);
      o += u4(s, t, n, l, i);
    }
  else if (((l = Gpe(e)), typeof l == "function"))
    for (e = l.call(e), a = 0; !(s = e.next()).done; )
      (s = s.value), (l = r + tA(s, a++)), (o += u4(s, t, n, l, i));
  else if (s === "object")
    throw (
      ((t = String(e)),
      Error(
        "Objects are not valid as a React child (found: " +
          (t === "[object Object]"
            ? "object with keys {" + Object.keys(e).join(", ") + "}"
            : t) +
          "). If you meant to render a collection of children, use an array instead."
      ))
    );
  return o;
}
function t_(e, t, n) {
  if (e == null) return e;
  var r = [],
    i = 0;
  return (
    u4(e, r, "", "", function (s) {
      return t.call(n, s, i++);
    }),
    r
  );
}
function Ype(e) {
  if (e._status === -1) {
    var t = e._result;
    (t = t()),
      t.then(
        function (n) {
          (e._status === 0 || e._status === -1) &&
            ((e._status = 1), (e._result = n));
        },
        function (n) {
          (e._status === 0 || e._status === -1) &&
            ((e._status = 2), (e._result = n));
        }
      ),
      e._status === -1 && ((e._status = 0), (e._result = t));
  }
  if (e._status === 1) return e._result.default;
  throw e._result;
}
var Pa = { current: null },
  d4 = { transition: null },
  Zpe = {
    ReactCurrentDispatcher: Pa,
    ReactCurrentBatchConfig: d4,
    ReactCurrentOwner: FI,
  };
function kq() {
  throw Error("act(...) is not supported in production builds of React.");
}
yr.Children = {
  map: t_,
  forEach: function (e, t, n) {
    t_(
      e,
      function () {
        t.apply(this, arguments);
      },
      n
    );
  },
  count: function (e) {
    var t = 0;
    return (
      t_(e, function () {
        t++;
      }),
      t
    );
  },
  toArray: function (e) {
    return (
      t_(e, function (t) {
        return t;
      }) || []
    );
  },
  only: function (e) {
    if (!UI(e))
      throw Error(
        "React.Children.only expected to receive a single React element child."
      );
    return e;
  },
};
yr.Component = tv;
yr.Fragment = Dpe;
yr.Profiler = Fpe;
yr.PureComponent = DI;
yr.StrictMode = Bpe;
yr.Suspense = Wpe;
yr.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Zpe;
yr.act = kq;
yr.cloneElement = function (e, t, n) {
  if (e == null)
    throw Error(
      "React.cloneElement(...): The argument must be a React element, but you passed " +
        e +
        "."
    );
  var r = xq({}, e.props),
    i = e.key,
    s = e.ref,
    o = e._owner;
  if (t != null) {
    if (
      (t.ref !== void 0 && ((s = t.ref), (o = FI.current)),
      t.key !== void 0 && (i = "" + t.key),
      e.type && e.type.defaultProps)
    )
      var a = e.type.defaultProps;
    for (l in t)
      Eq.call(t, l) &&
        !Aq.hasOwnProperty(l) &&
        (r[l] = t[l] === void 0 && a !== void 0 ? a[l] : t[l]);
  }
  var l = arguments.length - 2;
  if (l === 1) r.children = n;
  else if (1 < l) {
    a = Array(l);
    for (var c = 0; c < l; c++) a[c] = arguments[c + 2];
    r.children = a;
  }
  return { $$typeof: sx, type: e.type, key: i, ref: s, props: r, _owner: o };
};
yr.createContext = function (e) {
  return (
    (e = {
      $$typeof: $pe,
      _currentValue: e,
      _currentValue2: e,
      _threadCount: 0,
      Provider: null,
      Consumer: null,
      _defaultValue: null,
      _globalName: null,
    }),
    (e.Provider = { $$typeof: Upe, _context: e }),
    (e.Consumer = e)
  );
};
yr.createElement = Cq;
yr.createFactory = function (e) {
  var t = Cq.bind(null, e);
  return (t.type = e), t;
};
yr.createRef = function () {
  return { current: null };
};
yr.forwardRef = function (e) {
  return { $$typeof: zpe, render: e };
};
yr.isValidElement = UI;
yr.lazy = function (e) {
  return { $$typeof: Vpe, _payload: { _status: -1, _result: e }, _init: Ype };
};
yr.memo = function (e, t) {
  return { $$typeof: Hpe, type: e, compare: t === void 0 ? null : t };
};
yr.startTransition = function (e) {
  var t = d4.transition;
  d4.transition = {};
  try {
    e();
  } finally {
    d4.transition = t;
  }
};
yr.unstable_act = kq;
yr.useCallback = function (e, t) {
  return Pa.current.useCallback(e, t);
};
yr.useContext = function (e) {
  return Pa.current.useContext(e);
};
yr.useDebugValue = function () {};
yr.useDeferredValue = function (e) {
  return Pa.current.useDeferredValue(e);
};
yr.useEffect = function (e, t) {
  return Pa.current.useEffect(e, t);
};
yr.useId = function () {
  return Pa.current.useId();
};
yr.useImperativeHandle = function (e, t, n) {
  return Pa.current.useImperativeHandle(e, t, n);
};
yr.useInsertionEffect = function (e, t) {
  return Pa.current.useInsertionEffect(e, t);
};
yr.useLayoutEffect = function (e, t) {
  return Pa.current.useLayoutEffect(e, t);
};
yr.useMemo = function (e, t) {
  return Pa.current.useMemo(e, t);
};
yr.useReducer = function (e, t, n) {
  return Pa.current.useReducer(e, t, n);
};
yr.useRef = function (e) {
  return Pa.current.useRef(e);
};
yr.useState = function (e) {
  return Pa.current.useState(e);
};
yr.useSyncExternalStore = function (e, t, n) {
  return Pa.current.useSyncExternalStore(e, t, n);
};
yr.useTransition = function () {
  return Pa.current.useTransition();
};
yr.version = "18.3.1";
wq.exports = yr;
var Y = wq.exports;
const Ce = Gi(Y),
  tk = yq({ __proto__: null, default: Ce }, [Y]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Qpe = Y,
  Xpe = Symbol.for("react.element"),
  Jpe = Symbol.for("react.fragment"),
  e0e = Object.prototype.hasOwnProperty,
  t0e =
    Qpe.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
  n0e = { key: !0, ref: !0, __self: !0, __source: !0 };
function Tq(e, t, n) {
  var r,
    i = {},
    s = null,
    o = null;
  n !== void 0 && (s = "" + n),
    t.key !== void 0 && (s = "" + t.key),
    t.ref !== void 0 && (o = t.ref);
  for (r in t) e0e.call(t, r) && !n0e.hasOwnProperty(r) && (i[r] = t[r]);
  if (e && e.defaultProps)
    for (r in ((t = e.defaultProps), t)) i[r] === void 0 && (i[r] = t[r]);
  return {
    $$typeof: Xpe,
    type: e,
    key: s,
    ref: o,
    props: i,
    _owner: t0e.current,
  };
}
OS.Fragment = Jpe;
OS.jsx = Tq;
OS.jsxs = Tq;
vq.exports = OS;
var m = vq.exports,
  nk = {},
  Mq = { exports: {} },
  Wl = {},
  Iq = { exports: {} },
  Nq = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ (function (e) {
  function t(F, D) {
    var j = F.length;
    F.push(D);
    e: for (; 0 < j; ) {
      var z = (j - 1) >>> 1,
        $ = F[z];
      if (0 < i($, D)) (F[z] = D), (F[j] = $), (j = z);
      else break e;
    }
  }
  function n(F) {
    return F.length === 0 ? null : F[0];
  }
  function r(F) {
    if (F.length === 0) return null;
    var D = F[0],
      j = F.pop();
    if (j !== D) {
      F[0] = j;
      e: for (var z = 0, $ = F.length, K = $ >>> 1; z < K; ) {
        var re = 2 * (z + 1) - 1,
          G = F[re],
          ne = re + 1,
          ae = F[ne];
        if (0 > i(G, j))
          ne < $ && 0 > i(ae, G)
            ? ((F[z] = ae), (F[ne] = j), (z = ne))
            : ((F[z] = G), (F[re] = j), (z = re));
        else if (ne < $ && 0 > i(ae, j)) (F[z] = ae), (F[ne] = j), (z = ne);
        else break e;
      }
    }
    return D;
  }
  function i(F, D) {
    var j = F.sortIndex - D.sortIndex;
    return j !== 0 ? j : F.id - D.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var s = performance;
    e.unstable_now = function () {
      return s.now();
    };
  } else {
    var o = Date,
      a = o.now();
    e.unstable_now = function () {
      return o.now() - a;
    };
  }
  var l = [],
    c = [],
    u = 1,
    d = null,
    f = 3,
    h = !1,
    p = !1,
    g = !1,
    b = typeof setTimeout == "function" ? setTimeout : null,
    v = typeof clearTimeout == "function" ? clearTimeout : null,
    w = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function x(F) {
    for (var D = n(c); D !== null; ) {
      if (D.callback === null) r(c);
      else if (D.startTime <= F)
        r(c), (D.sortIndex = D.expirationTime), t(l, D);
      else break;
      D = n(c);
    }
  }
  function S(F) {
    if (((g = !1), x(F), !p))
      if (n(l) !== null) (p = !0), N(R);
      else {
        var D = n(c);
        D !== null && L(S, D.startTime - F);
      }
  }
  function R(F, D) {
    (p = !1), g && ((g = !1), v(C), (C = -1)), (h = !0);
    var j = f;
    try {
      for (
        x(D), d = n(l);
        d !== null && (!(d.expirationTime > D) || (F && !M()));

      ) {
        var z = d.callback;
        if (typeof z == "function") {
          (d.callback = null), (f = d.priorityLevel);
          var $ = z(d.expirationTime <= D);
          (D = e.unstable_now()),
            typeof $ == "function" ? (d.callback = $) : d === n(l) && r(l),
            x(D);
        } else r(l);
        d = n(l);
      }
      if (d !== null) var K = !0;
      else {
        var re = n(c);
        re !== null && L(S, re.startTime - D), (K = !1);
      }
      return K;
    } finally {
      (d = null), (f = j), (h = !1);
    }
  }
  var O = !1,
    B = null,
    C = -1,
    I = 5,
    P = -1;
  function M() {
    return !(e.unstable_now() - P < I);
  }
  function k() {
    if (B !== null) {
      var F = e.unstable_now();
      P = F;
      var D = !0;
      try {
        D = B(!0, F);
      } finally {
        D ? T() : ((O = !1), (B = null));
      }
    } else O = !1;
  }
  var T;
  if (typeof w == "function")
    T = function () {
      w(k);
    };
  else if (typeof MessageChannel < "u") {
    var _ = new MessageChannel(),
      A = _.port2;
    (_.port1.onmessage = k),
      (T = function () {
        A.postMessage(null);
      });
  } else
    T = function () {
      b(k, 0);
    };
  function N(F) {
    (B = F), O || ((O = !0), T());
  }
  function L(F, D) {
    C = b(function () {
      F(e.unstable_now());
    }, D);
  }
  (e.unstable_IdlePriority = 5),
    (e.unstable_ImmediatePriority = 1),
    (e.unstable_LowPriority = 4),
    (e.unstable_NormalPriority = 3),
    (e.unstable_Profiling = null),
    (e.unstable_UserBlockingPriority = 2),
    (e.unstable_cancelCallback = function (F) {
      F.callback = null;
    }),
    (e.unstable_continueExecution = function () {
      p || h || ((p = !0), N(R));
    }),
    (e.unstable_forceFrameRate = function (F) {
      0 > F || 125 < F
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          )
        : (I = 0 < F ? Math.floor(1e3 / F) : 5);
    }),
    (e.unstable_getCurrentPriorityLevel = function () {
      return f;
    }),
    (e.unstable_getFirstCallbackNode = function () {
      return n(l);
    }),
    (e.unstable_next = function (F) {
      switch (f) {
        case 1:
        case 2:
        case 3:
          var D = 3;
          break;
        default:
          D = f;
      }
      var j = f;
      f = D;
      try {
        return F();
      } finally {
        f = j;
      }
    }),
    (e.unstable_pauseExecution = function () {}),
    (e.unstable_requestPaint = function () {}),
    (e.unstable_runWithPriority = function (F, D) {
      switch (F) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          F = 3;
      }
      var j = f;
      f = F;
      try {
        return D();
      } finally {
        f = j;
      }
    }),
    (e.unstable_scheduleCallback = function (F, D, j) {
      var z = e.unstable_now();
      switch (
        (typeof j == "object" && j !== null
          ? ((j = j.delay), (j = typeof j == "number" && 0 < j ? z + j : z))
          : (j = z),
        F)
      ) {
        case 1:
          var $ = -1;
          break;
        case 2:
          $ = 250;
          break;
        case 5:
          $ = 1073741823;
          break;
        case 4:
          $ = 1e4;
          break;
        default:
          $ = 5e3;
      }
      return (
        ($ = j + $),
        (F = {
          id: u++,
          callback: D,
          priorityLevel: F,
          startTime: j,
          expirationTime: $,
          sortIndex: -1,
        }),
        j > z
          ? ((F.sortIndex = j),
            t(c, F),
            n(l) === null &&
              F === n(c) &&
              (g ? (v(C), (C = -1)) : (g = !0), L(S, j - z)))
          : ((F.sortIndex = $), t(l, F), p || h || ((p = !0), N(R))),
        F
      );
    }),
    (e.unstable_shouldYield = M),
    (e.unstable_wrapCallback = function (F) {
      var D = f;
      return function () {
        var j = f;
        f = D;
        try {
          return F.apply(this, arguments);
        } finally {
          f = j;
        }
      };
    });
})(Nq);
Iq.exports = Nq;
var r0e = Iq.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var i0e = Y,
  Fl = r0e;
function lt(e) {
  for (
    var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1;
    n < arguments.length;
    n++
  )
    t += "&args[]=" + encodeURIComponent(arguments[n]);
  return (
    "Minified React error #" +
    e +
    "; visit " +
    t +
    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
  );
}
var Rq = new Set(),
  Dw = {};
function u1(e, t) {
  fy(e, t), fy(e + "Capture", t);
}
function fy(e, t) {
  for (Dw[e] = t, e = 0; e < t.length; e++) Rq.add(t[e]);
}
var ih = !(
    typeof window > "u" ||
    typeof window.document > "u" ||
    typeof window.document.createElement > "u"
  ),
  rk = Object.prototype.hasOwnProperty,
  s0e =
    /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
  QD = {},
  XD = {};
function o0e(e) {
  return rk.call(XD, e)
    ? !0
    : rk.call(QD, e)
    ? !1
    : s0e.test(e)
    ? (XD[e] = !0)
    : ((QD[e] = !0), !1);
}
function a0e(e, t, n, r) {
  if (n !== null && n.type === 0) return !1;
  switch (typeof t) {
    case "function":
    case "symbol":
      return !0;
    case "boolean":
      return r
        ? !1
        : n !== null
        ? !n.acceptsBooleans
        : ((e = e.toLowerCase().slice(0, 5)), e !== "data-" && e !== "aria-");
    default:
      return !1;
  }
}
function l0e(e, t, n, r) {
  if (t === null || typeof t > "u" || a0e(e, t, n, r)) return !0;
  if (r) return !1;
  if (n !== null)
    switch (n.type) {
      case 3:
        return !t;
      case 4:
        return t === !1;
      case 5:
        return isNaN(t);
      case 6:
        return isNaN(t) || 1 > t;
    }
  return !1;
}
function La(e, t, n, r, i, s, o) {
  (this.acceptsBooleans = t === 2 || t === 3 || t === 4),
    (this.attributeName = r),
    (this.attributeNamespace = i),
    (this.mustUseProperty = n),
    (this.propertyName = e),
    (this.type = t),
    (this.sanitizeURL = s),
    (this.removeEmptyString = o);
}
var $o = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
  .split(" ")
  .forEach(function (e) {
    $o[e] = new La(e, 0, !1, e, null, !1, !1);
  });
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"],
].forEach(function (e) {
  var t = e[0];
  $o[t] = new La(t, 1, !1, e[1], null, !1, !1);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function (e) {
  $o[e] = new La(e, 2, !1, e.toLowerCase(), null, !1, !1);
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha",
].forEach(function (e) {
  $o[e] = new La(e, 2, !1, e, null, !1, !1);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
  .split(" ")
  .forEach(function (e) {
    $o[e] = new La(e, 3, !1, e.toLowerCase(), null, !1, !1);
  });
["checked", "multiple", "muted", "selected"].forEach(function (e) {
  $o[e] = new La(e, 3, !0, e, null, !1, !1);
});
["capture", "download"].forEach(function (e) {
  $o[e] = new La(e, 4, !1, e, null, !1, !1);
});
["cols", "rows", "size", "span"].forEach(function (e) {
  $o[e] = new La(e, 6, !1, e, null, !1, !1);
});
["rowSpan", "start"].forEach(function (e) {
  $o[e] = new La(e, 5, !1, e.toLowerCase(), null, !1, !1);
});
var $I = /[\-:]([a-z])/g;
function zI(e) {
  return e[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
  .split(" ")
  .forEach(function (e) {
    var t = e.replace($I, zI);
    $o[t] = new La(t, 1, !1, e, null, !1, !1);
  });
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type"
  .split(" ")
  .forEach(function (e) {
    var t = e.replace($I, zI);
    $o[t] = new La(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1);
  });
["xml:base", "xml:lang", "xml:space"].forEach(function (e) {
  var t = e.replace($I, zI);
  $o[t] = new La(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1);
});
["tabIndex", "crossOrigin"].forEach(function (e) {
  $o[e] = new La(e, 1, !1, e.toLowerCase(), null, !1, !1);
});
$o.xlinkHref = new La(
  "xlinkHref",
  1,
  !1,
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  !1
);
["src", "href", "action", "formAction"].forEach(function (e) {
  $o[e] = new La(e, 1, !1, e.toLowerCase(), null, !0, !0);
});
function WI(e, t, n, r) {
  var i = $o.hasOwnProperty(t) ? $o[t] : null;
  (i !== null
    ? i.type !== 0
    : r ||
      !(2 < t.length) ||
      (t[0] !== "o" && t[0] !== "O") ||
      (t[1] !== "n" && t[1] !== "N")) &&
    (l0e(t, n, i, r) && (n = null),
    r || i === null
      ? o0e(t) &&
        (n === null ? e.removeAttribute(t) : e.setAttribute(t, "" + n))
      : i.mustUseProperty
      ? (e[i.propertyName] = n === null ? (i.type === 3 ? !1 : "") : n)
      : ((t = i.attributeName),
        (r = i.attributeNamespace),
        n === null
          ? e.removeAttribute(t)
          : ((i = i.type),
            (n = i === 3 || (i === 4 && n === !0) ? "" : "" + n),
            r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n))));
}
var yh = i0e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  n_ = Symbol.for("react.element"),
  cg = Symbol.for("react.portal"),
  ug = Symbol.for("react.fragment"),
  HI = Symbol.for("react.strict_mode"),
  ik = Symbol.for("react.profiler"),
  Oq = Symbol.for("react.provider"),
  Pq = Symbol.for("react.context"),
  VI = Symbol.for("react.forward_ref"),
  sk = Symbol.for("react.suspense"),
  ok = Symbol.for("react.suspense_list"),
  GI = Symbol.for("react.memo"),
  lp = Symbol.for("react.lazy"),
  Lq = Symbol.for("react.offscreen"),
  JD = Symbol.iterator;
function c2(e) {
  return e === null || typeof e != "object"
    ? null
    : ((e = (JD && e[JD]) || e["@@iterator"]),
      typeof e == "function" ? e : null);
}
var ms = Object.assign,
  nA;
function W2(e) {
  if (nA === void 0)
    try {
      throw Error();
    } catch (n) {
      var t = n.stack.trim().match(/\n( *(at )?)/);
      nA = (t && t[1]) || "";
    }
  return (
    `
` +
    nA +
    e
  );
}
var rA = !1;
function iA(e, t) {
  if (!e || rA) return "";
  rA = !0;
  var n = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (t)
      if (
        ((t = function () {
          throw Error();
        }),
        Object.defineProperty(t.prototype, "props", {
          set: function () {
            throw Error();
          },
        }),
        typeof Reflect == "object" && Reflect.construct)
      ) {
        try {
          Reflect.construct(t, []);
        } catch (c) {
          var r = c;
        }
        Reflect.construct(e, [], t);
      } else {
        try {
          t.call();
        } catch (c) {
          r = c;
        }
        e.call(t.prototype);
      }
    else {
      try {
        throw Error();
      } catch (c) {
        r = c;
      }
      e();
    }
  } catch (c) {
    if (c && r && typeof c.stack == "string") {
      for (
        var i = c.stack.split(`
`),
          s = r.stack.split(`
`),
          o = i.length - 1,
          a = s.length - 1;
        1 <= o && 0 <= a && i[o] !== s[a];

      )
        a--;
      for (; 1 <= o && 0 <= a; o--, a--)
        if (i[o] !== s[a]) {
          if (o !== 1 || a !== 1)
            do
              if ((o--, a--, 0 > a || i[o] !== s[a])) {
                var l =
                  `
` + i[o].replace(" at new ", " at ");
                return (
                  e.displayName &&
                    l.includes("<anonymous>") &&
                    (l = l.replace("<anonymous>", e.displayName)),
                  l
                );
              }
            while (1 <= o && 0 <= a);
          break;
        }
    }
  } finally {
    (rA = !1), (Error.prepareStackTrace = n);
  }
  return (e = e ? e.displayName || e.name : "") ? W2(e) : "";
}
function c0e(e) {
  switch (e.tag) {
    case 5:
      return W2(e.type);
    case 16:
      return W2("Lazy");
    case 13:
      return W2("Suspense");
    case 19:
      return W2("SuspenseList");
    case 0:
    case 2:
    case 15:
      return (e = iA(e.type, !1)), e;
    case 11:
      return (e = iA(e.type.render, !1)), e;
    case 1:
      return (e = iA(e.type, !0)), e;
    default:
      return "";
  }
}
function ak(e) {
  if (e == null) return null;
  if (typeof e == "function") return e.displayName || e.name || null;
  if (typeof e == "string") return e;
  switch (e) {
    case ug:
      return "Fragment";
    case cg:
      return "Portal";
    case ik:
      return "Profiler";
    case HI:
      return "StrictMode";
    case sk:
      return "Suspense";
    case ok:
      return "SuspenseList";
  }
  if (typeof e == "object")
    switch (e.$$typeof) {
      case Pq:
        return (e.displayName || "Context") + ".Consumer";
      case Oq:
        return (e._context.displayName || "Context") + ".Provider";
      case VI:
        var t = e.render;
        return (
          (e = e.displayName),
          e ||
            ((e = t.displayName || t.name || ""),
            (e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef")),
          e
        );
      case GI:
        return (
          (t = e.displayName || null), t !== null ? t : ak(e.type) || "Memo"
        );
      case lp:
        (t = e._payload), (e = e._init);
        try {
          return ak(e(t));
        } catch {}
    }
  return null;
}
function u0e(e) {
  var t = e.type;
  switch (e.tag) {
    case 24:
      return "Cache";
    case 9:
      return (t.displayName || "Context") + ".Consumer";
    case 10:
      return (t._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return (
        (e = t.render),
        (e = e.displayName || e.name || ""),
        t.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef")
      );
    case 7:
      return "Fragment";
    case 5:
      return t;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return ak(t);
    case 8:
      return t === HI ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if (typeof t == "function") return t.displayName || t.name || null;
      if (typeof t == "string") return t;
  }
  return null;
}
function qp(e) {
  switch (typeof e) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return e;
    case "object":
      return e;
    default:
      return "";
  }
}
function jq(e) {
  var t = e.type;
  return (
    (e = e.nodeName) &&
    e.toLowerCase() === "input" &&
    (t === "checkbox" || t === "radio")
  );
}
function d0e(e) {
  var t = jq(e) ? "checked" : "value",
    n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t),
    r = "" + e[t];
  if (
    !e.hasOwnProperty(t) &&
    typeof n < "u" &&
    typeof n.get == "function" &&
    typeof n.set == "function"
  ) {
    var i = n.get,
      s = n.set;
    return (
      Object.defineProperty(e, t, {
        configurable: !0,
        get: function () {
          return i.call(this);
        },
        set: function (o) {
          (r = "" + o), s.call(this, o);
        },
      }),
      Object.defineProperty(e, t, { enumerable: n.enumerable }),
      {
        getValue: function () {
          return r;
        },
        setValue: function (o) {
          r = "" + o;
        },
        stopTracking: function () {
          (e._valueTracker = null), delete e[t];
        },
      }
    );
  }
}
function r_(e) {
  e._valueTracker || (e._valueTracker = d0e(e));
}
function Dq(e) {
  if (!e) return !1;
  var t = e._valueTracker;
  if (!t) return !0;
  var n = t.getValue(),
    r = "";
  return (
    e && (r = jq(e) ? (e.checked ? "true" : "false") : e.value),
    (e = r),
    e !== n ? (t.setValue(e), !0) : !1
  );
}
function A6(e) {
  if (((e = e || (typeof document < "u" ? document : void 0)), typeof e > "u"))
    return null;
  try {
    return e.activeElement || e.body;
  } catch {
    return e.body;
  }
}
function lk(e, t) {
  var n = t.checked;
  return ms({}, t, {
    defaultChecked: void 0,
    defaultValue: void 0,
    value: void 0,
    checked: n ?? e._wrapperState.initialChecked,
  });
}
function eB(e, t) {
  var n = t.defaultValue == null ? "" : t.defaultValue,
    r = t.checked != null ? t.checked : t.defaultChecked;
  (n = qp(t.value != null ? t.value : n)),
    (e._wrapperState = {
      initialChecked: r,
      initialValue: n,
      controlled:
        t.type === "checkbox" || t.type === "radio"
          ? t.checked != null
          : t.value != null,
    });
}
function Bq(e, t) {
  (t = t.checked), t != null && WI(e, "checked", t, !1);
}
function ck(e, t) {
  Bq(e, t);
  var n = qp(t.value),
    r = t.type;
  if (n != null)
    r === "number"
      ? ((n === 0 && e.value === "") || e.value != n) && (e.value = "" + n)
      : e.value !== "" + n && (e.value = "" + n);
  else if (r === "submit" || r === "reset") {
    e.removeAttribute("value");
    return;
  }
  t.hasOwnProperty("value")
    ? uk(e, t.type, n)
    : t.hasOwnProperty("defaultValue") && uk(e, t.type, qp(t.defaultValue)),
    t.checked == null &&
      t.defaultChecked != null &&
      (e.defaultChecked = !!t.defaultChecked);
}
function tB(e, t, n) {
  if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) {
    var r = t.type;
    if (
      !(
        (r !== "submit" && r !== "reset") ||
        (t.value !== void 0 && t.value !== null)
      )
    )
      return;
    (t = "" + e._wrapperState.initialValue),
      n || t === e.value || (e.value = t),
      (e.defaultValue = t);
  }
  (n = e.name),
    n !== "" && (e.name = ""),
    (e.defaultChecked = !!e._wrapperState.initialChecked),
    n !== "" && (e.name = n);
}
function uk(e, t, n) {
  (t !== "number" || A6(e.ownerDocument) !== e) &&
    (n == null
      ? (e.defaultValue = "" + e._wrapperState.initialValue)
      : e.defaultValue !== "" + n && (e.defaultValue = "" + n));
}
var H2 = Array.isArray;
function Ug(e, t, n, r) {
  if (((e = e.options), t)) {
    t = {};
    for (var i = 0; i < n.length; i++) t["$" + n[i]] = !0;
    for (n = 0; n < e.length; n++)
      (i = t.hasOwnProperty("$" + e[n].value)),
        e[n].selected !== i && (e[n].selected = i),
        i && r && (e[n].defaultSelected = !0);
  } else {
    for (n = "" + qp(n), t = null, i = 0; i < e.length; i++) {
      if (e[i].value === n) {
        (e[i].selected = !0), r && (e[i].defaultSelected = !0);
        return;
      }
      t !== null || e[i].disabled || (t = e[i]);
    }
    t !== null && (t.selected = !0);
  }
}
function dk(e, t) {
  if (t.dangerouslySetInnerHTML != null) throw Error(lt(91));
  return ms({}, t, {
    value: void 0,
    defaultValue: void 0,
    children: "" + e._wrapperState.initialValue,
  });
}
function nB(e, t) {
  var n = t.value;
  if (n == null) {
    if (((n = t.children), (t = t.defaultValue), n != null)) {
      if (t != null) throw Error(lt(92));
      if (H2(n)) {
        if (1 < n.length) throw Error(lt(93));
        n = n[0];
      }
      t = n;
    }
    t == null && (t = ""), (n = t);
  }
  e._wrapperState = { initialValue: qp(n) };
}
function Fq(e, t) {
  var n = qp(t.value),
    r = qp(t.defaultValue);
  n != null &&
    ((n = "" + n),
    n !== e.value && (e.value = n),
    t.defaultValue == null && e.defaultValue !== n && (e.defaultValue = n)),
    r != null && (e.defaultValue = "" + r);
}
function rB(e) {
  var t = e.textContent;
  t === e._wrapperState.initialValue && t !== "" && t !== null && (e.value = t);
}
function Uq(e) {
  switch (e) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function fk(e, t) {
  return e == null || e === "http://www.w3.org/1999/xhtml"
    ? Uq(t)
    : e === "http://www.w3.org/2000/svg" && t === "foreignObject"
    ? "http://www.w3.org/1999/xhtml"
    : e;
}
var i_,
  $q = (function (e) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction
      ? function (t, n, r, i) {
          MSApp.execUnsafeLocalFunction(function () {
            return e(t, n, r, i);
          });
        }
      : e;
  })(function (e, t) {
    if (e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in e)
      e.innerHTML = t;
    else {
      for (
        i_ = i_ || document.createElement("div"),
          i_.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>",
          t = i_.firstChild;
        e.firstChild;

      )
        e.removeChild(e.firstChild);
      for (; t.firstChild; ) e.appendChild(t.firstChild);
    }
  });
function Bw(e, t) {
  if (t) {
    var n = e.firstChild;
    if (n && n === e.lastChild && n.nodeType === 3) {
      n.nodeValue = t;
      return;
    }
  }
  e.textContent = t;
}
var ow = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0,
  },
  f0e = ["Webkit", "ms", "Moz", "O"];
Object.keys(ow).forEach(function (e) {
  f0e.forEach(function (t) {
    (t = t + e.charAt(0).toUpperCase() + e.substring(1)), (ow[t] = ow[e]);
  });
});
function zq(e, t, n) {
  return t == null || typeof t == "boolean" || t === ""
    ? ""
    : n || typeof t != "number" || t === 0 || (ow.hasOwnProperty(e) && ow[e])
    ? ("" + t).trim()
    : t + "px";
}
function Wq(e, t) {
  e = e.style;
  for (var n in t)
    if (t.hasOwnProperty(n)) {
      var r = n.indexOf("--") === 0,
        i = zq(n, t[n], r);
      n === "float" && (n = "cssFloat"), r ? e.setProperty(n, i) : (e[n] = i);
    }
}
var h0e = ms(
  { menuitem: !0 },
  {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0,
  }
);
function hk(e, t) {
  if (t) {
    if (h0e[e] && (t.children != null || t.dangerouslySetInnerHTML != null))
      throw Error(lt(137, e));
    if (t.dangerouslySetInnerHTML != null) {
      if (t.children != null) throw Error(lt(60));
      if (
        typeof t.dangerouslySetInnerHTML != "object" ||
        !("__html" in t.dangerouslySetInnerHTML)
      )
        throw Error(lt(61));
    }
    if (t.style != null && typeof t.style != "object") throw Error(lt(62));
  }
}
function pk(e, t) {
  if (e.indexOf("-") === -1) return typeof t.is == "string";
  switch (e) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0;
  }
}
var mk = null;
function qI(e) {
  return (
    (e = e.target || e.srcElement || window),
    e.correspondingUseElement && (e = e.correspondingUseElement),
    e.nodeType === 3 ? e.parentNode : e
  );
}
var gk = null,
  $g = null,
  zg = null;
function iB(e) {
  if ((e = lx(e))) {
    if (typeof gk != "function") throw Error(lt(280));
    var t = e.stateNode;
    t && ((t = BS(t)), gk(e.stateNode, e.type, t));
  }
}
function Hq(e) {
  $g ? (zg ? zg.push(e) : (zg = [e])) : ($g = e);
}
function Vq() {
  if ($g) {
    var e = $g,
      t = zg;
    if (((zg = $g = null), iB(e), t)) for (e = 0; e < t.length; e++) iB(t[e]);
  }
}
function Gq(e, t) {
  return e(t);
}
function qq() {}
var sA = !1;
function Kq(e, t, n) {
  if (sA) return e(t, n);
  sA = !0;
  try {
    return Gq(e, t, n);
  } finally {
    (sA = !1), ($g !== null || zg !== null) && (qq(), Vq());
  }
}
function Fw(e, t) {
  var n = e.stateNode;
  if (n === null) return null;
  var r = BS(n);
  if (r === null) return null;
  n = r[t];
  e: switch (t) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (r = !r.disabled) ||
        ((e = e.type),
        (r = !(
          e === "button" ||
          e === "input" ||
          e === "select" ||
          e === "textarea"
        ))),
        (e = !r);
      break e;
    default:
      e = !1;
  }
  if (e) return null;
  if (n && typeof n != "function") throw Error(lt(231, t, typeof n));
  return n;
}
var yk = !1;
if (ih)
  try {
    var u2 = {};
    Object.defineProperty(u2, "passive", {
      get: function () {
        yk = !0;
      },
    }),
      window.addEventListener("test", u2, u2),
      window.removeEventListener("test", u2, u2);
  } catch {
    yk = !1;
  }
function p0e(e, t, n, r, i, s, o, a, l) {
  var c = Array.prototype.slice.call(arguments, 3);
  try {
    t.apply(n, c);
  } catch (u) {
    this.onError(u);
  }
}
var aw = !1,
  C6 = null,
  k6 = !1,
  vk = null,
  m0e = {
    onError: function (e) {
      (aw = !0), (C6 = e);
    },
  };
function g0e(e, t, n, r, i, s, o, a, l) {
  (aw = !1), (C6 = null), p0e.apply(m0e, arguments);
}
function y0e(e, t, n, r, i, s, o, a, l) {
  if ((g0e.apply(this, arguments), aw)) {
    if (aw) {
      var c = C6;
      (aw = !1), (C6 = null);
    } else throw Error(lt(198));
    k6 || ((k6 = !0), (vk = c));
  }
}
function d1(e) {
  var t = e,
    n = e;
  if (e.alternate) for (; t.return; ) t = t.return;
  else {
    e = t;
    do (t = e), t.flags & 4098 && (n = t.return), (e = t.return);
    while (e);
  }
  return t.tag === 3 ? n : null;
}
function Yq(e) {
  if (e.tag === 13) {
    var t = e.memoizedState;
    if (
      (t === null && ((e = e.alternate), e !== null && (t = e.memoizedState)),
      t !== null)
    )
      return t.dehydrated;
  }
  return null;
}
function sB(e) {
  if (d1(e) !== e) throw Error(lt(188));
}
function v0e(e) {
  var t = e.alternate;
  if (!t) {
    if (((t = d1(e)), t === null)) throw Error(lt(188));
    return t !== e ? null : e;
  }
  for (var n = e, r = t; ; ) {
    var i = n.return;
    if (i === null) break;
    var s = i.alternate;
    if (s === null) {
      if (((r = i.return), r !== null)) {
        n = r;
        continue;
      }
      break;
    }
    if (i.child === s.child) {
      for (s = i.child; s; ) {
        if (s === n) return sB(i), e;
        if (s === r) return sB(i), t;
        s = s.sibling;
      }
      throw Error(lt(188));
    }
    if (n.return !== r.return) (n = i), (r = s);
    else {
      for (var o = !1, a = i.child; a; ) {
        if (a === n) {
          (o = !0), (n = i), (r = s);
          break;
        }
        if (a === r) {
          (o = !0), (r = i), (n = s);
          break;
        }
        a = a.sibling;
      }
      if (!o) {
        for (a = s.child; a; ) {
          if (a === n) {
            (o = !0), (n = s), (r = i);
            break;
          }
          if (a === r) {
            (o = !0), (r = s), (n = i);
            break;
          }
          a = a.sibling;
        }
        if (!o) throw Error(lt(189));
      }
    }
    if (n.alternate !== r) throw Error(lt(190));
  }
  if (n.tag !== 3) throw Error(lt(188));
  return n.stateNode.current === n ? e : t;
}
function Zq(e) {
  return (e = v0e(e)), e !== null ? Qq(e) : null;
}
function Qq(e) {
  if (e.tag === 5 || e.tag === 6) return e;
  for (e = e.child; e !== null; ) {
    var t = Qq(e);
    if (t !== null) return t;
    e = e.sibling;
  }
  return null;
}
var Xq = Fl.unstable_scheduleCallback,
  oB = Fl.unstable_cancelCallback,
  w0e = Fl.unstable_shouldYield,
  b0e = Fl.unstable_requestPaint,
  Ns = Fl.unstable_now,
  x0e = Fl.unstable_getCurrentPriorityLevel,
  KI = Fl.unstable_ImmediatePriority,
  Jq = Fl.unstable_UserBlockingPriority,
  T6 = Fl.unstable_NormalPriority,
  _0e = Fl.unstable_LowPriority,
  eK = Fl.unstable_IdlePriority,
  PS = null,
  gd = null;
function S0e(e) {
  if (gd && typeof gd.onCommitFiberRoot == "function")
    try {
      gd.onCommitFiberRoot(PS, e, void 0, (e.current.flags & 128) === 128);
    } catch {}
}
var wu = Math.clz32 ? Math.clz32 : C0e,
  E0e = Math.log,
  A0e = Math.LN2;
function C0e(e) {
  return (e >>>= 0), e === 0 ? 32 : (31 - ((E0e(e) / A0e) | 0)) | 0;
}
var s_ = 64,
  o_ = 4194304;
function V2(e) {
  switch (e & -e) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return e & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return e & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return e;
  }
}
function M6(e, t) {
  var n = e.pendingLanes;
  if (n === 0) return 0;
  var r = 0,
    i = e.suspendedLanes,
    s = e.pingedLanes,
    o = n & 268435455;
  if (o !== 0) {
    var a = o & ~i;
    a !== 0 ? (r = V2(a)) : ((s &= o), s !== 0 && (r = V2(s)));
  } else (o = n & ~i), o !== 0 ? (r = V2(o)) : s !== 0 && (r = V2(s));
  if (r === 0) return 0;
  if (
    t !== 0 &&
    t !== r &&
    !(t & i) &&
    ((i = r & -r), (s = t & -t), i >= s || (i === 16 && (s & 4194240) !== 0))
  )
    return t;
  if ((r & 4 && (r |= n & 16), (t = e.entangledLanes), t !== 0))
    for (e = e.entanglements, t &= r; 0 < t; )
      (n = 31 - wu(t)), (i = 1 << n), (r |= e[n]), (t &= ~i);
  return r;
}
function k0e(e, t) {
  switch (e) {
    case 1:
    case 2:
    case 4:
      return t + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return t + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function T0e(e, t) {
  for (
    var n = e.suspendedLanes,
      r = e.pingedLanes,
      i = e.expirationTimes,
      s = e.pendingLanes;
    0 < s;

  ) {
    var o = 31 - wu(s),
      a = 1 << o,
      l = i[o];
    l === -1
      ? (!(a & n) || a & r) && (i[o] = k0e(a, t))
      : l <= t && (e.expiredLanes |= a),
      (s &= ~a);
  }
}
function wk(e) {
  return (
    (e = e.pendingLanes & -1073741825),
    e !== 0 ? e : e & 1073741824 ? 1073741824 : 0
  );
}
function tK() {
  var e = s_;
  return (s_ <<= 1), !(s_ & 4194240) && (s_ = 64), e;
}
function oA(e) {
  for (var t = [], n = 0; 31 > n; n++) t.push(e);
  return t;
}
function ox(e, t, n) {
  (e.pendingLanes |= t),
    t !== 536870912 && ((e.suspendedLanes = 0), (e.pingedLanes = 0)),
    (e = e.eventTimes),
    (t = 31 - wu(t)),
    (e[t] = n);
}
function M0e(e, t) {
  var n = e.pendingLanes & ~t;
  (e.pendingLanes = t),
    (e.suspendedLanes = 0),
    (e.pingedLanes = 0),
    (e.expiredLanes &= t),
    (e.mutableReadLanes &= t),
    (e.entangledLanes &= t),
    (t = e.entanglements);
  var r = e.eventTimes;
  for (e = e.expirationTimes; 0 < n; ) {
    var i = 31 - wu(n),
      s = 1 << i;
    (t[i] = 0), (r[i] = -1), (e[i] = -1), (n &= ~s);
  }
}
function YI(e, t) {
  var n = (e.entangledLanes |= t);
  for (e = e.entanglements; n; ) {
    var r = 31 - wu(n),
      i = 1 << r;
    (i & t) | (e[r] & t) && (e[r] |= t), (n &= ~i);
  }
}
var ui = 0;
function nK(e) {
  return (e &= -e), 1 < e ? (4 < e ? (e & 268435455 ? 16 : 536870912) : 4) : 1;
}
var rK,
  ZI,
  iK,
  sK,
  oK,
  bk = !1,
  a_ = [],
  Mp = null,
  Ip = null,
  Np = null,
  Uw = new Map(),
  $w = new Map(),
  pp = [],
  I0e =
    "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(
      " "
    );
function aB(e, t) {
  switch (e) {
    case "focusin":
    case "focusout":
      Mp = null;
      break;
    case "dragenter":
    case "dragleave":
      Ip = null;
      break;
    case "mouseover":
    case "mouseout":
      Np = null;
      break;
    case "pointerover":
    case "pointerout":
      Uw.delete(t.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      $w.delete(t.pointerId);
  }
}
function d2(e, t, n, r, i, s) {
  return e === null || e.nativeEvent !== s
    ? ((e = {
        blockedOn: t,
        domEventName: n,
        eventSystemFlags: r,
        nativeEvent: s,
        targetContainers: [i],
      }),
      t !== null && ((t = lx(t)), t !== null && ZI(t)),
      e)
    : ((e.eventSystemFlags |= r),
      (t = e.targetContainers),
      i !== null && t.indexOf(i) === -1 && t.push(i),
      e);
}
function N0e(e, t, n, r, i) {
  switch (t) {
    case "focusin":
      return (Mp = d2(Mp, e, t, n, r, i)), !0;
    case "dragenter":
      return (Ip = d2(Ip, e, t, n, r, i)), !0;
    case "mouseover":
      return (Np = d2(Np, e, t, n, r, i)), !0;
    case "pointerover":
      var s = i.pointerId;
      return Uw.set(s, d2(Uw.get(s) || null, e, t, n, r, i)), !0;
    case "gotpointercapture":
      return (
        (s = i.pointerId), $w.set(s, d2($w.get(s) || null, e, t, n, r, i)), !0
      );
  }
  return !1;
}
function aK(e) {
  var t = em(e.target);
  if (t !== null) {
    var n = d1(t);
    if (n !== null) {
      if (((t = n.tag), t === 13)) {
        if (((t = Yq(n)), t !== null)) {
          (e.blockedOn = t),
            oK(e.priority, function () {
              iK(n);
            });
          return;
        }
      } else if (t === 3 && n.stateNode.current.memoizedState.isDehydrated) {
        e.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null;
        return;
      }
    }
  }
  e.blockedOn = null;
}
function f4(e) {
  if (e.blockedOn !== null) return !1;
  for (var t = e.targetContainers; 0 < t.length; ) {
    var n = xk(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent);
    if (n === null) {
      n = e.nativeEvent;
      var r = new n.constructor(n.type, n);
      (mk = r), n.target.dispatchEvent(r), (mk = null);
    } else return (t = lx(n)), t !== null && ZI(t), (e.blockedOn = n), !1;
    t.shift();
  }
  return !0;
}
function lB(e, t, n) {
  f4(e) && n.delete(t);
}
function R0e() {
  (bk = !1),
    Mp !== null && f4(Mp) && (Mp = null),
    Ip !== null && f4(Ip) && (Ip = null),
    Np !== null && f4(Np) && (Np = null),
    Uw.forEach(lB),
    $w.forEach(lB);
}
function f2(e, t) {
  e.blockedOn === t &&
    ((e.blockedOn = null),
    bk ||
      ((bk = !0),
      Fl.unstable_scheduleCallback(Fl.unstable_NormalPriority, R0e)));
}
function zw(e) {
  function t(i) {
    return f2(i, e);
  }
  if (0 < a_.length) {
    f2(a_[0], e);
    for (var n = 1; n < a_.length; n++) {
      var r = a_[n];
      r.blockedOn === e && (r.blockedOn = null);
    }
  }
  for (
    Mp !== null && f2(Mp, e),
      Ip !== null && f2(Ip, e),
      Np !== null && f2(Np, e),
      Uw.forEach(t),
      $w.forEach(t),
      n = 0;
    n < pp.length;
    n++
  )
    (r = pp[n]), r.blockedOn === e && (r.blockedOn = null);
  for (; 0 < pp.length && ((n = pp[0]), n.blockedOn === null); )
    aK(n), n.blockedOn === null && pp.shift();
}
var Wg = yh.ReactCurrentBatchConfig,
  I6 = !0;
function O0e(e, t, n, r) {
  var i = ui,
    s = Wg.transition;
  Wg.transition = null;
  try {
    (ui = 1), QI(e, t, n, r);
  } finally {
    (ui = i), (Wg.transition = s);
  }
}
function P0e(e, t, n, r) {
  var i = ui,
    s = Wg.transition;
  Wg.transition = null;
  try {
    (ui = 4), QI(e, t, n, r);
  } finally {
    (ui = i), (Wg.transition = s);
  }
}
function QI(e, t, n, r) {
  if (I6) {
    var i = xk(e, t, n, r);
    if (i === null) gA(e, t, r, N6, n), aB(e, r);
    else if (N0e(i, e, t, n, r)) r.stopPropagation();
    else if ((aB(e, r), t & 4 && -1 < I0e.indexOf(e))) {
      for (; i !== null; ) {
        var s = lx(i);
        if (
          (s !== null && rK(s),
          (s = xk(e, t, n, r)),
          s === null && gA(e, t, r, N6, n),
          s === i)
        )
          break;
        i = s;
      }
      i !== null && r.stopPropagation();
    } else gA(e, t, r, null, n);
  }
}
var N6 = null;
function xk(e, t, n, r) {
  if (((N6 = null), (e = qI(r)), (e = em(e)), e !== null))
    if (((t = d1(e)), t === null)) e = null;
    else if (((n = t.tag), n === 13)) {
      if (((e = Yq(t)), e !== null)) return e;
      e = null;
    } else if (n === 3) {
      if (t.stateNode.current.memoizedState.isDehydrated)
        return t.tag === 3 ? t.stateNode.containerInfo : null;
      e = null;
    } else t !== e && (e = null);
  return (N6 = e), null;
}
function lK(e) {
  switch (e) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (x0e()) {
        case KI:
          return 1;
        case Jq:
          return 4;
        case T6:
        case _0e:
          return 16;
        case eK:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var vp = null,
  XI = null,
  h4 = null;
function cK() {
  if (h4) return h4;
  var e,
    t = XI,
    n = t.length,
    r,
    i = "value" in vp ? vp.value : vp.textContent,
    s = i.length;
  for (e = 0; e < n && t[e] === i[e]; e++);
  var o = n - e;
  for (r = 1; r <= o && t[n - r] === i[s - r]; r++);
  return (h4 = i.slice(e, 1 < r ? 1 - r : void 0));
}
function p4(e) {
  var t = e.keyCode;
  return (
    "charCode" in e
      ? ((e = e.charCode), e === 0 && t === 13 && (e = 13))
      : (e = t),
    e === 10 && (e = 13),
    32 <= e || e === 13 ? e : 0
  );
}
function l_() {
  return !0;
}
function cB() {
  return !1;
}
function Hl(e) {
  function t(n, r, i, s, o) {
    (this._reactName = n),
      (this._targetInst = i),
      (this.type = r),
      (this.nativeEvent = s),
      (this.target = o),
      (this.currentTarget = null);
    for (var a in e)
      e.hasOwnProperty(a) && ((n = e[a]), (this[a] = n ? n(s) : s[a]));
    return (
      (this.isDefaultPrevented = (
        s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1
      )
        ? l_
        : cB),
      (this.isPropagationStopped = cB),
      this
    );
  }
  return (
    ms(t.prototype, {
      preventDefault: function () {
        this.defaultPrevented = !0;
        var n = this.nativeEvent;
        n &&
          (n.preventDefault
            ? n.preventDefault()
            : typeof n.returnValue != "unknown" && (n.returnValue = !1),
          (this.isDefaultPrevented = l_));
      },
      stopPropagation: function () {
        var n = this.nativeEvent;
        n &&
          (n.stopPropagation
            ? n.stopPropagation()
            : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0),
          (this.isPropagationStopped = l_));
      },
      persist: function () {},
      isPersistent: l_,
    }),
    t
  );
}
var nv = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function (e) {
      return e.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0,
  },
  JI = Hl(nv),
  ax = ms({}, nv, { view: 0, detail: 0 }),
  L0e = Hl(ax),
  aA,
  lA,
  h2,
  LS = ms({}, ax, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: eN,
    button: 0,
    buttons: 0,
    relatedTarget: function (e) {
      return e.relatedTarget === void 0
        ? e.fromElement === e.srcElement
          ? e.toElement
          : e.fromElement
        : e.relatedTarget;
    },
    movementX: function (e) {
      return "movementX" in e
        ? e.movementX
        : (e !== h2 &&
            (h2 && e.type === "mousemove"
              ? ((aA = e.screenX - h2.screenX), (lA = e.screenY - h2.screenY))
              : (lA = aA = 0),
            (h2 = e)),
          aA);
    },
    movementY: function (e) {
      return "movementY" in e ? e.movementY : lA;
    },
  }),
  uB = Hl(LS),
  j0e = ms({}, LS, { dataTransfer: 0 }),
  D0e = Hl(j0e),
  B0e = ms({}, ax, { relatedTarget: 0 }),
  cA = Hl(B0e),
  F0e = ms({}, nv, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
  U0e = Hl(F0e),
  $0e = ms({}, nv, {
    clipboardData: function (e) {
      return "clipboardData" in e ? e.clipboardData : window.clipboardData;
    },
  }),
  z0e = Hl($0e),
  W0e = ms({}, nv, { data: 0 }),
  dB = Hl(W0e),
  H0e = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified",
  },
  V0e = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta",
  },
  G0e = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey",
  };
function q0e(e) {
  var t = this.nativeEvent;
  return t.getModifierState
    ? t.getModifierState(e)
    : (e = G0e[e])
    ? !!t[e]
    : !1;
}
function eN() {
  return q0e;
}
var K0e = ms({}, ax, {
    key: function (e) {
      if (e.key) {
        var t = H0e[e.key] || e.key;
        if (t !== "Unidentified") return t;
      }
      return e.type === "keypress"
        ? ((e = p4(e)), e === 13 ? "Enter" : String.fromCharCode(e))
        : e.type === "keydown" || e.type === "keyup"
        ? V0e[e.keyCode] || "Unidentified"
        : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: eN,
    charCode: function (e) {
      return e.type === "keypress" ? p4(e) : 0;
    },
    keyCode: function (e) {
      return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0;
    },
    which: function (e) {
      return e.type === "keypress"
        ? p4(e)
        : e.type === "keydown" || e.type === "keyup"
        ? e.keyCode
        : 0;
    },
  }),
  Y0e = Hl(K0e),
  Z0e = ms({}, LS, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0,
  }),
  fB = Hl(Z0e),
  Q0e = ms({}, ax, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: eN,
  }),
  X0e = Hl(Q0e),
  J0e = ms({}, nv, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
  eme = Hl(J0e),
  tme = ms({}, LS, {
    deltaX: function (e) {
      return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0;
    },
    deltaY: function (e) {
      return "deltaY" in e
        ? e.deltaY
        : "wheelDeltaY" in e
        ? -e.wheelDeltaY
        : "wheelDelta" in e
        ? -e.wheelDelta
        : 0;
    },
    deltaZ: 0,
    deltaMode: 0,
  }),
  nme = Hl(tme),
  rme = [9, 13, 27, 32],
  tN = ih && "CompositionEvent" in window,
  lw = null;
ih && "documentMode" in document && (lw = document.documentMode);
var ime = ih && "TextEvent" in window && !lw,
  uK = ih && (!tN || (lw && 8 < lw && 11 >= lw)),
  hB = " ",
  pB = !1;
function dK(e, t) {
  switch (e) {
    case "keyup":
      return rme.indexOf(t.keyCode) !== -1;
    case "keydown":
      return t.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;
    default:
      return !1;
  }
}
function fK(e) {
  return (e = e.detail), typeof e == "object" && "data" in e ? e.data : null;
}
var dg = !1;
function sme(e, t) {
  switch (e) {
    case "compositionend":
      return fK(t);
    case "keypress":
      return t.which !== 32 ? null : ((pB = !0), hB);
    case "textInput":
      return (e = t.data), e === hB && pB ? null : e;
    default:
      return null;
  }
}
function ome(e, t) {
  if (dg)
    return e === "compositionend" || (!tN && dK(e, t))
      ? ((e = cK()), (h4 = XI = vp = null), (dg = !1), e)
      : null;
  switch (e) {
    case "paste":
      return null;
    case "keypress":
      if (!(t.ctrlKey || t.altKey || t.metaKey) || (t.ctrlKey && t.altKey)) {
        if (t.char && 1 < t.char.length) return t.char;
        if (t.which) return String.fromCharCode(t.which);
      }
      return null;
    case "compositionend":
      return uK && t.locale !== "ko" ? null : t.data;
    default:
      return null;
  }
}
var ame = {
  color: !0,
  date: !0,
  datetime: !0,
  "datetime-local": !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0,
};
function mB(e) {
  var t = e && e.nodeName && e.nodeName.toLowerCase();
  return t === "input" ? !!ame[e.type] : t === "textarea";
}
function hK(e, t, n, r) {
  Hq(r),
    (t = R6(t, "onChange")),
    0 < t.length &&
      ((n = new JI("onChange", "change", null, n, r)),
      e.push({ event: n, listeners: t }));
}
var cw = null,
  Ww = null;
function lme(e) {
  EK(e, 0);
}
function jS(e) {
  var t = pg(e);
  if (Dq(t)) return e;
}
function cme(e, t) {
  if (e === "change") return t;
}
var pK = !1;
if (ih) {
  var uA;
  if (ih) {
    var dA = "oninput" in document;
    if (!dA) {
      var gB = document.createElement("div");
      gB.setAttribute("oninput", "return;"),
        (dA = typeof gB.oninput == "function");
    }
    uA = dA;
  } else uA = !1;
  pK = uA && (!document.documentMode || 9 < document.documentMode);
}
function yB() {
  cw && (cw.detachEvent("onpropertychange", mK), (Ww = cw = null));
}
function mK(e) {
  if (e.propertyName === "value" && jS(Ww)) {
    var t = [];
    hK(t, Ww, e, qI(e)), Kq(lme, t);
  }
}
function ume(e, t, n) {
  e === "focusin"
    ? (yB(), (cw = t), (Ww = n), cw.attachEvent("onpropertychange", mK))
    : e === "focusout" && yB();
}
function dme(e) {
  if (e === "selectionchange" || e === "keyup" || e === "keydown")
    return jS(Ww);
}
function fme(e, t) {
  if (e === "click") return jS(t);
}
function hme(e, t) {
  if (e === "input" || e === "change") return jS(t);
}
function pme(e, t) {
  return (e === t && (e !== 0 || 1 / e === 1 / t)) || (e !== e && t !== t);
}
var Su = typeof Object.is == "function" ? Object.is : pme;
function Hw(e, t) {
  if (Su(e, t)) return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null)
    return !1;
  var n = Object.keys(e),
    r = Object.keys(t);
  if (n.length !== r.length) return !1;
  for (r = 0; r < n.length; r++) {
    var i = n[r];
    if (!rk.call(t, i) || !Su(e[i], t[i])) return !1;
  }
  return !0;
}
function vB(e) {
  for (; e && e.firstChild; ) e = e.firstChild;
  return e;
}
function wB(e, t) {
  var n = vB(e);
  e = 0;
  for (var r; n; ) {
    if (n.nodeType === 3) {
      if (((r = e + n.textContent.length), e <= t && r >= t))
        return { node: n, offset: t - e };
      e = r;
    }
    e: {
      for (; n; ) {
        if (n.nextSibling) {
          n = n.nextSibling;
          break e;
        }
        n = n.parentNode;
      }
      n = void 0;
    }
    n = vB(n);
  }
}
function gK(e, t) {
  return e && t
    ? e === t
      ? !0
      : e && e.nodeType === 3
      ? !1
      : t && t.nodeType === 3
      ? gK(e, t.parentNode)
      : "contains" in e
      ? e.contains(t)
      : e.compareDocumentPosition
      ? !!(e.compareDocumentPosition(t) & 16)
      : !1
    : !1;
}
function yK() {
  for (var e = window, t = A6(); t instanceof e.HTMLIFrameElement; ) {
    try {
      var n = typeof t.contentWindow.location.href == "string";
    } catch {
      n = !1;
    }
    if (n) e = t.contentWindow;
    else break;
    t = A6(e.document);
  }
  return t;
}
function nN(e) {
  var t = e && e.nodeName && e.nodeName.toLowerCase();
  return (
    t &&
    ((t === "input" &&
      (e.type === "text" ||
        e.type === "search" ||
        e.type === "tel" ||
        e.type === "url" ||
        e.type === "password")) ||
      t === "textarea" ||
      e.contentEditable === "true")
  );
}
function mme(e) {
  var t = yK(),
    n = e.focusedElem,
    r = e.selectionRange;
  if (
    t !== n &&
    n &&
    n.ownerDocument &&
    gK(n.ownerDocument.documentElement, n)
  ) {
    if (r !== null && nN(n)) {
      if (
        ((t = r.start),
        (e = r.end),
        e === void 0 && (e = t),
        "selectionStart" in n)
      )
        (n.selectionStart = t), (n.selectionEnd = Math.min(e, n.value.length));
      else if (
        ((e = ((t = n.ownerDocument || document) && t.defaultView) || window),
        e.getSelection)
      ) {
        e = e.getSelection();
        var i = n.textContent.length,
          s = Math.min(r.start, i);
        (r = r.end === void 0 ? s : Math.min(r.end, i)),
          !e.extend && s > r && ((i = r), (r = s), (s = i)),
          (i = wB(n, s));
        var o = wB(n, r);
        i &&
          o &&
          (e.rangeCount !== 1 ||
            e.anchorNode !== i.node ||
            e.anchorOffset !== i.offset ||
            e.focusNode !== o.node ||
            e.focusOffset !== o.offset) &&
          ((t = t.createRange()),
          t.setStart(i.node, i.offset),
          e.removeAllRanges(),
          s > r
            ? (e.addRange(t), e.extend(o.node, o.offset))
            : (t.setEnd(o.node, o.offset), e.addRange(t)));
      }
    }
    for (t = [], e = n; (e = e.parentNode); )
      e.nodeType === 1 &&
        t.push({ element: e, left: e.scrollLeft, top: e.scrollTop });
    for (typeof n.focus == "function" && n.focus(), n = 0; n < t.length; n++)
      (e = t[n]),
        (e.element.scrollLeft = e.left),
        (e.element.scrollTop = e.top);
  }
}
var gme = ih && "documentMode" in document && 11 >= document.documentMode,
  fg = null,
  _k = null,
  uw = null,
  Sk = !1;
function bB(e, t, n) {
  var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument;
  Sk ||
    fg == null ||
    fg !== A6(r) ||
    ((r = fg),
    "selectionStart" in r && nN(r)
      ? (r = { start: r.selectionStart, end: r.selectionEnd })
      : ((r = (
          (r.ownerDocument && r.ownerDocument.defaultView) ||
          window
        ).getSelection()),
        (r = {
          anchorNode: r.anchorNode,
          anchorOffset: r.anchorOffset,
          focusNode: r.focusNode,
          focusOffset: r.focusOffset,
        })),
    (uw && Hw(uw, r)) ||
      ((uw = r),
      (r = R6(_k, "onSelect")),
      0 < r.length &&
        ((t = new JI("onSelect", "select", null, t, n)),
        e.push({ event: t, listeners: r }),
        (t.target = fg))));
}
function c_(e, t) {
  var n = {};
  return (
    (n[e.toLowerCase()] = t.toLowerCase()),
    (n["Webkit" + e] = "webkit" + t),
    (n["Moz" + e] = "moz" + t),
    n
  );
}
var hg = {
    animationend: c_("Animation", "AnimationEnd"),
    animationiteration: c_("Animation", "AnimationIteration"),
    animationstart: c_("Animation", "AnimationStart"),
    transitionend: c_("Transition", "TransitionEnd"),
  },
  fA = {},
  vK = {};
ih &&
  ((vK = document.createElement("div").style),
  "AnimationEvent" in window ||
    (delete hg.animationend.animation,
    delete hg.animationiteration.animation,
    delete hg.animationstart.animation),
  "TransitionEvent" in window || delete hg.transitionend.transition);
function DS(e) {
  if (fA[e]) return fA[e];
  if (!hg[e]) return e;
  var t = hg[e],
    n;
  for (n in t) if (t.hasOwnProperty(n) && n in vK) return (fA[e] = t[n]);
  return e;
}
var wK = DS("animationend"),
  bK = DS("animationiteration"),
  xK = DS("animationstart"),
  _K = DS("transitionend"),
  SK = new Map(),
  xB =
    "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
      " "
    );
function l0(e, t) {
  SK.set(e, t), u1(t, [e]);
}
for (var hA = 0; hA < xB.length; hA++) {
  var pA = xB[hA],
    yme = pA.toLowerCase(),
    vme = pA[0].toUpperCase() + pA.slice(1);
  l0(yme, "on" + vme);
}
l0(wK, "onAnimationEnd");
l0(bK, "onAnimationIteration");
l0(xK, "onAnimationStart");
l0("dblclick", "onDoubleClick");
l0("focusin", "onFocus");
l0("focusout", "onBlur");
l0(_K, "onTransitionEnd");
fy("onMouseEnter", ["mouseout", "mouseover"]);
fy("onMouseLeave", ["mouseout", "mouseover"]);
fy("onPointerEnter", ["pointerout", "pointerover"]);
fy("onPointerLeave", ["pointerout", "pointerover"]);
u1(
  "onChange",
  "change click focusin focusout input keydown keyup selectionchange".split(" ")
);
u1(
  "onSelect",
  "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
    " "
  )
);
u1("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
u1(
  "onCompositionEnd",
  "compositionend focusout keydown keypress keyup mousedown".split(" ")
);
u1(
  "onCompositionStart",
  "compositionstart focusout keydown keypress keyup mousedown".split(" ")
);
u1(
  "onCompositionUpdate",
  "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
);
var G2 =
    "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ),
  wme = new Set(
    "cancel close invalid load scroll toggle".split(" ").concat(G2)
  );
function _B(e, t, n) {
  var r = e.type || "unknown-event";
  (e.currentTarget = n), y0e(r, t, void 0, e), (e.currentTarget = null);
}
function EK(e, t) {
  t = (t & 4) !== 0;
  for (var n = 0; n < e.length; n++) {
    var r = e[n],
      i = r.event;
    r = r.listeners;
    e: {
      var s = void 0;
      if (t)
        for (var o = r.length - 1; 0 <= o; o--) {
          var a = r[o],
            l = a.instance,
            c = a.currentTarget;
          if (((a = a.listener), l !== s && i.isPropagationStopped())) break e;
          _B(i, a, c), (s = l);
        }
      else
        for (o = 0; o < r.length; o++) {
          if (
            ((a = r[o]),
            (l = a.instance),
            (c = a.currentTarget),
            (a = a.listener),
            l !== s && i.isPropagationStopped())
          )
            break e;
          _B(i, a, c), (s = l);
        }
    }
  }
  if (k6) throw ((e = vk), (k6 = !1), (vk = null), e);
}
function Fi(e, t) {
  var n = t[Tk];
  n === void 0 && (n = t[Tk] = new Set());
  var r = e + "__bubble";
  n.has(r) || (AK(t, e, 2, !1), n.add(r));
}
function mA(e, t, n) {
  var r = 0;
  t && (r |= 4), AK(n, e, r, t);
}
var u_ = "_reactListening" + Math.random().toString(36).slice(2);
function Vw(e) {
  if (!e[u_]) {
    (e[u_] = !0),
      Rq.forEach(function (n) {
        n !== "selectionchange" && (wme.has(n) || mA(n, !1, e), mA(n, !0, e));
      });
    var t = e.nodeType === 9 ? e : e.ownerDocument;
    t === null || t[u_] || ((t[u_] = !0), mA("selectionchange", !1, t));
  }
}
function AK(e, t, n, r) {
  switch (lK(t)) {
    case 1:
      var i = O0e;
      break;
    case 4:
      i = P0e;
      break;
    default:
      i = QI;
  }
  (n = i.bind(null, t, n, e)),
    (i = void 0),
    !yk ||
      (t !== "touchstart" && t !== "touchmove" && t !== "wheel") ||
      (i = !0),
    r
      ? i !== void 0
        ? e.addEventListener(t, n, { capture: !0, passive: i })
        : e.addEventListener(t, n, !0)
      : i !== void 0
      ? e.addEventListener(t, n, { passive: i })
      : e.addEventListener(t, n, !1);
}
function gA(e, t, n, r, i) {
  var s = r;
  if (!(t & 1) && !(t & 2) && r !== null)
    e: for (;;) {
      if (r === null) return;
      var o = r.tag;
      if (o === 3 || o === 4) {
        var a = r.stateNode.containerInfo;
        if (a === i || (a.nodeType === 8 && a.parentNode === i)) break;
        if (o === 4)
          for (o = r.return; o !== null; ) {
            var l = o.tag;
            if (
              (l === 3 || l === 4) &&
              ((l = o.stateNode.containerInfo),
              l === i || (l.nodeType === 8 && l.parentNode === i))
            )
              return;
            o = o.return;
          }
        for (; a !== null; ) {
          if (((o = em(a)), o === null)) return;
          if (((l = o.tag), l === 5 || l === 6)) {
            r = s = o;
            continue e;
          }
          a = a.parentNode;
        }
      }
      r = r.return;
    }
  Kq(function () {
    var c = s,
      u = qI(n),
      d = [];
    e: {
      var f = SK.get(e);
      if (f !== void 0) {
        var h = JI,
          p = e;
        switch (e) {
          case "keypress":
            if (p4(n) === 0) break e;
          case "keydown":
          case "keyup":
            h = Y0e;
            break;
          case "focusin":
            (p = "focus"), (h = cA);
            break;
          case "focusout":
            (p = "blur"), (h = cA);
            break;
          case "beforeblur":
          case "afterblur":
            h = cA;
            break;
          case "click":
            if (n.button === 2) break e;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            h = uB;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            h = D0e;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            h = X0e;
            break;
          case wK:
          case bK:
          case xK:
            h = U0e;
            break;
          case _K:
            h = eme;
            break;
          case "scroll":
            h = L0e;
            break;
          case "wheel":
            h = nme;
            break;
          case "copy":
          case "cut":
          case "paste":
            h = z0e;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            h = fB;
        }
        var g = (t & 4) !== 0,
          b = !g && e === "scroll",
          v = g ? (f !== null ? f + "Capture" : null) : f;
        g = [];
        for (var w = c, x; w !== null; ) {
          x = w;
          var S = x.stateNode;
          if (
            (x.tag === 5 &&
              S !== null &&
              ((x = S),
              v !== null && ((S = Fw(w, v)), S != null && g.push(Gw(w, S, x)))),
            b)
          )
            break;
          w = w.return;
        }
        0 < g.length &&
          ((f = new h(f, p, null, n, u)), d.push({ event: f, listeners: g }));
      }
    }
    if (!(t & 7)) {
      e: {
        if (
          ((f = e === "mouseover" || e === "pointerover"),
          (h = e === "mouseout" || e === "pointerout"),
          f &&
            n !== mk &&
            (p = n.relatedTarget || n.fromElement) &&
            (em(p) || p[sh]))
        )
          break e;
        if (
          (h || f) &&
          ((f =
            u.window === u
              ? u
              : (f = u.ownerDocument)
              ? f.defaultView || f.parentWindow
              : window),
          h
            ? ((p = n.relatedTarget || n.toElement),
              (h = c),
              (p = p ? em(p) : null),
              p !== null &&
                ((b = d1(p)), p !== b || (p.tag !== 5 && p.tag !== 6)) &&
                (p = null))
            : ((h = null), (p = c)),
          h !== p)
        ) {
          if (
            ((g = uB),
            (S = "onMouseLeave"),
            (v = "onMouseEnter"),
            (w = "mouse"),
            (e === "pointerout" || e === "pointerover") &&
              ((g = fB),
              (S = "onPointerLeave"),
              (v = "onPointerEnter"),
              (w = "pointer")),
            (b = h == null ? f : pg(h)),
            (x = p == null ? f : pg(p)),
            (f = new g(S, w + "leave", h, n, u)),
            (f.target = b),
            (f.relatedTarget = x),
            (S = null),
            em(u) === c &&
              ((g = new g(v, w + "enter", p, n, u)),
              (g.target = x),
              (g.relatedTarget = b),
              (S = g)),
            (b = S),
            h && p)
          )
            t: {
              for (g = h, v = p, w = 0, x = g; x; x = U1(x)) w++;
              for (x = 0, S = v; S; S = U1(S)) x++;
              for (; 0 < w - x; ) (g = U1(g)), w--;
              for (; 0 < x - w; ) (v = U1(v)), x--;
              for (; w--; ) {
                if (g === v || (v !== null && g === v.alternate)) break t;
                (g = U1(g)), (v = U1(v));
              }
              g = null;
            }
          else g = null;
          h !== null && SB(d, f, h, g, !1),
            p !== null && b !== null && SB(d, b, p, g, !0);
        }
      }
      e: {
        if (
          ((f = c ? pg(c) : window),
          (h = f.nodeName && f.nodeName.toLowerCase()),
          h === "select" || (h === "input" && f.type === "file"))
        )
          var R = cme;
        else if (mB(f))
          if (pK) R = hme;
          else {
            R = dme;
            var O = ume;
          }
        else
          (h = f.nodeName) &&
            h.toLowerCase() === "input" &&
            (f.type === "checkbox" || f.type === "radio") &&
            (R = fme);
        if (R && (R = R(e, c))) {
          hK(d, R, n, u);
          break e;
        }
        O && O(e, f, c),
          e === "focusout" &&
            (O = f._wrapperState) &&
            O.controlled &&
            f.type === "number" &&
            uk(f, "number", f.value);
      }
      switch (((O = c ? pg(c) : window), e)) {
        case "focusin":
          (mB(O) || O.contentEditable === "true") &&
            ((fg = O), (_k = c), (uw = null));
          break;
        case "focusout":
          uw = _k = fg = null;
          break;
        case "mousedown":
          Sk = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          (Sk = !1), bB(d, n, u);
          break;
        case "selectionchange":
          if (gme) break;
        case "keydown":
        case "keyup":
          bB(d, n, u);
      }
      var B;
      if (tN)
        e: {
          switch (e) {
            case "compositionstart":
              var C = "onCompositionStart";
              break e;
            case "compositionend":
              C = "onCompositionEnd";
              break e;
            case "compositionupdate":
              C = "onCompositionUpdate";
              break e;
          }
          C = void 0;
        }
      else
        dg
          ? dK(e, n) && (C = "onCompositionEnd")
          : e === "keydown" && n.keyCode === 229 && (C = "onCompositionStart");
      C &&
        (uK &&
          n.locale !== "ko" &&
          (dg || C !== "onCompositionStart"
            ? C === "onCompositionEnd" && dg && (B = cK())
            : ((vp = u),
              (XI = "value" in vp ? vp.value : vp.textContent),
              (dg = !0))),
        (O = R6(c, C)),
        0 < O.length &&
          ((C = new dB(C, e, null, n, u)),
          d.push({ event: C, listeners: O }),
          B ? (C.data = B) : ((B = fK(n)), B !== null && (C.data = B)))),
        (B = ime ? sme(e, n) : ome(e, n)) &&
          ((c = R6(c, "onBeforeInput")),
          0 < c.length &&
            ((u = new dB("onBeforeInput", "beforeinput", null, n, u)),
            d.push({ event: u, listeners: c }),
            (u.data = B)));
    }
    EK(d, t);
  });
}
function Gw(e, t, n) {
  return { instance: e, listener: t, currentTarget: n };
}
function R6(e, t) {
  for (var n = t + "Capture", r = []; e !== null; ) {
    var i = e,
      s = i.stateNode;
    i.tag === 5 &&
      s !== null &&
      ((i = s),
      (s = Fw(e, n)),
      s != null && r.unshift(Gw(e, s, i)),
      (s = Fw(e, t)),
      s != null && r.push(Gw(e, s, i))),
      (e = e.return);
  }
  return r;
}
function U1(e) {
  if (e === null) return null;
  do e = e.return;
  while (e && e.tag !== 5);
  return e || null;
}
function SB(e, t, n, r, i) {
  for (var s = t._reactName, o = []; n !== null && n !== r; ) {
    var a = n,
      l = a.alternate,
      c = a.stateNode;
    if (l !== null && l === r) break;
    a.tag === 5 &&
      c !== null &&
      ((a = c),
      i
        ? ((l = Fw(n, s)), l != null && o.unshift(Gw(n, l, a)))
        : i || ((l = Fw(n, s)), l != null && o.push(Gw(n, l, a)))),
      (n = n.return);
  }
  o.length !== 0 && e.push({ event: t, listeners: o });
}
var bme = /\r\n?/g,
  xme = /\u0000|\uFFFD/g;
function EB(e) {
  return (typeof e == "string" ? e : "" + e)
    .replace(
      bme,
      `
`
    )
    .replace(xme, "");
}
function d_(e, t, n) {
  if (((t = EB(t)), EB(e) !== t && n)) throw Error(lt(425));
}
function O6() {}
var Ek = null,
  Ak = null;
function Ck(e, t) {
  return (
    e === "textarea" ||
    e === "noscript" ||
    typeof t.children == "string" ||
    typeof t.children == "number" ||
    (typeof t.dangerouslySetInnerHTML == "object" &&
      t.dangerouslySetInnerHTML !== null &&
      t.dangerouslySetInnerHTML.__html != null)
  );
}
var kk = typeof setTimeout == "function" ? setTimeout : void 0,
  _me = typeof clearTimeout == "function" ? clearTimeout : void 0,
  AB = typeof Promise == "function" ? Promise : void 0,
  Sme =
    typeof queueMicrotask == "function"
      ? queueMicrotask
      : typeof AB < "u"
      ? function (e) {
          return AB.resolve(null).then(e).catch(Eme);
        }
      : kk;
function Eme(e) {
  setTimeout(function () {
    throw e;
  });
}
function yA(e, t) {
  var n = t,
    r = 0;
  do {
    var i = n.nextSibling;
    if ((e.removeChild(n), i && i.nodeType === 8))
      if (((n = i.data), n === "/$")) {
        if (r === 0) {
          e.removeChild(i), zw(t);
          return;
        }
        r--;
      } else (n !== "$" && n !== "$?" && n !== "$!") || r++;
    n = i;
  } while (n);
  zw(t);
}
function Rp(e) {
  for (; e != null; e = e.nextSibling) {
    var t = e.nodeType;
    if (t === 1 || t === 3) break;
    if (t === 8) {
      if (((t = e.data), t === "$" || t === "$!" || t === "$?")) break;
      if (t === "/$") return null;
    }
  }
  return e;
}
function CB(e) {
  e = e.previousSibling;
  for (var t = 0; e; ) {
    if (e.nodeType === 8) {
      var n = e.data;
      if (n === "$" || n === "$!" || n === "$?") {
        if (t === 0) return e;
        t--;
      } else n === "/$" && t++;
    }
    e = e.previousSibling;
  }
  return null;
}
var rv = Math.random().toString(36).slice(2),
  ed = "__reactFiber$" + rv,
  qw = "__reactProps$" + rv,
  sh = "__reactContainer$" + rv,
  Tk = "__reactEvents$" + rv,
  Ame = "__reactListeners$" + rv,
  Cme = "__reactHandles$" + rv;
function em(e) {
  var t = e[ed];
  if (t) return t;
  for (var n = e.parentNode; n; ) {
    if ((t = n[sh] || n[ed])) {
      if (
        ((n = t.alternate),
        t.child !== null || (n !== null && n.child !== null))
      )
        for (e = CB(e); e !== null; ) {
          if ((n = e[ed])) return n;
          e = CB(e);
        }
      return t;
    }
    (e = n), (n = e.parentNode);
  }
  return null;
}
function lx(e) {
  return (
    (e = e[ed] || e[sh]),
    !e || (e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3) ? null : e
  );
}
function pg(e) {
  if (e.tag === 5 || e.tag === 6) return e.stateNode;
  throw Error(lt(33));
}
function BS(e) {
  return e[qw] || null;
}
var Mk = [],
  mg = -1;
function c0(e) {
  return { current: e };
}
function Hi(e) {
  0 > mg || ((e.current = Mk[mg]), (Mk[mg] = null), mg--);
}
function Li(e, t) {
  mg++, (Mk[mg] = e.current), (e.current = t);
}
var Kp = {},
  da = c0(Kp),
  nl = c0(!1),
  Lm = Kp;
function hy(e, t) {
  var n = e.type.contextTypes;
  if (!n) return Kp;
  var r = e.stateNode;
  if (r && r.__reactInternalMemoizedUnmaskedChildContext === t)
    return r.__reactInternalMemoizedMaskedChildContext;
  var i = {},
    s;
  for (s in n) i[s] = t[s];
  return (
    r &&
      ((e = e.stateNode),
      (e.__reactInternalMemoizedUnmaskedChildContext = t),
      (e.__reactInternalMemoizedMaskedChildContext = i)),
    i
  );
}
function rl(e) {
  return (e = e.childContextTypes), e != null;
}
function P6() {
  Hi(nl), Hi(da);
}
function kB(e, t, n) {
  if (da.current !== Kp) throw Error(lt(168));
  Li(da, t), Li(nl, n);
}
function CK(e, t, n) {
  var r = e.stateNode;
  if (((t = t.childContextTypes), typeof r.getChildContext != "function"))
    return n;
  r = r.getChildContext();
  for (var i in r) if (!(i in t)) throw Error(lt(108, u0e(e) || "Unknown", i));
  return ms({}, n, r);
}
function L6(e) {
  return (
    (e =
      ((e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext) || Kp),
    (Lm = da.current),
    Li(da, e),
    Li(nl, nl.current),
    !0
  );
}
function TB(e, t, n) {
  var r = e.stateNode;
  if (!r) throw Error(lt(169));
  n
    ? ((e = CK(e, t, Lm)),
      (r.__reactInternalMemoizedMergedChildContext = e),
      Hi(nl),
      Hi(da),
      Li(da, e))
    : Hi(nl),
    Li(nl, n);
}
var Af = null,
  FS = !1,
  vA = !1;
function kK(e) {
  Af === null ? (Af = [e]) : Af.push(e);
}
function kme(e) {
  (FS = !0), kK(e);
}
function u0() {
  if (!vA && Af !== null) {
    vA = !0;
    var e = 0,
      t = ui;
    try {
      var n = Af;
      for (ui = 1; e < n.length; e++) {
        var r = n[e];
        do r = r(!0);
        while (r !== null);
      }
      (Af = null), (FS = !1);
    } catch (i) {
      throw (Af !== null && (Af = Af.slice(e + 1)), Xq(KI, u0), i);
    } finally {
      (ui = t), (vA = !1);
    }
  }
  return null;
}
var gg = [],
  yg = 0,
  j6 = null,
  D6 = 0,
  yc = [],
  vc = 0,
  jm = null,
  Df = 1,
  Bf = "";
function F0(e, t) {
  (gg[yg++] = D6), (gg[yg++] = j6), (j6 = e), (D6 = t);
}
function TK(e, t, n) {
  (yc[vc++] = Df), (yc[vc++] = Bf), (yc[vc++] = jm), (jm = e);
  var r = Df;
  e = Bf;
  var i = 32 - wu(r) - 1;
  (r &= ~(1 << i)), (n += 1);
  var s = 32 - wu(t) + i;
  if (30 < s) {
    var o = i - (i % 5);
    (s = (r & ((1 << o) - 1)).toString(32)),
      (r >>= o),
      (i -= o),
      (Df = (1 << (32 - wu(t) + i)) | (n << i) | r),
      (Bf = s + e);
  } else (Df = (1 << s) | (n << i) | r), (Bf = e);
}
function rN(e) {
  e.return !== null && (F0(e, 1), TK(e, 1, 0));
}
function iN(e) {
  for (; e === j6; )
    (j6 = gg[--yg]), (gg[yg] = null), (D6 = gg[--yg]), (gg[yg] = null);
  for (; e === jm; )
    (jm = yc[--vc]),
      (yc[vc] = null),
      (Bf = yc[--vc]),
      (yc[vc] = null),
      (Df = yc[--vc]),
      (yc[vc] = null);
}
var Dl = null,
  Ol = null,
  rs = !1,
  fu = null;
function MK(e, t) {
  var n = _c(5, null, null, 0);
  (n.elementType = "DELETED"),
    (n.stateNode = t),
    (n.return = e),
    (t = e.deletions),
    t === null ? ((e.deletions = [n]), (e.flags |= 16)) : t.push(n);
}
function MB(e, t) {
  switch (e.tag) {
    case 5:
      var n = e.type;
      return (
        (t =
          t.nodeType !== 1 || n.toLowerCase() !== t.nodeName.toLowerCase()
            ? null
            : t),
        t !== null
          ? ((e.stateNode = t), (Dl = e), (Ol = Rp(t.firstChild)), !0)
          : !1
      );
    case 6:
      return (
        (t = e.pendingProps === "" || t.nodeType !== 3 ? null : t),
        t !== null ? ((e.stateNode = t), (Dl = e), (Ol = null), !0) : !1
      );
    case 13:
      return (
        (t = t.nodeType !== 8 ? null : t),
        t !== null
          ? ((n = jm !== null ? { id: Df, overflow: Bf } : null),
            (e.memoizedState = {
              dehydrated: t,
              treeContext: n,
              retryLane: 1073741824,
            }),
            (n = _c(18, null, null, 0)),
            (n.stateNode = t),
            (n.return = e),
            (e.child = n),
            (Dl = e),
            (Ol = null),
            !0)
          : !1
      );
    default:
      return !1;
  }
}
function Ik(e) {
  return (e.mode & 1) !== 0 && (e.flags & 128) === 0;
}
function Nk(e) {
  if (rs) {
    var t = Ol;
    if (t) {
      var n = t;
      if (!MB(e, t)) {
        if (Ik(e)) throw Error(lt(418));
        t = Rp(n.nextSibling);
        var r = Dl;
        t && MB(e, t)
          ? MK(r, n)
          : ((e.flags = (e.flags & -4097) | 2), (rs = !1), (Dl = e));
      }
    } else {
      if (Ik(e)) throw Error(lt(418));
      (e.flags = (e.flags & -4097) | 2), (rs = !1), (Dl = e);
    }
  }
}
function IB(e) {
  for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13; )
    e = e.return;
  Dl = e;
}
function f_(e) {
  if (e !== Dl) return !1;
  if (!rs) return IB(e), (rs = !0), !1;
  var t;
  if (
    ((t = e.tag !== 3) &&
      !(t = e.tag !== 5) &&
      ((t = e.type),
      (t = t !== "head" && t !== "body" && !Ck(e.type, e.memoizedProps))),
    t && (t = Ol))
  ) {
    if (Ik(e)) throw (IK(), Error(lt(418)));
    for (; t; ) MK(e, t), (t = Rp(t.nextSibling));
  }
  if ((IB(e), e.tag === 13)) {
    if (((e = e.memoizedState), (e = e !== null ? e.dehydrated : null), !e))
      throw Error(lt(317));
    e: {
      for (e = e.nextSibling, t = 0; e; ) {
        if (e.nodeType === 8) {
          var n = e.data;
          if (n === "/$") {
            if (t === 0) {
              Ol = Rp(e.nextSibling);
              break e;
            }
            t--;
          } else (n !== "$" && n !== "$!" && n !== "$?") || t++;
        }
        e = e.nextSibling;
      }
      Ol = null;
    }
  } else Ol = Dl ? Rp(e.stateNode.nextSibling) : null;
  return !0;
}
function IK() {
  for (var e = Ol; e; ) e = Rp(e.nextSibling);
}
function py() {
  (Ol = Dl = null), (rs = !1);
}
function sN(e) {
  fu === null ? (fu = [e]) : fu.push(e);
}
var Tme = yh.ReactCurrentBatchConfig;
function p2(e, t, n) {
  if (
    ((e = n.ref), e !== null && typeof e != "function" && typeof e != "object")
  ) {
    if (n._owner) {
      if (((n = n._owner), n)) {
        if (n.tag !== 1) throw Error(lt(309));
        var r = n.stateNode;
      }
      if (!r) throw Error(lt(147, e));
      var i = r,
        s = "" + e;
      return t !== null &&
        t.ref !== null &&
        typeof t.ref == "function" &&
        t.ref._stringRef === s
        ? t.ref
        : ((t = function (o) {
            var a = i.refs;
            o === null ? delete a[s] : (a[s] = o);
          }),
          (t._stringRef = s),
          t);
    }
    if (typeof e != "string") throw Error(lt(284));
    if (!n._owner) throw Error(lt(290, e));
  }
  return e;
}
function h_(e, t) {
  throw (
    ((e = Object.prototype.toString.call(t)),
    Error(
      lt(
        31,
        e === "[object Object]"
          ? "object with keys {" + Object.keys(t).join(", ") + "}"
          : e
      )
    ))
  );
}
function NB(e) {
  var t = e._init;
  return t(e._payload);
}
function NK(e) {
  function t(v, w) {
    if (e) {
      var x = v.deletions;
      x === null ? ((v.deletions = [w]), (v.flags |= 16)) : x.push(w);
    }
  }
  function n(v, w) {
    if (!e) return null;
    for (; w !== null; ) t(v, w), (w = w.sibling);
    return null;
  }
  function r(v, w) {
    for (v = new Map(); w !== null; )
      w.key !== null ? v.set(w.key, w) : v.set(w.index, w), (w = w.sibling);
    return v;
  }
  function i(v, w) {
    return (v = jp(v, w)), (v.index = 0), (v.sibling = null), v;
  }
  function s(v, w, x) {
    return (
      (v.index = x),
      e
        ? ((x = v.alternate),
          x !== null
            ? ((x = x.index), x < w ? ((v.flags |= 2), w) : x)
            : ((v.flags |= 2), w))
        : ((v.flags |= 1048576), w)
    );
  }
  function o(v) {
    return e && v.alternate === null && (v.flags |= 2), v;
  }
  function a(v, w, x, S) {
    return w === null || w.tag !== 6
      ? ((w = AA(x, v.mode, S)), (w.return = v), w)
      : ((w = i(w, x)), (w.return = v), w);
  }
  function l(v, w, x, S) {
    var R = x.type;
    return R === ug
      ? u(v, w, x.props.children, S, x.key)
      : w !== null &&
        (w.elementType === R ||
          (typeof R == "object" &&
            R !== null &&
            R.$$typeof === lp &&
            NB(R) === w.type))
      ? ((S = i(w, x.props)), (S.ref = p2(v, w, x)), (S.return = v), S)
      : ((S = x4(x.type, x.key, x.props, null, v.mode, S)),
        (S.ref = p2(v, w, x)),
        (S.return = v),
        S);
  }
  function c(v, w, x, S) {
    return w === null ||
      w.tag !== 4 ||
      w.stateNode.containerInfo !== x.containerInfo ||
      w.stateNode.implementation !== x.implementation
      ? ((w = CA(x, v.mode, S)), (w.return = v), w)
      : ((w = i(w, x.children || [])), (w.return = v), w);
  }
  function u(v, w, x, S, R) {
    return w === null || w.tag !== 7
      ? ((w = Sm(x, v.mode, S, R)), (w.return = v), w)
      : ((w = i(w, x)), (w.return = v), w);
  }
  function d(v, w, x) {
    if ((typeof w == "string" && w !== "") || typeof w == "number")
      return (w = AA("" + w, v.mode, x)), (w.return = v), w;
    if (typeof w == "object" && w !== null) {
      switch (w.$$typeof) {
        case n_:
          return (
            (x = x4(w.type, w.key, w.props, null, v.mode, x)),
            (x.ref = p2(v, null, w)),
            (x.return = v),
            x
          );
        case cg:
          return (w = CA(w, v.mode, x)), (w.return = v), w;
        case lp:
          var S = w._init;
          return d(v, S(w._payload), x);
      }
      if (H2(w) || c2(w))
        return (w = Sm(w, v.mode, x, null)), (w.return = v), w;
      h_(v, w);
    }
    return null;
  }
  function f(v, w, x, S) {
    var R = w !== null ? w.key : null;
    if ((typeof x == "string" && x !== "") || typeof x == "number")
      return R !== null ? null : a(v, w, "" + x, S);
    if (typeof x == "object" && x !== null) {
      switch (x.$$typeof) {
        case n_:
          return x.key === R ? l(v, w, x, S) : null;
        case cg:
          return x.key === R ? c(v, w, x, S) : null;
        case lp:
          return (R = x._init), f(v, w, R(x._payload), S);
      }
      if (H2(x) || c2(x)) return R !== null ? null : u(v, w, x, S, null);
      h_(v, x);
    }
    return null;
  }
  function h(v, w, x, S, R) {
    if ((typeof S == "string" && S !== "") || typeof S == "number")
      return (v = v.get(x) || null), a(w, v, "" + S, R);
    if (typeof S == "object" && S !== null) {
      switch (S.$$typeof) {
        case n_:
          return (v = v.get(S.key === null ? x : S.key) || null), l(w, v, S, R);
        case cg:
          return (v = v.get(S.key === null ? x : S.key) || null), c(w, v, S, R);
        case lp:
          var O = S._init;
          return h(v, w, x, O(S._payload), R);
      }
      if (H2(S) || c2(S)) return (v = v.get(x) || null), u(w, v, S, R, null);
      h_(w, S);
    }
    return null;
  }
  function p(v, w, x, S) {
    for (
      var R = null, O = null, B = w, C = (w = 0), I = null;
      B !== null && C < x.length;
      C++
    ) {
      B.index > C ? ((I = B), (B = null)) : (I = B.sibling);
      var P = f(v, B, x[C], S);
      if (P === null) {
        B === null && (B = I);
        break;
      }
      e && B && P.alternate === null && t(v, B),
        (w = s(P, w, C)),
        O === null ? (R = P) : (O.sibling = P),
        (O = P),
        (B = I);
    }
    if (C === x.length) return n(v, B), rs && F0(v, C), R;
    if (B === null) {
      for (; C < x.length; C++)
        (B = d(v, x[C], S)),
          B !== null &&
            ((w = s(B, w, C)), O === null ? (R = B) : (O.sibling = B), (O = B));
      return rs && F0(v, C), R;
    }
    for (B = r(v, B); C < x.length; C++)
      (I = h(B, v, C, x[C], S)),
        I !== null &&
          (e && I.alternate !== null && B.delete(I.key === null ? C : I.key),
          (w = s(I, w, C)),
          O === null ? (R = I) : (O.sibling = I),
          (O = I));
    return (
      e &&
        B.forEach(function (M) {
          return t(v, M);
        }),
      rs && F0(v, C),
      R
    );
  }
  function g(v, w, x, S) {
    var R = c2(x);
    if (typeof R != "function") throw Error(lt(150));
    if (((x = R.call(x)), x == null)) throw Error(lt(151));
    for (
      var O = (R = null), B = w, C = (w = 0), I = null, P = x.next();
      B !== null && !P.done;
      C++, P = x.next()
    ) {
      B.index > C ? ((I = B), (B = null)) : (I = B.sibling);
      var M = f(v, B, P.value, S);
      if (M === null) {
        B === null && (B = I);
        break;
      }
      e && B && M.alternate === null && t(v, B),
        (w = s(M, w, C)),
        O === null ? (R = M) : (O.sibling = M),
        (O = M),
        (B = I);
    }
    if (P.done) return n(v, B), rs && F0(v, C), R;
    if (B === null) {
      for (; !P.done; C++, P = x.next())
        (P = d(v, P.value, S)),
          P !== null &&
            ((w = s(P, w, C)), O === null ? (R = P) : (O.sibling = P), (O = P));
      return rs && F0(v, C), R;
    }
    for (B = r(v, B); !P.done; C++, P = x.next())
      (P = h(B, v, C, P.value, S)),
        P !== null &&
          (e && P.alternate !== null && B.delete(P.key === null ? C : P.key),
          (w = s(P, w, C)),
          O === null ? (R = P) : (O.sibling = P),
          (O = P));
    return (
      e &&
        B.forEach(function (k) {
          return t(v, k);
        }),
      rs && F0(v, C),
      R
    );
  }
  function b(v, w, x, S) {
    if (
      (typeof x == "object" &&
        x !== null &&
        x.type === ug &&
        x.key === null &&
        (x = x.props.children),
      typeof x == "object" && x !== null)
    ) {
      switch (x.$$typeof) {
        case n_:
          e: {
            for (var R = x.key, O = w; O !== null; ) {
              if (O.key === R) {
                if (((R = x.type), R === ug)) {
                  if (O.tag === 7) {
                    n(v, O.sibling),
                      (w = i(O, x.props.children)),
                      (w.return = v),
                      (v = w);
                    break e;
                  }
                } else if (
                  O.elementType === R ||
                  (typeof R == "object" &&
                    R !== null &&
                    R.$$typeof === lp &&
                    NB(R) === O.type)
                ) {
                  n(v, O.sibling),
                    (w = i(O, x.props)),
                    (w.ref = p2(v, O, x)),
                    (w.return = v),
                    (v = w);
                  break e;
                }
                n(v, O);
                break;
              } else t(v, O);
              O = O.sibling;
            }
            x.type === ug
              ? ((w = Sm(x.props.children, v.mode, S, x.key)),
                (w.return = v),
                (v = w))
              : ((S = x4(x.type, x.key, x.props, null, v.mode, S)),
                (S.ref = p2(v, w, x)),
                (S.return = v),
                (v = S));
          }
          return o(v);
        case cg:
          e: {
            for (O = x.key; w !== null; ) {
              if (w.key === O)
                if (
                  w.tag === 4 &&
                  w.stateNode.containerInfo === x.containerInfo &&
                  w.stateNode.implementation === x.implementation
                ) {
                  n(v, w.sibling),
                    (w = i(w, x.children || [])),
                    (w.return = v),
                    (v = w);
                  break e;
                } else {
                  n(v, w);
                  break;
                }
              else t(v, w);
              w = w.sibling;
            }
            (w = CA(x, v.mode, S)), (w.return = v), (v = w);
          }
          return o(v);
        case lp:
          return (O = x._init), b(v, w, O(x._payload), S);
      }
      if (H2(x)) return p(v, w, x, S);
      if (c2(x)) return g(v, w, x, S);
      h_(v, x);
    }
    return (typeof x == "string" && x !== "") || typeof x == "number"
      ? ((x = "" + x),
        w !== null && w.tag === 6
          ? (n(v, w.sibling), (w = i(w, x)), (w.return = v), (v = w))
          : (n(v, w), (w = AA(x, v.mode, S)), (w.return = v), (v = w)),
        o(v))
      : n(v, w);
  }
  return b;
}
var my = NK(!0),
  RK = NK(!1),
  B6 = c0(null),
  F6 = null,
  vg = null,
  oN = null;
function aN() {
  oN = vg = F6 = null;
}
function lN(e) {
  var t = B6.current;
  Hi(B6), (e._currentValue = t);
}
function Rk(e, t, n) {
  for (; e !== null; ) {
    var r = e.alternate;
    if (
      ((e.childLanes & t) !== t
        ? ((e.childLanes |= t), r !== null && (r.childLanes |= t))
        : r !== null && (r.childLanes & t) !== t && (r.childLanes |= t),
      e === n)
    )
      break;
    e = e.return;
  }
}
function Hg(e, t) {
  (F6 = e),
    (oN = vg = null),
    (e = e.dependencies),
    e !== null &&
      e.firstContext !== null &&
      (e.lanes & t && (Ja = !0), (e.firstContext = null));
}
function Mc(e) {
  var t = e._currentValue;
  if (oN !== e)
    if (((e = { context: e, memoizedValue: t, next: null }), vg === null)) {
      if (F6 === null) throw Error(lt(308));
      (vg = e), (F6.dependencies = { lanes: 0, firstContext: e });
    } else vg = vg.next = e;
  return t;
}
var tm = null;
function cN(e) {
  tm === null ? (tm = [e]) : tm.push(e);
}
function OK(e, t, n, r) {
  var i = t.interleaved;
  return (
    i === null ? ((n.next = n), cN(t)) : ((n.next = i.next), (i.next = n)),
    (t.interleaved = n),
    oh(e, r)
  );
}
function oh(e, t) {
  e.lanes |= t;
  var n = e.alternate;
  for (n !== null && (n.lanes |= t), n = e, e = e.return; e !== null; )
    (e.childLanes |= t),
      (n = e.alternate),
      n !== null && (n.childLanes |= t),
      (n = e),
      (e = e.return);
  return n.tag === 3 ? n.stateNode : null;
}
var cp = !1;
function uN(e) {
  e.updateQueue = {
    baseState: e.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: { pending: null, interleaved: null, lanes: 0 },
    effects: null,
  };
}
function PK(e, t) {
  (e = e.updateQueue),
    t.updateQueue === e &&
      (t.updateQueue = {
        baseState: e.baseState,
        firstBaseUpdate: e.firstBaseUpdate,
        lastBaseUpdate: e.lastBaseUpdate,
        shared: e.shared,
        effects: e.effects,
      });
}
function qf(e, t) {
  return {
    eventTime: e,
    lane: t,
    tag: 0,
    payload: null,
    callback: null,
    next: null,
  };
}
function Op(e, t, n) {
  var r = e.updateQueue;
  if (r === null) return null;
  if (((r = r.shared), $r & 2)) {
    var i = r.pending;
    return (
      i === null ? (t.next = t) : ((t.next = i.next), (i.next = t)),
      (r.pending = t),
      oh(e, n)
    );
  }
  return (
    (i = r.interleaved),
    i === null ? ((t.next = t), cN(r)) : ((t.next = i.next), (i.next = t)),
    (r.interleaved = t),
    oh(e, n)
  );
}
function m4(e, t, n) {
  if (
    ((t = t.updateQueue), t !== null && ((t = t.shared), (n & 4194240) !== 0))
  ) {
    var r = t.lanes;
    (r &= e.pendingLanes), (n |= r), (t.lanes = n), YI(e, n);
  }
}
function RB(e, t) {
  var n = e.updateQueue,
    r = e.alternate;
  if (r !== null && ((r = r.updateQueue), n === r)) {
    var i = null,
      s = null;
    if (((n = n.firstBaseUpdate), n !== null)) {
      do {
        var o = {
          eventTime: n.eventTime,
          lane: n.lane,
          tag: n.tag,
          payload: n.payload,
          callback: n.callback,
          next: null,
        };
        s === null ? (i = s = o) : (s = s.next = o), (n = n.next);
      } while (n !== null);
      s === null ? (i = s = t) : (s = s.next = t);
    } else i = s = t;
    (n = {
      baseState: r.baseState,
      firstBaseUpdate: i,
      lastBaseUpdate: s,
      shared: r.shared,
      effects: r.effects,
    }),
      (e.updateQueue = n);
    return;
  }
  (e = n.lastBaseUpdate),
    e === null ? (n.firstBaseUpdate = t) : (e.next = t),
    (n.lastBaseUpdate = t);
}
function U6(e, t, n, r) {
  var i = e.updateQueue;
  cp = !1;
  var s = i.firstBaseUpdate,
    o = i.lastBaseUpdate,
    a = i.shared.pending;
  if (a !== null) {
    i.shared.pending = null;
    var l = a,
      c = l.next;
    (l.next = null), o === null ? (s = c) : (o.next = c), (o = l);
    var u = e.alternate;
    u !== null &&
      ((u = u.updateQueue),
      (a = u.lastBaseUpdate),
      a !== o &&
        (a === null ? (u.firstBaseUpdate = c) : (a.next = c),
        (u.lastBaseUpdate = l)));
  }
  if (s !== null) {
    var d = i.baseState;
    (o = 0), (u = c = l = null), (a = s);
    do {
      var f = a.lane,
        h = a.eventTime;
      if ((r & f) === f) {
        u !== null &&
          (u = u.next =
            {
              eventTime: h,
              lane: 0,
              tag: a.tag,
              payload: a.payload,
              callback: a.callback,
              next: null,
            });
        e: {
          var p = e,
            g = a;
          switch (((f = t), (h = n), g.tag)) {
            case 1:
              if (((p = g.payload), typeof p == "function")) {
                d = p.call(h, d, f);
                break e;
              }
              d = p;
              break e;
            case 3:
              p.flags = (p.flags & -65537) | 128;
            case 0:
              if (
                ((p = g.payload),
                (f = typeof p == "function" ? p.call(h, d, f) : p),
                f == null)
              )
                break e;
              d = ms({}, d, f);
              break e;
            case 2:
              cp = !0;
          }
        }
        a.callback !== null &&
          a.lane !== 0 &&
          ((e.flags |= 64),
          (f = i.effects),
          f === null ? (i.effects = [a]) : f.push(a));
      } else
        (h = {
          eventTime: h,
          lane: f,
          tag: a.tag,
          payload: a.payload,
          callback: a.callback,
          next: null,
        }),
          u === null ? ((c = u = h), (l = d)) : (u = u.next = h),
          (o |= f);
      if (((a = a.next), a === null)) {
        if (((a = i.shared.pending), a === null)) break;
        (f = a),
          (a = f.next),
          (f.next = null),
          (i.lastBaseUpdate = f),
          (i.shared.pending = null);
      }
    } while (!0);
    if (
      (u === null && (l = d),
      (i.baseState = l),
      (i.firstBaseUpdate = c),
      (i.lastBaseUpdate = u),
      (t = i.shared.interleaved),
      t !== null)
    ) {
      i = t;
      do (o |= i.lane), (i = i.next);
      while (i !== t);
    } else s === null && (i.shared.lanes = 0);
    (Bm |= o), (e.lanes = o), (e.memoizedState = d);
  }
}
function OB(e, t, n) {
  if (((e = t.effects), (t.effects = null), e !== null))
    for (t = 0; t < e.length; t++) {
      var r = e[t],
        i = r.callback;
      if (i !== null) {
        if (((r.callback = null), (r = n), typeof i != "function"))
          throw Error(lt(191, i));
        i.call(r);
      }
    }
}
var cx = {},
  yd = c0(cx),
  Kw = c0(cx),
  Yw = c0(cx);
function nm(e) {
  if (e === cx) throw Error(lt(174));
  return e;
}
function dN(e, t) {
  switch ((Li(Yw, t), Li(Kw, e), Li(yd, cx), (e = t.nodeType), e)) {
    case 9:
    case 11:
      t = (t = t.documentElement) ? t.namespaceURI : fk(null, "");
      break;
    default:
      (e = e === 8 ? t.parentNode : t),
        (t = e.namespaceURI || null),
        (e = e.tagName),
        (t = fk(t, e));
  }
  Hi(yd), Li(yd, t);
}
function gy() {
  Hi(yd), Hi(Kw), Hi(Yw);
}
function LK(e) {
  nm(Yw.current);
  var t = nm(yd.current),
    n = fk(t, e.type);
  t !== n && (Li(Kw, e), Li(yd, n));
}
function fN(e) {
  Kw.current === e && (Hi(yd), Hi(Kw));
}
var cs = c0(0);
function $6(e) {
  for (var t = e; t !== null; ) {
    if (t.tag === 13) {
      var n = t.memoizedState;
      if (
        n !== null &&
        ((n = n.dehydrated), n === null || n.data === "$?" || n.data === "$!")
      )
        return t;
    } else if (t.tag === 19 && t.memoizedProps.revealOrder !== void 0) {
      if (t.flags & 128) return t;
    } else if (t.child !== null) {
      (t.child.return = t), (t = t.child);
      continue;
    }
    if (t === e) break;
    for (; t.sibling === null; ) {
      if (t.return === null || t.return === e) return null;
      t = t.return;
    }
    (t.sibling.return = t.return), (t = t.sibling);
  }
  return null;
}
var wA = [];
function hN() {
  for (var e = 0; e < wA.length; e++)
    wA[e]._workInProgressVersionPrimary = null;
  wA.length = 0;
}
var g4 = yh.ReactCurrentDispatcher,
  bA = yh.ReactCurrentBatchConfig,
  Dm = 0,
  ps = null,
  Zs = null,
  yo = null,
  z6 = !1,
  dw = !1,
  Zw = 0,
  Mme = 0;
function Ko() {
  throw Error(lt(321));
}
function pN(e, t) {
  if (t === null) return !1;
  for (var n = 0; n < t.length && n < e.length; n++)
    if (!Su(e[n], t[n])) return !1;
  return !0;
}
function mN(e, t, n, r, i, s) {
  if (
    ((Dm = s),
    (ps = t),
    (t.memoizedState = null),
    (t.updateQueue = null),
    (t.lanes = 0),
    (g4.current = e === null || e.memoizedState === null ? Ome : Pme),
    (e = n(r, i)),
    dw)
  ) {
    s = 0;
    do {
      if (((dw = !1), (Zw = 0), 25 <= s)) throw Error(lt(301));
      (s += 1),
        (yo = Zs = null),
        (t.updateQueue = null),
        (g4.current = Lme),
        (e = n(r, i));
    } while (dw);
  }
  if (
    ((g4.current = W6),
    (t = Zs !== null && Zs.next !== null),
    (Dm = 0),
    (yo = Zs = ps = null),
    (z6 = !1),
    t)
  )
    throw Error(lt(300));
  return e;
}
function gN() {
  var e = Zw !== 0;
  return (Zw = 0), e;
}
function Ku() {
  var e = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null,
  };
  return yo === null ? (ps.memoizedState = yo = e) : (yo = yo.next = e), yo;
}
function Ic() {
  if (Zs === null) {
    var e = ps.alternate;
    e = e !== null ? e.memoizedState : null;
  } else e = Zs.next;
  var t = yo === null ? ps.memoizedState : yo.next;
  if (t !== null) (yo = t), (Zs = e);
  else {
    if (e === null) throw Error(lt(310));
    (Zs = e),
      (e = {
        memoizedState: Zs.memoizedState,
        baseState: Zs.baseState,
        baseQueue: Zs.baseQueue,
        queue: Zs.queue,
        next: null,
      }),
      yo === null ? (ps.memoizedState = yo = e) : (yo = yo.next = e);
  }
  return yo;
}
function Qw(e, t) {
  return typeof t == "function" ? t(e) : t;
}
function xA(e) {
  var t = Ic(),
    n = t.queue;
  if (n === null) throw Error(lt(311));
  n.lastRenderedReducer = e;
  var r = Zs,
    i = r.baseQueue,
    s = n.pending;
  if (s !== null) {
    if (i !== null) {
      var o = i.next;
      (i.next = s.next), (s.next = o);
    }
    (r.baseQueue = i = s), (n.pending = null);
  }
  if (i !== null) {
    (s = i.next), (r = r.baseState);
    var a = (o = null),
      l = null,
      c = s;
    do {
      var u = c.lane;
      if ((Dm & u) === u)
        l !== null &&
          (l = l.next =
            {
              lane: 0,
              action: c.action,
              hasEagerState: c.hasEagerState,
              eagerState: c.eagerState,
              next: null,
            }),
          (r = c.hasEagerState ? c.eagerState : e(r, c.action));
      else {
        var d = {
          lane: u,
          action: c.action,
          hasEagerState: c.hasEagerState,
          eagerState: c.eagerState,
          next: null,
        };
        l === null ? ((a = l = d), (o = r)) : (l = l.next = d),
          (ps.lanes |= u),
          (Bm |= u);
      }
      c = c.next;
    } while (c !== null && c !== s);
    l === null ? (o = r) : (l.next = a),
      Su(r, t.memoizedState) || (Ja = !0),
      (t.memoizedState = r),
      (t.baseState = o),
      (t.baseQueue = l),
      (n.lastRenderedState = r);
  }
  if (((e = n.interleaved), e !== null)) {
    i = e;
    do (s = i.lane), (ps.lanes |= s), (Bm |= s), (i = i.next);
    while (i !== e);
  } else i === null && (n.lanes = 0);
  return [t.memoizedState, n.dispatch];
}
function _A(e) {
  var t = Ic(),
    n = t.queue;
  if (n === null) throw Error(lt(311));
  n.lastRenderedReducer = e;
  var r = n.dispatch,
    i = n.pending,
    s = t.memoizedState;
  if (i !== null) {
    n.pending = null;
    var o = (i = i.next);
    do (s = e(s, o.action)), (o = o.next);
    while (o !== i);
    Su(s, t.memoizedState) || (Ja = !0),
      (t.memoizedState = s),
      t.baseQueue === null && (t.baseState = s),
      (n.lastRenderedState = s);
  }
  return [s, r];
}
function jK() {}
function DK(e, t) {
  var n = ps,
    r = Ic(),
    i = t(),
    s = !Su(r.memoizedState, i);
  if (
    (s && ((r.memoizedState = i), (Ja = !0)),
    (r = r.queue),
    yN(UK.bind(null, n, r, e), [e]),
    r.getSnapshot !== t || s || (yo !== null && yo.memoizedState.tag & 1))
  ) {
    if (
      ((n.flags |= 2048),
      Xw(9, FK.bind(null, n, r, i, t), void 0, null),
      _o === null)
    )
      throw Error(lt(349));
    Dm & 30 || BK(n, t, i);
  }
  return i;
}
function BK(e, t, n) {
  (e.flags |= 16384),
    (e = { getSnapshot: t, value: n }),
    (t = ps.updateQueue),
    t === null
      ? ((t = { lastEffect: null, stores: null }),
        (ps.updateQueue = t),
        (t.stores = [e]))
      : ((n = t.stores), n === null ? (t.stores = [e]) : n.push(e));
}
function FK(e, t, n, r) {
  (t.value = n), (t.getSnapshot = r), $K(t) && zK(e);
}
function UK(e, t, n) {
  return n(function () {
    $K(t) && zK(e);
  });
}
function $K(e) {
  var t = e.getSnapshot;
  e = e.value;
  try {
    var n = t();
    return !Su(e, n);
  } catch {
    return !0;
  }
}
function zK(e) {
  var t = oh(e, 1);
  t !== null && bu(t, e, 1, -1);
}
function PB(e) {
  var t = Ku();
  return (
    typeof e == "function" && (e = e()),
    (t.memoizedState = t.baseState = e),
    (e = {
      pending: null,
      interleaved: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: Qw,
      lastRenderedState: e,
    }),
    (t.queue = e),
    (e = e.dispatch = Rme.bind(null, ps, e)),
    [t.memoizedState, e]
  );
}
function Xw(e, t, n, r) {
  return (
    (e = { tag: e, create: t, destroy: n, deps: r, next: null }),
    (t = ps.updateQueue),
    t === null
      ? ((t = { lastEffect: null, stores: null }),
        (ps.updateQueue = t),
        (t.lastEffect = e.next = e))
      : ((n = t.lastEffect),
        n === null
          ? (t.lastEffect = e.next = e)
          : ((r = n.next), (n.next = e), (e.next = r), (t.lastEffect = e))),
    e
  );
}
function WK() {
  return Ic().memoizedState;
}
function y4(e, t, n, r) {
  var i = Ku();
  (ps.flags |= e),
    (i.memoizedState = Xw(1 | t, n, void 0, r === void 0 ? null : r));
}
function US(e, t, n, r) {
  var i = Ic();
  r = r === void 0 ? null : r;
  var s = void 0;
  if (Zs !== null) {
    var o = Zs.memoizedState;
    if (((s = o.destroy), r !== null && pN(r, o.deps))) {
      i.memoizedState = Xw(t, n, s, r);
      return;
    }
  }
  (ps.flags |= e), (i.memoizedState = Xw(1 | t, n, s, r));
}
function LB(e, t) {
  return y4(8390656, 8, e, t);
}
function yN(e, t) {
  return US(2048, 8, e, t);
}
function HK(e, t) {
  return US(4, 2, e, t);
}
function VK(e, t) {
  return US(4, 4, e, t);
}
function GK(e, t) {
  if (typeof t == "function")
    return (
      (e = e()),
      t(e),
      function () {
        t(null);
      }
    );
  if (t != null)
    return (
      (e = e()),
      (t.current = e),
      function () {
        t.current = null;
      }
    );
}
function qK(e, t, n) {
  return (
    (n = n != null ? n.concat([e]) : null), US(4, 4, GK.bind(null, t, e), n)
  );
}
function vN() {}
function KK(e, t) {
  var n = Ic();
  t = t === void 0 ? null : t;
  var r = n.memoizedState;
  return r !== null && t !== null && pN(t, r[1])
    ? r[0]
    : ((n.memoizedState = [e, t]), e);
}
function YK(e, t) {
  var n = Ic();
  t = t === void 0 ? null : t;
  var r = n.memoizedState;
  return r !== null && t !== null && pN(t, r[1])
    ? r[0]
    : ((e = e()), (n.memoizedState = [e, t]), e);
}
function ZK(e, t, n) {
  return Dm & 21
    ? (Su(n, t) || ((n = tK()), (ps.lanes |= n), (Bm |= n), (e.baseState = !0)),
      t)
    : (e.baseState && ((e.baseState = !1), (Ja = !0)), (e.memoizedState = n));
}
function Ime(e, t) {
  var n = ui;
  (ui = n !== 0 && 4 > n ? n : 4), e(!0);
  var r = bA.transition;
  bA.transition = {};
  try {
    e(!1), t();
  } finally {
    (ui = n), (bA.transition = r);
  }
}
function QK() {
  return Ic().memoizedState;
}
function Nme(e, t, n) {
  var r = Lp(e);
  if (
    ((n = {
      lane: r,
      action: n,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    }),
    XK(e))
  )
    JK(t, n);
  else if (((n = OK(e, t, n, r)), n !== null)) {
    var i = Ca();
    bu(n, e, r, i), eY(n, t, r);
  }
}
function Rme(e, t, n) {
  var r = Lp(e),
    i = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null };
  if (XK(e)) JK(t, i);
  else {
    var s = e.alternate;
    if (
      e.lanes === 0 &&
      (s === null || s.lanes === 0) &&
      ((s = t.lastRenderedReducer), s !== null)
    )
      try {
        var o = t.lastRenderedState,
          a = s(o, n);
        if (((i.hasEagerState = !0), (i.eagerState = a), Su(a, o))) {
          var l = t.interleaved;
          l === null
            ? ((i.next = i), cN(t))
            : ((i.next = l.next), (l.next = i)),
            (t.interleaved = i);
          return;
        }
      } catch {
      } finally {
      }
    (n = OK(e, t, i, r)),
      n !== null && ((i = Ca()), bu(n, e, r, i), eY(n, t, r));
  }
}
function XK(e) {
  var t = e.alternate;
  return e === ps || (t !== null && t === ps);
}
function JK(e, t) {
  dw = z6 = !0;
  var n = e.pending;
  n === null ? (t.next = t) : ((t.next = n.next), (n.next = t)),
    (e.pending = t);
}
function eY(e, t, n) {
  if (n & 4194240) {
    var r = t.lanes;
    (r &= e.pendingLanes), (n |= r), (t.lanes = n), YI(e, n);
  }
}
var W6 = {
    readContext: Mc,
    useCallback: Ko,
    useContext: Ko,
    useEffect: Ko,
    useImperativeHandle: Ko,
    useInsertionEffect: Ko,
    useLayoutEffect: Ko,
    useMemo: Ko,
    useReducer: Ko,
    useRef: Ko,
    useState: Ko,
    useDebugValue: Ko,
    useDeferredValue: Ko,
    useTransition: Ko,
    useMutableSource: Ko,
    useSyncExternalStore: Ko,
    useId: Ko,
    unstable_isNewReconciler: !1,
  },
  Ome = {
    readContext: Mc,
    useCallback: function (e, t) {
      return (Ku().memoizedState = [e, t === void 0 ? null : t]), e;
    },
    useContext: Mc,
    useEffect: LB,
    useImperativeHandle: function (e, t, n) {
      return (
        (n = n != null ? n.concat([e]) : null),
        y4(4194308, 4, GK.bind(null, t, e), n)
      );
    },
    useLayoutEffect: function (e, t) {
      return y4(4194308, 4, e, t);
    },
    useInsertionEffect: function (e, t) {
      return y4(4, 2, e, t);
    },
    useMemo: function (e, t) {
      var n = Ku();
      return (
        (t = t === void 0 ? null : t), (e = e()), (n.memoizedState = [e, t]), e
      );
    },
    useReducer: function (e, t, n) {
      var r = Ku();
      return (
        (t = n !== void 0 ? n(t) : t),
        (r.memoizedState = r.baseState = t),
        (e = {
          pending: null,
          interleaved: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: e,
          lastRenderedState: t,
        }),
        (r.queue = e),
        (e = e.dispatch = Nme.bind(null, ps, e)),
        [r.memoizedState, e]
      );
    },
    useRef: function (e) {
      var t = Ku();
      return (e = { current: e }), (t.memoizedState = e);
    },
    useState: PB,
    useDebugValue: vN,
    useDeferredValue: function (e) {
      return (Ku().memoizedState = e);
    },
    useTransition: function () {
      var e = PB(!1),
        t = e[0];
      return (e = Ime.bind(null, e[1])), (Ku().memoizedState = e), [t, e];
    },
    useMutableSource: function () {},
    useSyncExternalStore: function (e, t, n) {
      var r = ps,
        i = Ku();
      if (rs) {
        if (n === void 0) throw Error(lt(407));
        n = n();
      } else {
        if (((n = t()), _o === null)) throw Error(lt(349));
        Dm & 30 || BK(r, t, n);
      }
      i.memoizedState = n;
      var s = { value: n, getSnapshot: t };
      return (
        (i.queue = s),
        LB(UK.bind(null, r, s, e), [e]),
        (r.flags |= 2048),
        Xw(9, FK.bind(null, r, s, n, t), void 0, null),
        n
      );
    },
    useId: function () {
      var e = Ku(),
        t = _o.identifierPrefix;
      if (rs) {
        var n = Bf,
          r = Df;
        (n = (r & ~(1 << (32 - wu(r) - 1))).toString(32) + n),
          (t = ":" + t + "R" + n),
          (n = Zw++),
          0 < n && (t += "H" + n.toString(32)),
          (t += ":");
      } else (n = Mme++), (t = ":" + t + "r" + n.toString(32) + ":");
      return (e.memoizedState = t);
    },
    unstable_isNewReconciler: !1,
  },
  Pme = {
    readContext: Mc,
    useCallback: KK,
    useContext: Mc,
    useEffect: yN,
    useImperativeHandle: qK,
    useInsertionEffect: HK,
    useLayoutEffect: VK,
    useMemo: YK,
    useReducer: xA,
    useRef: WK,
    useState: function () {
      return xA(Qw);
    },
    useDebugValue: vN,
    useDeferredValue: function (e) {
      var t = Ic();
      return ZK(t, Zs.memoizedState, e);
    },
    useTransition: function () {
      var e = xA(Qw)[0],
        t = Ic().memoizedState;
      return [e, t];
    },
    useMutableSource: jK,
    useSyncExternalStore: DK,
    useId: QK,
    unstable_isNewReconciler: !1,
  },
  Lme = {
    readContext: Mc,
    useCallback: KK,
    useContext: Mc,
    useEffect: yN,
    useImperativeHandle: qK,
    useInsertionEffect: HK,
    useLayoutEffect: VK,
    useMemo: YK,
    useReducer: _A,
    useRef: WK,
    useState: function () {
      return _A(Qw);
    },
    useDebugValue: vN,
    useDeferredValue: function (e) {
      var t = Ic();
      return Zs === null ? (t.memoizedState = e) : ZK(t, Zs.memoizedState, e);
    },
    useTransition: function () {
      var e = _A(Qw)[0],
        t = Ic().memoizedState;
      return [e, t];
    },
    useMutableSource: jK,
    useSyncExternalStore: DK,
    useId: QK,
    unstable_isNewReconciler: !1,
  };
function ou(e, t) {
  if (e && e.defaultProps) {
    (t = ms({}, t)), (e = e.defaultProps);
    for (var n in e) t[n] === void 0 && (t[n] = e[n]);
    return t;
  }
  return t;
}
function Ok(e, t, n, r) {
  (t = e.memoizedState),
    (n = n(r, t)),
    (n = n == null ? t : ms({}, t, n)),
    (e.memoizedState = n),
    e.lanes === 0 && (e.updateQueue.baseState = n);
}
var $S = {
  isMounted: function (e) {
    return (e = e._reactInternals) ? d1(e) === e : !1;
  },
  enqueueSetState: function (e, t, n) {
    e = e._reactInternals;
    var r = Ca(),
      i = Lp(e),
      s = qf(r, i);
    (s.payload = t),
      n != null && (s.callback = n),
      (t = Op(e, s, i)),
      t !== null && (bu(t, e, i, r), m4(t, e, i));
  },
  enqueueReplaceState: function (e, t, n) {
    e = e._reactInternals;
    var r = Ca(),
      i = Lp(e),
      s = qf(r, i);
    (s.tag = 1),
      (s.payload = t),
      n != null && (s.callback = n),
      (t = Op(e, s, i)),
      t !== null && (bu(t, e, i, r), m4(t, e, i));
  },
  enqueueForceUpdate: function (e, t) {
    e = e._reactInternals;
    var n = Ca(),
      r = Lp(e),
      i = qf(n, r);
    (i.tag = 2),
      t != null && (i.callback = t),
      (t = Op(e, i, r)),
      t !== null && (bu(t, e, r, n), m4(t, e, r));
  },
};
function jB(e, t, n, r, i, s, o) {
  return (
    (e = e.stateNode),
    typeof e.shouldComponentUpdate == "function"
      ? e.shouldComponentUpdate(r, s, o)
      : t.prototype && t.prototype.isPureReactComponent
      ? !Hw(n, r) || !Hw(i, s)
      : !0
  );
}
function tY(e, t, n) {
  var r = !1,
    i = Kp,
    s = t.contextType;
  return (
    typeof s == "object" && s !== null
      ? (s = Mc(s))
      : ((i = rl(t) ? Lm : da.current),
        (r = t.contextTypes),
        (s = (r = r != null) ? hy(e, i) : Kp)),
    (t = new t(n, s)),
    (e.memoizedState = t.state !== null && t.state !== void 0 ? t.state : null),
    (t.updater = $S),
    (e.stateNode = t),
    (t._reactInternals = e),
    r &&
      ((e = e.stateNode),
      (e.__reactInternalMemoizedUnmaskedChildContext = i),
      (e.__reactInternalMemoizedMaskedChildContext = s)),
    t
  );
}
function DB(e, t, n, r) {
  (e = t.state),
    typeof t.componentWillReceiveProps == "function" &&
      t.componentWillReceiveProps(n, r),
    typeof t.UNSAFE_componentWillReceiveProps == "function" &&
      t.UNSAFE_componentWillReceiveProps(n, r),
    t.state !== e && $S.enqueueReplaceState(t, t.state, null);
}
function Pk(e, t, n, r) {
  var i = e.stateNode;
  (i.props = n), (i.state = e.memoizedState), (i.refs = {}), uN(e);
  var s = t.contextType;
  typeof s == "object" && s !== null
    ? (i.context = Mc(s))
    : ((s = rl(t) ? Lm : da.current), (i.context = hy(e, s))),
    (i.state = e.memoizedState),
    (s = t.getDerivedStateFromProps),
    typeof s == "function" && (Ok(e, t, s, n), (i.state = e.memoizedState)),
    typeof t.getDerivedStateFromProps == "function" ||
      typeof i.getSnapshotBeforeUpdate == "function" ||
      (typeof i.UNSAFE_componentWillMount != "function" &&
        typeof i.componentWillMount != "function") ||
      ((t = i.state),
      typeof i.componentWillMount == "function" && i.componentWillMount(),
      typeof i.UNSAFE_componentWillMount == "function" &&
        i.UNSAFE_componentWillMount(),
      t !== i.state && $S.enqueueReplaceState(i, i.state, null),
      U6(e, n, i, r),
      (i.state = e.memoizedState)),
    typeof i.componentDidMount == "function" && (e.flags |= 4194308);
}
function yy(e, t) {
  try {
    var n = "",
      r = t;
    do (n += c0e(r)), (r = r.return);
    while (r);
    var i = n;
  } catch (s) {
    i =
      `
Error generating stack: ` +
      s.message +
      `
` +
      s.stack;
  }
  return { value: e, source: t, stack: i, digest: null };
}
function SA(e, t, n) {
  return { value: e, source: null, stack: n ?? null, digest: t ?? null };
}
function Lk(e, t) {
  try {
    console.error(t.value);
  } catch (n) {
    setTimeout(function () {
      throw n;
    });
  }
}
var jme = typeof WeakMap == "function" ? WeakMap : Map;
function nY(e, t, n) {
  (n = qf(-1, n)), (n.tag = 3), (n.payload = { element: null });
  var r = t.value;
  return (
    (n.callback = function () {
      V6 || ((V6 = !0), (Vk = r)), Lk(e, t);
    }),
    n
  );
}
function rY(e, t, n) {
  (n = qf(-1, n)), (n.tag = 3);
  var r = e.type.getDerivedStateFromError;
  if (typeof r == "function") {
    var i = t.value;
    (n.payload = function () {
      return r(i);
    }),
      (n.callback = function () {
        Lk(e, t);
      });
  }
  var s = e.stateNode;
  return (
    s !== null &&
      typeof s.componentDidCatch == "function" &&
      (n.callback = function () {
        Lk(e, t),
          typeof r != "function" &&
            (Pp === null ? (Pp = new Set([this])) : Pp.add(this));
        var o = t.stack;
        this.componentDidCatch(t.value, {
          componentStack: o !== null ? o : "",
        });
      }),
    n
  );
}
function BB(e, t, n) {
  var r = e.pingCache;
  if (r === null) {
    r = e.pingCache = new jme();
    var i = new Set();
    r.set(t, i);
  } else (i = r.get(t)), i === void 0 && ((i = new Set()), r.set(t, i));
  i.has(n) || (i.add(n), (e = Zme.bind(null, e, t, n)), t.then(e, e));
}
function FB(e) {
  do {
    var t;
    if (
      ((t = e.tag === 13) &&
        ((t = e.memoizedState), (t = t !== null ? t.dehydrated !== null : !0)),
      t)
    )
      return e;
    e = e.return;
  } while (e !== null);
  return null;
}
function UB(e, t, n, r, i) {
  return e.mode & 1
    ? ((e.flags |= 65536), (e.lanes = i), e)
    : (e === t
        ? (e.flags |= 65536)
        : ((e.flags |= 128),
          (n.flags |= 131072),
          (n.flags &= -52805),
          n.tag === 1 &&
            (n.alternate === null
              ? (n.tag = 17)
              : ((t = qf(-1, 1)), (t.tag = 2), Op(n, t, 1))),
          (n.lanes |= 1)),
      e);
}
var Dme = yh.ReactCurrentOwner,
  Ja = !1;
function ba(e, t, n, r) {
  t.child = e === null ? RK(t, null, n, r) : my(t, e.child, n, r);
}
function $B(e, t, n, r, i) {
  n = n.render;
  var s = t.ref;
  return (
    Hg(t, i),
    (r = mN(e, t, n, r, s, i)),
    (n = gN()),
    e !== null && !Ja
      ? ((t.updateQueue = e.updateQueue),
        (t.flags &= -2053),
        (e.lanes &= ~i),
        ah(e, t, i))
      : (rs && n && rN(t), (t.flags |= 1), ba(e, t, r, i), t.child)
  );
}
function zB(e, t, n, r, i) {
  if (e === null) {
    var s = n.type;
    return typeof s == "function" &&
      !CN(s) &&
      s.defaultProps === void 0 &&
      n.compare === null &&
      n.defaultProps === void 0
      ? ((t.tag = 15), (t.type = s), iY(e, t, s, r, i))
      : ((e = x4(n.type, null, r, t, t.mode, i)),
        (e.ref = t.ref),
        (e.return = t),
        (t.child = e));
  }
  if (((s = e.child), !(e.lanes & i))) {
    var o = s.memoizedProps;
    if (
      ((n = n.compare), (n = n !== null ? n : Hw), n(o, r) && e.ref === t.ref)
    )
      return ah(e, t, i);
  }
  return (
    (t.flags |= 1),
    (e = jp(s, r)),
    (e.ref = t.ref),
    (e.return = t),
    (t.child = e)
  );
}
function iY(e, t, n, r, i) {
  if (e !== null) {
    var s = e.memoizedProps;
    if (Hw(s, r) && e.ref === t.ref)
      if (((Ja = !1), (t.pendingProps = r = s), (e.lanes & i) !== 0))
        e.flags & 131072 && (Ja = !0);
      else return (t.lanes = e.lanes), ah(e, t, i);
  }
  return jk(e, t, n, r, i);
}
function sY(e, t, n) {
  var r = t.pendingProps,
    i = r.children,
    s = e !== null ? e.memoizedState : null;
  if (r.mode === "hidden")
    if (!(t.mode & 1))
      (t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        Li(bg, Al),
        (Al |= n);
    else {
      if (!(n & 1073741824))
        return (
          (e = s !== null ? s.baseLanes | n : n),
          (t.lanes = t.childLanes = 1073741824),
          (t.memoizedState = {
            baseLanes: e,
            cachePool: null,
            transitions: null,
          }),
          (t.updateQueue = null),
          Li(bg, Al),
          (Al |= e),
          null
        );
      (t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        (r = s !== null ? s.baseLanes : n),
        Li(bg, Al),
        (Al |= r);
    }
  else
    s !== null ? ((r = s.baseLanes | n), (t.memoizedState = null)) : (r = n),
      Li(bg, Al),
      (Al |= r);
  return ba(e, t, i, n), t.child;
}
function oY(e, t) {
  var n = t.ref;
  ((e === null && n !== null) || (e !== null && e.ref !== n)) &&
    ((t.flags |= 512), (t.flags |= 2097152));
}
function jk(e, t, n, r, i) {
  var s = rl(n) ? Lm : da.current;
  return (
    (s = hy(t, s)),
    Hg(t, i),
    (n = mN(e, t, n, r, s, i)),
    (r = gN()),
    e !== null && !Ja
      ? ((t.updateQueue = e.updateQueue),
        (t.flags &= -2053),
        (e.lanes &= ~i),
        ah(e, t, i))
      : (rs && r && rN(t), (t.flags |= 1), ba(e, t, n, i), t.child)
  );
}
function WB(e, t, n, r, i) {
  if (rl(n)) {
    var s = !0;
    L6(t);
  } else s = !1;
  if ((Hg(t, i), t.stateNode === null))
    v4(e, t), tY(t, n, r), Pk(t, n, r, i), (r = !0);
  else if (e === null) {
    var o = t.stateNode,
      a = t.memoizedProps;
    o.props = a;
    var l = o.context,
      c = n.contextType;
    typeof c == "object" && c !== null
      ? (c = Mc(c))
      : ((c = rl(n) ? Lm : da.current), (c = hy(t, c)));
    var u = n.getDerivedStateFromProps,
      d =
        typeof u == "function" ||
        typeof o.getSnapshotBeforeUpdate == "function";
    d ||
      (typeof o.UNSAFE_componentWillReceiveProps != "function" &&
        typeof o.componentWillReceiveProps != "function") ||
      ((a !== r || l !== c) && DB(t, o, r, c)),
      (cp = !1);
    var f = t.memoizedState;
    (o.state = f),
      U6(t, r, o, i),
      (l = t.memoizedState),
      a !== r || f !== l || nl.current || cp
        ? (typeof u == "function" && (Ok(t, n, u, r), (l = t.memoizedState)),
          (a = cp || jB(t, n, a, r, f, l, c))
            ? (d ||
                (typeof o.UNSAFE_componentWillMount != "function" &&
                  typeof o.componentWillMount != "function") ||
                (typeof o.componentWillMount == "function" &&
                  o.componentWillMount(),
                typeof o.UNSAFE_componentWillMount == "function" &&
                  o.UNSAFE_componentWillMount()),
              typeof o.componentDidMount == "function" && (t.flags |= 4194308))
            : (typeof o.componentDidMount == "function" && (t.flags |= 4194308),
              (t.memoizedProps = r),
              (t.memoizedState = l)),
          (o.props = r),
          (o.state = l),
          (o.context = c),
          (r = a))
        : (typeof o.componentDidMount == "function" && (t.flags |= 4194308),
          (r = !1));
  } else {
    (o = t.stateNode),
      PK(e, t),
      (a = t.memoizedProps),
      (c = t.type === t.elementType ? a : ou(t.type, a)),
      (o.props = c),
      (d = t.pendingProps),
      (f = o.context),
      (l = n.contextType),
      typeof l == "object" && l !== null
        ? (l = Mc(l))
        : ((l = rl(n) ? Lm : da.current), (l = hy(t, l)));
    var h = n.getDerivedStateFromProps;
    (u =
      typeof h == "function" ||
      typeof o.getSnapshotBeforeUpdate == "function") ||
      (typeof o.UNSAFE_componentWillReceiveProps != "function" &&
        typeof o.componentWillReceiveProps != "function") ||
      ((a !== d || f !== l) && DB(t, o, r, l)),
      (cp = !1),
      (f = t.memoizedState),
      (o.state = f),
      U6(t, r, o, i);
    var p = t.memoizedState;
    a !== d || f !== p || nl.current || cp
      ? (typeof h == "function" && (Ok(t, n, h, r), (p = t.memoizedState)),
        (c = cp || jB(t, n, c, r, f, p, l) || !1)
          ? (u ||
              (typeof o.UNSAFE_componentWillUpdate != "function" &&
                typeof o.componentWillUpdate != "function") ||
              (typeof o.componentWillUpdate == "function" &&
                o.componentWillUpdate(r, p, l),
              typeof o.UNSAFE_componentWillUpdate == "function" &&
                o.UNSAFE_componentWillUpdate(r, p, l)),
            typeof o.componentDidUpdate == "function" && (t.flags |= 4),
            typeof o.getSnapshotBeforeUpdate == "function" && (t.flags |= 1024))
          : (typeof o.componentDidUpdate != "function" ||
              (a === e.memoizedProps && f === e.memoizedState) ||
              (t.flags |= 4),
            typeof o.getSnapshotBeforeUpdate != "function" ||
              (a === e.memoizedProps && f === e.memoizedState) ||
              (t.flags |= 1024),
            (t.memoizedProps = r),
            (t.memoizedState = p)),
        (o.props = r),
        (o.state = p),
        (o.context = l),
        (r = c))
      : (typeof o.componentDidUpdate != "function" ||
          (a === e.memoizedProps && f === e.memoizedState) ||
          (t.flags |= 4),
        typeof o.getSnapshotBeforeUpdate != "function" ||
          (a === e.memoizedProps && f === e.memoizedState) ||
          (t.flags |= 1024),
        (r = !1));
  }
  return Dk(e, t, n, r, s, i);
}
function Dk(e, t, n, r, i, s) {
  oY(e, t);
  var o = (t.flags & 128) !== 0;
  if (!r && !o) return i && TB(t, n, !1), ah(e, t, s);
  (r = t.stateNode), (Dme.current = t);
  var a =
    o && typeof n.getDerivedStateFromError != "function" ? null : r.render();
  return (
    (t.flags |= 1),
    e !== null && o
      ? ((t.child = my(t, e.child, null, s)), (t.child = my(t, null, a, s)))
      : ba(e, t, a, s),
    (t.memoizedState = r.state),
    i && TB(t, n, !0),
    t.child
  );
}
function aY(e) {
  var t = e.stateNode;
  t.pendingContext
    ? kB(e, t.pendingContext, t.pendingContext !== t.context)
    : t.context && kB(e, t.context, !1),
    dN(e, t.containerInfo);
}
function HB(e, t, n, r, i) {
  return py(), sN(i), (t.flags |= 256), ba(e, t, n, r), t.child;
}
var Bk = { dehydrated: null, treeContext: null, retryLane: 0 };
function Fk(e) {
  return { baseLanes: e, cachePool: null, transitions: null };
}
function lY(e, t, n) {
  var r = t.pendingProps,
    i = cs.current,
    s = !1,
    o = (t.flags & 128) !== 0,
    a;
  if (
    ((a = o) ||
      (a = e !== null && e.memoizedState === null ? !1 : (i & 2) !== 0),
    a
      ? ((s = !0), (t.flags &= -129))
      : (e === null || e.memoizedState !== null) && (i |= 1),
    Li(cs, i & 1),
    e === null)
  )
    return (
      Nk(t),
      (e = t.memoizedState),
      e !== null && ((e = e.dehydrated), e !== null)
        ? (t.mode & 1
            ? e.data === "$!"
              ? (t.lanes = 8)
              : (t.lanes = 1073741824)
            : (t.lanes = 1),
          null)
        : ((o = r.children),
          (e = r.fallback),
          s
            ? ((r = t.mode),
              (s = t.child),
              (o = { mode: "hidden", children: o }),
              !(r & 1) && s !== null
                ? ((s.childLanes = 0), (s.pendingProps = o))
                : (s = HS(o, r, 0, null)),
              (e = Sm(e, r, n, null)),
              (s.return = t),
              (e.return = t),
              (s.sibling = e),
              (t.child = s),
              (t.child.memoizedState = Fk(n)),
              (t.memoizedState = Bk),
              e)
            : wN(t, o))
    );
  if (((i = e.memoizedState), i !== null && ((a = i.dehydrated), a !== null)))
    return Bme(e, t, o, r, a, i, n);
  if (s) {
    (s = r.fallback), (o = t.mode), (i = e.child), (a = i.sibling);
    var l = { mode: "hidden", children: r.children };
    return (
      !(o & 1) && t.child !== i
        ? ((r = t.child),
          (r.childLanes = 0),
          (r.pendingProps = l),
          (t.deletions = null))
        : ((r = jp(i, l)), (r.subtreeFlags = i.subtreeFlags & 14680064)),
      a !== null ? (s = jp(a, s)) : ((s = Sm(s, o, n, null)), (s.flags |= 2)),
      (s.return = t),
      (r.return = t),
      (r.sibling = s),
      (t.child = r),
      (r = s),
      (s = t.child),
      (o = e.child.memoizedState),
      (o =
        o === null
          ? Fk(n)
          : {
              baseLanes: o.baseLanes | n,
              cachePool: null,
              transitions: o.transitions,
            }),
      (s.memoizedState = o),
      (s.childLanes = e.childLanes & ~n),
      (t.memoizedState = Bk),
      r
    );
  }
  return (
    (s = e.child),
    (e = s.sibling),
    (r = jp(s, { mode: "visible", children: r.children })),
    !(t.mode & 1) && (r.lanes = n),
    (r.return = t),
    (r.sibling = null),
    e !== null &&
      ((n = t.deletions),
      n === null ? ((t.deletions = [e]), (t.flags |= 16)) : n.push(e)),
    (t.child = r),
    (t.memoizedState = null),
    r
  );
}
function wN(e, t) {
  return (
    (t = HS({ mode: "visible", children: t }, e.mode, 0, null)),
    (t.return = e),
    (e.child = t)
  );
}
function p_(e, t, n, r) {
  return (
    r !== null && sN(r),
    my(t, e.child, null, n),
    (e = wN(t, t.pendingProps.children)),
    (e.flags |= 2),
    (t.memoizedState = null),
    e
  );
}
function Bme(e, t, n, r, i, s, o) {
  if (n)
    return t.flags & 256
      ? ((t.flags &= -257), (r = SA(Error(lt(422)))), p_(e, t, o, r))
      : t.memoizedState !== null
      ? ((t.child = e.child), (t.flags |= 128), null)
      : ((s = r.fallback),
        (i = t.mode),
        (r = HS({ mode: "visible", children: r.children }, i, 0, null)),
        (s = Sm(s, i, o, null)),
        (s.flags |= 2),
        (r.return = t),
        (s.return = t),
        (r.sibling = s),
        (t.child = r),
        t.mode & 1 && my(t, e.child, null, o),
        (t.child.memoizedState = Fk(o)),
        (t.memoizedState = Bk),
        s);
  if (!(t.mode & 1)) return p_(e, t, o, null);
  if (i.data === "$!") {
    if (((r = i.nextSibling && i.nextSibling.dataset), r)) var a = r.dgst;
    return (
      (r = a), (s = Error(lt(419))), (r = SA(s, r, void 0)), p_(e, t, o, r)
    );
  }
  if (((a = (o & e.childLanes) !== 0), Ja || a)) {
    if (((r = _o), r !== null)) {
      switch (o & -o) {
        case 4:
          i = 2;
          break;
        case 16:
          i = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          i = 32;
          break;
        case 536870912:
          i = 268435456;
          break;
        default:
          i = 0;
      }
      (i = i & (r.suspendedLanes | o) ? 0 : i),
        i !== 0 &&
          i !== s.retryLane &&
          ((s.retryLane = i), oh(e, i), bu(r, e, i, -1));
    }
    return AN(), (r = SA(Error(lt(421)))), p_(e, t, o, r);
  }
  return i.data === "$?"
    ? ((t.flags |= 128),
      (t.child = e.child),
      (t = Qme.bind(null, e)),
      (i._reactRetry = t),
      null)
    : ((e = s.treeContext),
      (Ol = Rp(i.nextSibling)),
      (Dl = t),
      (rs = !0),
      (fu = null),
      e !== null &&
        ((yc[vc++] = Df),
        (yc[vc++] = Bf),
        (yc[vc++] = jm),
        (Df = e.id),
        (Bf = e.overflow),
        (jm = t)),
      (t = wN(t, r.children)),
      (t.flags |= 4096),
      t);
}
function VB(e, t, n) {
  e.lanes |= t;
  var r = e.alternate;
  r !== null && (r.lanes |= t), Rk(e.return, t, n);
}
function EA(e, t, n, r, i) {
  var s = e.memoizedState;
  s === null
    ? (e.memoizedState = {
        isBackwards: t,
        rendering: null,
        renderingStartTime: 0,
        last: r,
        tail: n,
        tailMode: i,
      })
    : ((s.isBackwards = t),
      (s.rendering = null),
      (s.renderingStartTime = 0),
      (s.last = r),
      (s.tail = n),
      (s.tailMode = i));
}
function cY(e, t, n) {
  var r = t.pendingProps,
    i = r.revealOrder,
    s = r.tail;
  if ((ba(e, t, r.children, n), (r = cs.current), r & 2))
    (r = (r & 1) | 2), (t.flags |= 128);
  else {
    if (e !== null && e.flags & 128)
      e: for (e = t.child; e !== null; ) {
        if (e.tag === 13) e.memoizedState !== null && VB(e, n, t);
        else if (e.tag === 19) VB(e, n, t);
        else if (e.child !== null) {
          (e.child.return = e), (e = e.child);
          continue;
        }
        if (e === t) break e;
        for (; e.sibling === null; ) {
          if (e.return === null || e.return === t) break e;
          e = e.return;
        }
        (e.sibling.return = e.return), (e = e.sibling);
      }
    r &= 1;
  }
  if ((Li(cs, r), !(t.mode & 1))) t.memoizedState = null;
  else
    switch (i) {
      case "forwards":
        for (n = t.child, i = null; n !== null; )
          (e = n.alternate),
            e !== null && $6(e) === null && (i = n),
            (n = n.sibling);
        (n = i),
          n === null
            ? ((i = t.child), (t.child = null))
            : ((i = n.sibling), (n.sibling = null)),
          EA(t, !1, i, n, s);
        break;
      case "backwards":
        for (n = null, i = t.child, t.child = null; i !== null; ) {
          if (((e = i.alternate), e !== null && $6(e) === null)) {
            t.child = i;
            break;
          }
          (e = i.sibling), (i.sibling = n), (n = i), (i = e);
        }
        EA(t, !0, n, null, s);
        break;
      case "together":
        EA(t, !1, null, null, void 0);
        break;
      default:
        t.memoizedState = null;
    }
  return t.child;
}
function v4(e, t) {
  !(t.mode & 1) &&
    e !== null &&
    ((e.alternate = null), (t.alternate = null), (t.flags |= 2));
}
function ah(e, t, n) {
  if (
    (e !== null && (t.dependencies = e.dependencies),
    (Bm |= t.lanes),
    !(n & t.childLanes))
  )
    return null;
  if (e !== null && t.child !== e.child) throw Error(lt(153));
  if (t.child !== null) {
    for (
      e = t.child, n = jp(e, e.pendingProps), t.child = n, n.return = t;
      e.sibling !== null;

    )
      (e = e.sibling), (n = n.sibling = jp(e, e.pendingProps)), (n.return = t);
    n.sibling = null;
  }
  return t.child;
}
function Fme(e, t, n) {
  switch (t.tag) {
    case 3:
      aY(t), py();
      break;
    case 5:
      LK(t);
      break;
    case 1:
      rl(t.type) && L6(t);
      break;
    case 4:
      dN(t, t.stateNode.containerInfo);
      break;
    case 10:
      var r = t.type._context,
        i = t.memoizedProps.value;
      Li(B6, r._currentValue), (r._currentValue = i);
      break;
    case 13:
      if (((r = t.memoizedState), r !== null))
        return r.dehydrated !== null
          ? (Li(cs, cs.current & 1), (t.flags |= 128), null)
          : n & t.child.childLanes
          ? lY(e, t, n)
          : (Li(cs, cs.current & 1),
            (e = ah(e, t, n)),
            e !== null ? e.sibling : null);
      Li(cs, cs.current & 1);
      break;
    case 19:
      if (((r = (n & t.childLanes) !== 0), e.flags & 128)) {
        if (r) return cY(e, t, n);
        t.flags |= 128;
      }
      if (
        ((i = t.memoizedState),
        i !== null &&
          ((i.rendering = null), (i.tail = null), (i.lastEffect = null)),
        Li(cs, cs.current),
        r)
      )
        break;
      return null;
    case 22:
    case 23:
      return (t.lanes = 0), sY(e, t, n);
  }
  return ah(e, t, n);
}
var uY, Uk, dY, fY;
uY = function (e, t) {
  for (var n = t.child; n !== null; ) {
    if (n.tag === 5 || n.tag === 6) e.appendChild(n.stateNode);
    else if (n.tag !== 4 && n.child !== null) {
      (n.child.return = n), (n = n.child);
      continue;
    }
    if (n === t) break;
    for (; n.sibling === null; ) {
      if (n.return === null || n.return === t) return;
      n = n.return;
    }
    (n.sibling.return = n.return), (n = n.sibling);
  }
};
Uk = function () {};
dY = function (e, t, n, r) {
  var i = e.memoizedProps;
  if (i !== r) {
    (e = t.stateNode), nm(yd.current);
    var s = null;
    switch (n) {
      case "input":
        (i = lk(e, i)), (r = lk(e, r)), (s = []);
        break;
      case "select":
        (i = ms({}, i, { value: void 0 })),
          (r = ms({}, r, { value: void 0 })),
          (s = []);
        break;
      case "textarea":
        (i = dk(e, i)), (r = dk(e, r)), (s = []);
        break;
      default:
        typeof i.onClick != "function" &&
          typeof r.onClick == "function" &&
          (e.onclick = O6);
    }
    hk(n, r);
    var o;
    n = null;
    for (c in i)
      if (!r.hasOwnProperty(c) && i.hasOwnProperty(c) && i[c] != null)
        if (c === "style") {
          var a = i[c];
          for (o in a) a.hasOwnProperty(o) && (n || (n = {}), (n[o] = ""));
        } else
          c !== "dangerouslySetInnerHTML" &&
            c !== "children" &&
            c !== "suppressContentEditableWarning" &&
            c !== "suppressHydrationWarning" &&
            c !== "autoFocus" &&
            (Dw.hasOwnProperty(c)
              ? s || (s = [])
              : (s = s || []).push(c, null));
    for (c in r) {
      var l = r[c];
      if (
        ((a = i != null ? i[c] : void 0),
        r.hasOwnProperty(c) && l !== a && (l != null || a != null))
      )
        if (c === "style")
          if (a) {
            for (o in a)
              !a.hasOwnProperty(o) ||
                (l && l.hasOwnProperty(o)) ||
                (n || (n = {}), (n[o] = ""));
            for (o in l)
              l.hasOwnProperty(o) &&
                a[o] !== l[o] &&
                (n || (n = {}), (n[o] = l[o]));
          } else n || (s || (s = []), s.push(c, n)), (n = l);
        else
          c === "dangerouslySetInnerHTML"
            ? ((l = l ? l.__html : void 0),
              (a = a ? a.__html : void 0),
              l != null && a !== l && (s = s || []).push(c, l))
            : c === "children"
            ? (typeof l != "string" && typeof l != "number") ||
              (s = s || []).push(c, "" + l)
            : c !== "suppressContentEditableWarning" &&
              c !== "suppressHydrationWarning" &&
              (Dw.hasOwnProperty(c)
                ? (l != null && c === "onScroll" && Fi("scroll", e),
                  s || a === l || (s = []))
                : (s = s || []).push(c, l));
    }
    n && (s = s || []).push("style", n);
    var c = s;
    (t.updateQueue = c) && (t.flags |= 4);
  }
};
fY = function (e, t, n, r) {
  n !== r && (t.flags |= 4);
};
function m2(e, t) {
  if (!rs)
    switch (e.tailMode) {
      case "hidden":
        t = e.tail;
        for (var n = null; t !== null; )
          t.alternate !== null && (n = t), (t = t.sibling);
        n === null ? (e.tail = null) : (n.sibling = null);
        break;
      case "collapsed":
        n = e.tail;
        for (var r = null; n !== null; )
          n.alternate !== null && (r = n), (n = n.sibling);
        r === null
          ? t || e.tail === null
            ? (e.tail = null)
            : (e.tail.sibling = null)
          : (r.sibling = null);
    }
}
function Yo(e) {
  var t = e.alternate !== null && e.alternate.child === e.child,
    n = 0,
    r = 0;
  if (t)
    for (var i = e.child; i !== null; )
      (n |= i.lanes | i.childLanes),
        (r |= i.subtreeFlags & 14680064),
        (r |= i.flags & 14680064),
        (i.return = e),
        (i = i.sibling);
  else
    for (i = e.child; i !== null; )
      (n |= i.lanes | i.childLanes),
        (r |= i.subtreeFlags),
        (r |= i.flags),
        (i.return = e),
        (i = i.sibling);
  return (e.subtreeFlags |= r), (e.childLanes = n), t;
}
function Ume(e, t, n) {
  var r = t.pendingProps;
  switch ((iN(t), t.tag)) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return Yo(t), null;
    case 1:
      return rl(t.type) && P6(), Yo(t), null;
    case 3:
      return (
        (r = t.stateNode),
        gy(),
        Hi(nl),
        Hi(da),
        hN(),
        r.pendingContext &&
          ((r.context = r.pendingContext), (r.pendingContext = null)),
        (e === null || e.child === null) &&
          (f_(t)
            ? (t.flags |= 4)
            : e === null ||
              (e.memoizedState.isDehydrated && !(t.flags & 256)) ||
              ((t.flags |= 1024), fu !== null && (Kk(fu), (fu = null)))),
        Uk(e, t),
        Yo(t),
        null
      );
    case 5:
      fN(t);
      var i = nm(Yw.current);
      if (((n = t.type), e !== null && t.stateNode != null))
        dY(e, t, n, r, i),
          e.ref !== t.ref && ((t.flags |= 512), (t.flags |= 2097152));
      else {
        if (!r) {
          if (t.stateNode === null) throw Error(lt(166));
          return Yo(t), null;
        }
        if (((e = nm(yd.current)), f_(t))) {
          (r = t.stateNode), (n = t.type);
          var s = t.memoizedProps;
          switch (((r[ed] = t), (r[qw] = s), (e = (t.mode & 1) !== 0), n)) {
            case "dialog":
              Fi("cancel", r), Fi("close", r);
              break;
            case "iframe":
            case "object":
            case "embed":
              Fi("load", r);
              break;
            case "video":
            case "audio":
              for (i = 0; i < G2.length; i++) Fi(G2[i], r);
              break;
            case "source":
              Fi("error", r);
              break;
            case "img":
            case "image":
            case "link":
              Fi("error", r), Fi("load", r);
              break;
            case "details":
              Fi("toggle", r);
              break;
            case "input":
              eB(r, s), Fi("invalid", r);
              break;
            case "select":
              (r._wrapperState = { wasMultiple: !!s.multiple }),
                Fi("invalid", r);
              break;
            case "textarea":
              nB(r, s), Fi("invalid", r);
          }
          hk(n, s), (i = null);
          for (var o in s)
            if (s.hasOwnProperty(o)) {
              var a = s[o];
              o === "children"
                ? typeof a == "string"
                  ? r.textContent !== a &&
                    (s.suppressHydrationWarning !== !0 &&
                      d_(r.textContent, a, e),
                    (i = ["children", a]))
                  : typeof a == "number" &&
                    r.textContent !== "" + a &&
                    (s.suppressHydrationWarning !== !0 &&
                      d_(r.textContent, a, e),
                    (i = ["children", "" + a]))
                : Dw.hasOwnProperty(o) &&
                  a != null &&
                  o === "onScroll" &&
                  Fi("scroll", r);
            }
          switch (n) {
            case "input":
              r_(r), tB(r, s, !0);
              break;
            case "textarea":
              r_(r), rB(r);
              break;
            case "select":
            case "option":
              break;
            default:
              typeof s.onClick == "function" && (r.onclick = O6);
          }
          (r = i), (t.updateQueue = r), r !== null && (t.flags |= 4);
        } else {
          (o = i.nodeType === 9 ? i : i.ownerDocument),
            e === "http://www.w3.org/1999/xhtml" && (e = Uq(n)),
            e === "http://www.w3.org/1999/xhtml"
              ? n === "script"
                ? ((e = o.createElement("div")),
                  (e.innerHTML = "<script></script>"),
                  (e = e.removeChild(e.firstChild)))
                : typeof r.is == "string"
                ? (e = o.createElement(n, { is: r.is }))
                : ((e = o.createElement(n)),
                  n === "select" &&
                    ((o = e),
                    r.multiple
                      ? (o.multiple = !0)
                      : r.size && (o.size = r.size)))
              : (e = o.createElementNS(e, n)),
            (e[ed] = t),
            (e[qw] = r),
            uY(e, t, !1, !1),
            (t.stateNode = e);
          e: {
            switch (((o = pk(n, r)), n)) {
              case "dialog":
                Fi("cancel", e), Fi("close", e), (i = r);
                break;
              case "iframe":
              case "object":
              case "embed":
                Fi("load", e), (i = r);
                break;
              case "video":
              case "audio":
                for (i = 0; i < G2.length; i++) Fi(G2[i], e);
                i = r;
                break;
              case "source":
                Fi("error", e), (i = r);
                break;
              case "img":
              case "image":
              case "link":
                Fi("error", e), Fi("load", e), (i = r);
                break;
              case "details":
                Fi("toggle", e), (i = r);
                break;
              case "input":
                eB(e, r), (i = lk(e, r)), Fi("invalid", e);
                break;
              case "option":
                i = r;
                break;
              case "select":
                (e._wrapperState = { wasMultiple: !!r.multiple }),
                  (i = ms({}, r, { value: void 0 })),
                  Fi("invalid", e);
                break;
              case "textarea":
                nB(e, r), (i = dk(e, r)), Fi("invalid", e);
                break;
              default:
                i = r;
            }
            hk(n, i), (a = i);
            for (s in a)
              if (a.hasOwnProperty(s)) {
                var l = a[s];
                s === "style"
                  ? Wq(e, l)
                  : s === "dangerouslySetInnerHTML"
                  ? ((l = l ? l.__html : void 0), l != null && $q(e, l))
                  : s === "children"
                  ? typeof l == "string"
                    ? (n !== "textarea" || l !== "") && Bw(e, l)
                    : typeof l == "number" && Bw(e, "" + l)
                  : s !== "suppressContentEditableWarning" &&
                    s !== "suppressHydrationWarning" &&
                    s !== "autoFocus" &&
                    (Dw.hasOwnProperty(s)
                      ? l != null && s === "onScroll" && Fi("scroll", e)
                      : l != null && WI(e, s, l, o));
              }
            switch (n) {
              case "input":
                r_(e), tB(e, r, !1);
                break;
              case "textarea":
                r_(e), rB(e);
                break;
              case "option":
                r.value != null && e.setAttribute("value", "" + qp(r.value));
                break;
              case "select":
                (e.multiple = !!r.multiple),
                  (s = r.value),
                  s != null
                    ? Ug(e, !!r.multiple, s, !1)
                    : r.defaultValue != null &&
                      Ug(e, !!r.multiple, r.defaultValue, !0);
                break;
              default:
                typeof i.onClick == "function" && (e.onclick = O6);
            }
            switch (n) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                r = !!r.autoFocus;
                break e;
              case "img":
                r = !0;
                break e;
              default:
                r = !1;
            }
          }
          r && (t.flags |= 4);
        }
        t.ref !== null && ((t.flags |= 512), (t.flags |= 2097152));
      }
      return Yo(t), null;
    case 6:
      if (e && t.stateNode != null) fY(e, t, e.memoizedProps, r);
      else {
        if (typeof r != "string" && t.stateNode === null) throw Error(lt(166));
        if (((n = nm(Yw.current)), nm(yd.current), f_(t))) {
          if (
            ((r = t.stateNode),
            (n = t.memoizedProps),
            (r[ed] = t),
            (s = r.nodeValue !== n) && ((e = Dl), e !== null))
          )
            switch (e.tag) {
              case 3:
                d_(r.nodeValue, n, (e.mode & 1) !== 0);
                break;
              case 5:
                e.memoizedProps.suppressHydrationWarning !== !0 &&
                  d_(r.nodeValue, n, (e.mode & 1) !== 0);
            }
          s && (t.flags |= 4);
        } else
          (r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r)),
            (r[ed] = t),
            (t.stateNode = r);
      }
      return Yo(t), null;
    case 13:
      if (
        (Hi(cs),
        (r = t.memoizedState),
        e === null ||
          (e.memoizedState !== null && e.memoizedState.dehydrated !== null))
      ) {
        if (rs && Ol !== null && t.mode & 1 && !(t.flags & 128))
          IK(), py(), (t.flags |= 98560), (s = !1);
        else if (((s = f_(t)), r !== null && r.dehydrated !== null)) {
          if (e === null) {
            if (!s) throw Error(lt(318));
            if (
              ((s = t.memoizedState),
              (s = s !== null ? s.dehydrated : null),
              !s)
            )
              throw Error(lt(317));
            s[ed] = t;
          } else
            py(), !(t.flags & 128) && (t.memoizedState = null), (t.flags |= 4);
          Yo(t), (s = !1);
        } else fu !== null && (Kk(fu), (fu = null)), (s = !0);
        if (!s) return t.flags & 65536 ? t : null;
      }
      return t.flags & 128
        ? ((t.lanes = n), t)
        : ((r = r !== null),
          r !== (e !== null && e.memoizedState !== null) &&
            r &&
            ((t.child.flags |= 8192),
            t.mode & 1 &&
              (e === null || cs.current & 1 ? to === 0 && (to = 3) : AN())),
          t.updateQueue !== null && (t.flags |= 4),
          Yo(t),
          null);
    case 4:
      return (
        gy(), Uk(e, t), e === null && Vw(t.stateNode.containerInfo), Yo(t), null
      );
    case 10:
      return lN(t.type._context), Yo(t), null;
    case 17:
      return rl(t.type) && P6(), Yo(t), null;
    case 19:
      if ((Hi(cs), (s = t.memoizedState), s === null)) return Yo(t), null;
      if (((r = (t.flags & 128) !== 0), (o = s.rendering), o === null))
        if (r) m2(s, !1);
        else {
          if (to !== 0 || (e !== null && e.flags & 128))
            for (e = t.child; e !== null; ) {
              if (((o = $6(e)), o !== null)) {
                for (
                  t.flags |= 128,
                    m2(s, !1),
                    r = o.updateQueue,
                    r !== null && ((t.updateQueue = r), (t.flags |= 4)),
                    t.subtreeFlags = 0,
                    r = n,
                    n = t.child;
                  n !== null;

                )
                  (s = n),
                    (e = r),
                    (s.flags &= 14680066),
                    (o = s.alternate),
                    o === null
                      ? ((s.childLanes = 0),
                        (s.lanes = e),
                        (s.child = null),
                        (s.subtreeFlags = 0),
                        (s.memoizedProps = null),
                        (s.memoizedState = null),
                        (s.updateQueue = null),
                        (s.dependencies = null),
                        (s.stateNode = null))
                      : ((s.childLanes = o.childLanes),
                        (s.lanes = o.lanes),
                        (s.child = o.child),
                        (s.subtreeFlags = 0),
                        (s.deletions = null),
                        (s.memoizedProps = o.memoizedProps),
                        (s.memoizedState = o.memoizedState),
                        (s.updateQueue = o.updateQueue),
                        (s.type = o.type),
                        (e = o.dependencies),
                        (s.dependencies =
                          e === null
                            ? null
                            : {
                                lanes: e.lanes,
                                firstContext: e.firstContext,
                              })),
                    (n = n.sibling);
                return Li(cs, (cs.current & 1) | 2), t.child;
              }
              e = e.sibling;
            }
          s.tail !== null &&
            Ns() > vy &&
            ((t.flags |= 128), (r = !0), m2(s, !1), (t.lanes = 4194304));
        }
      else {
        if (!r)
          if (((e = $6(o)), e !== null)) {
            if (
              ((t.flags |= 128),
              (r = !0),
              (n = e.updateQueue),
              n !== null && ((t.updateQueue = n), (t.flags |= 4)),
              m2(s, !0),
              s.tail === null && s.tailMode === "hidden" && !o.alternate && !rs)
            )
              return Yo(t), null;
          } else
            2 * Ns() - s.renderingStartTime > vy &&
              n !== 1073741824 &&
              ((t.flags |= 128), (r = !0), m2(s, !1), (t.lanes = 4194304));
        s.isBackwards
          ? ((o.sibling = t.child), (t.child = o))
          : ((n = s.last),
            n !== null ? (n.sibling = o) : (t.child = o),
            (s.last = o));
      }
      return s.tail !== null
        ? ((t = s.tail),
          (s.rendering = t),
          (s.tail = t.sibling),
          (s.renderingStartTime = Ns()),
          (t.sibling = null),
          (n = cs.current),
          Li(cs, r ? (n & 1) | 2 : n & 1),
          t)
        : (Yo(t), null);
    case 22:
    case 23:
      return (
        EN(),
        (r = t.memoizedState !== null),
        e !== null && (e.memoizedState !== null) !== r && (t.flags |= 8192),
        r && t.mode & 1
          ? Al & 1073741824 && (Yo(t), t.subtreeFlags & 6 && (t.flags |= 8192))
          : Yo(t),
        null
      );
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(lt(156, t.tag));
}
function $me(e, t) {
  switch ((iN(t), t.tag)) {
    case 1:
      return (
        rl(t.type) && P6(),
        (e = t.flags),
        e & 65536 ? ((t.flags = (e & -65537) | 128), t) : null
      );
    case 3:
      return (
        gy(),
        Hi(nl),
        Hi(da),
        hN(),
        (e = t.flags),
        e & 65536 && !(e & 128) ? ((t.flags = (e & -65537) | 128), t) : null
      );
    case 5:
      return fN(t), null;
    case 13:
      if (
        (Hi(cs), (e = t.memoizedState), e !== null && e.dehydrated !== null)
      ) {
        if (t.alternate === null) throw Error(lt(340));
        py();
      }
      return (
        (e = t.flags), e & 65536 ? ((t.flags = (e & -65537) | 128), t) : null
      );
    case 19:
      return Hi(cs), null;
    case 4:
      return gy(), null;
    case 10:
      return lN(t.type._context), null;
    case 22:
    case 23:
      return EN(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var m_ = !1,
  ia = !1,
  zme = typeof WeakSet == "function" ? WeakSet : Set,
  zt = null;
function wg(e, t) {
  var n = e.ref;
  if (n !== null)
    if (typeof n == "function")
      try {
        n(null);
      } catch (r) {
        Ss(e, t, r);
      }
    else n.current = null;
}
function $k(e, t, n) {
  try {
    n();
  } catch (r) {
    Ss(e, t, r);
  }
}
var GB = !1;
function Wme(e, t) {
  if (((Ek = I6), (e = yK()), nN(e))) {
    if ("selectionStart" in e)
      var n = { start: e.selectionStart, end: e.selectionEnd };
    else
      e: {
        n = ((n = e.ownerDocument) && n.defaultView) || window;
        var r = n.getSelection && n.getSelection();
        if (r && r.rangeCount !== 0) {
          n = r.anchorNode;
          var i = r.anchorOffset,
            s = r.focusNode;
          r = r.focusOffset;
          try {
            n.nodeType, s.nodeType;
          } catch {
            n = null;
            break e;
          }
          var o = 0,
            a = -1,
            l = -1,
            c = 0,
            u = 0,
            d = e,
            f = null;
          t: for (;;) {
            for (
              var h;
              d !== n || (i !== 0 && d.nodeType !== 3) || (a = o + i),
                d !== s || (r !== 0 && d.nodeType !== 3) || (l = o + r),
                d.nodeType === 3 && (o += d.nodeValue.length),
                (h = d.firstChild) !== null;

            )
              (f = d), (d = h);
            for (;;) {
              if (d === e) break t;
              if (
                (f === n && ++c === i && (a = o),
                f === s && ++u === r && (l = o),
                (h = d.nextSibling) !== null)
              )
                break;
              (d = f), (f = d.parentNode);
            }
            d = h;
          }
          n = a === -1 || l === -1 ? null : { start: a, end: l };
        } else n = null;
      }
    n = n || { start: 0, end: 0 };
  } else n = null;
  for (
    Ak = { focusedElem: e, selectionRange: n }, I6 = !1, zt = t;
    zt !== null;

  )
    if (((t = zt), (e = t.child), (t.subtreeFlags & 1028) !== 0 && e !== null))
      (e.return = t), (zt = e);
    else
      for (; zt !== null; ) {
        t = zt;
        try {
          var p = t.alternate;
          if (t.flags & 1024)
            switch (t.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (p !== null) {
                  var g = p.memoizedProps,
                    b = p.memoizedState,
                    v = t.stateNode,
                    w = v.getSnapshotBeforeUpdate(
                      t.elementType === t.type ? g : ou(t.type, g),
                      b
                    );
                  v.__reactInternalSnapshotBeforeUpdate = w;
                }
                break;
              case 3:
                var x = t.stateNode.containerInfo;
                x.nodeType === 1
                  ? (x.textContent = "")
                  : x.nodeType === 9 &&
                    x.documentElement &&
                    x.removeChild(x.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(lt(163));
            }
        } catch (S) {
          Ss(t, t.return, S);
        }
        if (((e = t.sibling), e !== null)) {
          (e.return = t.return), (zt = e);
          break;
        }
        zt = t.return;
      }
  return (p = GB), (GB = !1), p;
}
function fw(e, t, n) {
  var r = t.updateQueue;
  if (((r = r !== null ? r.lastEffect : null), r !== null)) {
    var i = (r = r.next);
    do {
      if ((i.tag & e) === e) {
        var s = i.destroy;
        (i.destroy = void 0), s !== void 0 && $k(t, n, s);
      }
      i = i.next;
    } while (i !== r);
  }
}
function zS(e, t) {
  if (
    ((t = t.updateQueue), (t = t !== null ? t.lastEffect : null), t !== null)
  ) {
    var n = (t = t.next);
    do {
      if ((n.tag & e) === e) {
        var r = n.create;
        n.destroy = r();
      }
      n = n.next;
    } while (n !== t);
  }
}
function zk(e) {
  var t = e.ref;
  if (t !== null) {
    var n = e.stateNode;
    switch (e.tag) {
      case 5:
        e = n;
        break;
      default:
        e = n;
    }
    typeof t == "function" ? t(e) : (t.current = e);
  }
}
function hY(e) {
  var t = e.alternate;
  t !== null && ((e.alternate = null), hY(t)),
    (e.child = null),
    (e.deletions = null),
    (e.sibling = null),
    e.tag === 5 &&
      ((t = e.stateNode),
      t !== null &&
        (delete t[ed],
        delete t[qw],
        delete t[Tk],
        delete t[Ame],
        delete t[Cme])),
    (e.stateNode = null),
    (e.return = null),
    (e.dependencies = null),
    (e.memoizedProps = null),
    (e.memoizedState = null),
    (e.pendingProps = null),
    (e.stateNode = null),
    (e.updateQueue = null);
}
function pY(e) {
  return e.tag === 5 || e.tag === 3 || e.tag === 4;
}
function qB(e) {
  e: for (;;) {
    for (; e.sibling === null; ) {
      if (e.return === null || pY(e.return)) return null;
      e = e.return;
    }
    for (
      e.sibling.return = e.return, e = e.sibling;
      e.tag !== 5 && e.tag !== 6 && e.tag !== 18;

    ) {
      if (e.flags & 2 || e.child === null || e.tag === 4) continue e;
      (e.child.return = e), (e = e.child);
    }
    if (!(e.flags & 2)) return e.stateNode;
  }
}
function Wk(e, t, n) {
  var r = e.tag;
  if (r === 5 || r === 6)
    (e = e.stateNode),
      t
        ? n.nodeType === 8
          ? n.parentNode.insertBefore(e, t)
          : n.insertBefore(e, t)
        : (n.nodeType === 8
            ? ((t = n.parentNode), t.insertBefore(e, n))
            : ((t = n), t.appendChild(e)),
          (n = n._reactRootContainer),
          n != null || t.onclick !== null || (t.onclick = O6));
  else if (r !== 4 && ((e = e.child), e !== null))
    for (Wk(e, t, n), e = e.sibling; e !== null; ) Wk(e, t, n), (e = e.sibling);
}
function Hk(e, t, n) {
  var r = e.tag;
  if (r === 5 || r === 6)
    (e = e.stateNode), t ? n.insertBefore(e, t) : n.appendChild(e);
  else if (r !== 4 && ((e = e.child), e !== null))
    for (Hk(e, t, n), e = e.sibling; e !== null; ) Hk(e, t, n), (e = e.sibling);
}
var Ro = null,
  cu = !1;
function qh(e, t, n) {
  for (n = n.child; n !== null; ) mY(e, t, n), (n = n.sibling);
}
function mY(e, t, n) {
  if (gd && typeof gd.onCommitFiberUnmount == "function")
    try {
      gd.onCommitFiberUnmount(PS, n);
    } catch {}
  switch (n.tag) {
    case 5:
      ia || wg(n, t);
    case 6:
      var r = Ro,
        i = cu;
      (Ro = null),
        qh(e, t, n),
        (Ro = r),
        (cu = i),
        Ro !== null &&
          (cu
            ? ((e = Ro),
              (n = n.stateNode),
              e.nodeType === 8 ? e.parentNode.removeChild(n) : e.removeChild(n))
            : Ro.removeChild(n.stateNode));
      break;
    case 18:
      Ro !== null &&
        (cu
          ? ((e = Ro),
            (n = n.stateNode),
            e.nodeType === 8
              ? yA(e.parentNode, n)
              : e.nodeType === 1 && yA(e, n),
            zw(e))
          : yA(Ro, n.stateNode));
      break;
    case 4:
      (r = Ro),
        (i = cu),
        (Ro = n.stateNode.containerInfo),
        (cu = !0),
        qh(e, t, n),
        (Ro = r),
        (cu = i);
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (
        !ia &&
        ((r = n.updateQueue), r !== null && ((r = r.lastEffect), r !== null))
      ) {
        i = r = r.next;
        do {
          var s = i,
            o = s.destroy;
          (s = s.tag),
            o !== void 0 && (s & 2 || s & 4) && $k(n, t, o),
            (i = i.next);
        } while (i !== r);
      }
      qh(e, t, n);
      break;
    case 1:
      if (
        !ia &&
        (wg(n, t),
        (r = n.stateNode),
        typeof r.componentWillUnmount == "function")
      )
        try {
          (r.props = n.memoizedProps),
            (r.state = n.memoizedState),
            r.componentWillUnmount();
        } catch (a) {
          Ss(n, t, a);
        }
      qh(e, t, n);
      break;
    case 21:
      qh(e, t, n);
      break;
    case 22:
      n.mode & 1
        ? ((ia = (r = ia) || n.memoizedState !== null), qh(e, t, n), (ia = r))
        : qh(e, t, n);
      break;
    default:
      qh(e, t, n);
  }
}
function KB(e) {
  var t = e.updateQueue;
  if (t !== null) {
    e.updateQueue = null;
    var n = e.stateNode;
    n === null && (n = e.stateNode = new zme()),
      t.forEach(function (r) {
        var i = Xme.bind(null, e, r);
        n.has(r) || (n.add(r), r.then(i, i));
      });
  }
}
function eu(e, t) {
  var n = t.deletions;
  if (n !== null)
    for (var r = 0; r < n.length; r++) {
      var i = n[r];
      try {
        var s = e,
          o = t,
          a = o;
        e: for (; a !== null; ) {
          switch (a.tag) {
            case 5:
              (Ro = a.stateNode), (cu = !1);
              break e;
            case 3:
              (Ro = a.stateNode.containerInfo), (cu = !0);
              break e;
            case 4:
              (Ro = a.stateNode.containerInfo), (cu = !0);
              break e;
          }
          a = a.return;
        }
        if (Ro === null) throw Error(lt(160));
        mY(s, o, i), (Ro = null), (cu = !1);
        var l = i.alternate;
        l !== null && (l.return = null), (i.return = null);
      } catch (c) {
        Ss(i, t, c);
      }
    }
  if (t.subtreeFlags & 12854)
    for (t = t.child; t !== null; ) gY(t, e), (t = t.sibling);
}
function gY(e, t) {
  var n = e.alternate,
    r = e.flags;
  switch (e.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      if ((eu(t, e), Vu(e), r & 4)) {
        try {
          fw(3, e, e.return), zS(3, e);
        } catch (g) {
          Ss(e, e.return, g);
        }
        try {
          fw(5, e, e.return);
        } catch (g) {
          Ss(e, e.return, g);
        }
      }
      break;
    case 1:
      eu(t, e), Vu(e), r & 512 && n !== null && wg(n, n.return);
      break;
    case 5:
      if (
        (eu(t, e),
        Vu(e),
        r & 512 && n !== null && wg(n, n.return),
        e.flags & 32)
      ) {
        var i = e.stateNode;
        try {
          Bw(i, "");
        } catch (g) {
          Ss(e, e.return, g);
        }
      }
      if (r & 4 && ((i = e.stateNode), i != null)) {
        var s = e.memoizedProps,
          o = n !== null ? n.memoizedProps : s,
          a = e.type,
          l = e.updateQueue;
        if (((e.updateQueue = null), l !== null))
          try {
            a === "input" && s.type === "radio" && s.name != null && Bq(i, s),
              pk(a, o);
            var c = pk(a, s);
            for (o = 0; o < l.length; o += 2) {
              var u = l[o],
                d = l[o + 1];
              u === "style"
                ? Wq(i, d)
                : u === "dangerouslySetInnerHTML"
                ? $q(i, d)
                : u === "children"
                ? Bw(i, d)
                : WI(i, u, d, c);
            }
            switch (a) {
              case "input":
                ck(i, s);
                break;
              case "textarea":
                Fq(i, s);
                break;
              case "select":
                var f = i._wrapperState.wasMultiple;
                i._wrapperState.wasMultiple = !!s.multiple;
                var h = s.value;
                h != null
                  ? Ug(i, !!s.multiple, h, !1)
                  : f !== !!s.multiple &&
                    (s.defaultValue != null
                      ? Ug(i, !!s.multiple, s.defaultValue, !0)
                      : Ug(i, !!s.multiple, s.multiple ? [] : "", !1));
            }
            i[qw] = s;
          } catch (g) {
            Ss(e, e.return, g);
          }
      }
      break;
    case 6:
      if ((eu(t, e), Vu(e), r & 4)) {
        if (e.stateNode === null) throw Error(lt(162));
        (i = e.stateNode), (s = e.memoizedProps);
        try {
          i.nodeValue = s;
        } catch (g) {
          Ss(e, e.return, g);
        }
      }
      break;
    case 3:
      if (
        (eu(t, e), Vu(e), r & 4 && n !== null && n.memoizedState.isDehydrated)
      )
        try {
          zw(t.containerInfo);
        } catch (g) {
          Ss(e, e.return, g);
        }
      break;
    case 4:
      eu(t, e), Vu(e);
      break;
    case 13:
      eu(t, e),
        Vu(e),
        (i = e.child),
        i.flags & 8192 &&
          ((s = i.memoizedState !== null),
          (i.stateNode.isHidden = s),
          !s ||
            (i.alternate !== null && i.alternate.memoizedState !== null) ||
            (_N = Ns())),
        r & 4 && KB(e);
      break;
    case 22:
      if (
        ((u = n !== null && n.memoizedState !== null),
        e.mode & 1 ? ((ia = (c = ia) || u), eu(t, e), (ia = c)) : eu(t, e),
        Vu(e),
        r & 8192)
      ) {
        if (
          ((c = e.memoizedState !== null),
          (e.stateNode.isHidden = c) && !u && e.mode & 1)
        )
          for (zt = e, u = e.child; u !== null; ) {
            for (d = zt = u; zt !== null; ) {
              switch (((f = zt), (h = f.child), f.tag)) {
                case 0:
                case 11:
                case 14:
                case 15:
                  fw(4, f, f.return);
                  break;
                case 1:
                  wg(f, f.return);
                  var p = f.stateNode;
                  if (typeof p.componentWillUnmount == "function") {
                    (r = f), (n = f.return);
                    try {
                      (t = r),
                        (p.props = t.memoizedProps),
                        (p.state = t.memoizedState),
                        p.componentWillUnmount();
                    } catch (g) {
                      Ss(r, n, g);
                    }
                  }
                  break;
                case 5:
                  wg(f, f.return);
                  break;
                case 22:
                  if (f.memoizedState !== null) {
                    ZB(d);
                    continue;
                  }
              }
              h !== null ? ((h.return = f), (zt = h)) : ZB(d);
            }
            u = u.sibling;
          }
        e: for (u = null, d = e; ; ) {
          if (d.tag === 5) {
            if (u === null) {
              u = d;
              try {
                (i = d.stateNode),
                  c
                    ? ((s = i.style),
                      typeof s.setProperty == "function"
                        ? s.setProperty("display", "none", "important")
                        : (s.display = "none"))
                    : ((a = d.stateNode),
                      (l = d.memoizedProps.style),
                      (o =
                        l != null && l.hasOwnProperty("display")
                          ? l.display
                          : null),
                      (a.style.display = zq("display", o)));
              } catch (g) {
                Ss(e, e.return, g);
              }
            }
          } else if (d.tag === 6) {
            if (u === null)
              try {
                d.stateNode.nodeValue = c ? "" : d.memoizedProps;
              } catch (g) {
                Ss(e, e.return, g);
              }
          } else if (
            ((d.tag !== 22 && d.tag !== 23) ||
              d.memoizedState === null ||
              d === e) &&
            d.child !== null
          ) {
            (d.child.return = d), (d = d.child);
            continue;
          }
          if (d === e) break e;
          for (; d.sibling === null; ) {
            if (d.return === null || d.return === e) break e;
            u === d && (u = null), (d = d.return);
          }
          u === d && (u = null), (d.sibling.return = d.return), (d = d.sibling);
        }
      }
      break;
    case 19:
      eu(t, e), Vu(e), r & 4 && KB(e);
      break;
    case 21:
      break;
    default:
      eu(t, e), Vu(e);
  }
}
function Vu(e) {
  var t = e.flags;
  if (t & 2) {
    try {
      e: {
        for (var n = e.return; n !== null; ) {
          if (pY(n)) {
            var r = n;
            break e;
          }
          n = n.return;
        }
        throw Error(lt(160));
      }
      switch (r.tag) {
        case 5:
          var i = r.stateNode;
          r.flags & 32 && (Bw(i, ""), (r.flags &= -33));
          var s = qB(e);
          Hk(e, s, i);
          break;
        case 3:
        case 4:
          var o = r.stateNode.containerInfo,
            a = qB(e);
          Wk(e, a, o);
          break;
        default:
          throw Error(lt(161));
      }
    } catch (l) {
      Ss(e, e.return, l);
    }
    e.flags &= -3;
  }
  t & 4096 && (e.flags &= -4097);
}
function Hme(e, t, n) {
  (zt = e), yY(e);
}
function yY(e, t, n) {
  for (var r = (e.mode & 1) !== 0; zt !== null; ) {
    var i = zt,
      s = i.child;
    if (i.tag === 22 && r) {
      var o = i.memoizedState !== null || m_;
      if (!o) {
        var a = i.alternate,
          l = (a !== null && a.memoizedState !== null) || ia;
        a = m_;
        var c = ia;
        if (((m_ = o), (ia = l) && !c))
          for (zt = i; zt !== null; )
            (o = zt),
              (l = o.child),
              o.tag === 22 && o.memoizedState !== null
                ? QB(i)
                : l !== null
                ? ((l.return = o), (zt = l))
                : QB(i);
        for (; s !== null; ) (zt = s), yY(s), (s = s.sibling);
        (zt = i), (m_ = a), (ia = c);
      }
      YB(e);
    } else
      i.subtreeFlags & 8772 && s !== null ? ((s.return = i), (zt = s)) : YB(e);
  }
}
function YB(e) {
  for (; zt !== null; ) {
    var t = zt;
    if (t.flags & 8772) {
      var n = t.alternate;
      try {
        if (t.flags & 8772)
          switch (t.tag) {
            case 0:
            case 11:
            case 15:
              ia || zS(5, t);
              break;
            case 1:
              var r = t.stateNode;
              if (t.flags & 4 && !ia)
                if (n === null) r.componentDidMount();
                else {
                  var i =
                    t.elementType === t.type
                      ? n.memoizedProps
                      : ou(t.type, n.memoizedProps);
                  r.componentDidUpdate(
                    i,
                    n.memoizedState,
                    r.__reactInternalSnapshotBeforeUpdate
                  );
                }
              var s = t.updateQueue;
              s !== null && OB(t, s, r);
              break;
            case 3:
              var o = t.updateQueue;
              if (o !== null) {
                if (((n = null), t.child !== null))
                  switch (t.child.tag) {
                    case 5:
                      n = t.child.stateNode;
                      break;
                    case 1:
                      n = t.child.stateNode;
                  }
                OB(t, o, n);
              }
              break;
            case 5:
              var a = t.stateNode;
              if (n === null && t.flags & 4) {
                n = a;
                var l = t.memoizedProps;
                switch (t.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    l.autoFocus && n.focus();
                    break;
                  case "img":
                    l.src && (n.src = l.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (t.memoizedState === null) {
                var c = t.alternate;
                if (c !== null) {
                  var u = c.memoizedState;
                  if (u !== null) {
                    var d = u.dehydrated;
                    d !== null && zw(d);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(lt(163));
          }
        ia || (t.flags & 512 && zk(t));
      } catch (f) {
        Ss(t, t.return, f);
      }
    }
    if (t === e) {
      zt = null;
      break;
    }
    if (((n = t.sibling), n !== null)) {
      (n.return = t.return), (zt = n);
      break;
    }
    zt = t.return;
  }
}
function ZB(e) {
  for (; zt !== null; ) {
    var t = zt;
    if (t === e) {
      zt = null;
      break;
    }
    var n = t.sibling;
    if (n !== null) {
      (n.return = t.return), (zt = n);
      break;
    }
    zt = t.return;
  }
}
function QB(e) {
  for (; zt !== null; ) {
    var t = zt;
    try {
      switch (t.tag) {
        case 0:
        case 11:
        case 15:
          var n = t.return;
          try {
            zS(4, t);
          } catch (l) {
            Ss(t, n, l);
          }
          break;
        case 1:
          var r = t.stateNode;
          if (typeof r.componentDidMount == "function") {
            var i = t.return;
            try {
              r.componentDidMount();
            } catch (l) {
              Ss(t, i, l);
            }
          }
          var s = t.return;
          try {
            zk(t);
          } catch (l) {
            Ss(t, s, l);
          }
          break;
        case 5:
          var o = t.return;
          try {
            zk(t);
          } catch (l) {
            Ss(t, o, l);
          }
      }
    } catch (l) {
      Ss(t, t.return, l);
    }
    if (t === e) {
      zt = null;
      break;
    }
    var a = t.sibling;
    if (a !== null) {
      (a.return = t.return), (zt = a);
      break;
    }
    zt = t.return;
  }
}
var Vme = Math.ceil,
  H6 = yh.ReactCurrentDispatcher,
  bN = yh.ReactCurrentOwner,
  Ac = yh.ReactCurrentBatchConfig,
  $r = 0,
  _o = null,
  Ws = null,
  Uo = 0,
  Al = 0,
  bg = c0(0),
  to = 0,
  Jw = null,
  Bm = 0,
  WS = 0,
  xN = 0,
  hw = null,
  Za = null,
  _N = 0,
  vy = 1 / 0,
  _f = null,
  V6 = !1,
  Vk = null,
  Pp = null,
  g_ = !1,
  wp = null,
  G6 = 0,
  pw = 0,
  Gk = null,
  w4 = -1,
  b4 = 0;
function Ca() {
  return $r & 6 ? Ns() : w4 !== -1 ? w4 : (w4 = Ns());
}
function Lp(e) {
  return e.mode & 1
    ? $r & 2 && Uo !== 0
      ? Uo & -Uo
      : Tme.transition !== null
      ? (b4 === 0 && (b4 = tK()), b4)
      : ((e = ui),
        e !== 0 || ((e = window.event), (e = e === void 0 ? 16 : lK(e.type))),
        e)
    : 1;
}
function bu(e, t, n, r) {
  if (50 < pw) throw ((pw = 0), (Gk = null), Error(lt(185)));
  ox(e, n, r),
    (!($r & 2) || e !== _o) &&
      (e === _o && (!($r & 2) && (WS |= n), to === 4 && mp(e, Uo)),
      il(e, r),
      n === 1 && $r === 0 && !(t.mode & 1) && ((vy = Ns() + 500), FS && u0()));
}
function il(e, t) {
  var n = e.callbackNode;
  T0e(e, t);
  var r = M6(e, e === _o ? Uo : 0);
  if (r === 0)
    n !== null && oB(n), (e.callbackNode = null), (e.callbackPriority = 0);
  else if (((t = r & -r), e.callbackPriority !== t)) {
    if ((n != null && oB(n), t === 1))
      e.tag === 0 ? kme(XB.bind(null, e)) : kK(XB.bind(null, e)),
        Sme(function () {
          !($r & 6) && u0();
        }),
        (n = null);
    else {
      switch (nK(r)) {
        case 1:
          n = KI;
          break;
        case 4:
          n = Jq;
          break;
        case 16:
          n = T6;
          break;
        case 536870912:
          n = eK;
          break;
        default:
          n = T6;
      }
      n = AY(n, vY.bind(null, e));
    }
    (e.callbackPriority = t), (e.callbackNode = n);
  }
}
function vY(e, t) {
  if (((w4 = -1), (b4 = 0), $r & 6)) throw Error(lt(327));
  var n = e.callbackNode;
  if (Vg() && e.callbackNode !== n) return null;
  var r = M6(e, e === _o ? Uo : 0);
  if (r === 0) return null;
  if (r & 30 || r & e.expiredLanes || t) t = q6(e, r);
  else {
    t = r;
    var i = $r;
    $r |= 2;
    var s = bY();
    (_o !== e || Uo !== t) && ((_f = null), (vy = Ns() + 500), _m(e, t));
    do
      try {
        Kme();
        break;
      } catch (a) {
        wY(e, a);
      }
    while (!0);
    aN(),
      (H6.current = s),
      ($r = i),
      Ws !== null ? (t = 0) : ((_o = null), (Uo = 0), (t = to));
  }
  if (t !== 0) {
    if (
      (t === 2 && ((i = wk(e)), i !== 0 && ((r = i), (t = qk(e, i)))), t === 1)
    )
      throw ((n = Jw), _m(e, 0), mp(e, r), il(e, Ns()), n);
    if (t === 6) mp(e, r);
    else {
      if (
        ((i = e.current.alternate),
        !(r & 30) &&
          !Gme(i) &&
          ((t = q6(e, r)),
          t === 2 && ((s = wk(e)), s !== 0 && ((r = s), (t = qk(e, s)))),
          t === 1))
      )
        throw ((n = Jw), _m(e, 0), mp(e, r), il(e, Ns()), n);
      switch (((e.finishedWork = i), (e.finishedLanes = r), t)) {
        case 0:
        case 1:
          throw Error(lt(345));
        case 2:
          U0(e, Za, _f);
          break;
        case 3:
          if (
            (mp(e, r), (r & 130023424) === r && ((t = _N + 500 - Ns()), 10 < t))
          ) {
            if (M6(e, 0) !== 0) break;
            if (((i = e.suspendedLanes), (i & r) !== r)) {
              Ca(), (e.pingedLanes |= e.suspendedLanes & i);
              break;
            }
            e.timeoutHandle = kk(U0.bind(null, e, Za, _f), t);
            break;
          }
          U0(e, Za, _f);
          break;
        case 4:
          if ((mp(e, r), (r & 4194240) === r)) break;
          for (t = e.eventTimes, i = -1; 0 < r; ) {
            var o = 31 - wu(r);
            (s = 1 << o), (o = t[o]), o > i && (i = o), (r &= ~s);
          }
          if (
            ((r = i),
            (r = Ns() - r),
            (r =
              (120 > r
                ? 120
                : 480 > r
                ? 480
                : 1080 > r
                ? 1080
                : 1920 > r
                ? 1920
                : 3e3 > r
                ? 3e3
                : 4320 > r
                ? 4320
                : 1960 * Vme(r / 1960)) - r),
            10 < r)
          ) {
            e.timeoutHandle = kk(U0.bind(null, e, Za, _f), r);
            break;
          }
          U0(e, Za, _f);
          break;
        case 5:
          U0(e, Za, _f);
          break;
        default:
          throw Error(lt(329));
      }
    }
  }
  return il(e, Ns()), e.callbackNode === n ? vY.bind(null, e) : null;
}
function qk(e, t) {
  var n = hw;
  return (
    e.current.memoizedState.isDehydrated && (_m(e, t).flags |= 256),
    (e = q6(e, t)),
    e !== 2 && ((t = Za), (Za = n), t !== null && Kk(t)),
    e
  );
}
function Kk(e) {
  Za === null ? (Za = e) : Za.push.apply(Za, e);
}
function Gme(e) {
  for (var t = e; ; ) {
    if (t.flags & 16384) {
      var n = t.updateQueue;
      if (n !== null && ((n = n.stores), n !== null))
        for (var r = 0; r < n.length; r++) {
          var i = n[r],
            s = i.getSnapshot;
          i = i.value;
          try {
            if (!Su(s(), i)) return !1;
          } catch {
            return !1;
          }
        }
    }
    if (((n = t.child), t.subtreeFlags & 16384 && n !== null))
      (n.return = t), (t = n);
    else {
      if (t === e) break;
      for (; t.sibling === null; ) {
        if (t.return === null || t.return === e) return !0;
        t = t.return;
      }
      (t.sibling.return = t.return), (t = t.sibling);
    }
  }
  return !0;
}
function mp(e, t) {
  for (
    t &= ~xN,
      t &= ~WS,
      e.suspendedLanes |= t,
      e.pingedLanes &= ~t,
      e = e.expirationTimes;
    0 < t;

  ) {
    var n = 31 - wu(t),
      r = 1 << n;
    (e[n] = -1), (t &= ~r);
  }
}
function XB(e) {
  if ($r & 6) throw Error(lt(327));
  Vg();
  var t = M6(e, 0);
  if (!(t & 1)) return il(e, Ns()), null;
  var n = q6(e, t);
  if (e.tag !== 0 && n === 2) {
    var r = wk(e);
    r !== 0 && ((t = r), (n = qk(e, r)));
  }
  if (n === 1) throw ((n = Jw), _m(e, 0), mp(e, t), il(e, Ns()), n);
  if (n === 6) throw Error(lt(345));
  return (
    (e.finishedWork = e.current.alternate),
    (e.finishedLanes = t),
    U0(e, Za, _f),
    il(e, Ns()),
    null
  );
}
function SN(e, t) {
  var n = $r;
  $r |= 1;
  try {
    return e(t);
  } finally {
    ($r = n), $r === 0 && ((vy = Ns() + 500), FS && u0());
  }
}
function Fm(e) {
  wp !== null && wp.tag === 0 && !($r & 6) && Vg();
  var t = $r;
  $r |= 1;
  var n = Ac.transition,
    r = ui;
  try {
    if (((Ac.transition = null), (ui = 1), e)) return e();
  } finally {
    (ui = r), (Ac.transition = n), ($r = t), !($r & 6) && u0();
  }
}
function EN() {
  (Al = bg.current), Hi(bg);
}
function _m(e, t) {
  (e.finishedWork = null), (e.finishedLanes = 0);
  var n = e.timeoutHandle;
  if ((n !== -1 && ((e.timeoutHandle = -1), _me(n)), Ws !== null))
    for (n = Ws.return; n !== null; ) {
      var r = n;
      switch ((iN(r), r.tag)) {
        case 1:
          (r = r.type.childContextTypes), r != null && P6();
          break;
        case 3:
          gy(), Hi(nl), Hi(da), hN();
          break;
        case 5:
          fN(r);
          break;
        case 4:
          gy();
          break;
        case 13:
          Hi(cs);
          break;
        case 19:
          Hi(cs);
          break;
        case 10:
          lN(r.type._context);
          break;
        case 22:
        case 23:
          EN();
      }
      n = n.return;
    }
  if (
    ((_o = e),
    (Ws = e = jp(e.current, null)),
    (Uo = Al = t),
    (to = 0),
    (Jw = null),
    (xN = WS = Bm = 0),
    (Za = hw = null),
    tm !== null)
  ) {
    for (t = 0; t < tm.length; t++)
      if (((n = tm[t]), (r = n.interleaved), r !== null)) {
        n.interleaved = null;
        var i = r.next,
          s = n.pending;
        if (s !== null) {
          var o = s.next;
          (s.next = i), (r.next = o);
        }
        n.pending = r;
      }
    tm = null;
  }
  return e;
}
function wY(e, t) {
  do {
    var n = Ws;
    try {
      if ((aN(), (g4.current = W6), z6)) {
        for (var r = ps.memoizedState; r !== null; ) {
          var i = r.queue;
          i !== null && (i.pending = null), (r = r.next);
        }
        z6 = !1;
      }
      if (
        ((Dm = 0),
        (yo = Zs = ps = null),
        (dw = !1),
        (Zw = 0),
        (bN.current = null),
        n === null || n.return === null)
      ) {
        (to = 1), (Jw = t), (Ws = null);
        break;
      }
      e: {
        var s = e,
          o = n.return,
          a = n,
          l = t;
        if (
          ((t = Uo),
          (a.flags |= 32768),
          l !== null && typeof l == "object" && typeof l.then == "function")
        ) {
          var c = l,
            u = a,
            d = u.tag;
          if (!(u.mode & 1) && (d === 0 || d === 11 || d === 15)) {
            var f = u.alternate;
            f
              ? ((u.updateQueue = f.updateQueue),
                (u.memoizedState = f.memoizedState),
                (u.lanes = f.lanes))
              : ((u.updateQueue = null), (u.memoizedState = null));
          }
          var h = FB(o);
          if (h !== null) {
            (h.flags &= -257),
              UB(h, o, a, s, t),
              h.mode & 1 && BB(s, c, t),
              (t = h),
              (l = c);
            var p = t.updateQueue;
            if (p === null) {
              var g = new Set();
              g.add(l), (t.updateQueue = g);
            } else p.add(l);
            break e;
          } else {
            if (!(t & 1)) {
              BB(s, c, t), AN();
              break e;
            }
            l = Error(lt(426));
          }
        } else if (rs && a.mode & 1) {
          var b = FB(o);
          if (b !== null) {
            !(b.flags & 65536) && (b.flags |= 256),
              UB(b, o, a, s, t),
              sN(yy(l, a));
            break e;
          }
        }
        (s = l = yy(l, a)),
          to !== 4 && (to = 2),
          hw === null ? (hw = [s]) : hw.push(s),
          (s = o);
        do {
          switch (s.tag) {
            case 3:
              (s.flags |= 65536), (t &= -t), (s.lanes |= t);
              var v = nY(s, l, t);
              RB(s, v);
              break e;
            case 1:
              a = l;
              var w = s.type,
                x = s.stateNode;
              if (
                !(s.flags & 128) &&
                (typeof w.getDerivedStateFromError == "function" ||
                  (x !== null &&
                    typeof x.componentDidCatch == "function" &&
                    (Pp === null || !Pp.has(x))))
              ) {
                (s.flags |= 65536), (t &= -t), (s.lanes |= t);
                var S = rY(s, a, t);
                RB(s, S);
                break e;
              }
          }
          s = s.return;
        } while (s !== null);
      }
      _Y(n);
    } catch (R) {
      (t = R), Ws === n && n !== null && (Ws = n = n.return);
      continue;
    }
    break;
  } while (!0);
}
function bY() {
  var e = H6.current;
  return (H6.current = W6), e === null ? W6 : e;
}
function AN() {
  (to === 0 || to === 3 || to === 2) && (to = 4),
    _o === null || (!(Bm & 268435455) && !(WS & 268435455)) || mp(_o, Uo);
}
function q6(e, t) {
  var n = $r;
  $r |= 2;
  var r = bY();
  (_o !== e || Uo !== t) && ((_f = null), _m(e, t));
  do
    try {
      qme();
      break;
    } catch (i) {
      wY(e, i);
    }
  while (!0);
  if ((aN(), ($r = n), (H6.current = r), Ws !== null)) throw Error(lt(261));
  return (_o = null), (Uo = 0), to;
}
function qme() {
  for (; Ws !== null; ) xY(Ws);
}
function Kme() {
  for (; Ws !== null && !w0e(); ) xY(Ws);
}
function xY(e) {
  var t = EY(e.alternate, e, Al);
  (e.memoizedProps = e.pendingProps),
    t === null ? _Y(e) : (Ws = t),
    (bN.current = null);
}
function _Y(e) {
  var t = e;
  do {
    var n = t.alternate;
    if (((e = t.return), t.flags & 32768)) {
      if (((n = $me(n, t)), n !== null)) {
        (n.flags &= 32767), (Ws = n);
        return;
      }
      if (e !== null)
        (e.flags |= 32768), (e.subtreeFlags = 0), (e.deletions = null);
      else {
        (to = 6), (Ws = null);
        return;
      }
    } else if (((n = Ume(n, t, Al)), n !== null)) {
      Ws = n;
      return;
    }
    if (((t = t.sibling), t !== null)) {
      Ws = t;
      return;
    }
    Ws = t = e;
  } while (t !== null);
  to === 0 && (to = 5);
}
function U0(e, t, n) {
  var r = ui,
    i = Ac.transition;
  try {
    (Ac.transition = null), (ui = 1), Yme(e, t, n, r);
  } finally {
    (Ac.transition = i), (ui = r);
  }
  return null;
}
function Yme(e, t, n, r) {
  do Vg();
  while (wp !== null);
  if ($r & 6) throw Error(lt(327));
  n = e.finishedWork;
  var i = e.finishedLanes;
  if (n === null) return null;
  if (((e.finishedWork = null), (e.finishedLanes = 0), n === e.current))
    throw Error(lt(177));
  (e.callbackNode = null), (e.callbackPriority = 0);
  var s = n.lanes | n.childLanes;
  if (
    (M0e(e, s),
    e === _o && ((Ws = _o = null), (Uo = 0)),
    (!(n.subtreeFlags & 2064) && !(n.flags & 2064)) ||
      g_ ||
      ((g_ = !0),
      AY(T6, function () {
        return Vg(), null;
      })),
    (s = (n.flags & 15990) !== 0),
    n.subtreeFlags & 15990 || s)
  ) {
    (s = Ac.transition), (Ac.transition = null);
    var o = ui;
    ui = 1;
    var a = $r;
    ($r |= 4),
      (bN.current = null),
      Wme(e, n),
      gY(n, e),
      mme(Ak),
      (I6 = !!Ek),
      (Ak = Ek = null),
      (e.current = n),
      Hme(n),
      b0e(),
      ($r = a),
      (ui = o),
      (Ac.transition = s);
  } else e.current = n;
  if (
    (g_ && ((g_ = !1), (wp = e), (G6 = i)),
    (s = e.pendingLanes),
    s === 0 && (Pp = null),
    S0e(n.stateNode),
    il(e, Ns()),
    t !== null)
  )
    for (r = e.onRecoverableError, n = 0; n < t.length; n++)
      (i = t[n]), r(i.value, { componentStack: i.stack, digest: i.digest });
  if (V6) throw ((V6 = !1), (e = Vk), (Vk = null), e);
  return (
    G6 & 1 && e.tag !== 0 && Vg(),
    (s = e.pendingLanes),
    s & 1 ? (e === Gk ? pw++ : ((pw = 0), (Gk = e))) : (pw = 0),
    u0(),
    null
  );
}
function Vg() {
  if (wp !== null) {
    var e = nK(G6),
      t = Ac.transition,
      n = ui;
    try {
      if (((Ac.transition = null), (ui = 16 > e ? 16 : e), wp === null))
        var r = !1;
      else {
        if (((e = wp), (wp = null), (G6 = 0), $r & 6)) throw Error(lt(331));
        var i = $r;
        for ($r |= 4, zt = e.current; zt !== null; ) {
          var s = zt,
            o = s.child;
          if (zt.flags & 16) {
            var a = s.deletions;
            if (a !== null) {
              for (var l = 0; l < a.length; l++) {
                var c = a[l];
                for (zt = c; zt !== null; ) {
                  var u = zt;
                  switch (u.tag) {
                    case 0:
                    case 11:
                    case 15:
                      fw(8, u, s);
                  }
                  var d = u.child;
                  if (d !== null) (d.return = u), (zt = d);
                  else
                    for (; zt !== null; ) {
                      u = zt;
                      var f = u.sibling,
                        h = u.return;
                      if ((hY(u), u === c)) {
                        zt = null;
                        break;
                      }
                      if (f !== null) {
                        (f.return = h), (zt = f);
                        break;
                      }
                      zt = h;
                    }
                }
              }
              var p = s.alternate;
              if (p !== null) {
                var g = p.child;
                if (g !== null) {
                  p.child = null;
                  do {
                    var b = g.sibling;
                    (g.sibling = null), (g = b);
                  } while (g !== null);
                }
              }
              zt = s;
            }
          }
          if (s.subtreeFlags & 2064 && o !== null) (o.return = s), (zt = o);
          else
            e: for (; zt !== null; ) {
              if (((s = zt), s.flags & 2048))
                switch (s.tag) {
                  case 0:
                  case 11:
                  case 15:
                    fw(9, s, s.return);
                }
              var v = s.sibling;
              if (v !== null) {
                (v.return = s.return), (zt = v);
                break e;
              }
              zt = s.return;
            }
        }
        var w = e.current;
        for (zt = w; zt !== null; ) {
          o = zt;
          var x = o.child;
          if (o.subtreeFlags & 2064 && x !== null) (x.return = o), (zt = x);
          else
            e: for (o = w; zt !== null; ) {
              if (((a = zt), a.flags & 2048))
                try {
                  switch (a.tag) {
                    case 0:
                    case 11:
                    case 15:
                      zS(9, a);
                  }
                } catch (R) {
                  Ss(a, a.return, R);
                }
              if (a === o) {
                zt = null;
                break e;
              }
              var S = a.sibling;
              if (S !== null) {
                (S.return = a.return), (zt = S);
                break e;
              }
              zt = a.return;
            }
        }
        if (
          (($r = i), u0(), gd && typeof gd.onPostCommitFiberRoot == "function")
        )
          try {
            gd.onPostCommitFiberRoot(PS, e);
          } catch {}
        r = !0;
      }
      return r;
    } finally {
      (ui = n), (Ac.transition = t);
    }
  }
  return !1;
}
function JB(e, t, n) {
  (t = yy(n, t)),
    (t = nY(e, t, 1)),
    (e = Op(e, t, 1)),
    (t = Ca()),
    e !== null && (ox(e, 1, t), il(e, t));
}
function Ss(e, t, n) {
  if (e.tag === 3) JB(e, e, n);
  else
    for (; t !== null; ) {
      if (t.tag === 3) {
        JB(t, e, n);
        break;
      } else if (t.tag === 1) {
        var r = t.stateNode;
        if (
          typeof t.type.getDerivedStateFromError == "function" ||
          (typeof r.componentDidCatch == "function" &&
            (Pp === null || !Pp.has(r)))
        ) {
          (e = yy(n, e)),
            (e = rY(t, e, 1)),
            (t = Op(t, e, 1)),
            (e = Ca()),
            t !== null && (ox(t, 1, e), il(t, e));
          break;
        }
      }
      t = t.return;
    }
}
function Zme(e, t, n) {
  var r = e.pingCache;
  r !== null && r.delete(t),
    (t = Ca()),
    (e.pingedLanes |= e.suspendedLanes & n),
    _o === e &&
      (Uo & n) === n &&
      (to === 4 || (to === 3 && (Uo & 130023424) === Uo && 500 > Ns() - _N)
        ? _m(e, 0)
        : (xN |= n)),
    il(e, t);
}
function SY(e, t) {
  t === 0 &&
    (e.mode & 1
      ? ((t = o_), (o_ <<= 1), !(o_ & 130023424) && (o_ = 4194304))
      : (t = 1));
  var n = Ca();
  (e = oh(e, t)), e !== null && (ox(e, t, n), il(e, n));
}
function Qme(e) {
  var t = e.memoizedState,
    n = 0;
  t !== null && (n = t.retryLane), SY(e, n);
}
function Xme(e, t) {
  var n = 0;
  switch (e.tag) {
    case 13:
      var r = e.stateNode,
        i = e.memoizedState;
      i !== null && (n = i.retryLane);
      break;
    case 19:
      r = e.stateNode;
      break;
    default:
      throw Error(lt(314));
  }
  r !== null && r.delete(t), SY(e, n);
}
var EY;
EY = function (e, t, n) {
  if (e !== null)
    if (e.memoizedProps !== t.pendingProps || nl.current) Ja = !0;
    else {
      if (!(e.lanes & n) && !(t.flags & 128)) return (Ja = !1), Fme(e, t, n);
      Ja = !!(e.flags & 131072);
    }
  else (Ja = !1), rs && t.flags & 1048576 && TK(t, D6, t.index);
  switch (((t.lanes = 0), t.tag)) {
    case 2:
      var r = t.type;
      v4(e, t), (e = t.pendingProps);
      var i = hy(t, da.current);
      Hg(t, n), (i = mN(null, t, r, e, i, n));
      var s = gN();
      return (
        (t.flags |= 1),
        typeof i == "object" &&
        i !== null &&
        typeof i.render == "function" &&
        i.$$typeof === void 0
          ? ((t.tag = 1),
            (t.memoizedState = null),
            (t.updateQueue = null),
            rl(r) ? ((s = !0), L6(t)) : (s = !1),
            (t.memoizedState =
              i.state !== null && i.state !== void 0 ? i.state : null),
            uN(t),
            (i.updater = $S),
            (t.stateNode = i),
            (i._reactInternals = t),
            Pk(t, r, e, n),
            (t = Dk(null, t, r, !0, s, n)))
          : ((t.tag = 0), rs && s && rN(t), ba(null, t, i, n), (t = t.child)),
        t
      );
    case 16:
      r = t.elementType;
      e: {
        switch (
          (v4(e, t),
          (e = t.pendingProps),
          (i = r._init),
          (r = i(r._payload)),
          (t.type = r),
          (i = t.tag = e1e(r)),
          (e = ou(r, e)),
          i)
        ) {
          case 0:
            t = jk(null, t, r, e, n);
            break e;
          case 1:
            t = WB(null, t, r, e, n);
            break e;
          case 11:
            t = $B(null, t, r, e, n);
            break e;
          case 14:
            t = zB(null, t, r, ou(r.type, e), n);
            break e;
        }
        throw Error(lt(306, r, ""));
      }
      return t;
    case 0:
      return (
        (r = t.type),
        (i = t.pendingProps),
        (i = t.elementType === r ? i : ou(r, i)),
        jk(e, t, r, i, n)
      );
    case 1:
      return (
        (r = t.type),
        (i = t.pendingProps),
        (i = t.elementType === r ? i : ou(r, i)),
        WB(e, t, r, i, n)
      );
    case 3:
      e: {
        if ((aY(t), e === null)) throw Error(lt(387));
        (r = t.pendingProps),
          (s = t.memoizedState),
          (i = s.element),
          PK(e, t),
          U6(t, r, null, n);
        var o = t.memoizedState;
        if (((r = o.element), s.isDehydrated))
          if (
            ((s = {
              element: r,
              isDehydrated: !1,
              cache: o.cache,
              pendingSuspenseBoundaries: o.pendingSuspenseBoundaries,
              transitions: o.transitions,
            }),
            (t.updateQueue.baseState = s),
            (t.memoizedState = s),
            t.flags & 256)
          ) {
            (i = yy(Error(lt(423)), t)), (t = HB(e, t, r, n, i));
            break e;
          } else if (r !== i) {
            (i = yy(Error(lt(424)), t)), (t = HB(e, t, r, n, i));
            break e;
          } else
            for (
              Ol = Rp(t.stateNode.containerInfo.firstChild),
                Dl = t,
                rs = !0,
                fu = null,
                n = RK(t, null, r, n),
                t.child = n;
              n;

            )
              (n.flags = (n.flags & -3) | 4096), (n = n.sibling);
        else {
          if ((py(), r === i)) {
            t = ah(e, t, n);
            break e;
          }
          ba(e, t, r, n);
        }
        t = t.child;
      }
      return t;
    case 5:
      return (
        LK(t),
        e === null && Nk(t),
        (r = t.type),
        (i = t.pendingProps),
        (s = e !== null ? e.memoizedProps : null),
        (o = i.children),
        Ck(r, i) ? (o = null) : s !== null && Ck(r, s) && (t.flags |= 32),
        oY(e, t),
        ba(e, t, o, n),
        t.child
      );
    case 6:
      return e === null && Nk(t), null;
    case 13:
      return lY(e, t, n);
    case 4:
      return (
        dN(t, t.stateNode.containerInfo),
        (r = t.pendingProps),
        e === null ? (t.child = my(t, null, r, n)) : ba(e, t, r, n),
        t.child
      );
    case 11:
      return (
        (r = t.type),
        (i = t.pendingProps),
        (i = t.elementType === r ? i : ou(r, i)),
        $B(e, t, r, i, n)
      );
    case 7:
      return ba(e, t, t.pendingProps, n), t.child;
    case 8:
      return ba(e, t, t.pendingProps.children, n), t.child;
    case 12:
      return ba(e, t, t.pendingProps.children, n), t.child;
    case 10:
      e: {
        if (
          ((r = t.type._context),
          (i = t.pendingProps),
          (s = t.memoizedProps),
          (o = i.value),
          Li(B6, r._currentValue),
          (r._currentValue = o),
          s !== null)
        )
          if (Su(s.value, o)) {
            if (s.children === i.children && !nl.current) {
              t = ah(e, t, n);
              break e;
            }
          } else
            for (s = t.child, s !== null && (s.return = t); s !== null; ) {
              var a = s.dependencies;
              if (a !== null) {
                o = s.child;
                for (var l = a.firstContext; l !== null; ) {
                  if (l.context === r) {
                    if (s.tag === 1) {
                      (l = qf(-1, n & -n)), (l.tag = 2);
                      var c = s.updateQueue;
                      if (c !== null) {
                        c = c.shared;
                        var u = c.pending;
                        u === null
                          ? (l.next = l)
                          : ((l.next = u.next), (u.next = l)),
                          (c.pending = l);
                      }
                    }
                    (s.lanes |= n),
                      (l = s.alternate),
                      l !== null && (l.lanes |= n),
                      Rk(s.return, n, t),
                      (a.lanes |= n);
                    break;
                  }
                  l = l.next;
                }
              } else if (s.tag === 10) o = s.type === t.type ? null : s.child;
              else if (s.tag === 18) {
                if (((o = s.return), o === null)) throw Error(lt(341));
                (o.lanes |= n),
                  (a = o.alternate),
                  a !== null && (a.lanes |= n),
                  Rk(o, n, t),
                  (o = s.sibling);
              } else o = s.child;
              if (o !== null) o.return = s;
              else
                for (o = s; o !== null; ) {
                  if (o === t) {
                    o = null;
                    break;
                  }
                  if (((s = o.sibling), s !== null)) {
                    (s.return = o.return), (o = s);
                    break;
                  }
                  o = o.return;
                }
              s = o;
            }
        ba(e, t, i.children, n), (t = t.child);
      }
      return t;
    case 9:
      return (
        (i = t.type),
        (r = t.pendingProps.children),
        Hg(t, n),
        (i = Mc(i)),
        (r = r(i)),
        (t.flags |= 1),
        ba(e, t, r, n),
        t.child
      );
    case 14:
      return (
        (r = t.type),
        (i = ou(r, t.pendingProps)),
        (i = ou(r.type, i)),
        zB(e, t, r, i, n)
      );
    case 15:
      return iY(e, t, t.type, t.pendingProps, n);
    case 17:
      return (
        (r = t.type),
        (i = t.pendingProps),
        (i = t.elementType === r ? i : ou(r, i)),
        v4(e, t),
        (t.tag = 1),
        rl(r) ? ((e = !0), L6(t)) : (e = !1),
        Hg(t, n),
        tY(t, r, i),
        Pk(t, r, i, n),
        Dk(null, t, r, !0, e, n)
      );
    case 19:
      return cY(e, t, n);
    case 22:
      return sY(e, t, n);
  }
  throw Error(lt(156, t.tag));
};
function AY(e, t) {
  return Xq(e, t);
}
function Jme(e, t, n, r) {
  (this.tag = e),
    (this.key = n),
    (this.sibling =
      this.child =
      this.return =
      this.stateNode =
      this.type =
      this.elementType =
        null),
    (this.index = 0),
    (this.ref = null),
    (this.pendingProps = t),
    (this.dependencies =
      this.memoizedState =
      this.updateQueue =
      this.memoizedProps =
        null),
    (this.mode = r),
    (this.subtreeFlags = this.flags = 0),
    (this.deletions = null),
    (this.childLanes = this.lanes = 0),
    (this.alternate = null);
}
function _c(e, t, n, r) {
  return new Jme(e, t, n, r);
}
function CN(e) {
  return (e = e.prototype), !(!e || !e.isReactComponent);
}
function e1e(e) {
  if (typeof e == "function") return CN(e) ? 1 : 0;
  if (e != null) {
    if (((e = e.$$typeof), e === VI)) return 11;
    if (e === GI) return 14;
  }
  return 2;
}
function jp(e, t) {
  var n = e.alternate;
  return (
    n === null
      ? ((n = _c(e.tag, t, e.key, e.mode)),
        (n.elementType = e.elementType),
        (n.type = e.type),
        (n.stateNode = e.stateNode),
        (n.alternate = e),
        (e.alternate = n))
      : ((n.pendingProps = t),
        (n.type = e.type),
        (n.flags = 0),
        (n.subtreeFlags = 0),
        (n.deletions = null)),
    (n.flags = e.flags & 14680064),
    (n.childLanes = e.childLanes),
    (n.lanes = e.lanes),
    (n.child = e.child),
    (n.memoizedProps = e.memoizedProps),
    (n.memoizedState = e.memoizedState),
    (n.updateQueue = e.updateQueue),
    (t = e.dependencies),
    (n.dependencies =
      t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }),
    (n.sibling = e.sibling),
    (n.index = e.index),
    (n.ref = e.ref),
    n
  );
}
function x4(e, t, n, r, i, s) {
  var o = 2;
  if (((r = e), typeof e == "function")) CN(e) && (o = 1);
  else if (typeof e == "string") o = 5;
  else
    e: switch (e) {
      case ug:
        return Sm(n.children, i, s, t);
      case HI:
        (o = 8), (i |= 8);
        break;
      case ik:
        return (
          (e = _c(12, n, t, i | 2)), (e.elementType = ik), (e.lanes = s), e
        );
      case sk:
        return (e = _c(13, n, t, i)), (e.elementType = sk), (e.lanes = s), e;
      case ok:
        return (e = _c(19, n, t, i)), (e.elementType = ok), (e.lanes = s), e;
      case Lq:
        return HS(n, i, s, t);
      default:
        if (typeof e == "object" && e !== null)
          switch (e.$$typeof) {
            case Oq:
              o = 10;
              break e;
            case Pq:
              o = 9;
              break e;
            case VI:
              o = 11;
              break e;
            case GI:
              o = 14;
              break e;
            case lp:
              (o = 16), (r = null);
              break e;
          }
        throw Error(lt(130, e == null ? e : typeof e, ""));
    }
  return (
    (t = _c(o, n, t, i)), (t.elementType = e), (t.type = r), (t.lanes = s), t
  );
}
function Sm(e, t, n, r) {
  return (e = _c(7, e, r, t)), (e.lanes = n), e;
}
function HS(e, t, n, r) {
  return (
    (e = _c(22, e, r, t)),
    (e.elementType = Lq),
    (e.lanes = n),
    (e.stateNode = { isHidden: !1 }),
    e
  );
}
function AA(e, t, n) {
  return (e = _c(6, e, null, t)), (e.lanes = n), e;
}
function CA(e, t, n) {
  return (
    (t = _c(4, e.children !== null ? e.children : [], e.key, t)),
    (t.lanes = n),
    (t.stateNode = {
      containerInfo: e.containerInfo,
      pendingChildren: null,
      implementation: e.implementation,
    }),
    t
  );
}
function t1e(e, t, n, r, i) {
  (this.tag = t),
    (this.containerInfo = e),
    (this.finishedWork =
      this.pingCache =
      this.current =
      this.pendingChildren =
        null),
    (this.timeoutHandle = -1),
    (this.callbackNode = this.pendingContext = this.context = null),
    (this.callbackPriority = 0),
    (this.eventTimes = oA(0)),
    (this.expirationTimes = oA(-1)),
    (this.entangledLanes =
      this.finishedLanes =
      this.mutableReadLanes =
      this.expiredLanes =
      this.pingedLanes =
      this.suspendedLanes =
      this.pendingLanes =
        0),
    (this.entanglements = oA(0)),
    (this.identifierPrefix = r),
    (this.onRecoverableError = i),
    (this.mutableSourceEagerHydrationData = null);
}
function kN(e, t, n, r, i, s, o, a, l) {
  return (
    (e = new t1e(e, t, n, a, l)),
    t === 1 ? ((t = 1), s === !0 && (t |= 8)) : (t = 0),
    (s = _c(3, null, null, t)),
    (e.current = s),
    (s.stateNode = e),
    (s.memoizedState = {
      element: r,
      isDehydrated: n,
      cache: null,
      transitions: null,
      pendingSuspenseBoundaries: null,
    }),
    uN(s),
    e
  );
}
function n1e(e, t, n) {
  var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return {
    $$typeof: cg,
    key: r == null ? null : "" + r,
    children: e,
    containerInfo: t,
    implementation: n,
  };
}
function CY(e) {
  if (!e) return Kp;
  e = e._reactInternals;
  e: {
    if (d1(e) !== e || e.tag !== 1) throw Error(lt(170));
    var t = e;
    do {
      switch (t.tag) {
        case 3:
          t = t.stateNode.context;
          break e;
        case 1:
          if (rl(t.type)) {
            t = t.stateNode.__reactInternalMemoizedMergedChildContext;
            break e;
          }
      }
      t = t.return;
    } while (t !== null);
    throw Error(lt(171));
  }
  if (e.tag === 1) {
    var n = e.type;
    if (rl(n)) return CK(e, n, t);
  }
  return t;
}
function kY(e, t, n, r, i, s, o, a, l) {
  return (
    (e = kN(n, r, !0, e, i, s, o, a, l)),
    (e.context = CY(null)),
    (n = e.current),
    (r = Ca()),
    (i = Lp(n)),
    (s = qf(r, i)),
    (s.callback = t ?? null),
    Op(n, s, i),
    (e.current.lanes = i),
    ox(e, i, r),
    il(e, r),
    e
  );
}
function VS(e, t, n, r) {
  var i = t.current,
    s = Ca(),
    o = Lp(i);
  return (
    (n = CY(n)),
    t.context === null ? (t.context = n) : (t.pendingContext = n),
    (t = qf(s, o)),
    (t.payload = { element: e }),
    (r = r === void 0 ? null : r),
    r !== null && (t.callback = r),
    (e = Op(i, t, o)),
    e !== null && (bu(e, i, o, s), m4(e, i, o)),
    o
  );
}
function K6(e) {
  if (((e = e.current), !e.child)) return null;
  switch (e.child.tag) {
    case 5:
      return e.child.stateNode;
    default:
      return e.child.stateNode;
  }
}
function eF(e, t) {
  if (((e = e.memoizedState), e !== null && e.dehydrated !== null)) {
    var n = e.retryLane;
    e.retryLane = n !== 0 && n < t ? n : t;
  }
}
function TN(e, t) {
  eF(e, t), (e = e.alternate) && eF(e, t);
}
function r1e() {
  return null;
}
var TY =
  typeof reportError == "function"
    ? reportError
    : function (e) {
        console.error(e);
      };
function MN(e) {
  this._internalRoot = e;
}
GS.prototype.render = MN.prototype.render = function (e) {
  var t = this._internalRoot;
  if (t === null) throw Error(lt(409));
  VS(e, t, null, null);
};
GS.prototype.unmount = MN.prototype.unmount = function () {
  var e = this._internalRoot;
  if (e !== null) {
    this._internalRoot = null;
    var t = e.containerInfo;
    Fm(function () {
      VS(null, e, null, null);
    }),
      (t[sh] = null);
  }
};
function GS(e) {
  this._internalRoot = e;
}
GS.prototype.unstable_scheduleHydration = function (e) {
  if (e) {
    var t = sK();
    e = { blockedOn: null, target: e, priority: t };
    for (var n = 0; n < pp.length && t !== 0 && t < pp[n].priority; n++);
    pp.splice(n, 0, e), n === 0 && aK(e);
  }
};
function IN(e) {
  return !(!e || (e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11));
}
function qS(e) {
  return !(
    !e ||
    (e.nodeType !== 1 &&
      e.nodeType !== 9 &&
      e.nodeType !== 11 &&
      (e.nodeType !== 8 || e.nodeValue !== " react-mount-point-unstable "))
  );
}
function tF() {}
function i1e(e, t, n, r, i) {
  if (i) {
    if (typeof r == "function") {
      var s = r;
      r = function () {
        var c = K6(o);
        s.call(c);
      };
    }
    var o = kY(t, r, e, 0, null, !1, !1, "", tF);
    return (
      (e._reactRootContainer = o),
      (e[sh] = o.current),
      Vw(e.nodeType === 8 ? e.parentNode : e),
      Fm(),
      o
    );
  }
  for (; (i = e.lastChild); ) e.removeChild(i);
  if (typeof r == "function") {
    var a = r;
    r = function () {
      var c = K6(l);
      a.call(c);
    };
  }
  var l = kN(e, 0, !1, null, null, !1, !1, "", tF);
  return (
    (e._reactRootContainer = l),
    (e[sh] = l.current),
    Vw(e.nodeType === 8 ? e.parentNode : e),
    Fm(function () {
      VS(t, l, n, r);
    }),
    l
  );
}
function KS(e, t, n, r, i) {
  var s = n._reactRootContainer;
  if (s) {
    var o = s;
    if (typeof i == "function") {
      var a = i;
      i = function () {
        var l = K6(o);
        a.call(l);
      };
    }
    VS(t, o, e, i);
  } else o = i1e(n, t, e, i, r);
  return K6(o);
}
rK = function (e) {
  switch (e.tag) {
    case 3:
      var t = e.stateNode;
      if (t.current.memoizedState.isDehydrated) {
        var n = V2(t.pendingLanes);
        n !== 0 &&
          (YI(t, n | 1), il(t, Ns()), !($r & 6) && ((vy = Ns() + 500), u0()));
      }
      break;
    case 13:
      Fm(function () {
        var r = oh(e, 1);
        if (r !== null) {
          var i = Ca();
          bu(r, e, 1, i);
        }
      }),
        TN(e, 1);
  }
};
ZI = function (e) {
  if (e.tag === 13) {
    var t = oh(e, 134217728);
    if (t !== null) {
      var n = Ca();
      bu(t, e, 134217728, n);
    }
    TN(e, 134217728);
  }
};
iK = function (e) {
  if (e.tag === 13) {
    var t = Lp(e),
      n = oh(e, t);
    if (n !== null) {
      var r = Ca();
      bu(n, e, t, r);
    }
    TN(e, t);
  }
};
sK = function () {
  return ui;
};
oK = function (e, t) {
  var n = ui;
  try {
    return (ui = e), t();
  } finally {
    ui = n;
  }
};
gk = function (e, t, n) {
  switch (t) {
    case "input":
      if ((ck(e, n), (t = n.name), n.type === "radio" && t != null)) {
        for (n = e; n.parentNode; ) n = n.parentNode;
        for (
          n = n.querySelectorAll(
            "input[name=" + JSON.stringify("" + t) + '][type="radio"]'
          ),
            t = 0;
          t < n.length;
          t++
        ) {
          var r = n[t];
          if (r !== e && r.form === e.form) {
            var i = BS(r);
            if (!i) throw Error(lt(90));
            Dq(r), ck(r, i);
          }
        }
      }
      break;
    case "textarea":
      Fq(e, n);
      break;
    case "select":
      (t = n.value), t != null && Ug(e, !!n.multiple, t, !1);
  }
};
Gq = SN;
qq = Fm;
var s1e = { usingClientEntryPoint: !1, Events: [lx, pg, BS, Hq, Vq, SN] },
  g2 = {
    findFiberByHostInstance: em,
    bundleType: 0,
    version: "18.3.1",
    rendererPackageName: "react-dom",
  },
  o1e = {
    bundleType: g2.bundleType,
    version: g2.version,
    rendererPackageName: g2.rendererPackageName,
    rendererConfig: g2.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: yh.ReactCurrentDispatcher,
    findHostInstanceByFiber: function (e) {
      return (e = Zq(e)), e === null ? null : e.stateNode;
    },
    findFiberByHostInstance: g2.findFiberByHostInstance || r1e,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.3.1-next-f1338f8080-20240426",
  };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
  var y_ = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!y_.isDisabled && y_.supportsFiber)
    try {
      (PS = y_.inject(o1e)), (gd = y_);
    } catch {}
}
Wl.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = s1e;
Wl.createPortal = function (e, t) {
  var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!IN(t)) throw Error(lt(200));
  return n1e(e, t, null, n);
};
Wl.createRoot = function (e, t) {
  if (!IN(e)) throw Error(lt(299));
  var n = !1,
    r = "",
    i = TY;
  return (
    t != null &&
      (t.unstable_strictMode === !0 && (n = !0),
      t.identifierPrefix !== void 0 && (r = t.identifierPrefix),
      t.onRecoverableError !== void 0 && (i = t.onRecoverableError)),
    (t = kN(e, 1, !1, null, null, n, !1, r, i)),
    (e[sh] = t.current),
    Vw(e.nodeType === 8 ? e.parentNode : e),
    new MN(t)
  );
};
Wl.findDOMNode = function (e) {
  if (e == null) return null;
  if (e.nodeType === 1) return e;
  var t = e._reactInternals;
  if (t === void 0)
    throw typeof e.render == "function"
      ? Error(lt(188))
      : ((e = Object.keys(e).join(",")), Error(lt(268, e)));
  return (e = Zq(t)), (e = e === null ? null : e.stateNode), e;
};
Wl.flushSync = function (e) {
  return Fm(e);
};
Wl.hydrate = function (e, t, n) {
  if (!qS(t)) throw Error(lt(200));
  return KS(null, e, t, !0, n);
};
Wl.hydrateRoot = function (e, t, n) {
  if (!IN(e)) throw Error(lt(405));
  var r = (n != null && n.hydratedSources) || null,
    i = !1,
    s = "",
    o = TY;
  if (
    (n != null &&
      (n.unstable_strictMode === !0 && (i = !0),
      n.identifierPrefix !== void 0 && (s = n.identifierPrefix),
      n.onRecoverableError !== void 0 && (o = n.onRecoverableError)),
    (t = kY(t, null, e, 1, n ?? null, i, !1, s, o)),
    (e[sh] = t.current),
    Vw(e),
    r)
  )
    for (e = 0; e < r.length; e++)
      (n = r[e]),
        (i = n._getVersion),
        (i = i(n._source)),
        t.mutableSourceEagerHydrationData == null
          ? (t.mutableSourceEagerHydrationData = [n, i])
          : t.mutableSourceEagerHydrationData.push(n, i);
  return new GS(t);
};
Wl.render = function (e, t, n) {
  if (!qS(t)) throw Error(lt(200));
  return KS(null, e, t, !1, n);
};
Wl.unmountComponentAtNode = function (e) {
  if (!qS(e)) throw Error(lt(40));
  return e._reactRootContainer
    ? (Fm(function () {
        KS(null, null, e, !1, function () {
          (e._reactRootContainer = null), (e[sh] = null);
        });
      }),
      !0)
    : !1;
};
Wl.unstable_batchedUpdates = SN;
Wl.unstable_renderSubtreeIntoContainer = function (e, t, n, r) {
  if (!qS(n)) throw Error(lt(200));
  if (e == null || e._reactInternals === void 0) throw Error(lt(38));
  return KS(e, t, n, !1, r);
};
Wl.version = "18.3.1-next-f1338f8080-20240426";
function MY() {
  if (
    !(
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
    )
  )
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(MY);
    } catch (e) {
      console.error(e);
    }
}
MY(), (Mq.exports = Wl);
var iv = Mq.exports;
const a1e = Gi(iv),
  l1e = yq({ __proto__: null, default: a1e }, [iv]);
var nF = iv;
(nk.createRoot = nF.createRoot), (nk.hydrateRoot = nF.hydrateRoot);
var IY = { exports: {} },
  NY = {};
/**
 * @license React
 * use-sync-external-store-with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var ux = Y;
function c1e(e, t) {
  return (e === t && (e !== 0 || 1 / e === 1 / t)) || (e !== e && t !== t);
}
var u1e = typeof Object.is == "function" ? Object.is : c1e,
  d1e = ux.useSyncExternalStore,
  f1e = ux.useRef,
  h1e = ux.useEffect,
  p1e = ux.useMemo,
  m1e = ux.useDebugValue;
NY.useSyncExternalStoreWithSelector = function (e, t, n, r, i) {
  var s = f1e(null);
  if (s.current === null) {
    var o = { hasValue: !1, value: null };
    s.current = o;
  } else o = s.current;
  s = p1e(
    function () {
      function l(h) {
        if (!c) {
          if (((c = !0), (u = h), (h = r(h)), i !== void 0 && o.hasValue)) {
            var p = o.value;
            if (i(p, h)) return (d = p);
          }
          return (d = h);
        }
        if (((p = d), u1e(u, h))) return p;
        var g = r(h);
        return i !== void 0 && i(p, g) ? p : ((u = h), (d = g));
      }
      var c = !1,
        u,
        d,
        f = n === void 0 ? null : n;
      return [
        function () {
          return l(t());
        },
        f === null
          ? void 0
          : function () {
              return l(f());
            },
      ];
    },
    [t, n, r, i]
  );
  var a = d1e(e, s[0], s[1]);
  return (
    h1e(
      function () {
        (o.hasValue = !0), (o.value = a);
      },
      [a]
    ),
    m1e(a),
    a
  );
};
IY.exports = NY;
var g1e = IY.exports,
  Pl = "default" in tk ? Ce : tk,
  rF = Symbol.for("react-redux-context"),
  iF = typeof globalThis < "u" ? globalThis : {};
function y1e() {
  if (!Pl.createContext) return {};
  const e = iF[rF] ?? (iF[rF] = new Map());
  let t = e.get(Pl.createContext);
  return t || ((t = Pl.createContext(null)), e.set(Pl.createContext, t)), t;
}
var Yp = y1e(),
  v1e = () => {
    throw new Error("uSES not initialized!");
  };
function NN(e = Yp) {
  return function () {
    return Pl.useContext(e);
  };
}
var RY = NN(),
  OY = v1e,
  w1e = (e) => {
    OY = e;
  },
  b1e = (e, t) => e === t;
function x1e(e = Yp) {
  const t = e === Yp ? RY : NN(e),
    n = (r, i = {}) => {
      const { equalityFn: s = b1e, devModeChecks: o = {} } =
          typeof i == "function" ? { equalityFn: i } : i,
        {
          store: a,
          subscription: l,
          getServerState: c,
          stabilityCheck: u,
          identityFunctionCheck: d,
        } = t();
      Pl.useRef(!0);
      const f = Pl.useCallback(
          {
            [r.name](p) {
              return r(p);
            },
          }[r.name],
          [r, u, o.stabilityCheck]
        ),
        h = OY(l.addNestedSub, a.getState, c || a.getState, f, s);
      return Pl.useDebugValue(h), h;
    };
  return Object.assign(n, { withTypes: () => n }), n;
}
var el = x1e();
function PY(e) {
  e();
}
function _1e() {
  let e = null,
    t = null;
  return {
    clear() {
      (e = null), (t = null);
    },
    notify() {
      PY(() => {
        let n = e;
        for (; n; ) n.callback(), (n = n.next);
      });
    },
    get() {
      const n = [];
      let r = e;
      for (; r; ) n.push(r), (r = r.next);
      return n;
    },
    subscribe(n) {
      let r = !0;
      const i = (t = { callback: n, next: null, prev: t });
      return (
        i.prev ? (i.prev.next = i) : (e = i),
        function () {
          !r ||
            e === null ||
            ((r = !1),
            i.next ? (i.next.prev = i.prev) : (t = i.prev),
            i.prev ? (i.prev.next = i.next) : (e = i.next));
        }
      );
    },
  };
}
var sF = { notify() {}, get: () => [] };
function S1e(e, t) {
  let n,
    r = sF,
    i = 0,
    s = !1;
  function o(g) {
    u();
    const b = r.subscribe(g);
    let v = !1;
    return () => {
      v || ((v = !0), b(), d());
    };
  }
  function a() {
    r.notify();
  }
  function l() {
    p.onStateChange && p.onStateChange();
  }
  function c() {
    return s;
  }
  function u() {
    i++, n || ((n = e.subscribe(l)), (r = _1e()));
  }
  function d() {
    i--, n && i === 0 && (n(), (n = void 0), r.clear(), (r = sF));
  }
  function f() {
    s || ((s = !0), u());
  }
  function h() {
    s && ((s = !1), d());
  }
  const p = {
    addNestedSub: o,
    notifyNestedSubs: a,
    handleChangeWrapper: l,
    isSubscribed: c,
    trySubscribe: f,
    tryUnsubscribe: h,
    getListeners: () => r,
  };
  return p;
}
var E1e =
    typeof window < "u" &&
    typeof window.document < "u" &&
    typeof window.document.createElement < "u",
  A1e = E1e ? Pl.useLayoutEffect : Pl.useEffect;
function oF(e, t) {
  return e === t ? e !== 0 || t !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function mw(e, t) {
  if (oF(e, t)) return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null)
    return !1;
  const n = Object.keys(e),
    r = Object.keys(t);
  if (n.length !== r.length) return !1;
  for (let i = 0; i < n.length; i++)
    if (!Object.prototype.hasOwnProperty.call(t, n[i]) || !oF(e[n[i]], t[n[i]]))
      return !1;
  return !0;
}
function C1e({
  store: e,
  context: t,
  children: n,
  serverState: r,
  stabilityCheck: i = "once",
  identityFunctionCheck: s = "once",
}) {
  const o = Pl.useMemo(() => {
      const c = S1e(e);
      return {
        store: e,
        subscription: c,
        getServerState: r ? () => r : void 0,
        stabilityCheck: i,
        identityFunctionCheck: s,
      };
    }, [e, r, i, s]),
    a = Pl.useMemo(() => e.getState(), [e]);
  A1e(() => {
    const { subscription: c } = o;
    return (
      (c.onStateChange = c.notifyNestedSubs),
      c.trySubscribe(),
      a !== e.getState() && c.notifyNestedSubs(),
      () => {
        c.tryUnsubscribe(), (c.onStateChange = void 0);
      }
    );
  }, [o, a]);
  const l = t || Yp;
  return Pl.createElement(l.Provider, { value: o }, n);
}
var k1e = C1e;
function LY(e = Yp) {
  const t = e === Yp ? RY : NN(e),
    n = () => {
      const { store: r } = t();
      return r;
    };
  return Object.assign(n, { withTypes: () => n }), n;
}
var jY = LY();
function T1e(e = Yp) {
  const t = e === Yp ? jY : LY(e),
    n = () => t().dispatch;
  return Object.assign(n, { withTypes: () => n }), n;
}
var RN = T1e(),
  M1e = PY;
w1e(g1e.useSyncExternalStoreWithSelector);
/**
 * @remix-run/router v1.20.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function ts() {
  return (
    (ts = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
          }
          return e;
        }),
    ts.apply(this, arguments)
  );
}
var js;
(function (e) {
  (e.Pop = "POP"), (e.Push = "PUSH"), (e.Replace = "REPLACE");
})(js || (js = {}));
const aF = "popstate";
function I1e(e) {
  e === void 0 && (e = {});
  function t(r, i) {
    let { pathname: s, search: o, hash: a } = r.location;
    return eb(
      "",
      { pathname: s, search: o, hash: a },
      (i.state && i.state.usr) || null,
      (i.state && i.state.key) || "default"
    );
  }
  function n(r, i) {
    return typeof i == "string" ? i : Um(i);
  }
  return R1e(t, n, null, e);
}
function tr(e, t) {
  if (e === !1 || e === null || typeof e > "u") throw new Error(t);
}
function wy(e, t) {
  if (!e) {
    typeof console < "u" && console.warn(t);
    try {
      throw new Error(t);
    } catch {}
  }
}
function N1e() {
  return Math.random().toString(36).substr(2, 8);
}
function lF(e, t) {
  return { usr: e.state, key: e.key, idx: t };
}
function eb(e, t, n, r) {
  return (
    n === void 0 && (n = null),
    ts(
      { pathname: typeof e == "string" ? e : e.pathname, search: "", hash: "" },
      typeof t == "string" ? d0(t) : t,
      { state: n, key: (t && t.key) || r || N1e() }
    )
  );
}
function Um(e) {
  let { pathname: t = "/", search: n = "", hash: r = "" } = e;
  return (
    n && n !== "?" && (t += n.charAt(0) === "?" ? n : "?" + n),
    r && r !== "#" && (t += r.charAt(0) === "#" ? r : "#" + r),
    t
  );
}
function d0(e) {
  let t = {};
  if (e) {
    let n = e.indexOf("#");
    n >= 0 && ((t.hash = e.substr(n)), (e = e.substr(0, n)));
    let r = e.indexOf("?");
    r >= 0 && ((t.search = e.substr(r)), (e = e.substr(0, r))),
      e && (t.pathname = e);
  }
  return t;
}
function R1e(e, t, n, r) {
  r === void 0 && (r = {});
  let { window: i = document.defaultView, v5Compat: s = !1 } = r,
    o = i.history,
    a = js.Pop,
    l = null,
    c = u();
  c == null && ((c = 0), o.replaceState(ts({}, o.state, { idx: c }), ""));
  function u() {
    return (o.state || { idx: null }).idx;
  }
  function d() {
    a = js.Pop;
    let b = u(),
      v = b == null ? null : b - c;
    (c = b), l && l({ action: a, location: g.location, delta: v });
  }
  function f(b, v) {
    a = js.Push;
    let w = eb(g.location, b, v);
    c = u() + 1;
    let x = lF(w, c),
      S = g.createHref(w);
    try {
      o.pushState(x, "", S);
    } catch (R) {
      if (R instanceof DOMException && R.name === "DataCloneError") throw R;
      i.location.assign(S);
    }
    s && l && l({ action: a, location: g.location, delta: 1 });
  }
  function h(b, v) {
    a = js.Replace;
    let w = eb(g.location, b, v);
    c = u();
    let x = lF(w, c),
      S = g.createHref(w);
    o.replaceState(x, "", S),
      s && l && l({ action: a, location: g.location, delta: 0 });
  }
  function p(b) {
    let v = i.location.origin !== "null" ? i.location.origin : i.location.href,
      w = typeof b == "string" ? b : Um(b);
    return (
      (w = w.replace(/ $/, "%20")),
      tr(
        v,
        "No window.location.(origin|href) available to create URL for href: " +
          w
      ),
      new URL(w, v)
    );
  }
  let g = {
    get action() {
      return a;
    },
    get location() {
      return e(i, o);
    },
    listen(b) {
      if (l) throw new Error("A history only accepts one active listener");
      return (
        i.addEventListener(aF, d),
        (l = b),
        () => {
          i.removeEventListener(aF, d), (l = null);
        }
      );
    },
    createHref(b) {
      return t(i, b);
    },
    createURL: p,
    encodeLocation(b) {
      let v = p(b);
      return { pathname: v.pathname, search: v.search, hash: v.hash };
    },
    push: f,
    replace: h,
    go(b) {
      return o.go(b);
    },
  };
  return g;
}
var gi;
(function (e) {
  (e.data = "data"),
    (e.deferred = "deferred"),
    (e.redirect = "redirect"),
    (e.error = "error");
})(gi || (gi = {}));
const O1e = new Set([
  "lazy",
  "caseSensitive",
  "path",
  "id",
  "index",
  "children",
]);
function P1e(e) {
  return e.index === !0;
}
function Y6(e, t, n, r) {
  return (
    n === void 0 && (n = []),
    r === void 0 && (r = {}),
    e.map((i, s) => {
      let o = [...n, String(s)],
        a = typeof i.id == "string" ? i.id : o.join("-");
      if (
        (tr(
          i.index !== !0 || !i.children,
          "Cannot specify children on an index route"
        ),
        tr(
          !r[a],
          'Found a route id collision on id "' +
            a +
            `".  Route id's must be globally unique within Data Router usages`
        ),
        P1e(i))
      ) {
        let l = ts({}, i, t(i), { id: a });
        return (r[a] = l), l;
      } else {
        let l = ts({}, i, t(i), { id: a, children: void 0 });
        return (
          (r[a] = l), i.children && (l.children = Y6(i.children, t, o, r)), l
        );
      }
    })
  );
}
function q0(e, t, n) {
  return n === void 0 && (n = "/"), _4(e, t, n, !1);
}
function _4(e, t, n, r) {
  let i = typeof t == "string" ? d0(t) : t,
    s = Md(i.pathname || "/", n);
  if (s == null) return null;
  let o = BY(e);
  L1e(o);
  let a = null;
  for (let l = 0; a == null && l < o.length; ++l) {
    let c = G1e(s);
    a = H1e(o[l], c, r);
  }
  return a;
}
function DY(e, t) {
  let { route: n, pathname: r, params: i } = e;
  return { id: n.id, pathname: r, params: i, data: t[n.id], handle: n.handle };
}
function BY(e, t, n, r) {
  t === void 0 && (t = []), n === void 0 && (n = []), r === void 0 && (r = "");
  let i = (s, o, a) => {
    let l = {
      relativePath: a === void 0 ? s.path || "" : a,
      caseSensitive: s.caseSensitive === !0,
      childrenIndex: o,
      route: s,
    };
    l.relativePath.startsWith("/") &&
      (tr(
        l.relativePath.startsWith(r),
        'Absolute route path "' +
          l.relativePath +
          '" nested under path ' +
          ('"' + r + '" is not valid. An absolute child route path ') +
          "must start with the combined path of all its parent routes."
      ),
      (l.relativePath = l.relativePath.slice(r.length)));
    let c = Kf([r, l.relativePath]),
      u = n.concat(l);
    s.children &&
      s.children.length > 0 &&
      (tr(
        s.index !== !0,
        "Index routes must not have child routes. Please remove " +
          ('all child routes from route path "' + c + '".')
      ),
      BY(s.children, t, u, c)),
      !(s.path == null && !s.index) &&
        t.push({ path: c, score: z1e(c, s.index), routesMeta: u });
  };
  return (
    e.forEach((s, o) => {
      var a;
      if (s.path === "" || !((a = s.path) != null && a.includes("?"))) i(s, o);
      else for (let l of FY(s.path)) i(s, o, l);
    }),
    t
  );
}
function FY(e) {
  let t = e.split("/");
  if (t.length === 0) return [];
  let [n, ...r] = t,
    i = n.endsWith("?"),
    s = n.replace(/\?$/, "");
  if (r.length === 0) return i ? [s, ""] : [s];
  let o = FY(r.join("/")),
    a = [];
  return (
    a.push(...o.map((l) => (l === "" ? s : [s, l].join("/")))),
    i && a.push(...o),
    a.map((l) => (e.startsWith("/") && l === "" ? "/" : l))
  );
}
function L1e(e) {
  e.sort((t, n) =>
    t.score !== n.score
      ? n.score - t.score
      : W1e(
          t.routesMeta.map((r) => r.childrenIndex),
          n.routesMeta.map((r) => r.childrenIndex)
        )
  );
}
const j1e = /^:[\w-]+$/,
  D1e = 3,
  B1e = 2,
  F1e = 1,
  U1e = 10,
  $1e = -2,
  cF = (e) => e === "*";
function z1e(e, t) {
  let n = e.split("/"),
    r = n.length;
  return (
    n.some(cF) && (r += $1e),
    t && (r += B1e),
    n
      .filter((i) => !cF(i))
      .reduce((i, s) => i + (j1e.test(s) ? D1e : s === "" ? F1e : U1e), r)
  );
}
function W1e(e, t) {
  return e.length === t.length && e.slice(0, -1).every((r, i) => r === t[i])
    ? e[e.length - 1] - t[t.length - 1]
    : 0;
}
function H1e(e, t, n) {
  n === void 0 && (n = !1);
  let { routesMeta: r } = e,
    i = {},
    s = "/",
    o = [];
  for (let a = 0; a < r.length; ++a) {
    let l = r[a],
      c = a === r.length - 1,
      u = s === "/" ? t : t.slice(s.length) || "/",
      d = Z6(
        { path: l.relativePath, caseSensitive: l.caseSensitive, end: c },
        u
      ),
      f = l.route;
    if (
      (!d &&
        c &&
        n &&
        !r[r.length - 1].route.index &&
        (d = Z6(
          { path: l.relativePath, caseSensitive: l.caseSensitive, end: !1 },
          u
        )),
      !d)
    )
      return null;
    Object.assign(i, d.params),
      o.push({
        params: i,
        pathname: Kf([s, d.pathname]),
        pathnameBase: Y1e(Kf([s, d.pathnameBase])),
        route: f,
      }),
      d.pathnameBase !== "/" && (s = Kf([s, d.pathnameBase]));
  }
  return o;
}
function Z6(e, t) {
  typeof e == "string" && (e = { path: e, caseSensitive: !1, end: !0 });
  let [n, r] = V1e(e.path, e.caseSensitive, e.end),
    i = t.match(n);
  if (!i) return null;
  let s = i[0],
    o = s.replace(/(.)\/+$/, "$1"),
    a = i.slice(1);
  return {
    params: r.reduce((c, u, d) => {
      let { paramName: f, isOptional: h } = u;
      if (f === "*") {
        let g = a[d] || "";
        o = s.slice(0, s.length - g.length).replace(/(.)\/+$/, "$1");
      }
      const p = a[d];
      return (
        h && !p ? (c[f] = void 0) : (c[f] = (p || "").replace(/%2F/g, "/")), c
      );
    }, {}),
    pathname: s,
    pathnameBase: o,
    pattern: e,
  };
}
function V1e(e, t, n) {
  t === void 0 && (t = !1),
    n === void 0 && (n = !0),
    wy(
      e === "*" || !e.endsWith("*") || e.endsWith("/*"),
      'Route path "' +
        e +
        '" will be treated as if it were ' +
        ('"' + e.replace(/\*$/, "/*") + '" because the `*` character must ') +
        "always follow a `/` in the pattern. To get rid of this warning, " +
        ('please change the route path to "' + e.replace(/\*$/, "/*") + '".')
    );
  let r = [],
    i =
      "^" +
      e
        .replace(/\/*\*?$/, "")
        .replace(/^\/*/, "/")
        .replace(/[\\.*+^${}|()[\]]/g, "\\$&")
        .replace(
          /\/:([\w-]+)(\?)?/g,
          (o, a, l) => (
            r.push({ paramName: a, isOptional: l != null }),
            l ? "/?([^\\/]+)?" : "/([^\\/]+)"
          )
        );
  return (
    e.endsWith("*")
      ? (r.push({ paramName: "*" }),
        (i += e === "*" || e === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$"))
      : n
      ? (i += "\\/*$")
      : e !== "" && e !== "/" && (i += "(?:(?=\\/|$))"),
    [new RegExp(i, t ? void 0 : "i"), r]
  );
}
function G1e(e) {
  try {
    return e
      .split("/")
      .map((t) => decodeURIComponent(t).replace(/\//g, "%2F"))
      .join("/");
  } catch (t) {
    return (
      wy(
        !1,
        'The URL path "' +
          e +
          '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' +
          ("encoding (" + t + ").")
      ),
      e
    );
  }
}
function Md(e, t) {
  if (t === "/") return e;
  if (!e.toLowerCase().startsWith(t.toLowerCase())) return null;
  let n = t.endsWith("/") ? t.length - 1 : t.length,
    r = e.charAt(n);
  return r && r !== "/" ? null : e.slice(n) || "/";
}
function q1e(e, t) {
  t === void 0 && (t = "/");
  let {
    pathname: n,
    search: r = "",
    hash: i = "",
  } = typeof e == "string" ? d0(e) : e;
  return {
    pathname: n ? (n.startsWith("/") ? n : K1e(n, t)) : t,
    search: Z1e(r),
    hash: Q1e(i),
  };
}
function K1e(e, t) {
  let n = t.replace(/\/+$/, "").split("/");
  return (
    e.split("/").forEach((i) => {
      i === ".." ? n.length > 1 && n.pop() : i !== "." && n.push(i);
    }),
    n.length > 1 ? n.join("/") : "/"
  );
}
function kA(e, t, n, r) {
  return (
    "Cannot include a '" +
    e +
    "' character in a manually specified " +
    ("`to." +
      t +
      "` field [" +
      JSON.stringify(r) +
      "].  Please separate it out to the ") +
    ("`to." + n + "` field. Alternatively you may provide the full path as ") +
    'a string in <Link to="..."> and the router will parse it for you.'
  );
}
function UY(e) {
  return e.filter(
    (t, n) => n === 0 || (t.route.path && t.route.path.length > 0)
  );
}
function YS(e, t) {
  let n = UY(e);
  return t
    ? n.map((r, i) => (i === n.length - 1 ? r.pathname : r.pathnameBase))
    : n.map((r) => r.pathnameBase);
}
function ZS(e, t, n, r) {
  r === void 0 && (r = !1);
  let i;
  typeof e == "string"
    ? (i = d0(e))
    : ((i = ts({}, e)),
      tr(
        !i.pathname || !i.pathname.includes("?"),
        kA("?", "pathname", "search", i)
      ),
      tr(
        !i.pathname || !i.pathname.includes("#"),
        kA("#", "pathname", "hash", i)
      ),
      tr(!i.search || !i.search.includes("#"), kA("#", "search", "hash", i)));
  let s = e === "" || i.pathname === "",
    o = s ? "/" : i.pathname,
    a;
  if (o == null) a = n;
  else {
    let d = t.length - 1;
    if (!r && o.startsWith("..")) {
      let f = o.split("/");
      for (; f[0] === ".."; ) f.shift(), (d -= 1);
      i.pathname = f.join("/");
    }
    a = d >= 0 ? t[d] : "/";
  }
  let l = q1e(i, a),
    c = o && o !== "/" && o.endsWith("/"),
    u = (s || o === ".") && n.endsWith("/");
  return !l.pathname.endsWith("/") && (c || u) && (l.pathname += "/"), l;
}
const Kf = (e) => e.join("/").replace(/\/\/+/g, "/"),
  Y1e = (e) => e.replace(/\/+$/, "").replace(/^\/*/, "/"),
  Z1e = (e) => (!e || e === "?" ? "" : e.startsWith("?") ? e : "?" + e),
  Q1e = (e) => (!e || e === "#" ? "" : e.startsWith("#") ? e : "#" + e);
class Q6 {
  constructor(t, n, r, i) {
    i === void 0 && (i = !1),
      (this.status = t),
      (this.statusText = n || ""),
      (this.internal = i),
      r instanceof Error
        ? ((this.data = r.toString()), (this.error = r))
        : (this.data = r);
  }
}
function QS(e) {
  return (
    e != null &&
    typeof e.status == "number" &&
    typeof e.statusText == "string" &&
    typeof e.internal == "boolean" &&
    "data" in e
  );
}
const $Y = ["post", "put", "patch", "delete"],
  X1e = new Set($Y),
  J1e = ["get", ...$Y],
  ege = new Set(J1e),
  tge = new Set([301, 302, 303, 307, 308]),
  nge = new Set([307, 308]),
  TA = {
    state: "idle",
    location: void 0,
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0,
  },
  rge = {
    state: "idle",
    data: void 0,
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0,
  },
  y2 = { state: "unblocked", proceed: void 0, reset: void 0, location: void 0 },
  ON = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
  ige = (e) => ({ hasErrorBoundary: !!e.hasErrorBoundary }),
  zY = "remix-router-transitions";
function sge(e) {
  const t = e.window ? e.window : typeof window < "u" ? window : void 0,
    n =
      typeof t < "u" &&
      typeof t.document < "u" &&
      typeof t.document.createElement < "u",
    r = !n;
  tr(
    e.routes.length > 0,
    "You must provide a non-empty routes array to createRouter"
  );
  let i;
  if (e.mapRouteProperties) i = e.mapRouteProperties;
  else if (e.detectErrorBoundary) {
    let oe = e.detectErrorBoundary;
    i = (de) => ({ hasErrorBoundary: oe(de) });
  } else i = ige;
  let s = {},
    o = Y6(e.routes, i, void 0, s),
    a,
    l = e.basename || "/",
    c = e.dataStrategy || cge,
    u = e.patchRoutesOnNavigation,
    d = ts(
      {
        v7_fetcherPersist: !1,
        v7_normalizeFormMethod: !1,
        v7_partialHydration: !1,
        v7_prependBasename: !1,
        v7_relativeSplatPath: !1,
        v7_skipActionErrorRevalidation: !1,
      },
      e.future
    ),
    f = null,
    h = new Set(),
    p = null,
    g = null,
    b = null,
    v = e.hydrationData != null,
    w = q0(o, e.history.location, l),
    x = null;
  if (w == null && !u) {
    let oe = Ga(404, { pathname: e.history.location.pathname }),
      { matches: de, route: be } = bF(o);
    (w = de), (x = { [be.id]: oe });
  }
  w &&
    !e.hydrationData &&
    Cn(w, o, e.history.location.pathname).active &&
    (w = null);
  let S;
  if (w)
    if (w.some((oe) => oe.route.lazy)) S = !1;
    else if (!w.some((oe) => oe.route.loader)) S = !0;
    else if (d.v7_partialHydration) {
      let oe = e.hydrationData ? e.hydrationData.loaderData : null,
        de = e.hydrationData ? e.hydrationData.errors : null;
      if (de) {
        let be = w.findIndex((Me) => de[Me.route.id] !== void 0);
        S = w.slice(0, be + 1).every((Me) => !Zk(Me.route, oe, de));
      } else S = w.every((be) => !Zk(be.route, oe, de));
    } else S = e.hydrationData != null;
  else if (((S = !1), (w = []), d.v7_partialHydration)) {
    let oe = Cn(null, o, e.history.location.pathname);
    oe.active && oe.matches && (w = oe.matches);
  }
  let R,
    O = {
      historyAction: e.history.action,
      location: e.history.location,
      matches: w,
      initialized: S,
      navigation: TA,
      restoreScrollPosition: e.hydrationData != null ? !1 : null,
      preventScrollReset: !1,
      revalidation: "idle",
      loaderData: (e.hydrationData && e.hydrationData.loaderData) || {},
      actionData: (e.hydrationData && e.hydrationData.actionData) || null,
      errors: (e.hydrationData && e.hydrationData.errors) || x,
      fetchers: new Map(),
      blockers: new Map(),
    },
    B = js.Pop,
    C = !1,
    I,
    P = !1,
    M = new Map(),
    k = null,
    T = !1,
    _ = !1,
    A = [],
    N = new Set(),
    L = new Map(),
    F = 0,
    D = -1,
    j = new Map(),
    z = new Set(),
    $ = new Map(),
    K = new Map(),
    re = new Set(),
    G = new Map(),
    ne = new Map(),
    ae;
  function le() {
    if (
      ((f = e.history.listen((oe) => {
        let { action: de, location: be, delta: Me } = oe;
        if (ae) {
          ae(), (ae = void 0);
          return;
        }
        wy(
          ne.size === 0 || Me != null,
          "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL."
        );
        let Fe = ct({
          currentLocation: O.location,
          nextLocation: be,
          historyAction: de,
        });
        if (Fe && Me != null) {
          let it = new Promise((ft) => {
            ae = ft;
          });
          e.history.go(Me * -1),
            vt(Fe, {
              state: "blocked",
              location: be,
              proceed() {
                vt(Fe, {
                  state: "proceeding",
                  proceed: void 0,
                  reset: void 0,
                  location: be,
                }),
                  it.then(() => e.history.go(Me));
              },
              reset() {
                let ft = new Map(O.blockers);
                ft.set(Fe, y2), _e({ blockers: ft });
              },
            });
          return;
        }
        return Be(de, be);
      })),
      n)
    ) {
      Sge(t, M);
      let oe = () => Ege(t, M);
      t.addEventListener("pagehide", oe),
        (k = () => t.removeEventListener("pagehide", oe));
    }
    return O.initialized || Be(js.Pop, O.location, { initialHydration: !0 }), R;
  }
  function ge() {
    f && f(),
      k && k(),
      h.clear(),
      I && I.abort(),
      O.fetchers.forEach((oe, de) => Q(de)),
      O.blockers.forEach((oe, de) => ht(de));
  }
  function Oe(oe) {
    return h.add(oe), () => h.delete(oe);
  }
  function _e(oe, de) {
    de === void 0 && (de = {}), (O = ts({}, O, oe));
    let be = [],
      Me = [];
    d.v7_fetcherPersist &&
      O.fetchers.forEach((Fe, it) => {
        Fe.state === "idle" && (re.has(it) ? Me.push(it) : be.push(it));
      }),
      [...h].forEach((Fe) =>
        Fe(O, {
          deletedFetchers: Me,
          viewTransitionOpts: de.viewTransitionOpts,
          flushSync: de.flushSync === !0,
        })
      ),
      d.v7_fetcherPersist &&
        (be.forEach((Fe) => O.fetchers.delete(Fe)), Me.forEach((Fe) => Q(Fe)));
  }
  function Ee(oe, de, be) {
    var Me, Fe;
    let { flushSync: it } = be === void 0 ? {} : be,
      ft =
        O.actionData != null &&
        O.navigation.formMethod != null &&
        uu(O.navigation.formMethod) &&
        O.navigation.state === "loading" &&
        ((Me = oe.state) == null ? void 0 : Me._isRedirect) !== !0,
      ze;
    de.actionData
      ? Object.keys(de.actionData).length > 0
        ? (ze = de.actionData)
        : (ze = null)
      : ft
      ? (ze = O.actionData)
      : (ze = null);
    let nt = de.loaderData
        ? vF(O.loaderData, de.loaderData, de.matches || [], de.errors)
        : O.loaderData,
      Xe = O.blockers;
    Xe.size > 0 && ((Xe = new Map(Xe)), Xe.forEach((gt, un) => Xe.set(un, y2)));
    let Ve =
      C === !0 ||
      (O.navigation.formMethod != null &&
        uu(O.navigation.formMethod) &&
        ((Fe = oe.state) == null ? void 0 : Fe._isRedirect) !== !0);
    a && ((o = a), (a = void 0)),
      T ||
        B === js.Pop ||
        (B === js.Push
          ? e.history.push(oe, oe.state)
          : B === js.Replace && e.history.replace(oe, oe.state));
    let bt;
    if (B === js.Pop) {
      let gt = M.get(O.location.pathname);
      gt && gt.has(oe.pathname)
        ? (bt = { currentLocation: O.location, nextLocation: oe })
        : M.has(oe.pathname) &&
          (bt = { currentLocation: oe, nextLocation: O.location });
    } else if (P) {
      let gt = M.get(O.location.pathname);
      gt
        ? gt.add(oe.pathname)
        : ((gt = new Set([oe.pathname])), M.set(O.location.pathname, gt)),
        (bt = { currentLocation: O.location, nextLocation: oe });
    }
    _e(
      ts({}, de, {
        actionData: ze,
        loaderData: nt,
        historyAction: B,
        location: oe,
        initialized: !0,
        navigation: TA,
        revalidation: "idle",
        restoreScrollPosition: Gt(oe, de.matches || O.matches),
        preventScrollReset: Ve,
        blockers: Xe,
      }),
      { viewTransitionOpts: bt, flushSync: it === !0 }
    ),
      (B = js.Pop),
      (C = !1),
      (P = !1),
      (T = !1),
      (_ = !1),
      (A = []);
  }
  async function He(oe, de) {
    if (typeof oe == "number") {
      e.history.go(oe);
      return;
    }
    let be = Yk(
        O.location,
        O.matches,
        l,
        d.v7_prependBasename,
        oe,
        d.v7_relativeSplatPath,
        de == null ? void 0 : de.fromRouteId,
        de == null ? void 0 : de.relative
      ),
      {
        path: Me,
        submission: Fe,
        error: it,
      } = uF(d.v7_normalizeFormMethod, !1, be, de),
      ft = O.location,
      ze = eb(O.location, Me, de && de.state);
    ze = ts({}, ze, e.history.encodeLocation(ze));
    let nt = de && de.replace != null ? de.replace : void 0,
      Xe = js.Push;
    nt === !0
      ? (Xe = js.Replace)
      : nt === !1 ||
        (Fe != null &&
          uu(Fe.formMethod) &&
          Fe.formAction === O.location.pathname + O.location.search &&
          (Xe = js.Replace));
    let Ve =
        de && "preventScrollReset" in de
          ? de.preventScrollReset === !0
          : void 0,
      bt = (de && de.flushSync) === !0,
      gt = ct({ currentLocation: ft, nextLocation: ze, historyAction: Xe });
    if (gt) {
      vt(gt, {
        state: "blocked",
        location: ze,
        proceed() {
          vt(gt, {
            state: "proceeding",
            proceed: void 0,
            reset: void 0,
            location: ze,
          }),
            He(oe, de);
        },
        reset() {
          let un = new Map(O.blockers);
          un.set(gt, y2), _e({ blockers: un });
        },
      });
      return;
    }
    return await Be(Xe, ze, {
      submission: Fe,
      pendingError: it,
      preventScrollReset: Ve,
      replace: de && de.replace,
      enableViewTransition: de && de.viewTransition,
      flushSync: bt,
    });
  }
  function je() {
    if (
      (wn(),
      _e({ revalidation: "loading" }),
      O.navigation.state !== "submitting")
    ) {
      if (O.navigation.state === "idle") {
        Be(O.historyAction, O.location, { startUninterruptedRevalidation: !0 });
        return;
      }
      Be(B || O.historyAction, O.navigation.location, {
        overrideNavigation: O.navigation,
        enableViewTransition: P === !0,
      });
    }
  }
  async function Be(oe, de, be) {
    I && I.abort(),
      (I = null),
      (B = oe),
      (T = (be && be.startUninterruptedRevalidation) === !0),
      jn(O.location, O.matches),
      (C = (be && be.preventScrollReset) === !0),
      (P = (be && be.enableViewTransition) === !0);
    let Me = a || o,
      Fe = be && be.overrideNavigation,
      it = q0(Me, de, l),
      ft = (be && be.flushSync) === !0,
      ze = Cn(it, Me, de.pathname);
    if ((ze.active && ze.matches && (it = ze.matches), !it)) {
      let { error: Rn, notFoundMatches: bn, route: Sn } = Lt(de.pathname);
      Ee(
        de,
        { matches: bn, loaderData: {}, errors: { [Sn.id]: Rn } },
        { flushSync: ft }
      );
      return;
    }
    if (
      O.initialized &&
      !_ &&
      mge(O.location, de) &&
      !(be && be.submission && uu(be.submission.formMethod))
    ) {
      Ee(de, { matches: it }, { flushSync: ft });
      return;
    }
    I = new AbortController();
    let nt = $1(e.history, de, I.signal, be && be.submission),
      Xe;
    if (be && be.pendingError)
      Xe = [K0(it).route.id, { type: gi.error, error: be.pendingError }];
    else if (be && be.submission && uu(be.submission.formMethod)) {
      let Rn = await rn(nt, de, be.submission, it, ze.active, {
        replace: be.replace,
        flushSync: ft,
      });
      if (Rn.shortCircuited) return;
      if (Rn.pendingActionResult) {
        let [bn, Sn] = Rn.pendingActionResult;
        if (kl(Sn) && QS(Sn.error) && Sn.error.status === 404) {
          (I = null),
            Ee(de, {
              matches: Rn.matches,
              loaderData: {},
              errors: { [bn]: Sn.error },
            });
          return;
        }
      }
      (it = Rn.matches || it),
        (Xe = Rn.pendingActionResult),
        (Fe = MA(de, be.submission)),
        (ft = !1),
        (ze.active = !1),
        (nt = $1(e.history, nt.url, nt.signal));
    }
    let {
      shortCircuited: Ve,
      matches: bt,
      loaderData: gt,
      errors: un,
    } = await Wt(
      nt,
      de,
      it,
      ze.active,
      Fe,
      be && be.submission,
      be && be.fetcherSubmission,
      be && be.replace,
      be && be.initialHydration === !0,
      ft,
      Xe
    );
    Ve ||
      ((I = null),
      Ee(
        de,
        ts({ matches: bt || it }, wF(Xe), { loaderData: gt, errors: un })
      ));
  }
  async function rn(oe, de, be, Me, Fe, it) {
    it === void 0 && (it = {}), wn();
    let ft = xge(de, be);
    if ((_e({ navigation: ft }, { flushSync: it.flushSync === !0 }), Fe)) {
      let Xe = await cn(Me, de.pathname, oe.signal);
      if (Xe.type === "aborted") return { shortCircuited: !0 };
      if (Xe.type === "error") {
        let Ve = K0(Xe.partialMatches).route.id;
        return {
          matches: Xe.partialMatches,
          pendingActionResult: [Ve, { type: gi.error, error: Xe.error }],
        };
      } else if (Xe.matches) Me = Xe.matches;
      else {
        let { notFoundMatches: Ve, error: bt, route: gt } = Lt(de.pathname);
        return {
          matches: Ve,
          pendingActionResult: [gt.id, { type: gi.error, error: bt }],
        };
      }
    }
    let ze,
      nt = q2(Me, de);
    if (!nt.route.action && !nt.route.lazy)
      ze = {
        type: gi.error,
        error: Ga(405, {
          method: oe.method,
          pathname: de.pathname,
          routeId: nt.route.id,
        }),
      };
    else if (
      ((ze = (await mt("action", O, oe, [nt], Me, null))[nt.route.id]),
      oe.signal.aborted)
    )
      return { shortCircuited: !0 };
    if (rm(ze)) {
      let Xe;
      return (
        it && it.replace != null
          ? (Xe = it.replace)
          : (Xe =
              mF(ze.response.headers.get("Location"), new URL(oe.url), l) ===
              O.location.pathname + O.location.search),
        await Rt(oe, ze, !0, { submission: be, replace: Xe }),
        { shortCircuited: !0 }
      );
    }
    if (bp(ze)) throw Ga(400, { type: "defer-action" });
    if (kl(ze)) {
      let Xe = K0(Me, nt.route.id);
      return (
        (it && it.replace) !== !0 && (B = js.Push),
        { matches: Me, pendingActionResult: [Xe.route.id, ze] }
      );
    }
    return { matches: Me, pendingActionResult: [nt.route.id, ze] };
  }
  async function Wt(oe, de, be, Me, Fe, it, ft, ze, nt, Xe, Ve) {
    let bt = Fe || MA(de, it),
      gt = it || ft || _F(bt),
      un = !T && (!d.v7_partialHydration || !nt);
    if (Me) {
      if (un) {
        let On = Mt(Ve);
        _e(ts({ navigation: bt }, On !== void 0 ? { actionData: On } : {}), {
          flushSync: Xe,
        });
      }
      let In = await cn(be, de.pathname, oe.signal);
      if (In.type === "aborted") return { shortCircuited: !0 };
      if (In.type === "error") {
        let On = K0(In.partialMatches).route.id;
        return {
          matches: In.partialMatches,
          loaderData: {},
          errors: { [On]: In.error },
        };
      } else if (In.matches) be = In.matches;
      else {
        let { error: On, notFoundMatches: Ei, route: As } = Lt(de.pathname);
        return { matches: Ei, loaderData: {}, errors: { [As.id]: On } };
      }
    }
    let Rn = a || o,
      [bn, Sn] = fF(
        e.history,
        O,
        be,
        gt,
        de,
        d.v7_partialHydration && nt === !0,
        d.v7_skipActionErrorRevalidation,
        _,
        A,
        N,
        re,
        $,
        z,
        Rn,
        l,
        Ve
      );
    if (
      (wt(
        (In) =>
          !(be && be.some((On) => On.route.id === In)) ||
          (bn && bn.some((On) => On.route.id === In))
      ),
      (D = ++F),
      bn.length === 0 && Sn.length === 0)
    ) {
      let In = ce();
      return (
        Ee(
          de,
          ts(
            {
              matches: be,
              loaderData: {},
              errors: Ve && kl(Ve[1]) ? { [Ve[0]]: Ve[1].error } : null,
            },
            wF(Ve),
            In ? { fetchers: new Map(O.fetchers) } : {}
          ),
          { flushSync: Xe }
        ),
        { shortCircuited: !0 }
      );
    }
    if (un) {
      let In = {};
      if (!Me) {
        In.navigation = bt;
        let On = Mt(Ve);
        On !== void 0 && (In.actionData = On);
      }
      Sn.length > 0 && (In.fetchers = an(Sn)), _e(In, { flushSync: Xe });
    }
    Sn.forEach((In) => {
      q(In.key), In.controller && L.set(In.key, In.controller);
    });
    let Si = () => Sn.forEach((In) => q(In.key));
    I && I.signal.addEventListener("abort", Si);
    let { loaderResults: vr, fetcherResults: pi } = await Pt(O, be, bn, Sn, oe);
    if (oe.signal.aborted) return { shortCircuited: !0 };
    I && I.signal.removeEventListener("abort", Si),
      Sn.forEach((In) => L.delete(In.key));
    let ii = v_(vr);
    if (ii)
      return (
        await Rt(oe, ii.result, !0, { replace: ze }), { shortCircuited: !0 }
      );
    if (((ii = v_(pi)), ii))
      return (
        z.add(ii.key),
        await Rt(oe, ii.result, !0, { replace: ze }),
        { shortCircuited: !0 }
      );
    let { loaderData: Ki, errors: si } = yF(O, be, vr, Ve, Sn, pi, G);
    G.forEach((In, On) => {
      In.subscribe((Ei) => {
        (Ei || In.done) && G.delete(On);
      });
    }),
      d.v7_partialHydration && nt && O.errors && (si = ts({}, O.errors, si));
    let Ti = ce(),
      Yi = pe(D),
      Es = Ti || Yi || Sn.length > 0;
    return ts(
      { matches: be, loaderData: Ki, errors: si },
      Es ? { fetchers: new Map(O.fetchers) } : {}
    );
  }
  function Mt(oe) {
    if (oe && !kl(oe[1])) return { [oe[0]]: oe[1].data };
    if (O.actionData)
      return Object.keys(O.actionData).length === 0 ? null : O.actionData;
  }
  function an(oe) {
    return (
      oe.forEach((de) => {
        let be = O.fetchers.get(de.key),
          Me = v2(void 0, be ? be.data : void 0);
        O.fetchers.set(de.key, Me);
      }),
      new Map(O.fetchers)
    );
  }
  function kt(oe, de, be, Me) {
    if (r)
      throw new Error(
        "router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback."
      );
    q(oe);
    let Fe = (Me && Me.flushSync) === !0,
      it = a || o,
      ft = Yk(
        O.location,
        O.matches,
        l,
        d.v7_prependBasename,
        be,
        d.v7_relativeSplatPath,
        de,
        Me == null ? void 0 : Me.relative
      ),
      ze = q0(it, ft, l),
      nt = Cn(ze, it, ft);
    if ((nt.active && nt.matches && (ze = nt.matches), !ze)) {
      Tt(oe, de, Ga(404, { pathname: ft }), { flushSync: Fe });
      return;
    }
    let {
      path: Xe,
      submission: Ve,
      error: bt,
    } = uF(d.v7_normalizeFormMethod, !0, ft, Me);
    if (bt) {
      Tt(oe, de, bt, { flushSync: Fe });
      return;
    }
    let gt = q2(ze, Xe),
      un = (Me && Me.preventScrollReset) === !0;
    if (Ve && uu(Ve.formMethod)) {
      Qe(oe, de, Xe, gt, ze, nt.active, Fe, un, Ve);
      return;
    }
    $.set(oe, { routeId: de, path: Xe }),
      Vt(oe, de, Xe, gt, ze, nt.active, Fe, un, Ve);
  }
  async function Qe(oe, de, be, Me, Fe, it, ft, ze, nt) {
    wn(), $.delete(oe);
    function Xe(wr) {
      if (!wr.route.action && !wr.route.lazy) {
        let Mi = Ga(405, { method: nt.formMethod, pathname: be, routeId: de });
        return Tt(oe, de, Mi, { flushSync: ft }), !0;
      }
      return !1;
    }
    if (!it && Xe(Me)) return;
    let Ve = O.fetchers.get(oe);
    xt(oe, _ge(nt, Ve), { flushSync: ft });
    let bt = new AbortController(),
      gt = $1(e.history, be, bt.signal, nt);
    if (it) {
      let wr = await cn(Fe, be, gt.signal);
      if (wr.type === "aborted") return;
      if (wr.type === "error") {
        Tt(oe, de, wr.error, { flushSync: ft });
        return;
      } else if (wr.matches) {
        if (((Fe = wr.matches), (Me = q2(Fe, be)), Xe(Me))) return;
      } else {
        Tt(oe, de, Ga(404, { pathname: be }), { flushSync: ft });
        return;
      }
    }
    L.set(oe, bt);
    let un = F,
      bn = (await mt("action", O, gt, [Me], Fe, oe))[Me.route.id];
    if (gt.signal.aborted) {
      L.get(oe) === bt && L.delete(oe);
      return;
    }
    if (d.v7_fetcherPersist && re.has(oe)) {
      if (rm(bn) || kl(bn)) {
        xt(oe, rp(void 0));
        return;
      }
    } else {
      if (rm(bn))
        if ((L.delete(oe), D > un)) {
          xt(oe, rp(void 0));
          return;
        } else
          return (
            z.add(oe),
            xt(oe, v2(nt)),
            Rt(gt, bn, !1, { fetcherSubmission: nt, preventScrollReset: ze })
          );
      if (kl(bn)) {
        Tt(oe, de, bn.error);
        return;
      }
    }
    if (bp(bn)) throw Ga(400, { type: "defer-action" });
    let Sn = O.navigation.location || O.location,
      Si = $1(e.history, Sn, bt.signal),
      vr = a || o,
      pi =
        O.navigation.state !== "idle"
          ? q0(vr, O.navigation.location, l)
          : O.matches;
    tr(pi, "Didn't find any matches after fetcher action");
    let ii = ++F;
    j.set(oe, ii);
    let Ki = v2(nt, bn.data);
    O.fetchers.set(oe, Ki);
    let [si, Ti] = fF(
      e.history,
      O,
      pi,
      nt,
      Sn,
      !1,
      d.v7_skipActionErrorRevalidation,
      _,
      A,
      N,
      re,
      $,
      z,
      vr,
      l,
      [Me.route.id, bn]
    );
    Ti.filter((wr) => wr.key !== oe).forEach((wr) => {
      let Mi = wr.key,
        ha = O.fetchers.get(Mi),
        ju = v2(void 0, ha ? ha.data : void 0);
      O.fetchers.set(Mi, ju), q(Mi), wr.controller && L.set(Mi, wr.controller);
    }),
      _e({ fetchers: new Map(O.fetchers) });
    let Yi = () => Ti.forEach((wr) => q(wr.key));
    bt.signal.addEventListener("abort", Yi);
    let { loaderResults: Es, fetcherResults: In } = await Pt(O, pi, si, Ti, Si);
    if (bt.signal.aborted) return;
    bt.signal.removeEventListener("abort", Yi),
      j.delete(oe),
      L.delete(oe),
      Ti.forEach((wr) => L.delete(wr.key));
    let On = v_(Es);
    if (On) return Rt(Si, On.result, !1, { preventScrollReset: ze });
    if (((On = v_(In)), On))
      return z.add(On.key), Rt(Si, On.result, !1, { preventScrollReset: ze });
    let { loaderData: Ei, errors: As } = yF(O, pi, Es, void 0, Ti, In, G);
    if (O.fetchers.has(oe)) {
      let wr = rp(bn.data);
      O.fetchers.set(oe, wr);
    }
    pe(ii),
      O.navigation.state === "loading" && ii > D
        ? (tr(B, "Expected pending action"),
          I && I.abort(),
          Ee(O.navigation.location, {
            matches: pi,
            loaderData: Ei,
            errors: As,
            fetchers: new Map(O.fetchers),
          }))
        : (_e({
            errors: As,
            loaderData: vF(O.loaderData, Ei, pi, As),
            fetchers: new Map(O.fetchers),
          }),
          (_ = !1));
  }
  async function Vt(oe, de, be, Me, Fe, it, ft, ze, nt) {
    let Xe = O.fetchers.get(oe);
    xt(oe, v2(nt, Xe ? Xe.data : void 0), { flushSync: ft });
    let Ve = new AbortController(),
      bt = $1(e.history, be, Ve.signal);
    if (it) {
      let bn = await cn(Fe, be, bt.signal);
      if (bn.type === "aborted") return;
      if (bn.type === "error") {
        Tt(oe, de, bn.error, { flushSync: ft });
        return;
      } else if (bn.matches) (Fe = bn.matches), (Me = q2(Fe, be));
      else {
        Tt(oe, de, Ga(404, { pathname: be }), { flushSync: ft });
        return;
      }
    }
    L.set(oe, Ve);
    let gt = F,
      Rn = (await mt("loader", O, bt, [Me], Fe, oe))[Me.route.id];
    if (
      (bp(Rn) && (Rn = (await PN(Rn, bt.signal, !0)) || Rn),
      L.get(oe) === Ve && L.delete(oe),
      !bt.signal.aborted)
    ) {
      if (re.has(oe)) {
        xt(oe, rp(void 0));
        return;
      }
      if (rm(Rn))
        if (D > gt) {
          xt(oe, rp(void 0));
          return;
        } else {
          z.add(oe), await Rt(bt, Rn, !1, { preventScrollReset: ze });
          return;
        }
      if (kl(Rn)) {
        Tt(oe, de, Rn.error);
        return;
      }
      tr(!bp(Rn), "Unhandled fetcher deferred data"), xt(oe, rp(Rn.data));
    }
  }
  async function Rt(oe, de, be, Me) {
    let {
      submission: Fe,
      fetcherSubmission: it,
      preventScrollReset: ft,
      replace: ze,
    } = Me === void 0 ? {} : Me;
    de.response.headers.has("X-Remix-Revalidate") && (_ = !0);
    let nt = de.response.headers.get("Location");
    tr(nt, "Expected a Location header on the redirect Response"),
      (nt = mF(nt, new URL(oe.url), l));
    let Xe = eb(O.location, nt, { _isRedirect: !0 });
    if (n) {
      let bn = !1;
      if (de.response.headers.has("X-Remix-Reload-Document")) bn = !0;
      else if (ON.test(nt)) {
        const Sn = e.history.createURL(nt);
        bn = Sn.origin !== t.location.origin || Md(Sn.pathname, l) == null;
      }
      if (bn) {
        ze ? t.location.replace(nt) : t.location.assign(nt);
        return;
      }
    }
    I = null;
    let Ve =
        ze === !0 || de.response.headers.has("X-Remix-Replace")
          ? js.Replace
          : js.Push,
      { formMethod: bt, formAction: gt, formEncType: un } = O.navigation;
    !Fe && !it && bt && gt && un && (Fe = _F(O.navigation));
    let Rn = Fe || it;
    if (nge.has(de.response.status) && Rn && uu(Rn.formMethod))
      await Be(Ve, Xe, {
        submission: ts({}, Rn, { formAction: nt }),
        preventScrollReset: ft || C,
        enableViewTransition: be ? P : void 0,
      });
    else {
      let bn = MA(Xe, Fe);
      await Be(Ve, Xe, {
        overrideNavigation: bn,
        fetcherSubmission: it,
        preventScrollReset: ft || C,
        enableViewTransition: be ? P : void 0,
      });
    }
  }
  async function mt(oe, de, be, Me, Fe, it) {
    let ft,
      ze = {};
    try {
      ft = await uge(c, oe, de, be, Me, Fe, it, s, i);
    } catch (nt) {
      return (
        Me.forEach((Xe) => {
          ze[Xe.route.id] = { type: gi.error, error: nt };
        }),
        ze
      );
    }
    for (let [nt, Xe] of Object.entries(ft))
      if (gge(Xe)) {
        let Ve = Xe.result;
        ze[nt] = {
          type: gi.redirect,
          response: hge(Ve, be, nt, Fe, l, d.v7_relativeSplatPath),
        };
      } else ze[nt] = await fge(Xe);
    return ze;
  }
  async function Pt(oe, de, be, Me, Fe) {
    let it = oe.matches,
      ft = mt("loader", oe, Fe, be, de, null),
      ze = Promise.all(
        Me.map(async (Ve) => {
          if (Ve.matches && Ve.match && Ve.controller) {
            let gt = (
              await mt(
                "loader",
                oe,
                $1(e.history, Ve.path, Ve.controller.signal),
                [Ve.match],
                Ve.matches,
                Ve.key
              )
            )[Ve.match.route.id];
            return { [Ve.key]: gt };
          } else
            return Promise.resolve({
              [Ve.key]: {
                type: gi.error,
                error: Ga(404, { pathname: Ve.path }),
              },
            });
        })
      ),
      nt = await ft,
      Xe = (await ze).reduce((Ve, bt) => Object.assign(Ve, bt), {});
    return (
      await Promise.all([
        wge(de, nt, Fe.signal, it, oe.loaderData),
        bge(de, Xe, Me),
      ]),
      { loaderResults: nt, fetcherResults: Xe }
    );
  }
  function wn() {
    (_ = !0),
      A.push(...wt()),
      $.forEach((oe, de) => {
        L.has(de) && N.add(de), q(de);
      });
  }
  function xt(oe, de, be) {
    be === void 0 && (be = {}),
      O.fetchers.set(oe, de),
      _e(
        { fetchers: new Map(O.fetchers) },
        { flushSync: (be && be.flushSync) === !0 }
      );
  }
  function Tt(oe, de, be, Me) {
    Me === void 0 && (Me = {});
    let Fe = K0(O.matches, de);
    Q(oe),
      _e(
        { errors: { [Fe.route.id]: be }, fetchers: new Map(O.fetchers) },
        { flushSync: (Me && Me.flushSync) === !0 }
      );
  }
  function _n(oe) {
    return (
      d.v7_fetcherPersist &&
        (K.set(oe, (K.get(oe) || 0) + 1), re.has(oe) && re.delete(oe)),
      O.fetchers.get(oe) || rge
    );
  }
  function Q(oe) {
    let de = O.fetchers.get(oe);
    L.has(oe) && !(de && de.state === "loading" && j.has(oe)) && q(oe),
      $.delete(oe),
      j.delete(oe),
      z.delete(oe),
      re.delete(oe),
      N.delete(oe),
      O.fetchers.delete(oe);
  }
  function H(oe) {
    if (d.v7_fetcherPersist) {
      let de = (K.get(oe) || 0) - 1;
      de <= 0 ? (K.delete(oe), re.add(oe)) : K.set(oe, de);
    } else Q(oe);
    _e({ fetchers: new Map(O.fetchers) });
  }
  function q(oe) {
    let de = L.get(oe);
    de && (de.abort(), L.delete(oe));
  }
  function ee(oe) {
    for (let de of oe) {
      let be = _n(de),
        Me = rp(be.data);
      O.fetchers.set(de, Me);
    }
  }
  function ce() {
    let oe = [],
      de = !1;
    for (let be of z) {
      let Me = O.fetchers.get(be);
      tr(Me, "Expected fetcher: " + be),
        Me.state === "loading" && (z.delete(be), oe.push(be), (de = !0));
    }
    return ee(oe), de;
  }
  function pe(oe) {
    let de = [];
    for (let [be, Me] of j)
      if (Me < oe) {
        let Fe = O.fetchers.get(be);
        tr(Fe, "Expected fetcher: " + be),
          Fe.state === "loading" && (q(be), j.delete(be), de.push(be));
      }
    return ee(de), de.length > 0;
  }
  function we(oe, de) {
    let be = O.blockers.get(oe) || y2;
    return ne.get(oe) !== de && ne.set(oe, de), be;
  }
  function ht(oe) {
    O.blockers.delete(oe), ne.delete(oe);
  }
  function vt(oe, de) {
    let be = O.blockers.get(oe) || y2;
    tr(
      (be.state === "unblocked" && de.state === "blocked") ||
        (be.state === "blocked" && de.state === "blocked") ||
        (be.state === "blocked" && de.state === "proceeding") ||
        (be.state === "blocked" && de.state === "unblocked") ||
        (be.state === "proceeding" && de.state === "unblocked"),
      "Invalid blocker state transition: " + be.state + " -> " + de.state
    );
    let Me = new Map(O.blockers);
    Me.set(oe, de), _e({ blockers: Me });
  }
  function ct(oe) {
    let { currentLocation: de, nextLocation: be, historyAction: Me } = oe;
    if (ne.size === 0) return;
    ne.size > 1 && wy(!1, "A router only supports one blocker at a time");
    let Fe = Array.from(ne.entries()),
      [it, ft] = Fe[Fe.length - 1],
      ze = O.blockers.get(it);
    if (
      !(ze && ze.state === "proceeding") &&
      ft({ currentLocation: de, nextLocation: be, historyAction: Me })
    )
      return it;
  }
  function Lt(oe) {
    let de = Ga(404, { pathname: oe }),
      be = a || o,
      { matches: Me, route: Fe } = bF(be);
    return wt(), { notFoundMatches: Me, route: Fe, error: de };
  }
  function wt(oe) {
    let de = [];
    return (
      G.forEach((be, Me) => {
        (!oe || oe(Me)) && (be.cancel(), de.push(Me), G.delete(Me));
      }),
      de
    );
  }
  function Ht(oe, de, be) {
    if (((p = oe), (b = de), (g = be || null), !v && O.navigation === TA)) {
      v = !0;
      let Me = Gt(O.location, O.matches);
      Me != null && _e({ restoreScrollPosition: Me });
    }
    return () => {
      (p = null), (b = null), (g = null);
    };
  }
  function mn(oe, de) {
    return (
      (g &&
        g(
          oe,
          de.map((Me) => DY(Me, O.loaderData))
        )) ||
      oe.key
    );
  }
  function jn(oe, de) {
    if (p && b) {
      let be = mn(oe, de);
      p[be] = b();
    }
  }
  function Gt(oe, de) {
    if (p) {
      let be = mn(oe, de),
        Me = p[be];
      if (typeof Me == "number") return Me;
    }
    return null;
  }
  function Cn(oe, de, be) {
    if (u)
      if (oe) {
        if (Object.keys(oe[0].params).length > 0)
          return { active: !0, matches: _4(de, be, l, !0) };
      } else return { active: !0, matches: _4(de, be, l, !0) || [] };
    return { active: !1, matches: null };
  }
  async function cn(oe, de, be) {
    if (!u) return { type: "success", matches: oe };
    let Me = oe;
    for (;;) {
      let Fe = a == null,
        it = a || o,
        ft = s;
      try {
        await u({
          path: de,
          matches: Me,
          patch: (Xe, Ve) => {
            be.aborted || pF(Xe, Ve, it, ft, i);
          },
        });
      } catch (Xe) {
        return { type: "error", error: Xe, partialMatches: Me };
      } finally {
        Fe && !be.aborted && (o = [...o]);
      }
      if (be.aborted) return { type: "aborted" };
      let ze = q0(it, de, l);
      if (ze) return { type: "success", matches: ze };
      let nt = _4(it, de, l, !0);
      if (
        !nt ||
        (Me.length === nt.length &&
          Me.every((Xe, Ve) => Xe.route.id === nt[Ve].route.id))
      )
        return { type: "success", matches: null };
      Me = nt;
    }
  }
  function Yt(oe) {
    (s = {}), (a = Y6(oe, i, void 0, s));
  }
  function ln(oe, de) {
    let be = a == null;
    pF(oe, de, a || o, s, i), be && ((o = [...o]), _e({}));
  }
  return (
    (R = {
      get basename() {
        return l;
      },
      get future() {
        return d;
      },
      get state() {
        return O;
      },
      get routes() {
        return o;
      },
      get window() {
        return t;
      },
      initialize: le,
      subscribe: Oe,
      enableScrollRestoration: Ht,
      navigate: He,
      fetch: kt,
      revalidate: je,
      createHref: (oe) => e.history.createHref(oe),
      encodeLocation: (oe) => e.history.encodeLocation(oe),
      getFetcher: _n,
      deleteFetcher: H,
      dispose: ge,
      getBlocker: we,
      deleteBlocker: ht,
      patchRoutes: ln,
      _internalFetchControllers: L,
      _internalActiveDeferreds: G,
      _internalSetRoutes: Yt,
    }),
    R
  );
}
function oge(e) {
  return (
    e != null &&
    (("formData" in e && e.formData != null) ||
      ("body" in e && e.body !== void 0))
  );
}
function Yk(e, t, n, r, i, s, o, a) {
  let l, c;
  if (o) {
    l = [];
    for (let d of t)
      if ((l.push(d), d.route.id === o)) {
        c = d;
        break;
      }
  } else (l = t), (c = t[t.length - 1]);
  let u = ZS(i || ".", YS(l, s), Md(e.pathname, n) || e.pathname, a === "path");
  if (
    (i == null && ((u.search = e.search), (u.hash = e.hash)),
    (i == null || i === "" || i === ".") && c)
  ) {
    let d = LN(u.search);
    if (c.route.index && !d)
      u.search = u.search ? u.search.replace(/^\?/, "?index&") : "?index";
    else if (!c.route.index && d) {
      let f = new URLSearchParams(u.search),
        h = f.getAll("index");
      f.delete("index"),
        h.filter((g) => g).forEach((g) => f.append("index", g));
      let p = f.toString();
      u.search = p ? "?" + p : "";
    }
  }
  return (
    r &&
      n !== "/" &&
      (u.pathname = u.pathname === "/" ? n : Kf([n, u.pathname])),
    Um(u)
  );
}
function uF(e, t, n, r) {
  if (!r || !oge(r)) return { path: n };
  if (r.formMethod && !vge(r.formMethod))
    return { path: n, error: Ga(405, { method: r.formMethod }) };
  let i = () => ({ path: n, error: Ga(400, { type: "invalid-body" }) }),
    s = r.formMethod || "get",
    o = e ? s.toUpperCase() : s.toLowerCase(),
    a = VY(n);
  if (r.body !== void 0) {
    if (r.formEncType === "text/plain") {
      if (!uu(o)) return i();
      let f =
        typeof r.body == "string"
          ? r.body
          : r.body instanceof FormData || r.body instanceof URLSearchParams
          ? Array.from(r.body.entries()).reduce((h, p) => {
              let [g, b] = p;
              return (
                "" +
                h +
                g +
                "=" +
                b +
                `
`
              );
            }, "")
          : String(r.body);
      return {
        path: n,
        submission: {
          formMethod: o,
          formAction: a,
          formEncType: r.formEncType,
          formData: void 0,
          json: void 0,
          text: f,
        },
      };
    } else if (r.formEncType === "application/json") {
      if (!uu(o)) return i();
      try {
        let f = typeof r.body == "string" ? JSON.parse(r.body) : r.body;
        return {
          path: n,
          submission: {
            formMethod: o,
            formAction: a,
            formEncType: r.formEncType,
            formData: void 0,
            json: f,
            text: void 0,
          },
        };
      } catch {
        return i();
      }
    }
  }
  tr(
    typeof FormData == "function",
    "FormData is not available in this environment"
  );
  let l, c;
  if (r.formData) (l = Qk(r.formData)), (c = r.formData);
  else if (r.body instanceof FormData) (l = Qk(r.body)), (c = r.body);
  else if (r.body instanceof URLSearchParams) (l = r.body), (c = gF(l));
  else if (r.body == null) (l = new URLSearchParams()), (c = new FormData());
  else
    try {
      (l = new URLSearchParams(r.body)), (c = gF(l));
    } catch {
      return i();
    }
  let u = {
    formMethod: o,
    formAction: a,
    formEncType: (r && r.formEncType) || "application/x-www-form-urlencoded",
    formData: c,
    json: void 0,
    text: void 0,
  };
  if (uu(u.formMethod)) return { path: n, submission: u };
  let d = d0(n);
  return (
    t && d.search && LN(d.search) && l.append("index", ""),
    (d.search = "?" + l),
    { path: Um(d), submission: u }
  );
}
function dF(e, t, n) {
  n === void 0 && (n = !1);
  let r = e.findIndex((i) => i.route.id === t);
  return r >= 0 ? e.slice(0, n ? r + 1 : r) : e;
}
function fF(e, t, n, r, i, s, o, a, l, c, u, d, f, h, p, g) {
  let b = g ? (kl(g[1]) ? g[1].error : g[1].data) : void 0,
    v = e.createURL(t.location),
    w = e.createURL(i),
    x = n;
  s && t.errors
    ? (x = dF(n, Object.keys(t.errors)[0], !0))
    : g && kl(g[1]) && (x = dF(n, g[0]));
  let S = g ? g[1].statusCode : void 0,
    R = o && S && S >= 400,
    O = x.filter((C, I) => {
      let { route: P } = C;
      if (P.lazy) return !0;
      if (P.loader == null) return !1;
      if (s) return Zk(P, t.loaderData, t.errors);
      if (age(t.loaderData, t.matches[I], C) || l.some((T) => T === C.route.id))
        return !0;
      let M = t.matches[I],
        k = C;
      return hF(
        C,
        ts(
          {
            currentUrl: v,
            currentParams: M.params,
            nextUrl: w,
            nextParams: k.params,
          },
          r,
          {
            actionResult: b,
            actionStatus: S,
            defaultShouldRevalidate: R
              ? !1
              : a ||
                v.pathname + v.search === w.pathname + w.search ||
                v.search !== w.search ||
                WY(M, k),
          }
        )
      );
    }),
    B = [];
  return (
    d.forEach((C, I) => {
      if (s || !n.some((_) => _.route.id === C.routeId) || u.has(I)) return;
      let P = q0(h, C.path, p);
      if (!P) {
        B.push({
          key: I,
          routeId: C.routeId,
          path: C.path,
          matches: null,
          match: null,
          controller: null,
        });
        return;
      }
      let M = t.fetchers.get(I),
        k = q2(P, C.path),
        T = !1;
      f.has(I)
        ? (T = !1)
        : c.has(I)
        ? (c.delete(I), (T = !0))
        : M && M.state !== "idle" && M.data === void 0
        ? (T = a)
        : (T = hF(
            k,
            ts(
              {
                currentUrl: v,
                currentParams: t.matches[t.matches.length - 1].params,
                nextUrl: w,
                nextParams: n[n.length - 1].params,
              },
              r,
              {
                actionResult: b,
                actionStatus: S,
                defaultShouldRevalidate: R ? !1 : a,
              }
            )
          )),
        T &&
          B.push({
            key: I,
            routeId: C.routeId,
            path: C.path,
            matches: P,
            match: k,
            controller: new AbortController(),
          });
    }),
    [O, B]
  );
}
function Zk(e, t, n) {
  if (e.lazy) return !0;
  if (!e.loader) return !1;
  let r = t != null && t[e.id] !== void 0,
    i = n != null && n[e.id] !== void 0;
  return !r && i
    ? !1
    : typeof e.loader == "function" && e.loader.hydrate === !0
    ? !0
    : !r && !i;
}
function age(e, t, n) {
  let r = !t || n.route.id !== t.route.id,
    i = e[n.route.id] === void 0;
  return r || i;
}
function WY(e, t) {
  let n = e.route.path;
  return (
    e.pathname !== t.pathname ||
    (n != null && n.endsWith("*") && e.params["*"] !== t.params["*"])
  );
}
function hF(e, t) {
  if (e.route.shouldRevalidate) {
    let n = e.route.shouldRevalidate(t);
    if (typeof n == "boolean") return n;
  }
  return t.defaultShouldRevalidate;
}
function pF(e, t, n, r, i) {
  var s;
  let o;
  if (e) {
    let c = r[e];
    tr(c, "No route found to patch children into: routeId = " + e),
      c.children || (c.children = []),
      (o = c.children);
  } else o = n;
  let a = t.filter((c) => !o.some((u) => HY(c, u))),
    l = Y6(
      a,
      i,
      [e || "_", "patch", String(((s = o) == null ? void 0 : s.length) || "0")],
      r
    );
  o.push(...l);
}
function HY(e, t) {
  return "id" in e && "id" in t && e.id === t.id
    ? !0
    : e.index === t.index &&
      e.path === t.path &&
      e.caseSensitive === t.caseSensitive
    ? (!e.children || e.children.length === 0) &&
      (!t.children || t.children.length === 0)
      ? !0
      : e.children.every((n, r) => {
          var i;
          return (i = t.children) == null ? void 0 : i.some((s) => HY(n, s));
        })
    : !1;
}
async function lge(e, t, n) {
  if (!e.lazy) return;
  let r = await e.lazy();
  if (!e.lazy) return;
  let i = n[e.id];
  tr(i, "No route found in manifest");
  let s = {};
  for (let o in r) {
    let l = i[o] !== void 0 && o !== "hasErrorBoundary";
    wy(
      !l,
      'Route "' +
        i.id +
        '" has a static property "' +
        o +
        '" defined but its lazy function is also returning a value for this property. ' +
        ('The lazy route property "' + o + '" will be ignored.')
    ),
      !l && !O1e.has(o) && (s[o] = r[o]);
  }
  Object.assign(i, s), Object.assign(i, ts({}, t(i), { lazy: void 0 }));
}
async function cge(e) {
  let { matches: t } = e,
    n = t.filter((i) => i.shouldLoad);
  return (await Promise.all(n.map((i) => i.resolve()))).reduce(
    (i, s, o) => Object.assign(i, { [n[o].route.id]: s }),
    {}
  );
}
async function uge(e, t, n, r, i, s, o, a, l, c) {
  let u = s.map((h) => (h.route.lazy ? lge(h.route, l, a) : void 0)),
    d = s.map((h, p) => {
      let g = u[p],
        b = i.some((w) => w.route.id === h.route.id);
      return ts({}, h, {
        shouldLoad: b,
        resolve: async (w) => (
          w &&
            r.method === "GET" &&
            (h.route.lazy || h.route.loader) &&
            (b = !0),
          b
            ? dge(t, r, h, g, w, c)
            : Promise.resolve({ type: gi.data, result: void 0 })
        ),
      });
    }),
    f = await e({
      matches: d,
      request: r,
      params: s[0].params,
      fetcherKey: o,
      context: c,
    });
  try {
    await Promise.all(u);
  } catch {}
  return f;
}
async function dge(e, t, n, r, i, s) {
  let o,
    a,
    l = (c) => {
      let u,
        d = new Promise((p, g) => (u = g));
      (a = () => u()), t.signal.addEventListener("abort", a);
      let f = (p) =>
          typeof c != "function"
            ? Promise.reject(
                new Error(
                  "You cannot call the handler for a route which defines a boolean " +
                    ('"' + e + '" [routeId: ' + n.route.id + "]")
                )
              )
            : c(
                { request: t, params: n.params, context: s },
                ...(p !== void 0 ? [p] : [])
              ),
        h = (async () => {
          try {
            return { type: "data", result: await (i ? i((g) => f(g)) : f()) };
          } catch (p) {
            return { type: "error", result: p };
          }
        })();
      return Promise.race([h, d]);
    };
  try {
    let c = n.route[e];
    if (r)
      if (c) {
        let u,
          [d] = await Promise.all([
            l(c).catch((f) => {
              u = f;
            }),
            r,
          ]);
        if (u !== void 0) throw u;
        o = d;
      } else if ((await r, (c = n.route[e]), c)) o = await l(c);
      else if (e === "action") {
        let u = new URL(t.url),
          d = u.pathname + u.search;
        throw Ga(405, { method: t.method, pathname: d, routeId: n.route.id });
      } else return { type: gi.data, result: void 0 };
    else if (c) o = await l(c);
    else {
      let u = new URL(t.url),
        d = u.pathname + u.search;
      throw Ga(404, { pathname: d });
    }
    tr(
      o.result !== void 0,
      "You defined " +
        (e === "action" ? "an action" : "a loader") +
        " for route " +
        ('"' +
          n.route.id +
          "\" but didn't return anything from your `" +
          e +
          "` ") +
        "function. Please return a value or `null`."
    );
  } catch (c) {
    return { type: gi.error, result: c };
  } finally {
    a && t.signal.removeEventListener("abort", a);
  }
  return o;
}
async function fge(e) {
  let { result: t, type: n } = e;
  if (GY(t)) {
    let c;
    try {
      let u = t.headers.get("Content-Type");
      u && /\bapplication\/json\b/.test(u)
        ? t.body == null
          ? (c = null)
          : (c = await t.json())
        : (c = await t.text());
    } catch (u) {
      return { type: gi.error, error: u };
    }
    return n === gi.error
      ? {
          type: gi.error,
          error: new Q6(t.status, t.statusText, c),
          statusCode: t.status,
          headers: t.headers,
        }
      : { type: gi.data, data: c, statusCode: t.status, headers: t.headers };
  }
  if (n === gi.error) {
    if (xF(t)) {
      var r;
      if (t.data instanceof Error) {
        var i;
        return {
          type: gi.error,
          error: t.data,
          statusCode: (i = t.init) == null ? void 0 : i.status,
        };
      }
      t = new Q6(
        ((r = t.init) == null ? void 0 : r.status) || 500,
        void 0,
        t.data
      );
    }
    return { type: gi.error, error: t, statusCode: QS(t) ? t.status : void 0 };
  }
  if (yge(t)) {
    var s, o;
    return {
      type: gi.deferred,
      deferredData: t,
      statusCode: (s = t.init) == null ? void 0 : s.status,
      headers:
        ((o = t.init) == null ? void 0 : o.headers) &&
        new Headers(t.init.headers),
    };
  }
  if (xF(t)) {
    var a, l;
    return {
      type: gi.data,
      data: t.data,
      statusCode: (a = t.init) == null ? void 0 : a.status,
      headers:
        (l = t.init) != null && l.headers
          ? new Headers(t.init.headers)
          : void 0,
    };
  }
  return { type: gi.data, data: t };
}
function hge(e, t, n, r, i, s) {
  let o = e.headers.get("Location");
  if (
    (tr(
      o,
      "Redirects returned/thrown from loaders/actions must have a Location header"
    ),
    !ON.test(o))
  ) {
    let a = r.slice(0, r.findIndex((l) => l.route.id === n) + 1);
    (o = Yk(new URL(t.url), a, i, !0, o, s)), e.headers.set("Location", o);
  }
  return e;
}
function mF(e, t, n) {
  if (ON.test(e)) {
    let r = e,
      i = r.startsWith("//") ? new URL(t.protocol + r) : new URL(r),
      s = Md(i.pathname, n) != null;
    if (i.origin === t.origin && s) return i.pathname + i.search + i.hash;
  }
  return e;
}
function $1(e, t, n, r) {
  let i = e.createURL(VY(t)).toString(),
    s = { signal: n };
  if (r && uu(r.formMethod)) {
    let { formMethod: o, formEncType: a } = r;
    (s.method = o.toUpperCase()),
      a === "application/json"
        ? ((s.headers = new Headers({ "Content-Type": a })),
          (s.body = JSON.stringify(r.json)))
        : a === "text/plain"
        ? (s.body = r.text)
        : a === "application/x-www-form-urlencoded" && r.formData
        ? (s.body = Qk(r.formData))
        : (s.body = r.formData);
  }
  return new Request(i, s);
}
function Qk(e) {
  let t = new URLSearchParams();
  for (let [n, r] of e.entries())
    t.append(n, typeof r == "string" ? r : r.name);
  return t;
}
function gF(e) {
  let t = new FormData();
  for (let [n, r] of e.entries()) t.append(n, r);
  return t;
}
function pge(e, t, n, r, i) {
  let s = {},
    o = null,
    a,
    l = !1,
    c = {},
    u = n && kl(n[1]) ? n[1].error : void 0;
  return (
    e.forEach((d) => {
      if (!(d.route.id in t)) return;
      let f = d.route.id,
        h = t[f];
      if (
        (tr(!rm(h), "Cannot handle redirect results in processLoaderData"),
        kl(h))
      ) {
        let p = h.error;
        u !== void 0 && ((p = u), (u = void 0)), (o = o || {});
        {
          let g = K0(e, f);
          o[g.route.id] == null && (o[g.route.id] = p);
        }
        (s[f] = void 0),
          l || ((l = !0), (a = QS(h.error) ? h.error.status : 500)),
          h.headers && (c[f] = h.headers);
      } else
        bp(h)
          ? (r.set(f, h.deferredData),
            (s[f] = h.deferredData.data),
            h.statusCode != null &&
              h.statusCode !== 200 &&
              !l &&
              (a = h.statusCode),
            h.headers && (c[f] = h.headers))
          : ((s[f] = h.data),
            h.statusCode && h.statusCode !== 200 && !l && (a = h.statusCode),
            h.headers && (c[f] = h.headers));
    }),
    u !== void 0 && n && ((o = { [n[0]]: u }), (s[n[0]] = void 0)),
    { loaderData: s, errors: o, statusCode: a || 200, loaderHeaders: c }
  );
}
function yF(e, t, n, r, i, s, o) {
  let { loaderData: a, errors: l } = pge(t, n, r, o);
  return (
    i.forEach((c) => {
      let { key: u, match: d, controller: f } = c,
        h = s[u];
      if (
        (tr(h, "Did not find corresponding fetcher result"),
        !(f && f.signal.aborted))
      )
        if (kl(h)) {
          let p = K0(e.matches, d == null ? void 0 : d.route.id);
          (l && l[p.route.id]) || (l = ts({}, l, { [p.route.id]: h.error })),
            e.fetchers.delete(u);
        } else if (rm(h)) tr(!1, "Unhandled fetcher revalidation redirect");
        else if (bp(h)) tr(!1, "Unhandled fetcher deferred data");
        else {
          let p = rp(h.data);
          e.fetchers.set(u, p);
        }
    }),
    { loaderData: a, errors: l }
  );
}
function vF(e, t, n, r) {
  let i = ts({}, t);
  for (let s of n) {
    let o = s.route.id;
    if (
      (t.hasOwnProperty(o)
        ? t[o] !== void 0 && (i[o] = t[o])
        : e[o] !== void 0 && s.route.loader && (i[o] = e[o]),
      r && r.hasOwnProperty(o))
    )
      break;
  }
  return i;
}
function wF(e) {
  return e
    ? kl(e[1])
      ? { actionData: {} }
      : { actionData: { [e[0]]: e[1].data } }
    : {};
}
function K0(e, t) {
  return (
    (t ? e.slice(0, e.findIndex((r) => r.route.id === t) + 1) : [...e])
      .reverse()
      .find((r) => r.route.hasErrorBoundary === !0) || e[0]
  );
}
function bF(e) {
  let t =
    e.length === 1
      ? e[0]
      : e.find((n) => n.index || !n.path || n.path === "/") || {
          id: "__shim-error-route__",
        };
  return {
    matches: [{ params: {}, pathname: "", pathnameBase: "", route: t }],
    route: t,
  };
}
function Ga(e, t) {
  let {
      pathname: n,
      routeId: r,
      method: i,
      type: s,
      message: o,
    } = t === void 0 ? {} : t,
    a = "Unknown Server Error",
    l = "Unknown @remix-run/router error";
  return (
    e === 400
      ? ((a = "Bad Request"),
        i && n && r
          ? (l =
              "You made a " +
              i +
              ' request to "' +
              n +
              '" but ' +
              ('did not provide a `loader` for route "' + r + '", ') +
              "so there is no way to handle the request.")
          : s === "defer-action"
          ? (l = "defer() is not supported in actions")
          : s === "invalid-body" && (l = "Unable to encode submission body"))
      : e === 403
      ? ((a = "Forbidden"),
        (l = 'Route "' + r + '" does not match URL "' + n + '"'))
      : e === 404
      ? ((a = "Not Found"), (l = 'No route matches URL "' + n + '"'))
      : e === 405 &&
        ((a = "Method Not Allowed"),
        i && n && r
          ? (l =
              "You made a " +
              i.toUpperCase() +
              ' request to "' +
              n +
              '" but ' +
              ('did not provide an `action` for route "' + r + '", ') +
              "so there is no way to handle the request.")
          : i && (l = 'Invalid request method "' + i.toUpperCase() + '"')),
    new Q6(e || 500, a, new Error(l), !0)
  );
}
function v_(e) {
  let t = Object.entries(e);
  for (let n = t.length - 1; n >= 0; n--) {
    let [r, i] = t[n];
    if (rm(i)) return { key: r, result: i };
  }
}
function VY(e) {
  let t = typeof e == "string" ? d0(e) : e;
  return Um(ts({}, t, { hash: "" }));
}
function mge(e, t) {
  return e.pathname !== t.pathname || e.search !== t.search
    ? !1
    : e.hash === ""
    ? t.hash !== ""
    : e.hash === t.hash
    ? !0
    : t.hash !== "";
}
function gge(e) {
  return GY(e.result) && tge.has(e.result.status);
}
function bp(e) {
  return e.type === gi.deferred;
}
function kl(e) {
  return e.type === gi.error;
}
function rm(e) {
  return (e && e.type) === gi.redirect;
}
function xF(e) {
  return (
    typeof e == "object" &&
    e != null &&
    "type" in e &&
    "data" in e &&
    "init" in e &&
    e.type === "DataWithResponseInit"
  );
}
function yge(e) {
  let t = e;
  return (
    t &&
    typeof t == "object" &&
    typeof t.data == "object" &&
    typeof t.subscribe == "function" &&
    typeof t.cancel == "function" &&
    typeof t.resolveData == "function"
  );
}
function GY(e) {
  return (
    e != null &&
    typeof e.status == "number" &&
    typeof e.statusText == "string" &&
    typeof e.headers == "object" &&
    typeof e.body < "u"
  );
}
function vge(e) {
  return ege.has(e.toLowerCase());
}
function uu(e) {
  return X1e.has(e.toLowerCase());
}
async function wge(e, t, n, r, i) {
  let s = Object.entries(t);
  for (let o = 0; o < s.length; o++) {
    let [a, l] = s[o],
      c = e.find((f) => (f == null ? void 0 : f.route.id) === a);
    if (!c) continue;
    let u = r.find((f) => f.route.id === c.route.id),
      d = u != null && !WY(u, c) && (i && i[c.route.id]) !== void 0;
    bp(l) &&
      d &&
      (await PN(l, n, !1).then((f) => {
        f && (t[a] = f);
      }));
  }
}
async function bge(e, t, n) {
  for (let r = 0; r < n.length; r++) {
    let { key: i, routeId: s, controller: o } = n[r],
      a = t[i];
    e.find((c) => (c == null ? void 0 : c.route.id) === s) &&
      bp(a) &&
      (tr(
        o,
        "Expected an AbortController for revalidating fetcher deferred result"
      ),
      await PN(a, o.signal, !0).then((c) => {
        c && (t[i] = c);
      }));
  }
}
async function PN(e, t, n) {
  if ((n === void 0 && (n = !1), !(await e.deferredData.resolveData(t)))) {
    if (n)
      try {
        return { type: gi.data, data: e.deferredData.unwrappedData };
      } catch (i) {
        return { type: gi.error, error: i };
      }
    return { type: gi.data, data: e.deferredData.data };
  }
}
function LN(e) {
  return new URLSearchParams(e).getAll("index").some((t) => t === "");
}
function q2(e, t) {
  let n = typeof t == "string" ? d0(t).search : t.search;
  if (e[e.length - 1].route.index && LN(n || "")) return e[e.length - 1];
  let r = UY(e);
  return r[r.length - 1];
}
function _F(e) {
  let {
    formMethod: t,
    formAction: n,
    formEncType: r,
    text: i,
    formData: s,
    json: o,
  } = e;
  if (!(!t || !n || !r)) {
    if (i != null)
      return {
        formMethod: t,
        formAction: n,
        formEncType: r,
        formData: void 0,
        json: void 0,
        text: i,
      };
    if (s != null)
      return {
        formMethod: t,
        formAction: n,
        formEncType: r,
        formData: s,
        json: void 0,
        text: void 0,
      };
    if (o !== void 0)
      return {
        formMethod: t,
        formAction: n,
        formEncType: r,
        formData: void 0,
        json: o,
        text: void 0,
      };
  }
}
function MA(e, t) {
  return t
    ? {
        state: "loading",
        location: e,
        formMethod: t.formMethod,
        formAction: t.formAction,
        formEncType: t.formEncType,
        formData: t.formData,
        json: t.json,
        text: t.text,
      }
    : {
        state: "loading",
        location: e,
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        json: void 0,
        text: void 0,
      };
}
function xge(e, t) {
  return {
    state: "submitting",
    location: e,
    formMethod: t.formMethod,
    formAction: t.formAction,
    formEncType: t.formEncType,
    formData: t.formData,
    json: t.json,
    text: t.text,
  };
}
function v2(e, t) {
  return e
    ? {
        state: "loading",
        formMethod: e.formMethod,
        formAction: e.formAction,
        formEncType: e.formEncType,
        formData: e.formData,
        json: e.json,
        text: e.text,
        data: t,
      }
    : {
        state: "loading",
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        json: void 0,
        text: void 0,
        data: t,
      };
}
function _ge(e, t) {
  return {
    state: "submitting",
    formMethod: e.formMethod,
    formAction: e.formAction,
    formEncType: e.formEncType,
    formData: e.formData,
    json: e.json,
    text: e.text,
    data: t ? t.data : void 0,
  };
}
function rp(e) {
  return {
    state: "idle",
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0,
    data: e,
  };
}
function Sge(e, t) {
  try {
    let n = e.sessionStorage.getItem(zY);
    if (n) {
      let r = JSON.parse(n);
      for (let [i, s] of Object.entries(r || {}))
        s && Array.isArray(s) && t.set(i, new Set(s || []));
    }
  } catch {}
}
function Ege(e, t) {
  if (t.size > 0) {
    let n = {};
    for (let [r, i] of t) n[r] = [...i];
    try {
      e.sessionStorage.setItem(zY, JSON.stringify(n));
    } catch (r) {
      wy(
        !1,
        "Failed to save applied view transitions in sessionStorage (" + r + ")."
      );
    }
  }
}
/**
 * React Router v6.27.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function X6() {
  return (
    (X6 = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
          }
          return e;
        }),
    X6.apply(this, arguments)
  );
}
const dx = Y.createContext(null),
  XS = Y.createContext(null),
  Fd = Y.createContext(null),
  jN = Y.createContext(null),
  vh = Y.createContext({ outlet: null, matches: [], isDataRoute: !1 }),
  qY = Y.createContext(null);
function Age(e, t) {
  let { relative: n } = t === void 0 ? {} : t;
  sv() || tr(!1);
  let { basename: r, navigator: i } = Y.useContext(Fd),
    { hash: s, pathname: o, search: a } = JS(e, { relative: n }),
    l = o;
  return (
    r !== "/" && (l = o === "/" ? r : Kf([r, o])),
    i.createHref({ pathname: l, search: a, hash: s })
  );
}
function sv() {
  return Y.useContext(jN) != null;
}
function Ud() {
  return sv() || tr(!1), Y.useContext(jN).location;
}
function KY(e) {
  Y.useContext(Fd).static || Y.useLayoutEffect(e);
}
function DN() {
  let { isDataRoute: e } = Y.useContext(vh);
  return e ? Uge() : Cge();
}
function Cge() {
  sv() || tr(!1);
  let e = Y.useContext(dx),
    { basename: t, future: n, navigator: r } = Y.useContext(Fd),
    { matches: i } = Y.useContext(vh),
    { pathname: s } = Ud(),
    o = JSON.stringify(YS(i, n.v7_relativeSplatPath)),
    a = Y.useRef(!1);
  return (
    KY(() => {
      a.current = !0;
    }),
    Y.useCallback(
      function (c, u) {
        if ((u === void 0 && (u = {}), !a.current)) return;
        if (typeof c == "number") {
          r.go(c);
          return;
        }
        let d = ZS(c, JSON.parse(o), s, u.relative === "path");
        e == null &&
          t !== "/" &&
          (d.pathname = d.pathname === "/" ? t : Kf([t, d.pathname])),
          (u.replace ? r.replace : r.push)(d, u.state, u);
      },
      [t, r, o, s, e]
    )
  );
}
const kge = Y.createContext(null);
function Tge(e) {
  let t = Y.useContext(vh).outlet;
  return t && Y.createElement(kge.Provider, { value: e }, t);
}
function JS(e, t) {
  let { relative: n } = t === void 0 ? {} : t,
    { future: r } = Y.useContext(Fd),
    { matches: i } = Y.useContext(vh),
    { pathname: s } = Ud(),
    o = JSON.stringify(YS(i, r.v7_relativeSplatPath));
  return Y.useMemo(() => ZS(e, JSON.parse(o), s, n === "path"), [e, o, s, n]);
}
function Mge(e, t, n, r) {
  sv() || tr(!1);
  let { navigator: i } = Y.useContext(Fd),
    { matches: s } = Y.useContext(vh),
    o = s[s.length - 1],
    a = o ? o.params : {};
  o && o.pathname;
  let l = o ? o.pathnameBase : "/";
  o && o.route;
  let c = Ud(),
    u;
  u = c;
  let d = u.pathname || "/",
    f = d;
  if (l !== "/") {
    let g = l.replace(/^\//, "").split("/");
    f = "/" + d.replace(/^\//, "").split("/").slice(g.length).join("/");
  }
  let h = q0(e, { pathname: f });
  return Pge(
    h &&
      h.map((g) =>
        Object.assign({}, g, {
          params: Object.assign({}, a, g.params),
          pathname: Kf([
            l,
            i.encodeLocation
              ? i.encodeLocation(g.pathname).pathname
              : g.pathname,
          ]),
          pathnameBase:
            g.pathnameBase === "/"
              ? l
              : Kf([
                  l,
                  i.encodeLocation
                    ? i.encodeLocation(g.pathnameBase).pathname
                    : g.pathnameBase,
                ]),
        })
      ),
    s,
    n,
    r
  );
}
function Ige() {
  let e = Fge(),
    t = QS(e)
      ? e.status + " " + e.statusText
      : e instanceof Error
      ? e.message
      : JSON.stringify(e),
    n = e instanceof Error ? e.stack : null,
    i = { padding: "0.5rem", backgroundColor: "rgba(200,200,200, 0.5)" };
  return Y.createElement(
    Y.Fragment,
    null,
    Y.createElement("h2", null, "Unexpected Application Error!"),
    Y.createElement("h3", { style: { fontStyle: "italic" } }, t),
    n ? Y.createElement("pre", { style: i }, n) : null,
    null
  );
}
const Nge = Y.createElement(Ige, null);
class Rge extends Y.Component {
  constructor(t) {
    super(t),
      (this.state = {
        location: t.location,
        revalidation: t.revalidation,
        error: t.error,
      });
  }
  static getDerivedStateFromError(t) {
    return { error: t };
  }
  static getDerivedStateFromProps(t, n) {
    return n.location !== t.location ||
      (n.revalidation !== "idle" && t.revalidation === "idle")
      ? { error: t.error, location: t.location, revalidation: t.revalidation }
      : {
          error: t.error !== void 0 ? t.error : n.error,
          location: n.location,
          revalidation: t.revalidation || n.revalidation,
        };
  }
  componentDidCatch(t, n) {
    console.error(
      "React Router caught the following error during render",
      t,
      n
    );
  }
  render() {
    return this.state.error !== void 0
      ? Y.createElement(
          vh.Provider,
          { value: this.props.routeContext },
          Y.createElement(qY.Provider, {
            value: this.state.error,
            children: this.props.component,
          })
        )
      : this.props.children;
  }
}
function Oge(e) {
  let { routeContext: t, match: n, children: r } = e,
    i = Y.useContext(dx);
  return (
    i &&
      i.static &&
      i.staticContext &&
      (n.route.errorElement || n.route.ErrorBoundary) &&
      (i.staticContext._deepestRenderedBoundaryId = n.route.id),
    Y.createElement(vh.Provider, { value: t }, r)
  );
}
function Pge(e, t, n, r) {
  var i;
  if (
    (t === void 0 && (t = []),
    n === void 0 && (n = null),
    r === void 0 && (r = null),
    e == null)
  ) {
    var s;
    if (!n) return null;
    if (n.errors) e = n.matches;
    else if (
      (s = r) != null &&
      s.v7_partialHydration &&
      t.length === 0 &&
      !n.initialized &&
      n.matches.length > 0
    )
      e = n.matches;
    else return null;
  }
  let o = e,
    a = (i = n) == null ? void 0 : i.errors;
  if (a != null) {
    let u = o.findIndex(
      (d) => d.route.id && (a == null ? void 0 : a[d.route.id]) !== void 0
    );
    u >= 0 || tr(!1), (o = o.slice(0, Math.min(o.length, u + 1)));
  }
  let l = !1,
    c = -1;
  if (n && r && r.v7_partialHydration)
    for (let u = 0; u < o.length; u++) {
      let d = o[u];
      if (
        ((d.route.HydrateFallback || d.route.hydrateFallbackElement) && (c = u),
        d.route.id)
      ) {
        let { loaderData: f, errors: h } = n,
          p =
            d.route.loader &&
            f[d.route.id] === void 0 &&
            (!h || h[d.route.id] === void 0);
        if (d.route.lazy || p) {
          (l = !0), c >= 0 ? (o = o.slice(0, c + 1)) : (o = [o[0]]);
          break;
        }
      }
    }
  return o.reduceRight((u, d, f) => {
    let h,
      p = !1,
      g = null,
      b = null;
    n &&
      ((h = a && d.route.id ? a[d.route.id] : void 0),
      (g = d.route.errorElement || Nge),
      l &&
        (c < 0 && f === 0
          ? ((p = !0), (b = null))
          : c === f &&
            ((p = !0), (b = d.route.hydrateFallbackElement || null))));
    let v = t.concat(o.slice(0, f + 1)),
      w = () => {
        let x;
        return (
          h
            ? (x = g)
            : p
            ? (x = b)
            : d.route.Component
            ? (x = Y.createElement(d.route.Component, null))
            : d.route.element
            ? (x = d.route.element)
            : (x = u),
          Y.createElement(Oge, {
            match: d,
            routeContext: { outlet: u, matches: v, isDataRoute: n != null },
            children: x,
          })
        );
      };
    return n && (d.route.ErrorBoundary || d.route.errorElement || f === 0)
      ? Y.createElement(Rge, {
          location: n.location,
          revalidation: n.revalidation,
          component: g,
          error: h,
          children: w(),
          routeContext: { outlet: null, matches: v, isDataRoute: !0 },
        })
      : w();
  }, null);
}
var YY = (function (e) {
    return (
      (e.UseBlocker = "useBlocker"),
      (e.UseRevalidator = "useRevalidator"),
      (e.UseNavigateStable = "useNavigate"),
      e
    );
  })(YY || {}),
  by = (function (e) {
    return (
      (e.UseBlocker = "useBlocker"),
      (e.UseLoaderData = "useLoaderData"),
      (e.UseActionData = "useActionData"),
      (e.UseRouteError = "useRouteError"),
      (e.UseNavigation = "useNavigation"),
      (e.UseRouteLoaderData = "useRouteLoaderData"),
      (e.UseMatches = "useMatches"),
      (e.UseRevalidator = "useRevalidator"),
      (e.UseNavigateStable = "useNavigate"),
      (e.UseRouteId = "useRouteId"),
      e
    );
  })(by || {});
function Lge(e) {
  let t = Y.useContext(dx);
  return t || tr(!1), t;
}
function BN(e) {
  let t = Y.useContext(XS);
  return t || tr(!1), t;
}
function jge(e) {
  let t = Y.useContext(vh);
  return t || tr(!1), t;
}
function ZY(e) {
  let t = jge(),
    n = t.matches[t.matches.length - 1];
  return n.route.id || tr(!1), n.route.id;
}
function Dge() {
  return BN(by.UseNavigation).navigation;
}
function Bge() {
  let { matches: e, loaderData: t } = BN(by.UseMatches);
  return Y.useMemo(() => e.map((n) => DY(n, t)), [e, t]);
}
function Fge() {
  var e;
  let t = Y.useContext(qY),
    n = BN(by.UseRouteError),
    r = ZY(by.UseRouteError);
  return t !== void 0 ? t : (e = n.errors) == null ? void 0 : e[r];
}
function Uge() {
  let { router: e } = Lge(YY.UseNavigateStable),
    t = ZY(by.UseNavigateStable),
    n = Y.useRef(!1);
  return (
    KY(() => {
      n.current = !0;
    }),
    Y.useCallback(
      function (i, s) {
        s === void 0 && (s = {}),
          n.current &&
            (typeof i == "number"
              ? e.navigate(i)
              : e.navigate(i, X6({ fromRouteId: t }, s)));
      },
      [e, t]
    )
  );
}
function SF(e) {
  let { to: t, replace: n, state: r, relative: i } = e;
  sv() || tr(!1);
  let { future: s, static: o } = Y.useContext(Fd),
    { matches: a } = Y.useContext(vh),
    { pathname: l } = Ud(),
    c = DN(),
    u = ZS(t, YS(a, s.v7_relativeSplatPath), l, i === "path"),
    d = JSON.stringify(u);
  return (
    Y.useEffect(
      () => c(JSON.parse(d), { replace: n, state: r, relative: i }),
      [c, d, i, n, r]
    ),
    null
  );
}
function QY(e) {
  return Tge(e.context);
}
function $ge(e) {
  let {
    basename: t = "/",
    children: n = null,
    location: r,
    navigationType: i = js.Pop,
    navigator: s,
    static: o = !1,
    future: a,
  } = e;
  sv() && tr(!1);
  let l = t.replace(/^\/*/, "/"),
    c = Y.useMemo(
      () => ({
        basename: l,
        navigator: s,
        static: o,
        future: X6({ v7_relativeSplatPath: !1 }, a),
      }),
      [l, a, s, o]
    );
  typeof r == "string" && (r = d0(r));
  let {
      pathname: u = "/",
      search: d = "",
      hash: f = "",
      state: h = null,
      key: p = "default",
    } = r,
    g = Y.useMemo(() => {
      let b = Md(u, l);
      return b == null
        ? null
        : {
            location: { pathname: b, search: d, hash: f, state: h, key: p },
            navigationType: i,
          };
    }, [l, u, d, f, h, p, i]);
  return g == null
    ? null
    : Y.createElement(
        Fd.Provider,
        { value: c },
        Y.createElement(jN.Provider, { children: n, value: g })
      );
}
new Promise(() => {});
function zge(e) {
  let t = {
    hasErrorBoundary: e.ErrorBoundary != null || e.errorElement != null,
  };
  return (
    e.Component &&
      Object.assign(t, {
        element: Y.createElement(e.Component),
        Component: void 0,
      }),
    e.HydrateFallback &&
      Object.assign(t, {
        hydrateFallbackElement: Y.createElement(e.HydrateFallback),
        HydrateFallback: void 0,
      }),
    e.ErrorBoundary &&
      Object.assign(t, {
        errorElement: Y.createElement(e.ErrorBoundary),
        ErrorBoundary: void 0,
      }),
    t
  );
}
/**
 * React Router DOM v6.27.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function $m() {
  return (
    ($m = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
          }
          return e;
        }),
    $m.apply(this, arguments)
  );
}
function XY(e, t) {
  if (e == null) return {};
  var n = {},
    r = Object.keys(e),
    i,
    s;
  for (s = 0; s < r.length; s++)
    (i = r[s]), !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function Wge(e) {
  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);
}
function Hge(e, t) {
  return e.button === 0 && (!t || t === "_self") && !Wge(e);
}
const Vge = [
    "onClick",
    "relative",
    "reloadDocument",
    "replace",
    "state",
    "target",
    "to",
    "preventScrollReset",
    "viewTransition",
  ],
  Gge = [
    "aria-current",
    "caseSensitive",
    "className",
    "end",
    "style",
    "to",
    "viewTransition",
    "children",
  ],
  qge = "6";
try {
  window.__reactRouterVersion = qge;
} catch {}
function Kge(e, t) {
  return sge({
    basename: void 0,
    future: $m({}, void 0, { v7_prependBasename: !0 }),
    history: I1e({ window: void 0 }),
    hydrationData: Yge(),
    routes: e,
    mapRouteProperties: zge,
    dataStrategy: void 0,
    patchRoutesOnNavigation: void 0,
    window: void 0,
  }).initialize();
}
function Yge() {
  var e;
  let t = (e = window) == null ? void 0 : e.__staticRouterHydrationData;
  return t && t.errors && (t = $m({}, t, { errors: Zge(t.errors) })), t;
}
function Zge(e) {
  if (!e) return null;
  let t = Object.entries(e),
    n = {};
  for (let [r, i] of t)
    if (i && i.__type === "RouteErrorResponse")
      n[r] = new Q6(i.status, i.statusText, i.data, i.internal === !0);
    else if (i && i.__type === "Error") {
      if (i.__subType) {
        let s = window[i.__subType];
        if (typeof s == "function")
          try {
            let o = new s(i.message);
            (o.stack = ""), (n[r] = o);
          } catch {}
      }
      if (n[r] == null) {
        let s = new Error(i.message);
        (s.stack = ""), (n[r] = s);
      }
    } else n[r] = i;
  return n;
}
const JY = Y.createContext({ isTransitioning: !1 }),
  Qge = Y.createContext(new Map()),
  Xge = "startTransition",
  EF = tk[Xge],
  Jge = "flushSync",
  AF = l1e[Jge];
function eye(e) {
  EF ? EF(e) : e();
}
function w2(e) {
  AF ? AF(e) : e();
}
class tye {
  constructor() {
    (this.status = "pending"),
      (this.promise = new Promise((t, n) => {
        (this.resolve = (r) => {
          this.status === "pending" && ((this.status = "resolved"), t(r));
        }),
          (this.reject = (r) => {
            this.status === "pending" && ((this.status = "rejected"), n(r));
          });
      }));
  }
}
function nye(e) {
  let { fallbackElement: t, router: n, future: r } = e,
    [i, s] = Y.useState(n.state),
    [o, a] = Y.useState(),
    [l, c] = Y.useState({ isTransitioning: !1 }),
    [u, d] = Y.useState(),
    [f, h] = Y.useState(),
    [p, g] = Y.useState(),
    b = Y.useRef(new Map()),
    { v7_startTransition: v } = r || {},
    w = Y.useCallback(
      (C) => {
        v ? eye(C) : C();
      },
      [v]
    ),
    x = Y.useCallback(
      (C, I) => {
        let { deletedFetchers: P, flushSync: M, viewTransitionOpts: k } = I;
        P.forEach((_) => b.current.delete(_)),
          C.fetchers.forEach((_, A) => {
            _.data !== void 0 && b.current.set(A, _.data);
          });
        let T =
          n.window == null ||
          n.window.document == null ||
          typeof n.window.document.startViewTransition != "function";
        if (!k || T) {
          M ? w2(() => s(C)) : w(() => s(C));
          return;
        }
        if (M) {
          w2(() => {
            f && (u && u.resolve(), f.skipTransition()),
              c({
                isTransitioning: !0,
                flushSync: !0,
                currentLocation: k.currentLocation,
                nextLocation: k.nextLocation,
              });
          });
          let _ = n.window.document.startViewTransition(() => {
            w2(() => s(C));
          });
          _.finished.finally(() => {
            w2(() => {
              d(void 0), h(void 0), a(void 0), c({ isTransitioning: !1 });
            });
          }),
            w2(() => h(_));
          return;
        }
        f
          ? (u && u.resolve(),
            f.skipTransition(),
            g({
              state: C,
              currentLocation: k.currentLocation,
              nextLocation: k.nextLocation,
            }))
          : (a(C),
            c({
              isTransitioning: !0,
              flushSync: !1,
              currentLocation: k.currentLocation,
              nextLocation: k.nextLocation,
            }));
      },
      [n.window, f, u, b, w]
    );
  Y.useLayoutEffect(() => n.subscribe(x), [n, x]),
    Y.useEffect(() => {
      l.isTransitioning && !l.flushSync && d(new tye());
    }, [l]),
    Y.useEffect(() => {
      if (u && o && n.window) {
        let C = o,
          I = u.promise,
          P = n.window.document.startViewTransition(async () => {
            w(() => s(C)), await I;
          });
        P.finished.finally(() => {
          d(void 0), h(void 0), a(void 0), c({ isTransitioning: !1 });
        }),
          h(P);
      }
    }, [w, o, u, n.window]),
    Y.useEffect(() => {
      u && o && i.location.key === o.location.key && u.resolve();
    }, [u, f, i.location, o]),
    Y.useEffect(() => {
      !l.isTransitioning &&
        p &&
        (a(p.state),
        c({
          isTransitioning: !0,
          flushSync: !1,
          currentLocation: p.currentLocation,
          nextLocation: p.nextLocation,
        }),
        g(void 0));
    }, [l.isTransitioning, p]),
    Y.useEffect(() => {}, []);
  let S = Y.useMemo(
      () => ({
        createHref: n.createHref,
        encodeLocation: n.encodeLocation,
        go: (C) => n.navigate(C),
        push: (C, I, P) =>
          n.navigate(C, {
            state: I,
            preventScrollReset: P == null ? void 0 : P.preventScrollReset,
          }),
        replace: (C, I, P) =>
          n.navigate(C, {
            replace: !0,
            state: I,
            preventScrollReset: P == null ? void 0 : P.preventScrollReset,
          }),
      }),
      [n]
    ),
    R = n.basename || "/",
    O = Y.useMemo(
      () => ({ router: n, navigator: S, static: !1, basename: R }),
      [n, S, R]
    ),
    B = Y.useMemo(
      () => ({ v7_relativeSplatPath: n.future.v7_relativeSplatPath }),
      [n.future.v7_relativeSplatPath]
    );
  return Y.createElement(
    Y.Fragment,
    null,
    Y.createElement(
      dx.Provider,
      { value: O },
      Y.createElement(
        XS.Provider,
        { value: i },
        Y.createElement(
          Qge.Provider,
          { value: b.current },
          Y.createElement(
            JY.Provider,
            { value: l },
            Y.createElement(
              $ge,
              {
                basename: R,
                location: i.location,
                navigationType: i.historyAction,
                navigator: S,
                future: B,
              },
              i.initialized || n.future.v7_partialHydration
                ? Y.createElement(rye, {
                    routes: n.routes,
                    future: n.future,
                    state: i,
                  })
                : t
            )
          )
        )
      )
    ),
    null
  );
}
const rye = Y.memo(iye);
function iye(e) {
  let { routes: t, future: n, state: r } = e;
  return Mge(t, void 0, r, n);
}
const sye =
    typeof window < "u" &&
    typeof window.document < "u" &&
    typeof window.document.createElement < "u",
  oye = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
  Nc = Y.forwardRef(function (t, n) {
    let {
        onClick: r,
        relative: i,
        reloadDocument: s,
        replace: o,
        state: a,
        target: l,
        to: c,
        preventScrollReset: u,
        viewTransition: d,
      } = t,
      f = XY(t, Vge),
      { basename: h } = Y.useContext(Fd),
      p,
      g = !1;
    if (typeof c == "string" && oye.test(c) && ((p = c), sye))
      try {
        let x = new URL(window.location.href),
          S = c.startsWith("//") ? new URL(x.protocol + c) : new URL(c),
          R = Md(S.pathname, h);
        S.origin === x.origin && R != null
          ? (c = R + S.search + S.hash)
          : (g = !0);
      } catch {}
    let b = Age(c, { relative: i }),
      v = cye(c, {
        replace: o,
        state: a,
        target: l,
        preventScrollReset: u,
        relative: i,
        viewTransition: d,
      });
    function w(x) {
      r && r(x), x.defaultPrevented || v(x);
    }
    return Y.createElement(
      "a",
      $m({}, f, { href: p || b, onClick: g || s ? r : w, ref: n, target: l })
    );
  }),
  IA = Y.forwardRef(function (t, n) {
    let {
        "aria-current": r = "page",
        caseSensitive: i = !1,
        className: s = "",
        end: o = !1,
        style: a,
        to: l,
        viewTransition: c,
        children: u,
      } = t,
      d = XY(t, Gge),
      f = JS(l, { relative: d.relative }),
      h = Ud(),
      p = Y.useContext(XS),
      { navigator: g, basename: b } = Y.useContext(Fd),
      v = p != null && fye(f) && c === !0,
      w = g.encodeLocation ? g.encodeLocation(f).pathname : f.pathname,
      x = h.pathname,
      S =
        p && p.navigation && p.navigation.location
          ? p.navigation.location.pathname
          : null;
    i ||
      ((x = x.toLowerCase()),
      (S = S ? S.toLowerCase() : null),
      (w = w.toLowerCase())),
      S && b && (S = Md(S, b) || S);
    const R = w !== "/" && w.endsWith("/") ? w.length - 1 : w.length;
    let O = x === w || (!o && x.startsWith(w) && x.charAt(R) === "/"),
      B =
        S != null &&
        (S === w || (!o && S.startsWith(w) && S.charAt(w.length) === "/")),
      C = { isActive: O, isPending: B, isTransitioning: v },
      I = O ? r : void 0,
      P;
    typeof s == "function"
      ? (P = s(C))
      : (P = [
          s,
          O ? "active" : null,
          B ? "pending" : null,
          v ? "transitioning" : null,
        ]
          .filter(Boolean)
          .join(" "));
    let M = typeof a == "function" ? a(C) : a;
    return Y.createElement(
      Nc,
      $m({}, d, {
        "aria-current": I,
        className: P,
        ref: n,
        style: M,
        to: l,
        viewTransition: c,
      }),
      typeof u == "function" ? u(C) : u
    );
  });
function aye(e) {
  let { getKey: t, storageKey: n } = e;
  return uye({ getKey: t, storageKey: n }), null;
}
var J6;
(function (e) {
  (e.UseScrollRestoration = "useScrollRestoration"),
    (e.UseSubmit = "useSubmit"),
    (e.UseSubmitFetcher = "useSubmitFetcher"),
    (e.UseFetcher = "useFetcher"),
    (e.useViewTransitionState = "useViewTransitionState");
})(J6 || (J6 = {}));
var Xk;
(function (e) {
  (e.UseFetcher = "useFetcher"),
    (e.UseFetchers = "useFetchers"),
    (e.UseScrollRestoration = "useScrollRestoration");
})(Xk || (Xk = {}));
function eZ(e) {
  let t = Y.useContext(dx);
  return t || tr(!1), t;
}
function lye(e) {
  let t = Y.useContext(XS);
  return t || tr(!1), t;
}
function cye(e, t) {
  let {
      target: n,
      replace: r,
      state: i,
      preventScrollReset: s,
      relative: o,
      viewTransition: a,
    } = t === void 0 ? {} : t,
    l = DN(),
    c = Ud(),
    u = JS(e, { relative: o });
  return Y.useCallback(
    (d) => {
      if (Hge(d, n)) {
        d.preventDefault();
        let f = r !== void 0 ? r : Um(c) === Um(u);
        l(e, {
          replace: f,
          state: i,
          preventScrollReset: s,
          relative: o,
          viewTransition: a,
        });
      }
    },
    [c, l, u, r, i, n, e, s, o, a]
  );
}
const CF = "react-router-scroll-positions";
let w_ = {};
function uye(e) {
  let { getKey: t, storageKey: n } = e === void 0 ? {} : e,
    { router: r } = eZ(J6.UseScrollRestoration),
    { restoreScrollPosition: i, preventScrollReset: s } = lye(
      Xk.UseScrollRestoration
    ),
    { basename: o } = Y.useContext(Fd),
    a = Ud(),
    l = Bge(),
    c = Dge();
  Y.useEffect(
    () => (
      (window.history.scrollRestoration = "manual"),
      () => {
        window.history.scrollRestoration = "auto";
      }
    ),
    []
  ),
    dye(
      Y.useCallback(() => {
        if (c.state === "idle") {
          let u = (t ? t(a, l) : null) || a.key;
          w_[u] = window.scrollY;
        }
        try {
          sessionStorage.setItem(n || CF, JSON.stringify(w_));
        } catch {}
        window.history.scrollRestoration = "auto";
      }, [n, t, c.state, a, l])
    ),
    typeof document < "u" &&
      (Y.useLayoutEffect(() => {
        try {
          let u = sessionStorage.getItem(n || CF);
          u && (w_ = JSON.parse(u));
        } catch {}
      }, [n]),
      Y.useLayoutEffect(() => {
        let u =
            t && o !== "/"
              ? (f, h) =>
                  t($m({}, f, { pathname: Md(f.pathname, o) || f.pathname }), h)
              : t,
          d =
            r == null
              ? void 0
              : r.enableScrollRestoration(w_, () => window.scrollY, u);
        return () => d && d();
      }, [r, o, t]),
      Y.useLayoutEffect(() => {
        if (i !== !1) {
          if (typeof i == "number") {
            window.scrollTo(0, i);
            return;
          }
          if (a.hash) {
            let u = document.getElementById(
              decodeURIComponent(a.hash.slice(1))
            );
            if (u) {
              u.scrollIntoView();
              return;
            }
          }
          s !== !0 && window.scrollTo(0, 0);
        }
      }, [a, i, s]));
}
function dye(e, t) {
  let { capture: n } = {};
  Y.useEffect(() => {
    let r = n != null ? { capture: n } : void 0;
    return (
      window.addEventListener("pagehide", e, r),
      () => {
        window.removeEventListener("pagehide", e, r);
      }
    );
  }, [e, n]);
}
function fye(e, t) {
  t === void 0 && (t = {});
  let n = Y.useContext(JY);
  n == null && tr(!1);
  let { basename: r } = eZ(J6.useViewTransitionState),
    i = JS(e, { relative: t.relative });
  if (!n.isTransitioning) return !1;
  let s = Md(n.currentLocation.pathname, r) || n.currentLocation.pathname,
    o = Md(n.nextLocation.pathname, r) || n.nextLocation.pathname;
  return Z6(i.pathname, o) != null || Z6(i.pathname, s) != null;
}
function tZ(e) {
  var t,
    n,
    r = "";
  if (typeof e == "string" || typeof e == "number") r += e;
  else if (typeof e == "object")
    if (Array.isArray(e)) {
      var i = e.length;
      for (t = 0; t < i; t++)
        e[t] && (n = tZ(e[t])) && (r && (r += " "), (r += n));
    } else for (n in e) e[n] && (r && (r += " "), (r += n));
  return r;
}
function xp() {
  for (var e, t, n = 0, r = "", i = arguments.length; n < i; n++)
    (e = arguments[n]) && (t = tZ(e)) && (r && (r += " "), (r += t));
  return r;
}
const tb = (e) => typeof e == "number" && !isNaN(e),
  Em = (e) => typeof e == "string",
  Ll = (e) => typeof e == "function",
  S4 = (e) => (Em(e) || Ll(e) ? e : null),
  Jk = (e) => Y.isValidElement(e) || Em(e) || Ll(e) || tb(e);
function hye(e, t, n) {
  n === void 0 && (n = 300);
  const { scrollHeight: r, style: i } = e;
  requestAnimationFrame(() => {
    (i.minHeight = "initial"),
      (i.height = r + "px"),
      (i.transition = `all ${n}ms`),
      requestAnimationFrame(() => {
        (i.height = "0"), (i.padding = "0"), (i.margin = "0"), setTimeout(t, n);
      });
  });
}
function e8(e) {
  let {
    enter: t,
    exit: n,
    appendPosition: r = !1,
    collapse: i = !0,
    collapseDuration: s = 300,
  } = e;
  return function (o) {
    let {
      children: a,
      position: l,
      preventExitTransition: c,
      done: u,
      nodeRef: d,
      isIn: f,
      playToast: h,
    } = o;
    const p = r ? `${t}--${l}` : t,
      g = r ? `${n}--${l}` : n,
      b = Y.useRef(0);
    return (
      Y.useLayoutEffect(() => {
        const v = d.current,
          w = p.split(" "),
          x = (S) => {
            S.target === d.current &&
              (h(),
              v.removeEventListener("animationend", x),
              v.removeEventListener("animationcancel", x),
              b.current === 0 &&
                S.type !== "animationcancel" &&
                v.classList.remove(...w));
          };
        v.classList.add(...w),
          v.addEventListener("animationend", x),
          v.addEventListener("animationcancel", x);
      }, []),
      Y.useEffect(() => {
        const v = d.current,
          w = () => {
            v.removeEventListener("animationend", w), i ? hye(v, u, s) : u();
          };
        f ||
          (c
            ? w()
            : ((b.current = 1),
              (v.className += ` ${g}`),
              v.addEventListener("animationend", w)));
      }, [f]),
      Ce.createElement(Ce.Fragment, null, a)
    );
  };
}
function kF(e, t) {
  return e != null
    ? {
        content: e.content,
        containerId: e.props.containerId,
        id: e.props.toastId,
        theme: e.props.theme,
        type: e.props.type,
        data: e.props.data || {},
        isLoading: e.props.isLoading,
        icon: e.props.icon,
        status: t,
      }
    : {};
}
const xa = new Map();
let nb = [];
const eT = new Set(),
  pye = (e) => eT.forEach((t) => t(e)),
  nZ = () => xa.size > 0;
function rZ(e, t) {
  var n;
  if (t) return !((n = xa.get(t)) == null || !n.isToastActive(e));
  let r = !1;
  return (
    xa.forEach((i) => {
      i.isToastActive(e) && (r = !0);
    }),
    r
  );
}
function iZ(e, t) {
  Jk(e) &&
    (nZ() || nb.push({ content: e, options: t }),
    xa.forEach((n) => {
      n.buildToast(e, t);
    }));
}
function TF(e, t) {
  xa.forEach((n) => {
    t != null && t != null && t.containerId
      ? (t == null ? void 0 : t.containerId) === n.id &&
        n.toggle(e, t == null ? void 0 : t.id)
      : n.toggle(e, t == null ? void 0 : t.id);
  });
}
function mye(e) {
  const {
    subscribe: t,
    getSnapshot: n,
    setProps: r,
  } = Y.useRef(
    (function (s) {
      const o = s.containerId || 1;
      return {
        subscribe(a) {
          const l = (function (u, d, f) {
            let h = 1,
              p = 0,
              g = [],
              b = [],
              v = [],
              w = d;
            const x = new Map(),
              S = new Set(),
              R = () => {
                (v = Array.from(x.values())), S.forEach((C) => C());
              },
              O = (C) => {
                (b = C == null ? [] : b.filter((I) => I !== C)), R();
              },
              B = (C) => {
                const {
                    toastId: I,
                    onOpen: P,
                    updateId: M,
                    children: k,
                  } = C.props,
                  T = M == null;
                C.staleId && x.delete(C.staleId),
                  x.set(I, C),
                  (b = [...b, C.props.toastId].filter((_) => _ !== C.staleId)),
                  R(),
                  f(kF(C, T ? "added" : "updated")),
                  T && Ll(P) && P(Y.isValidElement(k) && k.props);
              };
            return {
              id: u,
              props: w,
              observe: (C) => (S.add(C), () => S.delete(C)),
              toggle: (C, I) => {
                x.forEach((P) => {
                  (I != null && I !== P.props.toastId) ||
                    (Ll(P.toggle) && P.toggle(C));
                });
              },
              removeToast: O,
              toasts: x,
              clearQueue: () => {
                (p -= g.length), (g = []);
              },
              buildToast: (C, I) => {
                if (
                  (($) => {
                    let { containerId: K, toastId: re, updateId: G } = $;
                    const ne = K ? K !== u : u !== 1,
                      ae = x.has(re) && G == null;
                    return ne || ae;
                  })(I)
                )
                  return;
                const {
                    toastId: P,
                    updateId: M,
                    data: k,
                    staleId: T,
                    delay: _,
                  } = I,
                  A = () => {
                    O(P);
                  },
                  N = M == null;
                N && p++;
                const L = {
                  ...w,
                  style: w.toastStyle,
                  key: h++,
                  ...Object.fromEntries(
                    Object.entries(I).filter(($) => {
                      let [K, re] = $;
                      return re != null;
                    })
                  ),
                  toastId: P,
                  updateId: M,
                  data: k,
                  closeToast: A,
                  isIn: !1,
                  className: S4(I.className || w.toastClassName),
                  bodyClassName: S4(I.bodyClassName || w.bodyClassName),
                  progressClassName: S4(
                    I.progressClassName || w.progressClassName
                  ),
                  autoClose:
                    !I.isLoading &&
                    ((F = I.autoClose),
                    (D = w.autoClose),
                    F === !1 || (tb(F) && F > 0) ? F : D),
                  deleteToast() {
                    const $ = x.get(P),
                      { onClose: K, children: re } = $.props;
                    Ll(K) && K(Y.isValidElement(re) && re.props),
                      f(kF($, "removed")),
                      x.delete(P),
                      p--,
                      p < 0 && (p = 0),
                      g.length > 0 ? B(g.shift()) : R();
                  },
                };
                var F, D;
                (L.closeButton = w.closeButton),
                  I.closeButton === !1 || Jk(I.closeButton)
                    ? (L.closeButton = I.closeButton)
                    : I.closeButton === !0 &&
                      (L.closeButton = !Jk(w.closeButton) || w.closeButton);
                let j = C;
                Y.isValidElement(C) && !Em(C.type)
                  ? (j = Y.cloneElement(C, {
                      closeToast: A,
                      toastProps: L,
                      data: k,
                    }))
                  : Ll(C) && (j = C({ closeToast: A, toastProps: L, data: k }));
                const z = { content: j, props: L, staleId: T };
                w.limit && w.limit > 0 && p > w.limit && N
                  ? g.push(z)
                  : tb(_)
                  ? setTimeout(() => {
                      B(z);
                    }, _)
                  : B(z);
              },
              setProps(C) {
                w = C;
              },
              setToggle: (C, I) => {
                x.get(C).toggle = I;
              },
              isToastActive: (C) => b.some((I) => I === C),
              getSnapshot: () => v,
            };
          })(o, s, pye);
          xa.set(o, l);
          const c = l.observe(a);
          return (
            nb.forEach((u) => iZ(u.content, u.options)),
            (nb = []),
            () => {
              c(), xa.delete(o);
            }
          );
        },
        setProps(a) {
          var l;
          (l = xa.get(o)) == null || l.setProps(a);
        },
        getSnapshot() {
          var a;
          return (a = xa.get(o)) == null ? void 0 : a.getSnapshot();
        },
      };
    })(e)
  ).current;
  r(e);
  const i = Y.useSyncExternalStore(t, n, n);
  return {
    getToastToRender: function (s) {
      if (!i) return [];
      const o = new Map();
      return (
        e.newestOnTop && i.reverse(),
        i.forEach((a) => {
          const { position: l } = a.props;
          o.has(l) || o.set(l, []), o.get(l).push(a);
        }),
        Array.from(o, (a) => s(a[0], a[1]))
      );
    },
    isToastActive: rZ,
    count: i == null ? void 0 : i.length,
  };
}
function gye(e) {
  const [t, n] = Y.useState(!1),
    [r, i] = Y.useState(!1),
    s = Y.useRef(null),
    o = Y.useRef({
      start: 0,
      delta: 0,
      removalDistance: 0,
      canCloseOnClick: !0,
      canDrag: !1,
      didMove: !1,
    }).current,
    {
      autoClose: a,
      pauseOnHover: l,
      closeToast: c,
      onClick: u,
      closeOnClick: d,
    } = e;
  var f, h;
  function p() {
    n(!0);
  }
  function g() {
    n(!1);
  }
  function b(x) {
    const S = s.current;
    o.canDrag &&
      S &&
      ((o.didMove = !0),
      t && g(),
      (o.delta =
        e.draggableDirection === "x"
          ? x.clientX - o.start
          : x.clientY - o.start),
      o.start !== x.clientX && (o.canCloseOnClick = !1),
      (S.style.transform = `translate3d(${
        e.draggableDirection === "x"
          ? `${o.delta}px, var(--y)`
          : `0, calc(${o.delta}px + var(--y))`
      },0)`),
      (S.style.opacity = "" + (1 - Math.abs(o.delta / o.removalDistance))));
  }
  function v() {
    document.removeEventListener("pointermove", b),
      document.removeEventListener("pointerup", v);
    const x = s.current;
    if (o.canDrag && o.didMove && x) {
      if (((o.canDrag = !1), Math.abs(o.delta) > o.removalDistance))
        return i(!0), e.closeToast(), void e.collapseAll();
      (x.style.transition = "transform 0.2s, opacity 0.2s"),
        x.style.removeProperty("transform"),
        x.style.removeProperty("opacity");
    }
  }
  (h = xa.get(
    (f = { id: e.toastId, containerId: e.containerId, fn: n }).containerId || 1
  )) == null || h.setToggle(f.id, f.fn),
    Y.useEffect(() => {
      if (e.pauseOnFocusLoss)
        return (
          document.hasFocus() || g(),
          window.addEventListener("focus", p),
          window.addEventListener("blur", g),
          () => {
            window.removeEventListener("focus", p),
              window.removeEventListener("blur", g);
          }
        );
    }, [e.pauseOnFocusLoss]);
  const w = {
    onPointerDown: function (x) {
      if (e.draggable === !0 || e.draggable === x.pointerType) {
        (o.didMove = !1),
          document.addEventListener("pointermove", b),
          document.addEventListener("pointerup", v);
        const S = s.current;
        (o.canCloseOnClick = !0),
          (o.canDrag = !0),
          (S.style.transition = "none"),
          e.draggableDirection === "x"
            ? ((o.start = x.clientX),
              (o.removalDistance = S.offsetWidth * (e.draggablePercent / 100)))
            : ((o.start = x.clientY),
              (o.removalDistance =
                (S.offsetHeight *
                  (e.draggablePercent === 80
                    ? 1.5 * e.draggablePercent
                    : e.draggablePercent)) /
                100));
      }
    },
    onPointerUp: function (x) {
      const {
        top: S,
        bottom: R,
        left: O,
        right: B,
      } = s.current.getBoundingClientRect();
      x.nativeEvent.type !== "touchend" &&
      e.pauseOnHover &&
      x.clientX >= O &&
      x.clientX <= B &&
      x.clientY >= S &&
      x.clientY <= R
        ? g()
        : p();
    },
  };
  return (
    a && l && ((w.onMouseEnter = g), e.stacked || (w.onMouseLeave = p)),
    d &&
      (w.onClick = (x) => {
        u && u(x), o.canCloseOnClick && c();
      }),
    {
      playToast: p,
      pauseToast: g,
      isRunning: t,
      preventExitTransition: r,
      toastRef: s,
      eventHandlers: w,
    }
  );
}
function yye(e) {
  let {
    delay: t,
    isRunning: n,
    closeToast: r,
    type: i = "default",
    hide: s,
    className: o,
    style: a,
    controlledProgress: l,
    progress: c,
    rtl: u,
    isIn: d,
    theme: f,
  } = e;
  const h = s || (l && c === 0),
    p = {
      ...a,
      animationDuration: `${t}ms`,
      animationPlayState: n ? "running" : "paused",
    };
  l && (p.transform = `scaleX(${c})`);
  const g = xp(
      "Toastify__progress-bar",
      l
        ? "Toastify__progress-bar--controlled"
        : "Toastify__progress-bar--animated",
      `Toastify__progress-bar-theme--${f}`,
      `Toastify__progress-bar--${i}`,
      { "Toastify__progress-bar--rtl": u }
    ),
    b = Ll(o) ? o({ rtl: u, type: i, defaultClassName: g }) : xp(g, o),
    v = {
      [l && c >= 1 ? "onTransitionEnd" : "onAnimationEnd"]:
        l && c < 1
          ? null
          : () => {
              d && r();
            },
    };
  return Ce.createElement(
    "div",
    { className: "Toastify__progress-bar--wrp", "data-hidden": h },
    Ce.createElement("div", {
      className: `Toastify__progress-bar--bg Toastify__progress-bar-theme--${f} Toastify__progress-bar--${i}`,
    }),
    Ce.createElement("div", {
      role: "progressbar",
      "aria-hidden": h ? "true" : "false",
      "aria-label": "notification timer",
      className: b,
      style: p,
      ...v,
    })
  );
}
let vye = 1;
const sZ = () => "" + vye++;
function wye(e) {
  return e && (Em(e.toastId) || tb(e.toastId)) ? e.toastId : sZ();
}
function gw(e, t) {
  return iZ(e, t), t.toastId;
}
function e5(e, t) {
  return { ...t, type: (t && t.type) || e, toastId: wye(t) };
}
function b_(e) {
  return (t, n) => gw(t, e5(e, n));
}
function Oi(e, t) {
  return gw(e, e5("default", t));
}
(Oi.loading = (e, t) =>
  gw(
    e,
    e5("default", {
      isLoading: !0,
      autoClose: !1,
      closeOnClick: !1,
      closeButton: !1,
      draggable: !1,
      ...t,
    })
  )),
  (Oi.promise = function (e, t, n) {
    let r,
      { pending: i, error: s, success: o } = t;
    i && (r = Em(i) ? Oi.loading(i, n) : Oi.loading(i.render, { ...n, ...i }));
    const a = {
        isLoading: null,
        autoClose: null,
        closeOnClick: null,
        closeButton: null,
        draggable: null,
      },
      l = (u, d, f) => {
        if (d == null) return void Oi.dismiss(r);
        const h = { type: u, ...a, ...n, data: f },
          p = Em(d) ? { render: d } : d;
        return (
          r ? Oi.update(r, { ...h, ...p }) : Oi(p.render, { ...h, ...p }), f
        );
      },
      c = Ll(e) ? e() : e;
    return c.then((u) => l("success", o, u)).catch((u) => l("error", s, u)), c;
  }),
  (Oi.success = b_("success")),
  (Oi.info = b_("info")),
  (Oi.error = b_("error")),
  (Oi.warning = b_("warning")),
  (Oi.warn = Oi.warning),
  (Oi.dark = (e, t) => gw(e, e5("default", { theme: "dark", ...t }))),
  (Oi.dismiss = function (e) {
    (function (t) {
      var n;
      if (nZ()) {
        if (t == null || Em((n = t)) || tb(n))
          xa.forEach((r) => {
            r.removeToast(t);
          });
        else if (t && ("containerId" in t || "id" in t)) {
          const r = xa.get(t.containerId);
          r
            ? r.removeToast(t.id)
            : xa.forEach((i) => {
                i.removeToast(t.id);
              });
        }
      } else nb = nb.filter((r) => t != null && r.options.toastId !== t);
    })(e);
  }),
  (Oi.clearWaitingQueue = function (e) {
    e === void 0 && (e = {}),
      xa.forEach((t) => {
        !t.props.limit ||
          (e.containerId && t.id !== e.containerId) ||
          t.clearQueue();
      });
  }),
  (Oi.isActive = rZ),
  (Oi.update = function (e, t) {
    t === void 0 && (t = {});
    const n = ((r, i) => {
      var s;
      let { containerId: o } = i;
      return (s = xa.get(o || 1)) == null ? void 0 : s.toasts.get(r);
    })(e, t);
    if (n) {
      const { props: r, content: i } = n,
        s = { delay: 100, ...r, ...t, toastId: t.toastId || e, updateId: sZ() };
      s.toastId !== e && (s.staleId = e);
      const o = s.render || i;
      delete s.render, gw(o, s);
    }
  }),
  (Oi.done = (e) => {
    Oi.update(e, { progress: 1 });
  }),
  (Oi.onChange = function (e) {
    return (
      eT.add(e),
      () => {
        eT.delete(e);
      }
    );
  }),
  (Oi.play = (e) => TF(!0, e)),
  (Oi.pause = (e) => TF(!1, e));
const bye = typeof window < "u" ? Y.useLayoutEffect : Y.useEffect,
  x_ = (e) => {
    let { theme: t, type: n, isLoading: r, ...i } = e;
    return Ce.createElement("svg", {
      viewBox: "0 0 24 24",
      width: "100%",
      height: "100%",
      fill:
        t === "colored" ? "currentColor" : `var(--toastify-icon-color-${n})`,
      ...i,
    });
  },
  NA = {
    info: function (e) {
      return Ce.createElement(
        x_,
        { ...e },
        Ce.createElement("path", {
          d: "M12 0a12 12 0 1012 12A12.013 12.013 0 0012 0zm.25 5a1.5 1.5 0 11-1.5 1.5 1.5 1.5 0 011.5-1.5zm2.25 13.5h-4a1 1 0 010-2h.75a.25.25 0 00.25-.25v-4.5a.25.25 0 00-.25-.25h-.75a1 1 0 010-2h1a2 2 0 012 2v4.75a.25.25 0 00.25.25h.75a1 1 0 110 2z",
        })
      );
    },
    warning: function (e) {
      return Ce.createElement(
        x_,
        { ...e },
        Ce.createElement("path", {
          d: "M23.32 17.191L15.438 2.184C14.728.833 13.416 0 11.996 0c-1.42 0-2.733.833-3.443 2.184L.533 17.448a4.744 4.744 0 000 4.368C1.243 23.167 2.555 24 3.975 24h16.05C22.22 24 24 22.044 24 19.632c0-.904-.251-1.746-.68-2.44zm-9.622 1.46c0 1.033-.724 1.823-1.698 1.823s-1.698-.79-1.698-1.822v-.043c0-1.028.724-1.822 1.698-1.822s1.698.79 1.698 1.822v.043zm.039-12.285l-.84 8.06c-.057.581-.408.943-.897.943-.49 0-.84-.367-.896-.942l-.84-8.065c-.057-.624.25-1.095.779-1.095h1.91c.528.005.84.476.784 1.1z",
        })
      );
    },
    success: function (e) {
      return Ce.createElement(
        x_,
        { ...e },
        Ce.createElement("path", {
          d: "M12 0a12 12 0 1012 12A12.014 12.014 0 0012 0zm6.927 8.2l-6.845 9.289a1.011 1.011 0 01-1.43.188l-4.888-3.908a1 1 0 111.25-1.562l4.076 3.261 6.227-8.451a1 1 0 111.61 1.183z",
        })
      );
    },
    error: function (e) {
      return Ce.createElement(
        x_,
        { ...e },
        Ce.createElement("path", {
          d: "M11.983 0a12.206 12.206 0 00-8.51 3.653A11.8 11.8 0 000 12.207 11.779 11.779 0 0011.8 24h.214A12.111 12.111 0 0024 11.791 11.766 11.766 0 0011.983 0zM10.5 16.542a1.476 1.476 0 011.449-1.53h.027a1.527 1.527 0 011.523 1.47 1.475 1.475 0 01-1.449 1.53h-.027a1.529 1.529 0 01-1.523-1.47zM11 12.5v-6a1 1 0 012 0v6a1 1 0 11-2 0z",
        })
      );
    },
    spinner: function () {
      return Ce.createElement("div", { className: "Toastify__spinner" });
    },
  },
  xye = (e) => {
    const {
        isRunning: t,
        preventExitTransition: n,
        toastRef: r,
        eventHandlers: i,
        playToast: s,
      } = gye(e),
      {
        closeButton: o,
        children: a,
        autoClose: l,
        onClick: c,
        type: u,
        hideProgressBar: d,
        closeToast: f,
        transition: h,
        position: p,
        className: g,
        style: b,
        bodyClassName: v,
        bodyStyle: w,
        progressClassName: x,
        progressStyle: S,
        updateId: R,
        role: O,
        progress: B,
        rtl: C,
        toastId: I,
        deleteToast: P,
        isIn: M,
        isLoading: k,
        closeOnClick: T,
        theme: _,
      } = e,
      A = xp(
        "Toastify__toast",
        `Toastify__toast-theme--${_}`,
        `Toastify__toast--${u}`,
        { "Toastify__toast--rtl": C },
        { "Toastify__toast--close-on-click": T }
      ),
      N = Ll(g)
        ? g({ rtl: C, position: p, type: u, defaultClassName: A })
        : xp(A, g),
      L = (function (z) {
        let { theme: $, type: K, isLoading: re, icon: G } = z,
          ne = null;
        const ae = { theme: $, type: K };
        return (
          G === !1 ||
            (Ll(G)
              ? (ne = G({ ...ae, isLoading: re }))
              : Y.isValidElement(G)
              ? (ne = Y.cloneElement(G, ae))
              : re
              ? (ne = NA.spinner())
              : ((le) => le in NA)(K) && (ne = NA[K](ae))),
          ne
        );
      })(e),
      F = !!B || !l,
      D = { closeToast: f, type: u, theme: _ };
    let j = null;
    return (
      o === !1 ||
        (j = Ll(o)
          ? o(D)
          : Y.isValidElement(o)
          ? Y.cloneElement(o, D)
          : (function (z) {
              let { closeToast: $, theme: K, ariaLabel: re = "close" } = z;
              return Ce.createElement(
                "button",
                {
                  className: `Toastify__close-button Toastify__close-button--${K}`,
                  type: "button",
                  onClick: (G) => {
                    G.stopPropagation(), $(G);
                  },
                  "aria-label": re,
                },
                Ce.createElement(
                  "svg",
                  { "aria-hidden": "true", viewBox: "0 0 14 16" },
                  Ce.createElement("path", {
                    fillRule: "evenodd",
                    d: "M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z",
                  })
                )
              );
            })(D)),
      Ce.createElement(
        h,
        {
          isIn: M,
          done: P,
          position: p,
          preventExitTransition: n,
          nodeRef: r,
          playToast: s,
        },
        Ce.createElement(
          "div",
          {
            id: I,
            onClick: c,
            "data-in": M,
            className: N,
            ...i,
            style: b,
            ref: r,
          },
          Ce.createElement(
            "div",
            {
              ...(M && { role: O }),
              className: Ll(v) ? v({ type: u }) : xp("Toastify__toast-body", v),
              style: w,
            },
            L != null &&
              Ce.createElement(
                "div",
                {
                  className: xp("Toastify__toast-icon", {
                    "Toastify--animate-icon Toastify__zoom-enter": !k,
                  }),
                },
                L
              ),
            Ce.createElement("div", null, a)
          ),
          j,
          Ce.createElement(yye, {
            ...(R && !F ? { key: `pb-${R}` } : {}),
            rtl: C,
            theme: _,
            delay: l,
            isRunning: t,
            isIn: M,
            closeToast: f,
            hide: d,
            type: u,
            style: S,
            className: x,
            controlledProgress: F,
            progress: B || 0,
          })
        )
      )
    );
  },
  t8 = function (e, t) {
    return (
      t === void 0 && (t = !1),
      {
        enter: `Toastify--animate Toastify__${e}-enter`,
        exit: `Toastify--animate Toastify__${e}-exit`,
        appendPosition: t,
      }
    );
  },
  _ye = e8(t8("bounce", !0));
e8(t8("slide", !0));
e8(t8("zoom"));
e8(t8("flip"));
const Sye = {
  position: "top-right",
  transition: _ye,
  autoClose: 5e3,
  closeButton: !0,
  pauseOnHover: !0,
  pauseOnFocusLoss: !0,
  draggable: "touch",
  draggablePercent: 80,
  draggableDirection: "x",
  role: "alert",
  theme: "light",
};
function Eye(e) {
  let t = { ...Sye, ...e };
  const n = e.stacked,
    [r, i] = Y.useState(!0),
    s = Y.useRef(null),
    { getToastToRender: o, isToastActive: a, count: l } = mye(t),
    { className: c, style: u, rtl: d, containerId: f } = t;
  function h(g) {
    const b = xp(
      "Toastify__toast-container",
      `Toastify__toast-container--${g}`,
      { "Toastify__toast-container--rtl": d }
    );
    return Ll(c)
      ? c({ position: g, rtl: d, defaultClassName: b })
      : xp(b, S4(c));
  }
  function p() {
    n && (i(!0), Oi.play());
  }
  return (
    bye(() => {
      if (n) {
        var g;
        const b = s.current.querySelectorAll('[data-in="true"]'),
          v = 12,
          w = (g = t.position) == null ? void 0 : g.includes("top");
        let x = 0,
          S = 0;
        Array.from(b)
          .reverse()
          .forEach((R, O) => {
            const B = R;
            B.classList.add("Toastify__toast--stacked"),
              O > 0 && (B.dataset.collapsed = `${r}`),
              B.dataset.pos || (B.dataset.pos = w ? "top" : "bot");
            const C = x * (r ? 0.2 : 1) + (r ? 0 : v * O);
            B.style.setProperty("--y", `${w ? C : -1 * C}px`),
              B.style.setProperty("--g", `${v}`),
              B.style.setProperty("--s", "" + (1 - (r ? S : 0))),
              (x += B.offsetHeight),
              (S += 0.025);
          });
      }
    }, [r, l, n]),
    Ce.createElement(
      "div",
      {
        ref: s,
        className: "Toastify",
        id: f,
        onMouseEnter: () => {
          n && (i(!1), Oi.pause());
        },
        onMouseLeave: p,
      },
      o((g, b) => {
        const v = b.length ? { ...u } : { ...u, pointerEvents: "none" };
        return Ce.createElement(
          "div",
          { className: h(g), style: v, key: `container-${g}` },
          b.map((w) => {
            let { content: x, props: S } = w;
            return Ce.createElement(
              xye,
              {
                ...S,
                stacked: n,
                collapseAll: p,
                isIn: a(S.toastId, S.containerId),
                style: S.style,
                key: `toast-${S.key}`,
              },
              x
            );
          })
        );
      })
    )
  );
}
function E4(e) {
  return (
    typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
      ? (E4 = function (n) {
          return typeof n;
        })
      : (E4 = function (n) {
          return n &&
            typeof Symbol == "function" &&
            n.constructor === Symbol &&
            n !== Symbol.prototype
            ? "symbol"
            : typeof n;
        }),
    E4(e)
  );
}
function Aye(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Cye(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    (r.enumerable = r.enumerable || !1),
      (r.configurable = !0),
      "value" in r && (r.writable = !0),
      Object.defineProperty(e, r.key, r);
  }
}
function kye(e, t, n) {
  return t && Cye(e.prototype, t), e;
}
function Tye(e, t) {
  return t && (E4(t) === "object" || typeof t == "function") ? t : A4(e);
}
function tT(e) {
  return (
    (tT = Object.setPrototypeOf
      ? Object.getPrototypeOf
      : function (n) {
          return n.__proto__ || Object.getPrototypeOf(n);
        }),
    tT(e)
  );
}
function A4(e) {
  if (e === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    );
  return e;
}
function Mye(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  (e.prototype = Object.create(t && t.prototype, {
    constructor: { value: e, writable: !0, configurable: !0 },
  })),
    t && nT(e, t);
}
function nT(e, t) {
  return (
    (nT =
      Object.setPrototypeOf ||
      function (r, i) {
        return (r.__proto__ = i), r;
      }),
    nT(e, t)
  );
}
function C4(e, t, n) {
  return (
    t in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (e[t] = n),
    e
  );
}
var oZ = (function (e) {
  Mye(t, e);
  function t() {
    var n, r;
    Aye(this, t);
    for (var i = arguments.length, s = new Array(i), o = 0; o < i; o++)
      s[o] = arguments[o];
    return (
      (r = Tye(this, (n = tT(t)).call.apply(n, [this].concat(s)))),
      C4(A4(r), "state", { bootstrapped: !1 }),
      C4(A4(r), "_unsubscribe", void 0),
      C4(A4(r), "handlePersistorState", function () {
        var a = r.props.persistor,
          l = a.getState(),
          c = l.bootstrapped;
        c &&
          (r.props.onBeforeLift
            ? Promise.resolve(r.props.onBeforeLift()).finally(function () {
                return r.setState({ bootstrapped: !0 });
              })
            : r.setState({ bootstrapped: !0 }),
          r._unsubscribe && r._unsubscribe());
      }),
      r
    );
  }
  return (
    kye(t, [
      {
        key: "componentDidMount",
        value: function () {
          (this._unsubscribe = this.props.persistor.subscribe(
            this.handlePersistorState
          )),
            this.handlePersistorState();
        },
      },
      {
        key: "componentWillUnmount",
        value: function () {
          this._unsubscribe && this._unsubscribe();
        },
      },
      {
        key: "render",
        value: function () {
          return typeof this.props.children == "function"
            ? this.props.children(this.state.bootstrapped)
            : this.state.bootstrapped
            ? this.props.children
            : this.props.loading;
        },
      },
    ]),
    t
  );
})(Y.PureComponent);
C4(oZ, "defaultProps", { children: null, loading: null });
const Iye = `
	.modal {
		overflow-y: auto!important; /* Handle overflow */
		padding: 0px!important; /* Remove padding */

	}
	.outer-container {
		background: none;
		padding: 0px!important; /* Remove padding */

	}
	.modal .container {
		height: auto!important;
		padding: 0px!important; /* Remove padding */

	}
	section, section > div { 
		height: 100%;
		padding: 0px!important; /* Remove padding */

	}
	.modal-position > .max-height {
		max-height: none!important;
	}
	.width-100 {
		width: 100%!important;
	}
	.header, .mobile-header {
		display: none!important;
		padding: 0px!important; /* Remove padding */

	}
	.wallets-container {
		display: flex!important;
		flex-direction: column!important;
		width: 100%; /* Full width */
		overflow: hidden; /* Handle content overflow */
		padding: 8px!important; /* Remove padding */
	}
	.wallet-button-container {
		display: flex!important;
		justify-content: space-between; /* Space between name and icon */
		padding: 0px!important; /* Remove padding */
		border-radius: 8px!important;
	}
	.wallet-button-container .wallet-button-container-inner {
		width: 308px!important;
		height: 50px!important; /* Fixed height */
		gap: 8px!important;
		transition: all 0.2s;
		flex-flow: row!important;
		background: #ffffff05!important;
		border-radius: 8px!important;
		padding: 0!important; /* Remove padding */
	}
	.wallet-button-container button {
		border: none!important;
		padding: 0!important; /* Remove padding */
	}
	.wallet-button-container:hover .wallet-button-container-inner {
		border-color: #c599e0!important;
	}
	.wallet-button-container:hover button {
		background: none!important;
		border-radius: 8px!important;

	}
	.wallet-button-container .wallet-button-container-inner > div:first-child {
		width: 32px!important;
		height: 32px!important;
		border-radius: 8px!important;
		border: none;
		padding: 0!important; /* Remove padding */
	}
	.wallet-button-container .wallet-button-container-inner > .name {
		font-family: 'Raleway';
		color: #b9c0d4;
		font-size: 14px;
		font-weight: 600;
		line-height: 100%;
		max-width: none!important;
		transition: color 0.2s;
		text-align: left;
		padding: 0!important; /* Remove padding */
	}
	.button-container {
		display: none!important;
	}
	.warning-container {
		
	}
	.modal-overflow, .modal {
		width: 100%!important;
		overflow: hidden; /* Ensure no overflow */
	}
	.notice-container {
		// display: none!important;

	}
	.modal-container-mobile {
		margin: 0!important;
	}
	@media (max-width: 768px) {
		/* No specific styles needed for this media query as per your request */
	}
	@media (min-width: 768px) {
		.width-100 {
			width: 100%!important;
		}
		.max-height {
			max-height: none!important;
		}
		.modal > .container {
			height: auto!important;
		}
	}
`;
var so = {},
  n8 = {};
n8.byteLength = Oye;
n8.toByteArray = Lye;
n8.fromByteArray = Bye;
var td = [],
  mc = [],
  Nye = typeof Uint8Array < "u" ? Uint8Array : Array,
  RA = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var z1 = 0, Rye = RA.length; z1 < Rye; ++z1)
  (td[z1] = RA[z1]), (mc[RA.charCodeAt(z1)] = z1);
mc[45] = 62;
mc[95] = 63;
function aZ(e) {
  var t = e.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var n = e.indexOf("=");
  n === -1 && (n = t);
  var r = n === t ? 0 : 4 - (n % 4);
  return [n, r];
}
function Oye(e) {
  var t = aZ(e),
    n = t[0],
    r = t[1];
  return ((n + r) * 3) / 4 - r;
}
function Pye(e, t, n) {
  return ((t + n) * 3) / 4 - n;
}
function Lye(e) {
  var t,
    n = aZ(e),
    r = n[0],
    i = n[1],
    s = new Nye(Pye(e, r, i)),
    o = 0,
    a = i > 0 ? r - 4 : r,
    l;
  for (l = 0; l < a; l += 4)
    (t =
      (mc[e.charCodeAt(l)] << 18) |
      (mc[e.charCodeAt(l + 1)] << 12) |
      (mc[e.charCodeAt(l + 2)] << 6) |
      mc[e.charCodeAt(l + 3)]),
      (s[o++] = (t >> 16) & 255),
      (s[o++] = (t >> 8) & 255),
      (s[o++] = t & 255);
  return (
    i === 2 &&
      ((t = (mc[e.charCodeAt(l)] << 2) | (mc[e.charCodeAt(l + 1)] >> 4)),
      (s[o++] = t & 255)),
    i === 1 &&
      ((t =
        (mc[e.charCodeAt(l)] << 10) |
        (mc[e.charCodeAt(l + 1)] << 4) |
        (mc[e.charCodeAt(l + 2)] >> 2)),
      (s[o++] = (t >> 8) & 255),
      (s[o++] = t & 255)),
    s
  );
}
function jye(e) {
  return (
    td[(e >> 18) & 63] + td[(e >> 12) & 63] + td[(e >> 6) & 63] + td[e & 63]
  );
}
function Dye(e, t, n) {
  for (var r, i = [], s = t; s < n; s += 3)
    (r =
      ((e[s] << 16) & 16711680) + ((e[s + 1] << 8) & 65280) + (e[s + 2] & 255)),
      i.push(jye(r));
  return i.join("");
}
function Bye(e) {
  for (
    var t, n = e.length, r = n % 3, i = [], s = 16383, o = 0, a = n - r;
    o < a;
    o += s
  )
    i.push(Dye(e, o, o + s > a ? a : o + s));
  return (
    r === 1
      ? ((t = e[n - 1]), i.push(td[t >> 2] + td[(t << 4) & 63] + "=="))
      : r === 2 &&
        ((t = (e[n - 2] << 8) + e[n - 1]),
        i.push(td[t >> 10] + td[(t >> 4) & 63] + td[(t << 2) & 63] + "=")),
    i.join("")
  );
}
var FN = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ FN.read =
  function (e, t, n, r, i) {
    var s,
      o,
      a = i * 8 - r - 1,
      l = (1 << a) - 1,
      c = l >> 1,
      u = -7,
      d = n ? i - 1 : 0,
      f = n ? -1 : 1,
      h = e[t + d];
    for (
      d += f, s = h & ((1 << -u) - 1), h >>= -u, u += a;
      u > 0;
      s = s * 256 + e[t + d], d += f, u -= 8
    );
    for (
      o = s & ((1 << -u) - 1), s >>= -u, u += r;
      u > 0;
      o = o * 256 + e[t + d], d += f, u -= 8
    );
    if (s === 0) s = 1 - c;
    else {
      if (s === l) return o ? NaN : (h ? -1 : 1) * (1 / 0);
      (o = o + Math.pow(2, r)), (s = s - c);
    }
    return (h ? -1 : 1) * o * Math.pow(2, s - r);
  };
FN.write = function (e, t, n, r, i, s) {
  var o,
    a,
    l,
    c = s * 8 - i - 1,
    u = (1 << c) - 1,
    d = u >> 1,
    f = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
    h = r ? 0 : s - 1,
    p = r ? 1 : -1,
    g = t < 0 || (t === 0 && 1 / t < 0) ? 1 : 0;
  for (
    t = Math.abs(t),
      isNaN(t) || t === 1 / 0
        ? ((a = isNaN(t) ? 1 : 0), (o = u))
        : ((o = Math.floor(Math.log(t) / Math.LN2)),
          t * (l = Math.pow(2, -o)) < 1 && (o--, (l *= 2)),
          o + d >= 1 ? (t += f / l) : (t += f * Math.pow(2, 1 - d)),
          t * l >= 2 && (o++, (l /= 2)),
          o + d >= u
            ? ((a = 0), (o = u))
            : o + d >= 1
            ? ((a = (t * l - 1) * Math.pow(2, i)), (o = o + d))
            : ((a = t * Math.pow(2, d - 1) * Math.pow(2, i)), (o = 0)));
    i >= 8;
    e[n + h] = a & 255, h += p, a /= 256, i -= 8
  );
  for (
    o = (o << i) | a, c += i;
    c > 0;
    e[n + h] = o & 255, h += p, o /= 256, c -= 8
  );
  e[n + h - p] |= g * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ (function (e) {
  const t = n8,
    n = FN,
    r =
      typeof Symbol == "function" && typeof Symbol.for == "function"
        ? Symbol.for("nodejs.util.inspect.custom")
        : null;
  (e.Buffer = u), (e.SlowBuffer = R), (e.INSPECT_MAX_BYTES = 50);
  const i = 2147483647;
  e.kMaxLength = i;
  const { Uint8Array: s, ArrayBuffer: o, SharedArrayBuffer: a } = globalThis;
  (u.TYPED_ARRAY_SUPPORT = l()),
    !u.TYPED_ARRAY_SUPPORT &&
      typeof console < "u" &&
      typeof console.error == "function" &&
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
  function l() {
    try {
      const Q = new s(1),
        H = {
          foo: function () {
            return 42;
          },
        };
      return (
        Object.setPrototypeOf(H, s.prototype),
        Object.setPrototypeOf(Q, H),
        Q.foo() === 42
      );
    } catch {
      return !1;
    }
  }
  Object.defineProperty(u.prototype, "parent", {
    enumerable: !0,
    get: function () {
      if (u.isBuffer(this)) return this.buffer;
    },
  }),
    Object.defineProperty(u.prototype, "offset", {
      enumerable: !0,
      get: function () {
        if (u.isBuffer(this)) return this.byteOffset;
      },
    });
  function c(Q) {
    if (Q > i)
      throw new RangeError(
        'The value "' + Q + '" is invalid for option "size"'
      );
    const H = new s(Q);
    return Object.setPrototypeOf(H, u.prototype), H;
  }
  function u(Q, H, q) {
    if (typeof Q == "number") {
      if (typeof H == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return p(Q);
    }
    return d(Q, H, q);
  }
  u.poolSize = 8192;
  function d(Q, H, q) {
    if (typeof Q == "string") return g(Q, H);
    if (o.isView(Q)) return v(Q);
    if (Q == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
          typeof Q
      );
    if (
      Pt(Q, o) ||
      (Q && Pt(Q.buffer, o)) ||
      (typeof a < "u" && (Pt(Q, a) || (Q && Pt(Q.buffer, a))))
    )
      return w(Q, H, q);
    if (typeof Q == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const ee = Q.valueOf && Q.valueOf();
    if (ee != null && ee !== Q) return u.from(ee, H, q);
    const ce = x(Q);
    if (ce) return ce;
    if (
      typeof Symbol < "u" &&
      Symbol.toPrimitive != null &&
      typeof Q[Symbol.toPrimitive] == "function"
    )
      return u.from(Q[Symbol.toPrimitive]("string"), H, q);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
        typeof Q
    );
  }
  (u.from = function (Q, H, q) {
    return d(Q, H, q);
  }),
    Object.setPrototypeOf(u.prototype, s.prototype),
    Object.setPrototypeOf(u, s);
  function f(Q) {
    if (typeof Q != "number")
      throw new TypeError('"size" argument must be of type number');
    if (Q < 0)
      throw new RangeError(
        'The value "' + Q + '" is invalid for option "size"'
      );
  }
  function h(Q, H, q) {
    return (
      f(Q),
      Q <= 0
        ? c(Q)
        : H !== void 0
        ? typeof q == "string"
          ? c(Q).fill(H, q)
          : c(Q).fill(H)
        : c(Q)
    );
  }
  u.alloc = function (Q, H, q) {
    return h(Q, H, q);
  };
  function p(Q) {
    return f(Q), c(Q < 0 ? 0 : S(Q) | 0);
  }
  (u.allocUnsafe = function (Q) {
    return p(Q);
  }),
    (u.allocUnsafeSlow = function (Q) {
      return p(Q);
    });
  function g(Q, H) {
    if (((typeof H != "string" || H === "") && (H = "utf8"), !u.isEncoding(H)))
      throw new TypeError("Unknown encoding: " + H);
    const q = O(Q, H) | 0;
    let ee = c(q);
    const ce = ee.write(Q, H);
    return ce !== q && (ee = ee.slice(0, ce)), ee;
  }
  function b(Q) {
    const H = Q.length < 0 ? 0 : S(Q.length) | 0,
      q = c(H);
    for (let ee = 0; ee < H; ee += 1) q[ee] = Q[ee] & 255;
    return q;
  }
  function v(Q) {
    if (Pt(Q, s)) {
      const H = new s(Q);
      return w(H.buffer, H.byteOffset, H.byteLength);
    }
    return b(Q);
  }
  function w(Q, H, q) {
    if (H < 0 || Q.byteLength < H)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (Q.byteLength < H + (q || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let ee;
    return (
      H === void 0 && q === void 0
        ? (ee = new s(Q))
        : q === void 0
        ? (ee = new s(Q, H))
        : (ee = new s(Q, H, q)),
      Object.setPrototypeOf(ee, u.prototype),
      ee
    );
  }
  function x(Q) {
    if (u.isBuffer(Q)) {
      const H = S(Q.length) | 0,
        q = c(H);
      return q.length === 0 || Q.copy(q, 0, 0, H), q;
    }
    if (Q.length !== void 0)
      return typeof Q.length != "number" || wn(Q.length) ? c(0) : b(Q);
    if (Q.type === "Buffer" && Array.isArray(Q.data)) return b(Q.data);
  }
  function S(Q) {
    if (Q >= i)
      throw new RangeError(
        "Attempt to allocate Buffer larger than maximum size: 0x" +
          i.toString(16) +
          " bytes"
      );
    return Q | 0;
  }
  function R(Q) {
    return +Q != Q && (Q = 0), u.alloc(+Q);
  }
  (u.isBuffer = function (H) {
    return H != null && H._isBuffer === !0 && H !== u.prototype;
  }),
    (u.compare = function (H, q) {
      if (
        (Pt(H, s) && (H = u.from(H, H.offset, H.byteLength)),
        Pt(q, s) && (q = u.from(q, q.offset, q.byteLength)),
        !u.isBuffer(H) || !u.isBuffer(q))
      )
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      if (H === q) return 0;
      let ee = H.length,
        ce = q.length;
      for (let pe = 0, we = Math.min(ee, ce); pe < we; ++pe)
        if (H[pe] !== q[pe]) {
          (ee = H[pe]), (ce = q[pe]);
          break;
        }
      return ee < ce ? -1 : ce < ee ? 1 : 0;
    }),
    (u.isEncoding = function (H) {
      switch (String(H).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return !0;
        default:
          return !1;
      }
    }),
    (u.concat = function (H, q) {
      if (!Array.isArray(H))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (H.length === 0) return u.alloc(0);
      let ee;
      if (q === void 0)
        for (q = 0, ee = 0; ee < H.length; ++ee) q += H[ee].length;
      const ce = u.allocUnsafe(q);
      let pe = 0;
      for (ee = 0; ee < H.length; ++ee) {
        let we = H[ee];
        if (Pt(we, s))
          pe + we.length > ce.length
            ? (u.isBuffer(we) || (we = u.from(we)), we.copy(ce, pe))
            : s.prototype.set.call(ce, we, pe);
        else if (u.isBuffer(we)) we.copy(ce, pe);
        else throw new TypeError('"list" argument must be an Array of Buffers');
        pe += we.length;
      }
      return ce;
    });
  function O(Q, H) {
    if (u.isBuffer(Q)) return Q.length;
    if (o.isView(Q) || Pt(Q, o)) return Q.byteLength;
    if (typeof Q != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' +
          typeof Q
      );
    const q = Q.length,
      ee = arguments.length > 2 && arguments[2] === !0;
    if (!ee && q === 0) return 0;
    let ce = !1;
    for (;;)
      switch (H) {
        case "ascii":
        case "latin1":
        case "binary":
          return q;
        case "utf8":
        case "utf-8":
          return kt(Q).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return q * 2;
        case "hex":
          return q >>> 1;
        case "base64":
          return Rt(Q).length;
        default:
          if (ce) return ee ? -1 : kt(Q).length;
          (H = ("" + H).toLowerCase()), (ce = !0);
      }
  }
  u.byteLength = O;
  function B(Q, H, q) {
    let ee = !1;
    if (
      ((H === void 0 || H < 0) && (H = 0),
      H > this.length ||
        ((q === void 0 || q > this.length) && (q = this.length), q <= 0) ||
        ((q >>>= 0), (H >>>= 0), q <= H))
    )
      return "";
    for (Q || (Q = "utf8"); ; )
      switch (Q) {
        case "hex":
          return $(this, H, q);
        case "utf8":
        case "utf-8":
          return L(this, H, q);
        case "ascii":
          return j(this, H, q);
        case "latin1":
        case "binary":
          return z(this, H, q);
        case "base64":
          return N(this, H, q);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return K(this, H, q);
        default:
          if (ee) throw new TypeError("Unknown encoding: " + Q);
          (Q = (Q + "").toLowerCase()), (ee = !0);
      }
  }
  u.prototype._isBuffer = !0;
  function C(Q, H, q) {
    const ee = Q[H];
    (Q[H] = Q[q]), (Q[q] = ee);
  }
  (u.prototype.swap16 = function () {
    const H = this.length;
    if (H % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let q = 0; q < H; q += 2) C(this, q, q + 1);
    return this;
  }),
    (u.prototype.swap32 = function () {
      const H = this.length;
      if (H % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let q = 0; q < H; q += 4) C(this, q, q + 3), C(this, q + 1, q + 2);
      return this;
    }),
    (u.prototype.swap64 = function () {
      const H = this.length;
      if (H % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let q = 0; q < H; q += 8)
        C(this, q, q + 7),
          C(this, q + 1, q + 6),
          C(this, q + 2, q + 5),
          C(this, q + 3, q + 4);
      return this;
    }),
    (u.prototype.toString = function () {
      const H = this.length;
      return H === 0
        ? ""
        : arguments.length === 0
        ? L(this, 0, H)
        : B.apply(this, arguments);
    }),
    (u.prototype.toLocaleString = u.prototype.toString),
    (u.prototype.equals = function (H) {
      if (!u.isBuffer(H)) throw new TypeError("Argument must be a Buffer");
      return this === H ? !0 : u.compare(this, H) === 0;
    }),
    (u.prototype.inspect = function () {
      let H = "";
      const q = e.INSPECT_MAX_BYTES;
      return (
        (H = this.toString("hex", 0, q)
          .replace(/(.{2})/g, "$1 ")
          .trim()),
        this.length > q && (H += " ... "),
        "<Buffer " + H + ">"
      );
    }),
    r && (u.prototype[r] = u.prototype.inspect),
    (u.prototype.compare = function (H, q, ee, ce, pe) {
      if ((Pt(H, s) && (H = u.from(H, H.offset, H.byteLength)), !u.isBuffer(H)))
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' +
            typeof H
        );
      if (
        (q === void 0 && (q = 0),
        ee === void 0 && (ee = H ? H.length : 0),
        ce === void 0 && (ce = 0),
        pe === void 0 && (pe = this.length),
        q < 0 || ee > H.length || ce < 0 || pe > this.length)
      )
        throw new RangeError("out of range index");
      if (ce >= pe && q >= ee) return 0;
      if (ce >= pe) return -1;
      if (q >= ee) return 1;
      if (((q >>>= 0), (ee >>>= 0), (ce >>>= 0), (pe >>>= 0), this === H))
        return 0;
      let we = pe - ce,
        ht = ee - q;
      const vt = Math.min(we, ht),
        ct = this.slice(ce, pe),
        Lt = H.slice(q, ee);
      for (let wt = 0; wt < vt; ++wt)
        if (ct[wt] !== Lt[wt]) {
          (we = ct[wt]), (ht = Lt[wt]);
          break;
        }
      return we < ht ? -1 : ht < we ? 1 : 0;
    });
  function I(Q, H, q, ee, ce) {
    if (Q.length === 0) return -1;
    if (
      (typeof q == "string"
        ? ((ee = q), (q = 0))
        : q > 2147483647
        ? (q = 2147483647)
        : q < -2147483648 && (q = -2147483648),
      (q = +q),
      wn(q) && (q = ce ? 0 : Q.length - 1),
      q < 0 && (q = Q.length + q),
      q >= Q.length)
    ) {
      if (ce) return -1;
      q = Q.length - 1;
    } else if (q < 0)
      if (ce) q = 0;
      else return -1;
    if ((typeof H == "string" && (H = u.from(H, ee)), u.isBuffer(H)))
      return H.length === 0 ? -1 : P(Q, H, q, ee, ce);
    if (typeof H == "number")
      return (
        (H = H & 255),
        typeof s.prototype.indexOf == "function"
          ? ce
            ? s.prototype.indexOf.call(Q, H, q)
            : s.prototype.lastIndexOf.call(Q, H, q)
          : P(Q, [H], q, ee, ce)
      );
    throw new TypeError("val must be string, number or Buffer");
  }
  function P(Q, H, q, ee, ce) {
    let pe = 1,
      we = Q.length,
      ht = H.length;
    if (
      ee !== void 0 &&
      ((ee = String(ee).toLowerCase()),
      ee === "ucs2" || ee === "ucs-2" || ee === "utf16le" || ee === "utf-16le")
    ) {
      if (Q.length < 2 || H.length < 2) return -1;
      (pe = 2), (we /= 2), (ht /= 2), (q /= 2);
    }
    function vt(Lt, wt) {
      return pe === 1 ? Lt[wt] : Lt.readUInt16BE(wt * pe);
    }
    let ct;
    if (ce) {
      let Lt = -1;
      for (ct = q; ct < we; ct++)
        if (vt(Q, ct) === vt(H, Lt === -1 ? 0 : ct - Lt)) {
          if ((Lt === -1 && (Lt = ct), ct - Lt + 1 === ht)) return Lt * pe;
        } else Lt !== -1 && (ct -= ct - Lt), (Lt = -1);
    } else
      for (q + ht > we && (q = we - ht), ct = q; ct >= 0; ct--) {
        let Lt = !0;
        for (let wt = 0; wt < ht; wt++)
          if (vt(Q, ct + wt) !== vt(H, wt)) {
            Lt = !1;
            break;
          }
        if (Lt) return ct;
      }
    return -1;
  }
  (u.prototype.includes = function (H, q, ee) {
    return this.indexOf(H, q, ee) !== -1;
  }),
    (u.prototype.indexOf = function (H, q, ee) {
      return I(this, H, q, ee, !0);
    }),
    (u.prototype.lastIndexOf = function (H, q, ee) {
      return I(this, H, q, ee, !1);
    });
  function M(Q, H, q, ee) {
    q = Number(q) || 0;
    const ce = Q.length - q;
    ee ? ((ee = Number(ee)), ee > ce && (ee = ce)) : (ee = ce);
    const pe = H.length;
    ee > pe / 2 && (ee = pe / 2);
    let we;
    for (we = 0; we < ee; ++we) {
      const ht = parseInt(H.substr(we * 2, 2), 16);
      if (wn(ht)) return we;
      Q[q + we] = ht;
    }
    return we;
  }
  function k(Q, H, q, ee) {
    return mt(kt(H, Q.length - q), Q, q, ee);
  }
  function T(Q, H, q, ee) {
    return mt(Qe(H), Q, q, ee);
  }
  function _(Q, H, q, ee) {
    return mt(Rt(H), Q, q, ee);
  }
  function A(Q, H, q, ee) {
    return mt(Vt(H, Q.length - q), Q, q, ee);
  }
  (u.prototype.write = function (H, q, ee, ce) {
    if (q === void 0) (ce = "utf8"), (ee = this.length), (q = 0);
    else if (ee === void 0 && typeof q == "string")
      (ce = q), (ee = this.length), (q = 0);
    else if (isFinite(q))
      (q = q >>> 0),
        isFinite(ee)
          ? ((ee = ee >>> 0), ce === void 0 && (ce = "utf8"))
          : ((ce = ee), (ee = void 0));
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const pe = this.length - q;
    if (
      ((ee === void 0 || ee > pe) && (ee = pe),
      (H.length > 0 && (ee < 0 || q < 0)) || q > this.length)
    )
      throw new RangeError("Attempt to write outside buffer bounds");
    ce || (ce = "utf8");
    let we = !1;
    for (;;)
      switch (ce) {
        case "hex":
          return M(this, H, q, ee);
        case "utf8":
        case "utf-8":
          return k(this, H, q, ee);
        case "ascii":
        case "latin1":
        case "binary":
          return T(this, H, q, ee);
        case "base64":
          return _(this, H, q, ee);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return A(this, H, q, ee);
        default:
          if (we) throw new TypeError("Unknown encoding: " + ce);
          (ce = ("" + ce).toLowerCase()), (we = !0);
      }
  }),
    (u.prototype.toJSON = function () {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0),
      };
    });
  function N(Q, H, q) {
    return H === 0 && q === Q.length
      ? t.fromByteArray(Q)
      : t.fromByteArray(Q.slice(H, q));
  }
  function L(Q, H, q) {
    q = Math.min(Q.length, q);
    const ee = [];
    let ce = H;
    for (; ce < q; ) {
      const pe = Q[ce];
      let we = null,
        ht = pe > 239 ? 4 : pe > 223 ? 3 : pe > 191 ? 2 : 1;
      if (ce + ht <= q) {
        let vt, ct, Lt, wt;
        switch (ht) {
          case 1:
            pe < 128 && (we = pe);
            break;
          case 2:
            (vt = Q[ce + 1]),
              (vt & 192) === 128 &&
                ((wt = ((pe & 31) << 6) | (vt & 63)), wt > 127 && (we = wt));
            break;
          case 3:
            (vt = Q[ce + 1]),
              (ct = Q[ce + 2]),
              (vt & 192) === 128 &&
                (ct & 192) === 128 &&
                ((wt = ((pe & 15) << 12) | ((vt & 63) << 6) | (ct & 63)),
                wt > 2047 && (wt < 55296 || wt > 57343) && (we = wt));
            break;
          case 4:
            (vt = Q[ce + 1]),
              (ct = Q[ce + 2]),
              (Lt = Q[ce + 3]),
              (vt & 192) === 128 &&
                (ct & 192) === 128 &&
                (Lt & 192) === 128 &&
                ((wt =
                  ((pe & 15) << 18) |
                  ((vt & 63) << 12) |
                  ((ct & 63) << 6) |
                  (Lt & 63)),
                wt > 65535 && wt < 1114112 && (we = wt));
        }
      }
      we === null
        ? ((we = 65533), (ht = 1))
        : we > 65535 &&
          ((we -= 65536),
          ee.push(((we >>> 10) & 1023) | 55296),
          (we = 56320 | (we & 1023))),
        ee.push(we),
        (ce += ht);
    }
    return D(ee);
  }
  const F = 4096;
  function D(Q) {
    const H = Q.length;
    if (H <= F) return String.fromCharCode.apply(String, Q);
    let q = "",
      ee = 0;
    for (; ee < H; )
      q += String.fromCharCode.apply(String, Q.slice(ee, (ee += F)));
    return q;
  }
  function j(Q, H, q) {
    let ee = "";
    q = Math.min(Q.length, q);
    for (let ce = H; ce < q; ++ce) ee += String.fromCharCode(Q[ce] & 127);
    return ee;
  }
  function z(Q, H, q) {
    let ee = "";
    q = Math.min(Q.length, q);
    for (let ce = H; ce < q; ++ce) ee += String.fromCharCode(Q[ce]);
    return ee;
  }
  function $(Q, H, q) {
    const ee = Q.length;
    (!H || H < 0) && (H = 0), (!q || q < 0 || q > ee) && (q = ee);
    let ce = "";
    for (let pe = H; pe < q; ++pe) ce += xt[Q[pe]];
    return ce;
  }
  function K(Q, H, q) {
    const ee = Q.slice(H, q);
    let ce = "";
    for (let pe = 0; pe < ee.length - 1; pe += 2)
      ce += String.fromCharCode(ee[pe] + ee[pe + 1] * 256);
    return ce;
  }
  u.prototype.slice = function (H, q) {
    const ee = this.length;
    (H = ~~H),
      (q = q === void 0 ? ee : ~~q),
      H < 0 ? ((H += ee), H < 0 && (H = 0)) : H > ee && (H = ee),
      q < 0 ? ((q += ee), q < 0 && (q = 0)) : q > ee && (q = ee),
      q < H && (q = H);
    const ce = this.subarray(H, q);
    return Object.setPrototypeOf(ce, u.prototype), ce;
  };
  function re(Q, H, q) {
    if (Q % 1 !== 0 || Q < 0) throw new RangeError("offset is not uint");
    if (Q + H > q)
      throw new RangeError("Trying to access beyond buffer length");
  }
  (u.prototype.readUintLE = u.prototype.readUIntLE =
    function (H, q, ee) {
      (H = H >>> 0), (q = q >>> 0), ee || re(H, q, this.length);
      let ce = this[H],
        pe = 1,
        we = 0;
      for (; ++we < q && (pe *= 256); ) ce += this[H + we] * pe;
      return ce;
    }),
    (u.prototype.readUintBE = u.prototype.readUIntBE =
      function (H, q, ee) {
        (H = H >>> 0), (q = q >>> 0), ee || re(H, q, this.length);
        let ce = this[H + --q],
          pe = 1;
        for (; q > 0 && (pe *= 256); ) ce += this[H + --q] * pe;
        return ce;
      }),
    (u.prototype.readUint8 = u.prototype.readUInt8 =
      function (H, q) {
        return (H = H >>> 0), q || re(H, 1, this.length), this[H];
      }),
    (u.prototype.readUint16LE = u.prototype.readUInt16LE =
      function (H, q) {
        return (
          (H = H >>> 0),
          q || re(H, 2, this.length),
          this[H] | (this[H + 1] << 8)
        );
      }),
    (u.prototype.readUint16BE = u.prototype.readUInt16BE =
      function (H, q) {
        return (
          (H = H >>> 0),
          q || re(H, 2, this.length),
          (this[H] << 8) | this[H + 1]
        );
      }),
    (u.prototype.readUint32LE = u.prototype.readUInt32LE =
      function (H, q) {
        return (
          (H = H >>> 0),
          q || re(H, 4, this.length),
          (this[H] | (this[H + 1] << 8) | (this[H + 2] << 16)) +
            this[H + 3] * 16777216
        );
      }),
    (u.prototype.readUint32BE = u.prototype.readUInt32BE =
      function (H, q) {
        return (
          (H = H >>> 0),
          q || re(H, 4, this.length),
          this[H] * 16777216 +
            ((this[H + 1] << 16) | (this[H + 2] << 8) | this[H + 3])
        );
      }),
    (u.prototype.readBigUInt64LE = Tt(function (H) {
      (H = H >>> 0), rn(H, "offset");
      const q = this[H],
        ee = this[H + 7];
      (q === void 0 || ee === void 0) && Wt(H, this.length - 8);
      const ce =
          q + this[++H] * 2 ** 8 + this[++H] * 2 ** 16 + this[++H] * 2 ** 24,
        pe =
          this[++H] + this[++H] * 2 ** 8 + this[++H] * 2 ** 16 + ee * 2 ** 24;
      return BigInt(ce) + (BigInt(pe) << BigInt(32));
    })),
    (u.prototype.readBigUInt64BE = Tt(function (H) {
      (H = H >>> 0), rn(H, "offset");
      const q = this[H],
        ee = this[H + 7];
      (q === void 0 || ee === void 0) && Wt(H, this.length - 8);
      const ce =
          q * 2 ** 24 + this[++H] * 2 ** 16 + this[++H] * 2 ** 8 + this[++H],
        pe =
          this[++H] * 2 ** 24 + this[++H] * 2 ** 16 + this[++H] * 2 ** 8 + ee;
      return (BigInt(ce) << BigInt(32)) + BigInt(pe);
    })),
    (u.prototype.readIntLE = function (H, q, ee) {
      (H = H >>> 0), (q = q >>> 0), ee || re(H, q, this.length);
      let ce = this[H],
        pe = 1,
        we = 0;
      for (; ++we < q && (pe *= 256); ) ce += this[H + we] * pe;
      return (pe *= 128), ce >= pe && (ce -= Math.pow(2, 8 * q)), ce;
    }),
    (u.prototype.readIntBE = function (H, q, ee) {
      (H = H >>> 0), (q = q >>> 0), ee || re(H, q, this.length);
      let ce = q,
        pe = 1,
        we = this[H + --ce];
      for (; ce > 0 && (pe *= 256); ) we += this[H + --ce] * pe;
      return (pe *= 128), we >= pe && (we -= Math.pow(2, 8 * q)), we;
    }),
    (u.prototype.readInt8 = function (H, q) {
      return (
        (H = H >>> 0),
        q || re(H, 1, this.length),
        this[H] & 128 ? (255 - this[H] + 1) * -1 : this[H]
      );
    }),
    (u.prototype.readInt16LE = function (H, q) {
      (H = H >>> 0), q || re(H, 2, this.length);
      const ee = this[H] | (this[H + 1] << 8);
      return ee & 32768 ? ee | 4294901760 : ee;
    }),
    (u.prototype.readInt16BE = function (H, q) {
      (H = H >>> 0), q || re(H, 2, this.length);
      const ee = this[H + 1] | (this[H] << 8);
      return ee & 32768 ? ee | 4294901760 : ee;
    }),
    (u.prototype.readInt32LE = function (H, q) {
      return (
        (H = H >>> 0),
        q || re(H, 4, this.length),
        this[H] | (this[H + 1] << 8) | (this[H + 2] << 16) | (this[H + 3] << 24)
      );
    }),
    (u.prototype.readInt32BE = function (H, q) {
      return (
        (H = H >>> 0),
        q || re(H, 4, this.length),
        (this[H] << 24) | (this[H + 1] << 16) | (this[H + 2] << 8) | this[H + 3]
      );
    }),
    (u.prototype.readBigInt64LE = Tt(function (H) {
      (H = H >>> 0), rn(H, "offset");
      const q = this[H],
        ee = this[H + 7];
      (q === void 0 || ee === void 0) && Wt(H, this.length - 8);
      const ce =
        this[H + 4] + this[H + 5] * 2 ** 8 + this[H + 6] * 2 ** 16 + (ee << 24);
      return (
        (BigInt(ce) << BigInt(32)) +
        BigInt(
          q + this[++H] * 2 ** 8 + this[++H] * 2 ** 16 + this[++H] * 2 ** 24
        )
      );
    })),
    (u.prototype.readBigInt64BE = Tt(function (H) {
      (H = H >>> 0), rn(H, "offset");
      const q = this[H],
        ee = this[H + 7];
      (q === void 0 || ee === void 0) && Wt(H, this.length - 8);
      const ce =
        (q << 24) + this[++H] * 2 ** 16 + this[++H] * 2 ** 8 + this[++H];
      return (
        (BigInt(ce) << BigInt(32)) +
        BigInt(
          this[++H] * 2 ** 24 + this[++H] * 2 ** 16 + this[++H] * 2 ** 8 + ee
        )
      );
    })),
    (u.prototype.readFloatLE = function (H, q) {
      return (
        (H = H >>> 0), q || re(H, 4, this.length), n.read(this, H, !0, 23, 4)
      );
    }),
    (u.prototype.readFloatBE = function (H, q) {
      return (
        (H = H >>> 0), q || re(H, 4, this.length), n.read(this, H, !1, 23, 4)
      );
    }),
    (u.prototype.readDoubleLE = function (H, q) {
      return (
        (H = H >>> 0), q || re(H, 8, this.length), n.read(this, H, !0, 52, 8)
      );
    }),
    (u.prototype.readDoubleBE = function (H, q) {
      return (
        (H = H >>> 0), q || re(H, 8, this.length), n.read(this, H, !1, 52, 8)
      );
    });
  function G(Q, H, q, ee, ce, pe) {
    if (!u.isBuffer(Q))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (H > ce || H < pe)
      throw new RangeError('"value" argument is out of bounds');
    if (q + ee > Q.length) throw new RangeError("Index out of range");
  }
  (u.prototype.writeUintLE = u.prototype.writeUIntLE =
    function (H, q, ee, ce) {
      if (((H = +H), (q = q >>> 0), (ee = ee >>> 0), !ce)) {
        const ht = Math.pow(2, 8 * ee) - 1;
        G(this, H, q, ee, ht, 0);
      }
      let pe = 1,
        we = 0;
      for (this[q] = H & 255; ++we < ee && (pe *= 256); )
        this[q + we] = (H / pe) & 255;
      return q + ee;
    }),
    (u.prototype.writeUintBE = u.prototype.writeUIntBE =
      function (H, q, ee, ce) {
        if (((H = +H), (q = q >>> 0), (ee = ee >>> 0), !ce)) {
          const ht = Math.pow(2, 8 * ee) - 1;
          G(this, H, q, ee, ht, 0);
        }
        let pe = ee - 1,
          we = 1;
        for (this[q + pe] = H & 255; --pe >= 0 && (we *= 256); )
          this[q + pe] = (H / we) & 255;
        return q + ee;
      }),
    (u.prototype.writeUint8 = u.prototype.writeUInt8 =
      function (H, q, ee) {
        return (
          (H = +H),
          (q = q >>> 0),
          ee || G(this, H, q, 1, 255, 0),
          (this[q] = H & 255),
          q + 1
        );
      }),
    (u.prototype.writeUint16LE = u.prototype.writeUInt16LE =
      function (H, q, ee) {
        return (
          (H = +H),
          (q = q >>> 0),
          ee || G(this, H, q, 2, 65535, 0),
          (this[q] = H & 255),
          (this[q + 1] = H >>> 8),
          q + 2
        );
      }),
    (u.prototype.writeUint16BE = u.prototype.writeUInt16BE =
      function (H, q, ee) {
        return (
          (H = +H),
          (q = q >>> 0),
          ee || G(this, H, q, 2, 65535, 0),
          (this[q] = H >>> 8),
          (this[q + 1] = H & 255),
          q + 2
        );
      }),
    (u.prototype.writeUint32LE = u.prototype.writeUInt32LE =
      function (H, q, ee) {
        return (
          (H = +H),
          (q = q >>> 0),
          ee || G(this, H, q, 4, 4294967295, 0),
          (this[q + 3] = H >>> 24),
          (this[q + 2] = H >>> 16),
          (this[q + 1] = H >>> 8),
          (this[q] = H & 255),
          q + 4
        );
      }),
    (u.prototype.writeUint32BE = u.prototype.writeUInt32BE =
      function (H, q, ee) {
        return (
          (H = +H),
          (q = q >>> 0),
          ee || G(this, H, q, 4, 4294967295, 0),
          (this[q] = H >>> 24),
          (this[q + 1] = H >>> 16),
          (this[q + 2] = H >>> 8),
          (this[q + 3] = H & 255),
          q + 4
        );
      });
  function ne(Q, H, q, ee, ce) {
    Be(H, ee, ce, Q, q, 7);
    let pe = Number(H & BigInt(4294967295));
    (Q[q++] = pe),
      (pe = pe >> 8),
      (Q[q++] = pe),
      (pe = pe >> 8),
      (Q[q++] = pe),
      (pe = pe >> 8),
      (Q[q++] = pe);
    let we = Number((H >> BigInt(32)) & BigInt(4294967295));
    return (
      (Q[q++] = we),
      (we = we >> 8),
      (Q[q++] = we),
      (we = we >> 8),
      (Q[q++] = we),
      (we = we >> 8),
      (Q[q++] = we),
      q
    );
  }
  function ae(Q, H, q, ee, ce) {
    Be(H, ee, ce, Q, q, 7);
    let pe = Number(H & BigInt(4294967295));
    (Q[q + 7] = pe),
      (pe = pe >> 8),
      (Q[q + 6] = pe),
      (pe = pe >> 8),
      (Q[q + 5] = pe),
      (pe = pe >> 8),
      (Q[q + 4] = pe);
    let we = Number((H >> BigInt(32)) & BigInt(4294967295));
    return (
      (Q[q + 3] = we),
      (we = we >> 8),
      (Q[q + 2] = we),
      (we = we >> 8),
      (Q[q + 1] = we),
      (we = we >> 8),
      (Q[q] = we),
      q + 8
    );
  }
  (u.prototype.writeBigUInt64LE = Tt(function (H, q = 0) {
    return ne(this, H, q, BigInt(0), BigInt("0xffffffffffffffff"));
  })),
    (u.prototype.writeBigUInt64BE = Tt(function (H, q = 0) {
      return ae(this, H, q, BigInt(0), BigInt("0xffffffffffffffff"));
    })),
    (u.prototype.writeIntLE = function (H, q, ee, ce) {
      if (((H = +H), (q = q >>> 0), !ce)) {
        const vt = Math.pow(2, 8 * ee - 1);
        G(this, H, q, ee, vt - 1, -vt);
      }
      let pe = 0,
        we = 1,
        ht = 0;
      for (this[q] = H & 255; ++pe < ee && (we *= 256); )
        H < 0 && ht === 0 && this[q + pe - 1] !== 0 && (ht = 1),
          (this[q + pe] = (((H / we) >> 0) - ht) & 255);
      return q + ee;
    }),
    (u.prototype.writeIntBE = function (H, q, ee, ce) {
      if (((H = +H), (q = q >>> 0), !ce)) {
        const vt = Math.pow(2, 8 * ee - 1);
        G(this, H, q, ee, vt - 1, -vt);
      }
      let pe = ee - 1,
        we = 1,
        ht = 0;
      for (this[q + pe] = H & 255; --pe >= 0 && (we *= 256); )
        H < 0 && ht === 0 && this[q + pe + 1] !== 0 && (ht = 1),
          (this[q + pe] = (((H / we) >> 0) - ht) & 255);
      return q + ee;
    }),
    (u.prototype.writeInt8 = function (H, q, ee) {
      return (
        (H = +H),
        (q = q >>> 0),
        ee || G(this, H, q, 1, 127, -128),
        H < 0 && (H = 255 + H + 1),
        (this[q] = H & 255),
        q + 1
      );
    }),
    (u.prototype.writeInt16LE = function (H, q, ee) {
      return (
        (H = +H),
        (q = q >>> 0),
        ee || G(this, H, q, 2, 32767, -32768),
        (this[q] = H & 255),
        (this[q + 1] = H >>> 8),
        q + 2
      );
    }),
    (u.prototype.writeInt16BE = function (H, q, ee) {
      return (
        (H = +H),
        (q = q >>> 0),
        ee || G(this, H, q, 2, 32767, -32768),
        (this[q] = H >>> 8),
        (this[q + 1] = H & 255),
        q + 2
      );
    }),
    (u.prototype.writeInt32LE = function (H, q, ee) {
      return (
        (H = +H),
        (q = q >>> 0),
        ee || G(this, H, q, 4, 2147483647, -2147483648),
        (this[q] = H & 255),
        (this[q + 1] = H >>> 8),
        (this[q + 2] = H >>> 16),
        (this[q + 3] = H >>> 24),
        q + 4
      );
    }),
    (u.prototype.writeInt32BE = function (H, q, ee) {
      return (
        (H = +H),
        (q = q >>> 0),
        ee || G(this, H, q, 4, 2147483647, -2147483648),
        H < 0 && (H = 4294967295 + H + 1),
        (this[q] = H >>> 24),
        (this[q + 1] = H >>> 16),
        (this[q + 2] = H >>> 8),
        (this[q + 3] = H & 255),
        q + 4
      );
    }),
    (u.prototype.writeBigInt64LE = Tt(function (H, q = 0) {
      return ne(
        this,
        H,
        q,
        -BigInt("0x8000000000000000"),
        BigInt("0x7fffffffffffffff")
      );
    })),
    (u.prototype.writeBigInt64BE = Tt(function (H, q = 0) {
      return ae(
        this,
        H,
        q,
        -BigInt("0x8000000000000000"),
        BigInt("0x7fffffffffffffff")
      );
    }));
  function le(Q, H, q, ee, ce, pe) {
    if (q + ee > Q.length) throw new RangeError("Index out of range");
    if (q < 0) throw new RangeError("Index out of range");
  }
  function ge(Q, H, q, ee, ce) {
    return (
      (H = +H),
      (q = q >>> 0),
      ce || le(Q, H, q, 4),
      n.write(Q, H, q, ee, 23, 4),
      q + 4
    );
  }
  (u.prototype.writeFloatLE = function (H, q, ee) {
    return ge(this, H, q, !0, ee);
  }),
    (u.prototype.writeFloatBE = function (H, q, ee) {
      return ge(this, H, q, !1, ee);
    });
  function Oe(Q, H, q, ee, ce) {
    return (
      (H = +H),
      (q = q >>> 0),
      ce || le(Q, H, q, 8),
      n.write(Q, H, q, ee, 52, 8),
      q + 8
    );
  }
  (u.prototype.writeDoubleLE = function (H, q, ee) {
    return Oe(this, H, q, !0, ee);
  }),
    (u.prototype.writeDoubleBE = function (H, q, ee) {
      return Oe(this, H, q, !1, ee);
    }),
    (u.prototype.copy = function (H, q, ee, ce) {
      if (!u.isBuffer(H)) throw new TypeError("argument should be a Buffer");
      if (
        (ee || (ee = 0),
        !ce && ce !== 0 && (ce = this.length),
        q >= H.length && (q = H.length),
        q || (q = 0),
        ce > 0 && ce < ee && (ce = ee),
        ce === ee || H.length === 0 || this.length === 0)
      )
        return 0;
      if (q < 0) throw new RangeError("targetStart out of bounds");
      if (ee < 0 || ee >= this.length)
        throw new RangeError("Index out of range");
      if (ce < 0) throw new RangeError("sourceEnd out of bounds");
      ce > this.length && (ce = this.length),
        H.length - q < ce - ee && (ce = H.length - q + ee);
      const pe = ce - ee;
      return (
        this === H && typeof s.prototype.copyWithin == "function"
          ? this.copyWithin(q, ee, ce)
          : s.prototype.set.call(H, this.subarray(ee, ce), q),
        pe
      );
    }),
    (u.prototype.fill = function (H, q, ee, ce) {
      if (typeof H == "string") {
        if (
          (typeof q == "string"
            ? ((ce = q), (q = 0), (ee = this.length))
            : typeof ee == "string" && ((ce = ee), (ee = this.length)),
          ce !== void 0 && typeof ce != "string")
        )
          throw new TypeError("encoding must be a string");
        if (typeof ce == "string" && !u.isEncoding(ce))
          throw new TypeError("Unknown encoding: " + ce);
        if (H.length === 1) {
          const we = H.charCodeAt(0);
          ((ce === "utf8" && we < 128) || ce === "latin1") && (H = we);
        }
      } else
        typeof H == "number"
          ? (H = H & 255)
          : typeof H == "boolean" && (H = Number(H));
      if (q < 0 || this.length < q || this.length < ee)
        throw new RangeError("Out of range index");
      if (ee <= q) return this;
      (q = q >>> 0),
        (ee = ee === void 0 ? this.length : ee >>> 0),
        H || (H = 0);
      let pe;
      if (typeof H == "number") for (pe = q; pe < ee; ++pe) this[pe] = H;
      else {
        const we = u.isBuffer(H) ? H : u.from(H, ce),
          ht = we.length;
        if (ht === 0)
          throw new TypeError(
            'The value "' + H + '" is invalid for argument "value"'
          );
        for (pe = 0; pe < ee - q; ++pe) this[pe + q] = we[pe % ht];
      }
      return this;
    });
  const _e = {};
  function Ee(Q, H, q) {
    _e[Q] = class extends q {
      constructor() {
        super(),
          Object.defineProperty(this, "message", {
            value: H.apply(this, arguments),
            writable: !0,
            configurable: !0,
          }),
          (this.name = `${this.name} [${Q}]`),
          this.stack,
          delete this.name;
      }
      get code() {
        return Q;
      }
      set code(ce) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: ce,
          writable: !0,
        });
      }
      toString() {
        return `${this.name} [${Q}]: ${this.message}`;
      }
    };
  }
  Ee(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function (Q) {
      return Q
        ? `${Q} is outside of buffer bounds`
        : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ),
    Ee(
      "ERR_INVALID_ARG_TYPE",
      function (Q, H) {
        return `The "${Q}" argument must be of type number. Received type ${typeof H}`;
      },
      TypeError
    ),
    Ee(
      "ERR_OUT_OF_RANGE",
      function (Q, H, q) {
        let ee = `The value of "${Q}" is out of range.`,
          ce = q;
        return (
          Number.isInteger(q) && Math.abs(q) > 2 ** 32
            ? (ce = He(String(q)))
            : typeof q == "bigint" &&
              ((ce = String(q)),
              (q > BigInt(2) ** BigInt(32) || q < -(BigInt(2) ** BigInt(32))) &&
                (ce = He(ce)),
              (ce += "n")),
          (ee += ` It must be ${H}. Received ${ce}`),
          ee
        );
      },
      RangeError
    );
  function He(Q) {
    let H = "",
      q = Q.length;
    const ee = Q[0] === "-" ? 1 : 0;
    for (; q >= ee + 4; q -= 3) H = `_${Q.slice(q - 3, q)}${H}`;
    return `${Q.slice(0, q)}${H}`;
  }
  function je(Q, H, q) {
    rn(H, "offset"),
      (Q[H] === void 0 || Q[H + q] === void 0) && Wt(H, Q.length - (q + 1));
  }
  function Be(Q, H, q, ee, ce, pe) {
    if (Q > q || Q < H) {
      const we = typeof H == "bigint" ? "n" : "";
      let ht;
      throw (
        (H === 0 || H === BigInt(0)
          ? (ht = `>= 0${we} and < 2${we} ** ${(pe + 1) * 8}${we}`)
          : (ht = `>= -(2${we} ** ${(pe + 1) * 8 - 1}${we}) and < 2 ** ${
              (pe + 1) * 8 - 1
            }${we}`),
        new _e.ERR_OUT_OF_RANGE("value", ht, Q))
      );
    }
    je(ee, ce, pe);
  }
  function rn(Q, H) {
    if (typeof Q != "number") throw new _e.ERR_INVALID_ARG_TYPE(H, "number", Q);
  }
  function Wt(Q, H, q) {
    throw Math.floor(Q) !== Q
      ? (rn(Q, q), new _e.ERR_OUT_OF_RANGE("offset", "an integer", Q))
      : H < 0
      ? new _e.ERR_BUFFER_OUT_OF_BOUNDS()
      : new _e.ERR_OUT_OF_RANGE("offset", `>= 0 and <= ${H}`, Q);
  }
  const Mt = /[^+/0-9A-Za-z-_]/g;
  function an(Q) {
    if (((Q = Q.split("=")[0]), (Q = Q.trim().replace(Mt, "")), Q.length < 2))
      return "";
    for (; Q.length % 4 !== 0; ) Q = Q + "=";
    return Q;
  }
  function kt(Q, H) {
    H = H || 1 / 0;
    let q;
    const ee = Q.length;
    let ce = null;
    const pe = [];
    for (let we = 0; we < ee; ++we) {
      if (((q = Q.charCodeAt(we)), q > 55295 && q < 57344)) {
        if (!ce) {
          if (q > 56319) {
            (H -= 3) > -1 && pe.push(239, 191, 189);
            continue;
          } else if (we + 1 === ee) {
            (H -= 3) > -1 && pe.push(239, 191, 189);
            continue;
          }
          ce = q;
          continue;
        }
        if (q < 56320) {
          (H -= 3) > -1 && pe.push(239, 191, 189), (ce = q);
          continue;
        }
        q = (((ce - 55296) << 10) | (q - 56320)) + 65536;
      } else ce && (H -= 3) > -1 && pe.push(239, 191, 189);
      if (((ce = null), q < 128)) {
        if ((H -= 1) < 0) break;
        pe.push(q);
      } else if (q < 2048) {
        if ((H -= 2) < 0) break;
        pe.push((q >> 6) | 192, (q & 63) | 128);
      } else if (q < 65536) {
        if ((H -= 3) < 0) break;
        pe.push((q >> 12) | 224, ((q >> 6) & 63) | 128, (q & 63) | 128);
      } else if (q < 1114112) {
        if ((H -= 4) < 0) break;
        pe.push(
          (q >> 18) | 240,
          ((q >> 12) & 63) | 128,
          ((q >> 6) & 63) | 128,
          (q & 63) | 128
        );
      } else throw new Error("Invalid code point");
    }
    return pe;
  }
  function Qe(Q) {
    const H = [];
    for (let q = 0; q < Q.length; ++q) H.push(Q.charCodeAt(q) & 255);
    return H;
  }
  function Vt(Q, H) {
    let q, ee, ce;
    const pe = [];
    for (let we = 0; we < Q.length && !((H -= 2) < 0); ++we)
      (q = Q.charCodeAt(we)),
        (ee = q >> 8),
        (ce = q % 256),
        pe.push(ce),
        pe.push(ee);
    return pe;
  }
  function Rt(Q) {
    return t.toByteArray(an(Q));
  }
  function mt(Q, H, q, ee) {
    let ce;
    for (ce = 0; ce < ee && !(ce + q >= H.length || ce >= Q.length); ++ce)
      H[ce + q] = Q[ce];
    return ce;
  }
  function Pt(Q, H) {
    return (
      Q instanceof H ||
      (Q != null &&
        Q.constructor != null &&
        Q.constructor.name != null &&
        Q.constructor.name === H.name)
    );
  }
  function wn(Q) {
    return Q !== Q;
  }
  const xt = (function () {
    const Q = "0123456789abcdef",
      H = new Array(256);
    for (let q = 0; q < 16; ++q) {
      const ee = q * 16;
      for (let ce = 0; ce < 16; ++ce) H[ee + ce] = Q[q] + Q[ce];
    }
    return H;
  })();
  function Tt(Q) {
    return typeof BigInt > "u" ? _n : Q;
  }
  function _n() {
    throw new Error("BigInt not supported");
  }
})(so);
const It = so.Buffer,
  Fye = so.Blob,
  Uye = so.BlobOptions,
  Xt = so.Buffer,
  $ye = so.File,
  zye = so.FileOptions,
  Wye = so.INSPECT_MAX_BYTES,
  Hye = so.SlowBuffer,
  Vye = so.TranscodeEncoding,
  Gye = so.atob,
  qye = so.btoa,
  Kye = so.constants,
  Yye = so.isAscii,
  Zye = so.isUtf8,
  Qye = so.kMaxLength,
  Xye = so.kStringMaxLength,
  Jye = so.resolveObjectURL,
  eve = so.transcode,
  tve = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        Blob: Fye,
        BlobOptions: Uye,
        Buffer: Xt,
        File: $ye,
        FileOptions: zye,
        INSPECT_MAX_BYTES: Wye,
        SlowBuffer: Hye,
        TranscodeEncoding: Vye,
        atob: Gye,
        btoa: qye,
        constants: Kye,
        default: It,
        isAscii: Yye,
        isUtf8: Zye,
        kMaxLength: Qye,
        kStringMaxLength: Xye,
        resolveObjectURL: Jye,
        transcode: eve,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  );
function t5(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`positive integer expected, not ${e}`);
}
function nve(e) {
  return (
    e instanceof Uint8Array ||
    (e != null && typeof e == "object" && e.constructor.name === "Uint8Array")
  );
}
function fx(e, ...t) {
  if (!nve(e)) throw new Error("Uint8Array expected");
  if (t.length > 0 && !t.includes(e.length))
    throw new Error(
      `Uint8Array expected of length ${t}, not of length=${e.length}`
    );
}
function rve(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  t5(e.outputLen), t5(e.blockLen);
}
function xy(e, t = !0) {
  if (e.destroyed) throw new Error("Hash instance has been destroyed");
  if (t && e.finished) throw new Error("Hash#digest() has already been called");
}
function lZ(e, t) {
  fx(e);
  const n = t.outputLen;
  if (e.length < n)
    throw new Error(
      `digestInto() expects output buffer of length at least ${n}`
    );
}
const W1 =
  typeof globalThis == "object" && "crypto" in globalThis
    ? globalThis.crypto
    : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const ive =
    (e) =>
      new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4)),
  OA = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength),
  Gu = (e, t) => (e << (32 - t)) | (e >>> t),
  MF = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68,
  sve = (e) =>
    ((e << 24) & 4278190080) |
    ((e << 8) & 16711680) |
    ((e >>> 8) & 65280) |
    ((e >>> 24) & 255);
function IF(e) {
  for (let t = 0; t < e.length; t++) e[t] = sve(e[t]);
}
function ove(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
function r8(e) {
  return typeof e == "string" && (e = ove(e)), fx(e), e;
}
function ave(...e) {
  let t = 0;
  for (let r = 0; r < e.length; r++) {
    const i = e[r];
    fx(i), (t += i.length);
  }
  const n = new Uint8Array(t);
  for (let r = 0, i = 0; r < e.length; r++) {
    const s = e[r];
    n.set(s, i), (i += s.length);
  }
  return n;
}
let UN = class {
  clone() {
    return this._cloneInto();
  }
};
function $N(e) {
  const t = (r) => e().update(r8(r)).digest(),
    n = e();
  return (
    (t.outputLen = n.outputLen),
    (t.blockLen = n.blockLen),
    (t.create = () => e()),
    t
  );
}
function cZ(e = 32) {
  if (W1 && typeof W1.getRandomValues == "function")
    return W1.getRandomValues(new Uint8Array(e));
  if (W1 && typeof W1.randomBytes == "function") return W1.randomBytes(e);
  throw new Error("crypto.getRandomValues must be defined");
}
function lve(e, t, n, r) {
  if (typeof e.setBigUint64 == "function") return e.setBigUint64(t, n, r);
  const i = BigInt(32),
    s = BigInt(4294967295),
    o = Number((n >> i) & s),
    a = Number(n & s),
    l = r ? 4 : 0,
    c = r ? 0 : 4;
  e.setUint32(t + l, o, r), e.setUint32(t + c, a, r);
}
const cve = (e, t, n) => (e & t) ^ (~e & n),
  uve = (e, t, n) => (e & t) ^ (e & n) ^ (t & n);
class uZ extends UN {
  constructor(t, n, r, i) {
    super(),
      (this.blockLen = t),
      (this.outputLen = n),
      (this.padOffset = r),
      (this.isLE = i),
      (this.finished = !1),
      (this.length = 0),
      (this.pos = 0),
      (this.destroyed = !1),
      (this.buffer = new Uint8Array(t)),
      (this.view = OA(this.buffer));
  }
  update(t) {
    xy(this);
    const { view: n, buffer: r, blockLen: i } = this;
    t = r8(t);
    const s = t.length;
    for (let o = 0; o < s; ) {
      const a = Math.min(i - this.pos, s - o);
      if (a === i) {
        const l = OA(t);
        for (; i <= s - o; o += i) this.process(l, o);
        continue;
      }
      r.set(t.subarray(o, o + a), this.pos),
        (this.pos += a),
        (o += a),
        this.pos === i && (this.process(n, 0), (this.pos = 0));
    }
    return (this.length += t.length), this.roundClean(), this;
  }
  digestInto(t) {
    xy(this), lZ(t, this), (this.finished = !0);
    const { buffer: n, view: r, blockLen: i, isLE: s } = this;
    let { pos: o } = this;
    (n[o++] = 128),
      this.buffer.subarray(o).fill(0),
      this.padOffset > i - o && (this.process(r, 0), (o = 0));
    for (let d = o; d < i; d++) n[d] = 0;
    lve(r, i - 8, BigInt(this.length * 8), s), this.process(r, 0);
    const a = OA(t),
      l = this.outputLen;
    if (l % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const c = l / 4,
      u = this.get();
    if (c > u.length) throw new Error("_sha2: outputLen bigger than state");
    for (let d = 0; d < c; d++) a.setUint32(4 * d, u[d], s);
  }
  digest() {
    const { buffer: t, outputLen: n } = this;
    this.digestInto(t);
    const r = t.slice(0, n);
    return this.destroy(), r;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const {
      blockLen: n,
      buffer: r,
      length: i,
      finished: s,
      destroyed: o,
      pos: a,
    } = this;
    return (
      (t.length = i),
      (t.pos = a),
      (t.finished = s),
      (t.destroyed = o),
      i % n && t.buffer.set(r),
      t
    );
  }
}
const __ = BigInt(2 ** 32 - 1),
  rT = BigInt(32);
function dZ(e, t = !1) {
  return t
    ? { h: Number(e & __), l: Number((e >> rT) & __) }
    : { h: Number((e >> rT) & __) | 0, l: Number(e & __) | 0 };
}
function fZ(e, t = !1) {
  let n = new Uint32Array(e.length),
    r = new Uint32Array(e.length);
  for (let i = 0; i < e.length; i++) {
    const { h: s, l: o } = dZ(e[i], t);
    [n[i], r[i]] = [s, o];
  }
  return [n, r];
}
const dve = (e, t) => (BigInt(e >>> 0) << rT) | BigInt(t >>> 0),
  fve = (e, t, n) => e >>> n,
  hve = (e, t, n) => (e << (32 - n)) | (t >>> n),
  pve = (e, t, n) => (e >>> n) | (t << (32 - n)),
  mve = (e, t, n) => (e << (32 - n)) | (t >>> n),
  gve = (e, t, n) => (e << (64 - n)) | (t >>> (n - 32)),
  yve = (e, t, n) => (e >>> (n - 32)) | (t << (64 - n)),
  vve = (e, t) => t,
  wve = (e, t) => e,
  hZ = (e, t, n) => (e << n) | (t >>> (32 - n)),
  pZ = (e, t, n) => (t << n) | (e >>> (32 - n)),
  mZ = (e, t, n) => (t << (n - 32)) | (e >>> (64 - n)),
  gZ = (e, t, n) => (e << (n - 32)) | (t >>> (64 - n));
function bve(e, t, n, r) {
  const i = (t >>> 0) + (r >>> 0);
  return { h: (e + n + ((i / 2 ** 32) | 0)) | 0, l: i | 0 };
}
const xve = (e, t, n) => (e >>> 0) + (t >>> 0) + (n >>> 0),
  _ve = (e, t, n, r) => (t + n + r + ((e / 2 ** 32) | 0)) | 0,
  Sve = (e, t, n, r) => (e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0),
  Eve = (e, t, n, r, i) => (t + n + r + i + ((e / 2 ** 32) | 0)) | 0,
  Ave = (e, t, n, r, i) =>
    (e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0) + (i >>> 0),
  Cve = (e, t, n, r, i, s) => (t + n + r + i + s + ((e / 2 ** 32) | 0)) | 0,
  Xn = {
    fromBig: dZ,
    split: fZ,
    toBig: dve,
    shrSH: fve,
    shrSL: hve,
    rotrSH: pve,
    rotrSL: mve,
    rotrBH: gve,
    rotrBL: yve,
    rotr32H: vve,
    rotr32L: wve,
    rotlSH: hZ,
    rotlSL: pZ,
    rotlBH: mZ,
    rotlBL: gZ,
    add: bve,
    add3L: xve,
    add3H: _ve,
    add4L: Sve,
    add4H: Eve,
    add5H: Cve,
    add5L: Ave,
  },
  [kve, Tve] = Xn.split(
    [
      "0x428a2f98d728ae22",
      "0x7137449123ef65cd",
      "0xb5c0fbcfec4d3b2f",
      "0xe9b5dba58189dbbc",
      "0x3956c25bf348b538",
      "0x59f111f1b605d019",
      "0x923f82a4af194f9b",
      "0xab1c5ed5da6d8118",
      "0xd807aa98a3030242",
      "0x12835b0145706fbe",
      "0x243185be4ee4b28c",
      "0x550c7dc3d5ffb4e2",
      "0x72be5d74f27b896f",
      "0x80deb1fe3b1696b1",
      "0x9bdc06a725c71235",
      "0xc19bf174cf692694",
      "0xe49b69c19ef14ad2",
      "0xefbe4786384f25e3",
      "0x0fc19dc68b8cd5b5",
      "0x240ca1cc77ac9c65",
      "0x2de92c6f592b0275",
      "0x4a7484aa6ea6e483",
      "0x5cb0a9dcbd41fbd4",
      "0x76f988da831153b5",
      "0x983e5152ee66dfab",
      "0xa831c66d2db43210",
      "0xb00327c898fb213f",
      "0xbf597fc7beef0ee4",
      "0xc6e00bf33da88fc2",
      "0xd5a79147930aa725",
      "0x06ca6351e003826f",
      "0x142929670a0e6e70",
      "0x27b70a8546d22ffc",
      "0x2e1b21385c26c926",
      "0x4d2c6dfc5ac42aed",
      "0x53380d139d95b3df",
      "0x650a73548baf63de",
      "0x766a0abb3c77b2a8",
      "0x81c2c92e47edaee6",
      "0x92722c851482353b",
      "0xa2bfe8a14cf10364",
      "0xa81a664bbc423001",
      "0xc24b8b70d0f89791",
      "0xc76c51a30654be30",
      "0xd192e819d6ef5218",
      "0xd69906245565a910",
      "0xf40e35855771202a",
      "0x106aa07032bbd1b8",
      "0x19a4c116b8d2d0c8",
      "0x1e376c085141ab53",
      "0x2748774cdf8eeb99",
      "0x34b0bcb5e19b48a8",
      "0x391c0cb3c5c95a63",
      "0x4ed8aa4ae3418acb",
      "0x5b9cca4f7763e373",
      "0x682e6ff3d6b2b8a3",
      "0x748f82ee5defb2fc",
      "0x78a5636f43172f60",
      "0x84c87814a1f0ab72",
      "0x8cc702081a6439ec",
      "0x90befffa23631e28",
      "0xa4506cebde82bde9",
      "0xbef9a3f7b2c67915",
      "0xc67178f2e372532b",
      "0xca273eceea26619c",
      "0xd186b8c721c0c207",
      "0xeada7dd6cde0eb1e",
      "0xf57d4f7fee6ed178",
      "0x06f067aa72176fba",
      "0x0a637dc5a2c898a6",
      "0x113f9804bef90dae",
      "0x1b710b35131c471b",
      "0x28db77f523047d84",
      "0x32caab7b40c72493",
      "0x3c9ebe0a15c9bebc",
      "0x431d67c49c100d4c",
      "0x4cc5d4becb3e42b6",
      "0x597f299cfc657e2a",
      "0x5fcb6fab3ad6faec",
      "0x6c44198c4a475817",
    ].map((e) => BigInt(e))
  ),
  Kh = new Uint32Array(80),
  Yh = new Uint32Array(80);
let Mve = class extends uZ {
  constructor() {
    super(128, 64, 16, !1),
      (this.Ah = 1779033703),
      (this.Al = -205731576),
      (this.Bh = -1150833019),
      (this.Bl = -2067093701),
      (this.Ch = 1013904242),
      (this.Cl = -23791573),
      (this.Dh = -1521486534),
      (this.Dl = 1595750129),
      (this.Eh = 1359893119),
      (this.El = -1377402159),
      (this.Fh = -1694144372),
      (this.Fl = 725511199),
      (this.Gh = 528734635),
      (this.Gl = -79577749),
      (this.Hh = 1541459225),
      (this.Hl = 327033209);
  }
  get() {
    const {
      Ah: t,
      Al: n,
      Bh: r,
      Bl: i,
      Ch: s,
      Cl: o,
      Dh: a,
      Dl: l,
      Eh: c,
      El: u,
      Fh: d,
      Fl: f,
      Gh: h,
      Gl: p,
      Hh: g,
      Hl: b,
    } = this;
    return [t, n, r, i, s, o, a, l, c, u, d, f, h, p, g, b];
  }
  set(t, n, r, i, s, o, a, l, c, u, d, f, h, p, g, b) {
    (this.Ah = t | 0),
      (this.Al = n | 0),
      (this.Bh = r | 0),
      (this.Bl = i | 0),
      (this.Ch = s | 0),
      (this.Cl = o | 0),
      (this.Dh = a | 0),
      (this.Dl = l | 0),
      (this.Eh = c | 0),
      (this.El = u | 0),
      (this.Fh = d | 0),
      (this.Fl = f | 0),
      (this.Gh = h | 0),
      (this.Gl = p | 0),
      (this.Hh = g | 0),
      (this.Hl = b | 0);
  }
  process(t, n) {
    for (let x = 0; x < 16; x++, n += 4)
      (Kh[x] = t.getUint32(n)), (Yh[x] = t.getUint32((n += 4)));
    for (let x = 16; x < 80; x++) {
      const S = Kh[x - 15] | 0,
        R = Yh[x - 15] | 0,
        O = Xn.rotrSH(S, R, 1) ^ Xn.rotrSH(S, R, 8) ^ Xn.shrSH(S, R, 7),
        B = Xn.rotrSL(S, R, 1) ^ Xn.rotrSL(S, R, 8) ^ Xn.shrSL(S, R, 7),
        C = Kh[x - 2] | 0,
        I = Yh[x - 2] | 0,
        P = Xn.rotrSH(C, I, 19) ^ Xn.rotrBH(C, I, 61) ^ Xn.shrSH(C, I, 6),
        M = Xn.rotrSL(C, I, 19) ^ Xn.rotrBL(C, I, 61) ^ Xn.shrSL(C, I, 6),
        k = Xn.add4L(B, M, Yh[x - 7], Yh[x - 16]),
        T = Xn.add4H(k, O, P, Kh[x - 7], Kh[x - 16]);
      (Kh[x] = T | 0), (Yh[x] = k | 0);
    }
    let {
      Ah: r,
      Al: i,
      Bh: s,
      Bl: o,
      Ch: a,
      Cl: l,
      Dh: c,
      Dl: u,
      Eh: d,
      El: f,
      Fh: h,
      Fl: p,
      Gh: g,
      Gl: b,
      Hh: v,
      Hl: w,
    } = this;
    for (let x = 0; x < 80; x++) {
      const S = Xn.rotrSH(d, f, 14) ^ Xn.rotrSH(d, f, 18) ^ Xn.rotrBH(d, f, 41),
        R = Xn.rotrSL(d, f, 14) ^ Xn.rotrSL(d, f, 18) ^ Xn.rotrBL(d, f, 41),
        O = (d & h) ^ (~d & g),
        B = (f & p) ^ (~f & b),
        C = Xn.add5L(w, R, B, Tve[x], Yh[x]),
        I = Xn.add5H(C, v, S, O, kve[x], Kh[x]),
        P = C | 0,
        M = Xn.rotrSH(r, i, 28) ^ Xn.rotrBH(r, i, 34) ^ Xn.rotrBH(r, i, 39),
        k = Xn.rotrSL(r, i, 28) ^ Xn.rotrBL(r, i, 34) ^ Xn.rotrBL(r, i, 39),
        T = (r & s) ^ (r & a) ^ (s & a),
        _ = (i & o) ^ (i & l) ^ (o & l);
      (v = g | 0),
        (w = b | 0),
        (g = h | 0),
        (b = p | 0),
        (h = d | 0),
        (p = f | 0),
        ({ h: d, l: f } = Xn.add(c | 0, u | 0, I | 0, P | 0)),
        (c = a | 0),
        (u = l | 0),
        (a = s | 0),
        (l = o | 0),
        (s = r | 0),
        (o = i | 0);
      const A = Xn.add3L(P, k, _);
      (r = Xn.add3H(A, I, M, T)), (i = A | 0);
    }
    ({ h: r, l: i } = Xn.add(this.Ah | 0, this.Al | 0, r | 0, i | 0)),
      ({ h: s, l: o } = Xn.add(this.Bh | 0, this.Bl | 0, s | 0, o | 0)),
      ({ h: a, l } = Xn.add(this.Ch | 0, this.Cl | 0, a | 0, l | 0)),
      ({ h: c, l: u } = Xn.add(this.Dh | 0, this.Dl | 0, c | 0, u | 0)),
      ({ h: d, l: f } = Xn.add(this.Eh | 0, this.El | 0, d | 0, f | 0)),
      ({ h, l: p } = Xn.add(this.Fh | 0, this.Fl | 0, h | 0, p | 0)),
      ({ h: g, l: b } = Xn.add(this.Gh | 0, this.Gl | 0, g | 0, b | 0)),
      ({ h: v, l: w } = Xn.add(this.Hh | 0, this.Hl | 0, v | 0, w | 0)),
      this.set(r, i, s, o, a, l, c, u, d, f, h, p, g, b, v, w);
  }
  roundClean() {
    Kh.fill(0), Yh.fill(0);
  }
  destroy() {
    this.buffer.fill(0),
      this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
const Ive = $N(() => new Mve());
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const zN =
    BigInt(0),
  i8 = BigInt(1),
  Nve = BigInt(2);
function zm(e) {
  return (
    e instanceof Uint8Array ||
    (e != null && typeof e == "object" && e.constructor.name === "Uint8Array")
  );
}
function hx(e) {
  if (!zm(e)) throw new Error("Uint8Array expected");
}
function Yf(e, t) {
  if (typeof t != "boolean")
    throw new Error(`${e} must be valid boolean, got "${t}".`);
}
const Rve = Array.from({ length: 256 }, (e, t) =>
  t.toString(16).padStart(2, "0")
);
function Wm(e) {
  hx(e);
  let t = "";
  for (let n = 0; n < e.length; n++) t += Rve[e[n]];
  return t;
}
function xg(e) {
  const t = e.toString(16);
  return t.length & 1 ? `0${t}` : t;
}
function WN(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  return BigInt(e === "" ? "0" : `0x${e}`);
}
const pf = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function NF(e) {
  if (e >= pf._0 && e <= pf._9) return e - pf._0;
  if (e >= pf._A && e <= pf._F) return e - (pf._A - 10);
  if (e >= pf._a && e <= pf._f) return e - (pf._a - 10);
}
function _y(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  const t = e.length,
    n = t / 2;
  if (t % 2)
    throw new Error(
      "padded hex string expected, got unpadded hex of length " + t
    );
  const r = new Uint8Array(n);
  for (let i = 0, s = 0; i < n; i++, s += 2) {
    const o = NF(e.charCodeAt(s)),
      a = NF(e.charCodeAt(s + 1));
    if (o === void 0 || a === void 0) {
      const l = e[s] + e[s + 1];
      throw new Error(
        'hex string expected, got non-hex character "' + l + '" at index ' + s
      );
    }
    r[i] = o * 16 + a;
  }
  return r;
}
function Am(e) {
  return WN(Wm(e));
}
function Gg(e) {
  return hx(e), WN(Wm(Uint8Array.from(e).reverse()));
}
function Sy(e, t) {
  return _y(e.toString(16).padStart(t * 2, "0"));
}
function rb(e, t) {
  return Sy(e, t).reverse();
}
function Ove(e) {
  return _y(xg(e));
}
function Qs(e, t, n) {
  let r;
  if (typeof t == "string")
    try {
      r = _y(t);
    } catch (s) {
      throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${s}`);
    }
  else if (zm(t)) r = Uint8Array.from(t);
  else throw new Error(`${e} must be hex string or Uint8Array`);
  const i = r.length;
  if (typeof n == "number" && i !== n)
    throw new Error(`${e} expected ${n} bytes, got ${i}`);
  return r;
}
function Hm(...e) {
  let t = 0;
  for (let r = 0; r < e.length; r++) {
    const i = e[r];
    hx(i), (t += i.length);
  }
  const n = new Uint8Array(t);
  for (let r = 0, i = 0; r < e.length; r++) {
    const s = e[r];
    n.set(s, i), (i += s.length);
  }
  return n;
}
function Pve(e, t) {
  if (e.length !== t.length) return !1;
  let n = 0;
  for (let r = 0; r < e.length; r++) n |= e[r] ^ t[r];
  return n === 0;
}
function Lve(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
const PA = (e) => typeof e == "bigint" && zN <= e;
function s8(e, t, n) {
  return PA(e) && PA(t) && PA(n) && t <= e && e < n;
}
function bc(e, t, n, r) {
  if (!s8(t, n, r))
    throw new Error(
      `expected valid ${e}: ${n} <= n < ${r}, got ${typeof t} ${t}`
    );
}
function yZ(e) {
  let t;
  for (t = 0; e > zN; e >>= i8, t += 1);
  return t;
}
function jve(e, t) {
  return (e >> BigInt(t)) & i8;
}
function Dve(e, t, n) {
  return e | ((n ? i8 : zN) << BigInt(t));
}
const HN = (e) => (Nve << BigInt(e - 1)) - i8,
  LA = (e) => new Uint8Array(e),
  RF = (e) => Uint8Array.from(e);
function vZ(e, t, n) {
  if (typeof e != "number" || e < 2)
    throw new Error("hashLen must be a number");
  if (typeof t != "number" || t < 2)
    throw new Error("qByteLen must be a number");
  if (typeof n != "function") throw new Error("hmacFn must be a function");
  let r = LA(e),
    i = LA(e),
    s = 0;
  const o = () => {
      r.fill(1), i.fill(0), (s = 0);
    },
    a = (...d) => n(i, r, ...d),
    l = (d = LA()) => {
      (i = a(RF([0]), d)),
        (r = a()),
        d.length !== 0 && ((i = a(RF([1]), d)), (r = a()));
    },
    c = () => {
      if (s++ >= 1e3) throw new Error("drbg: tried 1000 values");
      let d = 0;
      const f = [];
      for (; d < t; ) {
        r = a();
        const h = r.slice();
        f.push(h), (d += r.length);
      }
      return Hm(...f);
    };
  return (d, f) => {
    o(), l(d);
    let h;
    for (; !(h = f(c())); ) l();
    return o(), h;
  };
}
const Bve = {
  bigint: (e) => typeof e == "bigint",
  function: (e) => typeof e == "function",
  boolean: (e) => typeof e == "boolean",
  string: (e) => typeof e == "string",
  stringOrUint8Array: (e) => typeof e == "string" || zm(e),
  isSafeInteger: (e) => Number.isSafeInteger(e),
  array: (e) => Array.isArray(e),
  field: (e, t) => t.Fp.isValid(e),
  hash: (e) => typeof e == "function" && Number.isSafeInteger(e.outputLen),
};
function ov(e, t, n = {}) {
  const r = (i, s, o) => {
    const a = Bve[s];
    if (typeof a != "function")
      throw new Error(`Invalid validator "${s}", expected function`);
    const l = e[i];
    if (!(o && l === void 0) && !a(l, e))
      throw new Error(
        `Invalid param ${String(i)}=${l} (${typeof l}), expected ${s}`
      );
  };
  for (const [i, s] of Object.entries(t)) r(i, s, !1);
  for (const [i, s] of Object.entries(n)) r(i, s, !0);
  return e;
}
const Fve = () => {
  throw new Error("not implemented");
};
function ib(e) {
  const t = new WeakMap();
  return (n, ...r) => {
    const i = t.get(n);
    if (i !== void 0) return i;
    const s = e(n, ...r);
    return t.set(n, s), s;
  };
}
const Uve = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      aInRange: bc,
      abool: Yf,
      abytes: hx,
      bitGet: jve,
      bitLen: yZ,
      bitMask: HN,
      bitSet: Dve,
      bytesToHex: Wm,
      bytesToNumberBE: Am,
      bytesToNumberLE: Gg,
      concatBytes: Hm,
      createHmacDrbg: vZ,
      ensureBytes: Qs,
      equalBytes: Pve,
      hexToBytes: _y,
      hexToNumber: WN,
      inRange: s8,
      isBytes: zm,
      memoized: ib,
      notImplemented: Fve,
      numberToBytesBE: Sy,
      numberToBytesLE: rb,
      numberToHexUnpadded: xg,
      numberToVarBytesBE: Ove,
      utf8ToBytes: Lve,
      validateObject: ov,
    },
    Symbol.toStringTag,
    { value: "Module" }
  )
);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const bo =
    BigInt(0),
  ds = BigInt(1),
  Y0 = BigInt(2),
  $ve = BigInt(3),
  iT = BigInt(4),
  OF = BigInt(5),
  PF = BigInt(8);
BigInt(9);
BigInt(16);
function ns(e, t) {
  const n = e % t;
  return n >= bo ? n : t + n;
}
function zve(e, t, n) {
  if (n <= bo || t < bo) throw new Error("Expected power/modulo > 0");
  if (n === ds) return bo;
  let r = ds;
  for (; t > bo; ) t & ds && (r = (r * e) % n), (e = (e * e) % n), (t >>= ds);
  return r;
}
function bs(e, t, n) {
  let r = e;
  for (; t-- > bo; ) (r *= r), (r %= n);
  return r;
}
function sT(e, t) {
  if (e === bo || t <= bo)
    throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);
  let n = ns(e, t),
    r = t,
    i = bo,
    s = ds;
  for (; n !== bo; ) {
    const a = r / n,
      l = r % n,
      c = i - s * a;
    (r = n), (n = l), (i = s), (s = c);
  }
  if (r !== ds) throw new Error("invert: does not exist");
  return ns(i, t);
}
function Wve(e) {
  const t = (e - ds) / Y0;
  let n, r, i;
  for (n = e - ds, r = 0; n % Y0 === bo; n /= Y0, r++);
  for (i = Y0; i < e && zve(i, t, e) !== e - ds; i++);
  if (r === 1) {
    const o = (e + ds) / iT;
    return function (l, c) {
      const u = l.pow(c, o);
      if (!l.eql(l.sqr(u), c)) throw new Error("Cannot find square root");
      return u;
    };
  }
  const s = (n + ds) / Y0;
  return function (a, l) {
    if (a.pow(l, t) === a.neg(a.ONE))
      throw new Error("Cannot find square root");
    let c = r,
      u = a.pow(a.mul(a.ONE, i), n),
      d = a.pow(l, s),
      f = a.pow(l, n);
    for (; !a.eql(f, a.ONE); ) {
      if (a.eql(f, a.ZERO)) return a.ZERO;
      let h = 1;
      for (let g = a.sqr(f); h < c && !a.eql(g, a.ONE); h++) g = a.sqr(g);
      const p = a.pow(u, ds << BigInt(c - h - 1));
      (u = a.sqr(p)), (d = a.mul(d, p)), (f = a.mul(f, u)), (c = h);
    }
    return d;
  };
}
function Hve(e) {
  if (e % iT === $ve) {
    const t = (e + ds) / iT;
    return function (r, i) {
      const s = r.pow(i, t);
      if (!r.eql(r.sqr(s), i)) throw new Error("Cannot find square root");
      return s;
    };
  }
  if (e % PF === OF) {
    const t = (e - OF) / PF;
    return function (r, i) {
      const s = r.mul(i, Y0),
        o = r.pow(s, t),
        a = r.mul(i, o),
        l = r.mul(r.mul(a, Y0), o),
        c = r.mul(a, r.sub(l, r.ONE));
      if (!r.eql(r.sqr(c), i)) throw new Error("Cannot find square root");
      return c;
    };
  }
  return Wve(e);
}
const Vve = (e, t) => (ns(e, t) & ds) === ds,
  Gve = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN",
  ];
function qve(e) {
  const t = {
      ORDER: "bigint",
      MASK: "bigint",
      BYTES: "isSafeInteger",
      BITS: "isSafeInteger",
    },
    n = Gve.reduce((r, i) => ((r[i] = "function"), r), t);
  return ov(e, n);
}
function Kve(e, t, n) {
  if (n < bo) throw new Error("Expected power > 0");
  if (n === bo) return e.ONE;
  if (n === ds) return t;
  let r = e.ONE,
    i = t;
  for (; n > bo; ) n & ds && (r = e.mul(r, i)), (i = e.sqr(i)), (n >>= ds);
  return r;
}
function Yve(e, t) {
  const n = new Array(t.length),
    r = t.reduce(
      (s, o, a) => (e.is0(o) ? s : ((n[a] = s), e.mul(s, o))),
      e.ONE
    ),
    i = e.inv(r);
  return (
    t.reduceRight(
      (s, o, a) => (e.is0(o) ? s : ((n[a] = e.mul(s, n[a])), e.mul(s, o))),
      i
    ),
    n
  );
}
function wZ(e, t) {
  const n = t !== void 0 ? t : e.toString(2).length,
    r = Math.ceil(n / 8);
  return { nBitLength: n, nByteLength: r };
}
function o8(e, t, n = !1, r = {}) {
  if (e <= bo) throw new Error(`Expected Field ORDER > 0, got ${e}`);
  const { nBitLength: i, nByteLength: s } = wZ(e, t);
  if (s > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const o = Hve(e),
    a = Object.freeze({
      ORDER: e,
      BITS: i,
      BYTES: s,
      MASK: HN(i),
      ZERO: bo,
      ONE: ds,
      create: (l) => ns(l, e),
      isValid: (l) => {
        if (typeof l != "bigint")
          throw new Error(
            `Invalid field element: expected bigint, got ${typeof l}`
          );
        return bo <= l && l < e;
      },
      is0: (l) => l === bo,
      isOdd: (l) => (l & ds) === ds,
      neg: (l) => ns(-l, e),
      eql: (l, c) => l === c,
      sqr: (l) => ns(l * l, e),
      add: (l, c) => ns(l + c, e),
      sub: (l, c) => ns(l - c, e),
      mul: (l, c) => ns(l * c, e),
      pow: (l, c) => Kve(a, l, c),
      div: (l, c) => ns(l * sT(c, e), e),
      sqrN: (l) => l * l,
      addN: (l, c) => l + c,
      subN: (l, c) => l - c,
      mulN: (l, c) => l * c,
      inv: (l) => sT(l, e),
      sqrt: r.sqrt || ((l) => o(a, l)),
      invertBatch: (l) => Yve(a, l),
      cmov: (l, c, u) => (u ? c : l),
      toBytes: (l) => (n ? rb(l, s) : Sy(l, s)),
      fromBytes: (l) => {
        if (l.length !== s)
          throw new Error(`Fp.fromBytes: expected ${s}, got ${l.length}`);
        return n ? Gg(l) : Am(l);
      },
    });
  return Object.freeze(a);
}
function bZ(e) {
  if (typeof e != "bigint") throw new Error("field order must be bigint");
  const t = e.toString(2).length;
  return Math.ceil(t / 8);
}
function xZ(e) {
  const t = bZ(e);
  return t + Math.ceil(t / 2);
}
function Zve(e, t, n = !1) {
  const r = e.length,
    i = bZ(t),
    s = xZ(t);
  if (r < 16 || r < s || r > 1024)
    throw new Error(`expected ${s}-1024 bytes of input, got ${r}`);
  const o = n ? Am(e) : Gg(e),
    a = ns(o, t - ds) + ds;
  return n ? rb(a, i) : Sy(a, i);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const Qve =
    BigInt(0),
  jA = BigInt(1),
  DA = new WeakMap(),
  LF = new WeakMap();
function _Z(e, t) {
  const n = (s, o) => {
      const a = o.negate();
      return s ? a : o;
    },
    r = (s) => {
      if (!Number.isSafeInteger(s) || s <= 0 || s > t)
        throw new Error(`Wrong window size=${s}, should be [1..${t}]`);
    },
    i = (s) => {
      r(s);
      const o = Math.ceil(t / s) + 1,
        a = 2 ** (s - 1);
      return { windows: o, windowSize: a };
    };
  return {
    constTimeNegate: n,
    unsafeLadder(s, o) {
      let a = e.ZERO,
        l = s;
      for (; o > Qve; ) o & jA && (a = a.add(l)), (l = l.double()), (o >>= jA);
      return a;
    },
    precomputeWindow(s, o) {
      const { windows: a, windowSize: l } = i(o),
        c = [];
      let u = s,
        d = u;
      for (let f = 0; f < a; f++) {
        (d = u), c.push(d);
        for (let h = 1; h < l; h++) (d = d.add(u)), c.push(d);
        u = d.double();
      }
      return c;
    },
    wNAF(s, o, a) {
      const { windows: l, windowSize: c } = i(s);
      let u = e.ZERO,
        d = e.BASE;
      const f = BigInt(2 ** s - 1),
        h = 2 ** s,
        p = BigInt(s);
      for (let g = 0; g < l; g++) {
        const b = g * c;
        let v = Number(a & f);
        (a >>= p), v > c && ((v -= h), (a += jA));
        const w = b,
          x = b + Math.abs(v) - 1,
          S = g % 2 !== 0,
          R = v < 0;
        v === 0 ? (d = d.add(n(S, o[w]))) : (u = u.add(n(R, o[x])));
      }
      return { p: u, f: d };
    },
    wNAFCached(s, o, a) {
      const l = LF.get(s) || 1;
      let c = DA.get(s);
      return (
        c || ((c = this.precomputeWindow(s, l)), l !== 1 && DA.set(s, a(c))),
        this.wNAF(l, c, o)
      );
    },
    setWindowSize(s, o) {
      r(o), LF.set(s, o), DA.delete(s);
    },
  };
}
function SZ(e, t, n, r) {
  if (!Array.isArray(n) || !Array.isArray(r) || r.length !== n.length)
    throw new Error("arrays of points and scalars must have equal length");
  r.forEach((u, d) => {
    if (!t.isValid(u)) throw new Error(`wrong scalar at index ${d}`);
  }),
    n.forEach((u, d) => {
      if (!(u instanceof e)) throw new Error(`wrong point at index ${d}`);
    });
  const i = yZ(BigInt(n.length)),
    s = i > 12 ? i - 3 : i > 4 ? i - 2 : i ? 2 : 1,
    o = (1 << s) - 1,
    a = new Array(o + 1).fill(e.ZERO),
    l = Math.floor((t.BITS - 1) / s) * s;
  let c = e.ZERO;
  for (let u = l; u >= 0; u -= s) {
    a.fill(e.ZERO);
    for (let f = 0; f < r.length; f++) {
      const h = r[f],
        p = Number((h >> BigInt(u)) & BigInt(o));
      a[p] = a[p].add(n[f]);
    }
    let d = e.ZERO;
    for (let f = a.length - 1, h = e.ZERO; f > 0; f--)
      (h = h.add(a[f])), (d = d.add(h));
    if (((c = c.add(d)), u !== 0)) for (let f = 0; f < s; f++) c = c.double();
  }
  return c;
}
function VN(e) {
  return (
    qve(e.Fp),
    ov(
      e,
      { n: "bigint", h: "bigint", Gx: "field", Gy: "field" },
      { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" }
    ),
    Object.freeze({ ...wZ(e.n, e.nBitLength), ...e, p: e.Fp.ORDER })
  );
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const tu =
    BigInt(0),
  za = BigInt(1),
  S_ = BigInt(2),
  Xve = BigInt(8),
  Jve = { zip215: !0 };
function e2e(e) {
  const t = VN(e);
  return (
    ov(
      e,
      { hash: "function", a: "bigint", d: "bigint", randomBytes: "function" },
      {
        adjustScalarBytes: "function",
        domain: "function",
        uvRatio: "function",
        mapToCurve: "function",
      }
    ),
    Object.freeze({ ...t })
  );
}
function t2e(e) {
  const t = e2e(e),
    {
      Fp: n,
      n: r,
      prehash: i,
      hash: s,
      randomBytes: o,
      nByteLength: a,
      h: l,
    } = t,
    c = S_ << (BigInt(a * 8) - za),
    u = n.create,
    d = o8(t.n, t.nBitLength),
    f =
      t.uvRatio ||
      ((N, L) => {
        try {
          return { isValid: !0, value: n.sqrt(N * n.inv(L)) };
        } catch {
          return { isValid: !1, value: tu };
        }
      }),
    h = t.adjustScalarBytes || ((N) => N),
    p =
      t.domain ||
      ((N, L, F) => {
        if ((Yf("phflag", F), L.length || F))
          throw new Error("Contexts/pre-hash are not supported");
        return N;
      });
  function g(N, L) {
    bc("coordinate " + N, L, tu, c);
  }
  function b(N) {
    if (!(N instanceof x)) throw new Error("ExtendedPoint expected");
  }
  const v = ib((N, L) => {
      const { ex: F, ey: D, ez: j } = N,
        z = N.is0();
      L == null && (L = z ? Xve : n.inv(j));
      const $ = u(F * L),
        K = u(D * L),
        re = u(j * L);
      if (z) return { x: tu, y: za };
      if (re !== za) throw new Error("invZ was invalid");
      return { x: $, y: K };
    }),
    w = ib((N) => {
      const { a: L, d: F } = t;
      if (N.is0()) throw new Error("bad point: ZERO");
      const { ex: D, ey: j, ez: z, et: $ } = N,
        K = u(D * D),
        re = u(j * j),
        G = u(z * z),
        ne = u(G * G),
        ae = u(K * L),
        le = u(G * u(ae + re)),
        ge = u(ne + u(F * u(K * re)));
      if (le !== ge) throw new Error("bad point: equation left != right (1)");
      const Oe = u(D * j),
        _e = u(z * $);
      if (Oe !== _e) throw new Error("bad point: equation left != right (2)");
      return !0;
    });
  class x {
    constructor(L, F, D, j) {
      (this.ex = L),
        (this.ey = F),
        (this.ez = D),
        (this.et = j),
        g("x", L),
        g("y", F),
        g("z", D),
        g("t", j),
        Object.freeze(this);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(L) {
      if (L instanceof x) throw new Error("extended point not allowed");
      const { x: F, y: D } = L || {};
      return g("x", F), g("y", D), new x(F, D, za, u(F * D));
    }
    static normalizeZ(L) {
      const F = n.invertBatch(L.map((D) => D.ez));
      return L.map((D, j) => D.toAffine(F[j])).map(x.fromAffine);
    }
    static msm(L, F) {
      return SZ(x, d, L, F);
    }
    _setWindowSize(L) {
      O.setWindowSize(this, L);
    }
    assertValidity() {
      w(this);
    }
    equals(L) {
      b(L);
      const { ex: F, ey: D, ez: j } = this,
        { ex: z, ey: $, ez: K } = L,
        re = u(F * K),
        G = u(z * j),
        ne = u(D * K),
        ae = u($ * j);
      return re === G && ne === ae;
    }
    is0() {
      return this.equals(x.ZERO);
    }
    negate() {
      return new x(u(-this.ex), this.ey, this.ez, u(-this.et));
    }
    double() {
      const { a: L } = t,
        { ex: F, ey: D, ez: j } = this,
        z = u(F * F),
        $ = u(D * D),
        K = u(S_ * u(j * j)),
        re = u(L * z),
        G = F + D,
        ne = u(u(G * G) - z - $),
        ae = re + $,
        le = ae - K,
        ge = re - $,
        Oe = u(ne * le),
        _e = u(ae * ge),
        Ee = u(ne * ge),
        He = u(le * ae);
      return new x(Oe, _e, He, Ee);
    }
    add(L) {
      b(L);
      const { a: F, d: D } = t,
        { ex: j, ey: z, ez: $, et: K } = this,
        { ex: re, ey: G, ez: ne, et: ae } = L;
      if (F === BigInt(-1)) {
        const kt = u((z - j) * (G + re)),
          Qe = u((z + j) * (G - re)),
          Vt = u(Qe - kt);
        if (Vt === tu) return this.double();
        const Rt = u($ * S_ * ae),
          mt = u(K * S_ * ne),
          Pt = mt + Rt,
          wn = Qe + kt,
          xt = mt - Rt,
          Tt = u(Pt * Vt),
          _n = u(wn * xt),
          Q = u(Pt * xt),
          H = u(Vt * wn);
        return new x(Tt, _n, H, Q);
      }
      const le = u(j * re),
        ge = u(z * G),
        Oe = u(K * D * ae),
        _e = u($ * ne),
        Ee = u((j + z) * (re + G) - le - ge),
        He = _e - Oe,
        je = _e + Oe,
        Be = u(ge - F * le),
        rn = u(Ee * He),
        Wt = u(je * Be),
        Mt = u(Ee * Be),
        an = u(He * je);
      return new x(rn, Wt, an, Mt);
    }
    subtract(L) {
      return this.add(L.negate());
    }
    wNAF(L) {
      return O.wNAFCached(this, L, x.normalizeZ);
    }
    multiply(L) {
      const F = L;
      bc("scalar", F, za, r);
      const { p: D, f: j } = this.wNAF(F);
      return x.normalizeZ([D, j])[0];
    }
    multiplyUnsafe(L) {
      const F = L;
      return (
        bc("scalar", F, tu, r),
        F === tu
          ? R
          : this.equals(R) || F === za
          ? this
          : this.equals(S)
          ? this.wNAF(F).p
          : O.unsafeLadder(this, F)
      );
    }
    isSmallOrder() {
      return this.multiplyUnsafe(l).is0();
    }
    isTorsionFree() {
      return O.unsafeLadder(this, r).is0();
    }
    toAffine(L) {
      return v(this, L);
    }
    clearCofactor() {
      const { h: L } = t;
      return L === za ? this : this.multiplyUnsafe(L);
    }
    static fromHex(L, F = !1) {
      const { d: D, a: j } = t,
        z = n.BYTES;
      (L = Qs("pointHex", L, z)), Yf("zip215", F);
      const $ = L.slice(),
        K = L[z - 1];
      $[z - 1] = K & -129;
      const re = Gg($),
        G = F ? c : n.ORDER;
      bc("pointHex.y", re, tu, G);
      const ne = u(re * re),
        ae = u(ne - za),
        le = u(D * ne - j);
      let { isValid: ge, value: Oe } = f(ae, le);
      if (!ge) throw new Error("Point.fromHex: invalid y coordinate");
      const _e = (Oe & za) === za,
        Ee = (K & 128) !== 0;
      if (!F && Oe === tu && Ee)
        throw new Error("Point.fromHex: x=0 and x_0=1");
      return Ee !== _e && (Oe = u(-Oe)), x.fromAffine({ x: Oe, y: re });
    }
    static fromPrivateKey(L) {
      return I(L).point;
    }
    toRawBytes() {
      const { x: L, y: F } = this.toAffine(),
        D = rb(F, n.BYTES);
      return (D[D.length - 1] |= L & za ? 128 : 0), D;
    }
    toHex() {
      return Wm(this.toRawBytes());
    }
  }
  (x.BASE = new x(t.Gx, t.Gy, za, u(t.Gx * t.Gy))),
    (x.ZERO = new x(tu, za, za, tu));
  const { BASE: S, ZERO: R } = x,
    O = _Z(x, a * 8);
  function B(N) {
    return ns(N, r);
  }
  function C(N) {
    return B(Gg(N));
  }
  function I(N) {
    const L = a;
    N = Qs("private key", N, L);
    const F = Qs("hashed private key", s(N), 2 * L),
      D = h(F.slice(0, L)),
      j = F.slice(L, 2 * L),
      z = C(D),
      $ = S.multiply(z),
      K = $.toRawBytes();
    return { head: D, prefix: j, scalar: z, point: $, pointBytes: K };
  }
  function P(N) {
    return I(N).pointBytes;
  }
  function M(N = new Uint8Array(), ...L) {
    const F = Hm(...L);
    return C(s(p(F, Qs("context", N), !!i)));
  }
  function k(N, L, F = {}) {
    (N = Qs("message", N)), i && (N = i(N));
    const { prefix: D, scalar: j, pointBytes: z } = I(L),
      $ = M(F.context, D, N),
      K = S.multiply($).toRawBytes(),
      re = M(F.context, K, z, N),
      G = B($ + re * j);
    bc("signature.s", G, tu, r);
    const ne = Hm(K, rb(G, n.BYTES));
    return Qs("result", ne, a * 2);
  }
  const T = Jve;
  function _(N, L, F, D = T) {
    const { context: j, zip215: z } = D,
      $ = n.BYTES;
    (N = Qs("signature", N, 2 * $)),
      (L = Qs("message", L)),
      z !== void 0 && Yf("zip215", z),
      i && (L = i(L));
    const K = Gg(N.slice($, 2 * $));
    let re, G, ne;
    try {
      (re = x.fromHex(F, z)),
        (G = x.fromHex(N.slice(0, $), z)),
        (ne = S.multiplyUnsafe(K));
    } catch {
      return !1;
    }
    if (!z && re.isSmallOrder()) return !1;
    const ae = M(j, G.toRawBytes(), re.toRawBytes(), L);
    return G.add(re.multiplyUnsafe(ae))
      .subtract(ne)
      .clearCofactor()
      .equals(x.ZERO);
  }
  return (
    S._setWindowSize(8),
    {
      CURVE: t,
      getPublicKey: P,
      sign: k,
      verify: _,
      ExtendedPoint: x,
      utils: {
        getExtendedPublicKey: I,
        randomPrivateKey: () => o(n.BYTES),
        precompute(N = 8, L = x.BASE) {
          return L._setWindowSize(N), L.multiply(BigInt(3)), L;
        },
      },
    }
  );
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const GN =
    BigInt(
      "57896044618658097711785492504343953926634992332820282019728792003956564819949"
    ),
  jF = BigInt(
    "19681161376707505956807079304988542015446066515923890162744021073123829784752"
  );
BigInt(0);
const n2e = BigInt(1),
  DF = BigInt(2);
BigInt(3);
const r2e = BigInt(5),
  i2e = BigInt(8);
function s2e(e) {
  const t = BigInt(10),
    n = BigInt(20),
    r = BigInt(40),
    i = BigInt(80),
    s = GN,
    a = (((e * e) % s) * e) % s,
    l = (bs(a, DF, s) * a) % s,
    c = (bs(l, n2e, s) * e) % s,
    u = (bs(c, r2e, s) * c) % s,
    d = (bs(u, t, s) * u) % s,
    f = (bs(d, n, s) * d) % s,
    h = (bs(f, r, s) * f) % s,
    p = (bs(h, i, s) * h) % s,
    g = (bs(p, i, s) * h) % s,
    b = (bs(g, t, s) * u) % s;
  return { pow_p_5_8: (bs(b, DF, s) * e) % s, b2: a };
}
function o2e(e) {
  return (e[0] &= 248), (e[31] &= 127), (e[31] |= 64), e;
}
function a2e(e, t) {
  const n = GN,
    r = ns(t * t * t, n),
    i = ns(r * r * t, n),
    s = s2e(e * i).pow_p_5_8;
  let o = ns(e * r * s, n);
  const a = ns(t * o * o, n),
    l = o,
    c = ns(o * jF, n),
    u = a === e,
    d = a === ns(-e, n),
    f = a === ns(-e * jF, n);
  return (
    u && (o = l),
    (d || f) && (o = c),
    Vve(o, n) && (o = ns(-o, n)),
    { isValid: u || d, value: o }
  );
}
const l2e = o8(GN, void 0, !0),
  c2e = {
    a: BigInt(-1),
    d: BigInt(
      "37095705934669439343138083508754565189542113879843219016388785533085940283555"
    ),
    Fp: l2e,
    n: BigInt(
      "7237005577332262213973186563042994240857116359379907606001950938285454250989"
    ),
    h: i2e,
    Gx: BigInt(
      "15112221349535400772501151409588531511454012693041857206046113283949847762202"
    ),
    Gy: BigInt(
      "46316835694926478169428394003475163141307993866256225615783033603165251855960"
    ),
    hash: Ive,
    randomBytes: cZ,
    adjustScalarBytes: o2e,
    uvRatio: a2e,
  },
  av = t2e(c2e);
var qN = { exports: {} };
const px = ix(tve);
qN.exports;
(function (e) {
  (function (t, n) {
    function r(T, _) {
      if (!T) throw new Error(_ || "Assertion failed");
    }
    function i(T, _) {
      T.super_ = _;
      var A = function () {};
      (A.prototype = _.prototype),
        (T.prototype = new A()),
        (T.prototype.constructor = T);
    }
    function s(T, _, A) {
      if (s.isBN(T)) return T;
      (this.negative = 0),
        (this.words = null),
        (this.length = 0),
        (this.red = null),
        T !== null &&
          ((_ === "le" || _ === "be") && ((A = _), (_ = 10)),
          this._init(T || 0, _ || 10, A || "be"));
    }
    typeof t == "object" ? (t.exports = s) : (n.BN = s),
      (s.BN = s),
      (s.wordSize = 26);
    var o;
    try {
      typeof window < "u" && typeof window.Buffer < "u"
        ? (o = window.Buffer)
        : (o = px.Buffer);
    } catch {}
    (s.isBN = function (_) {
      return _ instanceof s
        ? !0
        : _ !== null &&
            typeof _ == "object" &&
            _.constructor.wordSize === s.wordSize &&
            Array.isArray(_.words);
    }),
      (s.max = function (_, A) {
        return _.cmp(A) > 0 ? _ : A;
      }),
      (s.min = function (_, A) {
        return _.cmp(A) < 0 ? _ : A;
      }),
      (s.prototype._init = function (_, A, N) {
        if (typeof _ == "number") return this._initNumber(_, A, N);
        if (typeof _ == "object") return this._initArray(_, A, N);
        A === "hex" && (A = 16),
          r(A === (A | 0) && A >= 2 && A <= 36),
          (_ = _.toString().replace(/\s+/g, ""));
        var L = 0;
        _[0] === "-" && (L++, (this.negative = 1)),
          L < _.length &&
            (A === 16
              ? this._parseHex(_, L, N)
              : (this._parseBase(_, A, L),
                N === "le" && this._initArray(this.toArray(), A, N)));
      }),
      (s.prototype._initNumber = function (_, A, N) {
        _ < 0 && ((this.negative = 1), (_ = -_)),
          _ < 67108864
            ? ((this.words = [_ & 67108863]), (this.length = 1))
            : _ < 4503599627370496
            ? ((this.words = [_ & 67108863, (_ / 67108864) & 67108863]),
              (this.length = 2))
            : (r(_ < 9007199254740992),
              (this.words = [_ & 67108863, (_ / 67108864) & 67108863, 1]),
              (this.length = 3)),
          N === "le" && this._initArray(this.toArray(), A, N);
      }),
      (s.prototype._initArray = function (_, A, N) {
        if ((r(typeof _.length == "number"), _.length <= 0))
          return (this.words = [0]), (this.length = 1), this;
        (this.length = Math.ceil(_.length / 3)),
          (this.words = new Array(this.length));
        for (var L = 0; L < this.length; L++) this.words[L] = 0;
        var F,
          D,
          j = 0;
        if (N === "be")
          for (L = _.length - 1, F = 0; L >= 0; L -= 3)
            (D = _[L] | (_[L - 1] << 8) | (_[L - 2] << 16)),
              (this.words[F] |= (D << j) & 67108863),
              (this.words[F + 1] = (D >>> (26 - j)) & 67108863),
              (j += 24),
              j >= 26 && ((j -= 26), F++);
        else if (N === "le")
          for (L = 0, F = 0; L < _.length; L += 3)
            (D = _[L] | (_[L + 1] << 8) | (_[L + 2] << 16)),
              (this.words[F] |= (D << j) & 67108863),
              (this.words[F + 1] = (D >>> (26 - j)) & 67108863),
              (j += 24),
              j >= 26 && ((j -= 26), F++);
        return this._strip();
      });
    function a(T, _) {
      var A = T.charCodeAt(_);
      if (A >= 48 && A <= 57) return A - 48;
      if (A >= 65 && A <= 70) return A - 55;
      if (A >= 97 && A <= 102) return A - 87;
      r(!1, "Invalid character in " + T);
    }
    function l(T, _, A) {
      var N = a(T, A);
      return A - 1 >= _ && (N |= a(T, A - 1) << 4), N;
    }
    s.prototype._parseHex = function (_, A, N) {
      (this.length = Math.ceil((_.length - A) / 6)),
        (this.words = new Array(this.length));
      for (var L = 0; L < this.length; L++) this.words[L] = 0;
      var F = 0,
        D = 0,
        j;
      if (N === "be")
        for (L = _.length - 1; L >= A; L -= 2)
          (j = l(_, A, L) << F),
            (this.words[D] |= j & 67108863),
            F >= 18
              ? ((F -= 18), (D += 1), (this.words[D] |= j >>> 26))
              : (F += 8);
      else {
        var z = _.length - A;
        for (L = z % 2 === 0 ? A + 1 : A; L < _.length; L += 2)
          (j = l(_, A, L) << F),
            (this.words[D] |= j & 67108863),
            F >= 18
              ? ((F -= 18), (D += 1), (this.words[D] |= j >>> 26))
              : (F += 8);
      }
      this._strip();
    };
    function c(T, _, A, N) {
      for (var L = 0, F = 0, D = Math.min(T.length, A), j = _; j < D; j++) {
        var z = T.charCodeAt(j) - 48;
        (L *= N),
          z >= 49 ? (F = z - 49 + 10) : z >= 17 ? (F = z - 17 + 10) : (F = z),
          r(z >= 0 && F < N, "Invalid character"),
          (L += F);
      }
      return L;
    }
    (s.prototype._parseBase = function (_, A, N) {
      (this.words = [0]), (this.length = 1);
      for (var L = 0, F = 1; F <= 67108863; F *= A) L++;
      L--, (F = (F / A) | 0);
      for (
        var D = _.length - N,
          j = D % L,
          z = Math.min(D, D - j) + N,
          $ = 0,
          K = N;
        K < z;
        K += L
      )
        ($ = c(_, K, K + L, A)),
          this.imuln(F),
          this.words[0] + $ < 67108864 ? (this.words[0] += $) : this._iaddn($);
      if (j !== 0) {
        var re = 1;
        for ($ = c(_, K, _.length, A), K = 0; K < j; K++) re *= A;
        this.imuln(re),
          this.words[0] + $ < 67108864 ? (this.words[0] += $) : this._iaddn($);
      }
      this._strip();
    }),
      (s.prototype.copy = function (_) {
        _.words = new Array(this.length);
        for (var A = 0; A < this.length; A++) _.words[A] = this.words[A];
        (_.length = this.length),
          (_.negative = this.negative),
          (_.red = this.red);
      });
    function u(T, _) {
      (T.words = _.words),
        (T.length = _.length),
        (T.negative = _.negative),
        (T.red = _.red);
    }
    if (
      ((s.prototype._move = function (_) {
        u(_, this);
      }),
      (s.prototype.clone = function () {
        var _ = new s(null);
        return this.copy(_), _;
      }),
      (s.prototype._expand = function (_) {
        for (; this.length < _; ) this.words[this.length++] = 0;
        return this;
      }),
      (s.prototype._strip = function () {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }),
      (s.prototype._normSign = function () {
        return (
          this.length === 1 && this.words[0] === 0 && (this.negative = 0), this
        );
      }),
      typeof Symbol < "u" && typeof Symbol.for == "function")
    )
      try {
        s.prototype[Symbol.for("nodejs.util.inspect.custom")] = d;
      } catch {
        s.prototype.inspect = d;
      }
    else s.prototype.inspect = d;
    function d() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var f = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000",
      ],
      h = [
        0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
      ],
      p = [
        0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607,
        16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536,
        11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101,
        5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368,
        20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875,
        60466176,
      ];
    (s.prototype.toString = function (_, A) {
      (_ = _ || 10), (A = A | 0 || 1);
      var N;
      if (_ === 16 || _ === "hex") {
        N = "";
        for (var L = 0, F = 0, D = 0; D < this.length; D++) {
          var j = this.words[D],
            z = (((j << L) | F) & 16777215).toString(16);
          (F = (j >>> (24 - L)) & 16777215),
            (L += 2),
            L >= 26 && ((L -= 26), D--),
            F !== 0 || D !== this.length - 1
              ? (N = f[6 - z.length] + z + N)
              : (N = z + N);
        }
        for (F !== 0 && (N = F.toString(16) + N); N.length % A !== 0; )
          N = "0" + N;
        return this.negative !== 0 && (N = "-" + N), N;
      }
      if (_ === (_ | 0) && _ >= 2 && _ <= 36) {
        var $ = h[_],
          K = p[_];
        N = "";
        var re = this.clone();
        for (re.negative = 0; !re.isZero(); ) {
          var G = re.modrn(K).toString(_);
          (re = re.idivn(K)),
            re.isZero() ? (N = G + N) : (N = f[$ - G.length] + G + N);
        }
        for (this.isZero() && (N = "0" + N); N.length % A !== 0; ) N = "0" + N;
        return this.negative !== 0 && (N = "-" + N), N;
      }
      r(!1, "Base should be between 2 and 36");
    }),
      (s.prototype.toNumber = function () {
        var _ = this.words[0];
        return (
          this.length === 2
            ? (_ += this.words[1] * 67108864)
            : this.length === 3 && this.words[2] === 1
            ? (_ += 4503599627370496 + this.words[1] * 67108864)
            : this.length > 2 &&
              r(!1, "Number can only safely store up to 53 bits"),
          this.negative !== 0 ? -_ : _
        );
      }),
      (s.prototype.toJSON = function () {
        return this.toString(16, 2);
      }),
      o &&
        (s.prototype.toBuffer = function (_, A) {
          return this.toArrayLike(o, _, A);
        }),
      (s.prototype.toArray = function (_, A) {
        return this.toArrayLike(Array, _, A);
      });
    var g = function (_, A) {
      return _.allocUnsafe ? _.allocUnsafe(A) : new _(A);
    };
    (s.prototype.toArrayLike = function (_, A, N) {
      this._strip();
      var L = this.byteLength(),
        F = N || Math.max(1, L);
      r(L <= F, "byte array longer than desired length"),
        r(F > 0, "Requested array length <= 0");
      var D = g(_, F),
        j = A === "le" ? "LE" : "BE";
      return this["_toArrayLike" + j](D, L), D;
    }),
      (s.prototype._toArrayLikeLE = function (_, A) {
        for (var N = 0, L = 0, F = 0, D = 0; F < this.length; F++) {
          var j = (this.words[F] << D) | L;
          (_[N++] = j & 255),
            N < _.length && (_[N++] = (j >> 8) & 255),
            N < _.length && (_[N++] = (j >> 16) & 255),
            D === 6
              ? (N < _.length && (_[N++] = (j >> 24) & 255), (L = 0), (D = 0))
              : ((L = j >>> 24), (D += 2));
        }
        if (N < _.length) for (_[N++] = L; N < _.length; ) _[N++] = 0;
      }),
      (s.prototype._toArrayLikeBE = function (_, A) {
        for (var N = _.length - 1, L = 0, F = 0, D = 0; F < this.length; F++) {
          var j = (this.words[F] << D) | L;
          (_[N--] = j & 255),
            N >= 0 && (_[N--] = (j >> 8) & 255),
            N >= 0 && (_[N--] = (j >> 16) & 255),
            D === 6
              ? (N >= 0 && (_[N--] = (j >> 24) & 255), (L = 0), (D = 0))
              : ((L = j >>> 24), (D += 2));
        }
        if (N >= 0) for (_[N--] = L; N >= 0; ) _[N--] = 0;
      }),
      Math.clz32
        ? (s.prototype._countBits = function (_) {
            return 32 - Math.clz32(_);
          })
        : (s.prototype._countBits = function (_) {
            var A = _,
              N = 0;
            return (
              A >= 4096 && ((N += 13), (A >>>= 13)),
              A >= 64 && ((N += 7), (A >>>= 7)),
              A >= 8 && ((N += 4), (A >>>= 4)),
              A >= 2 && ((N += 2), (A >>>= 2)),
              N + A
            );
          }),
      (s.prototype._zeroBits = function (_) {
        if (_ === 0) return 26;
        var A = _,
          N = 0;
        return (
          A & 8191 || ((N += 13), (A >>>= 13)),
          A & 127 || ((N += 7), (A >>>= 7)),
          A & 15 || ((N += 4), (A >>>= 4)),
          A & 3 || ((N += 2), (A >>>= 2)),
          A & 1 || N++,
          N
        );
      }),
      (s.prototype.bitLength = function () {
        var _ = this.words[this.length - 1],
          A = this._countBits(_);
        return (this.length - 1) * 26 + A;
      });
    function b(T) {
      for (var _ = new Array(T.bitLength()), A = 0; A < _.length; A++) {
        var N = (A / 26) | 0,
          L = A % 26;
        _[A] = (T.words[N] >>> L) & 1;
      }
      return _;
    }
    (s.prototype.zeroBits = function () {
      if (this.isZero()) return 0;
      for (var _ = 0, A = 0; A < this.length; A++) {
        var N = this._zeroBits(this.words[A]);
        if (((_ += N), N !== 26)) break;
      }
      return _;
    }),
      (s.prototype.byteLength = function () {
        return Math.ceil(this.bitLength() / 8);
      }),
      (s.prototype.toTwos = function (_) {
        return this.negative !== 0
          ? this.abs().inotn(_).iaddn(1)
          : this.clone();
      }),
      (s.prototype.fromTwos = function (_) {
        return this.testn(_ - 1) ? this.notn(_).iaddn(1).ineg() : this.clone();
      }),
      (s.prototype.isNeg = function () {
        return this.negative !== 0;
      }),
      (s.prototype.neg = function () {
        return this.clone().ineg();
      }),
      (s.prototype.ineg = function () {
        return this.isZero() || (this.negative ^= 1), this;
      }),
      (s.prototype.iuor = function (_) {
        for (; this.length < _.length; ) this.words[this.length++] = 0;
        for (var A = 0; A < _.length; A++)
          this.words[A] = this.words[A] | _.words[A];
        return this._strip();
      }),
      (s.prototype.ior = function (_) {
        return r((this.negative | _.negative) === 0), this.iuor(_);
      }),
      (s.prototype.or = function (_) {
        return this.length > _.length
          ? this.clone().ior(_)
          : _.clone().ior(this);
      }),
      (s.prototype.uor = function (_) {
        return this.length > _.length
          ? this.clone().iuor(_)
          : _.clone().iuor(this);
      }),
      (s.prototype.iuand = function (_) {
        var A;
        this.length > _.length ? (A = _) : (A = this);
        for (var N = 0; N < A.length; N++)
          this.words[N] = this.words[N] & _.words[N];
        return (this.length = A.length), this._strip();
      }),
      (s.prototype.iand = function (_) {
        return r((this.negative | _.negative) === 0), this.iuand(_);
      }),
      (s.prototype.and = function (_) {
        return this.length > _.length
          ? this.clone().iand(_)
          : _.clone().iand(this);
      }),
      (s.prototype.uand = function (_) {
        return this.length > _.length
          ? this.clone().iuand(_)
          : _.clone().iuand(this);
      }),
      (s.prototype.iuxor = function (_) {
        var A, N;
        this.length > _.length ? ((A = this), (N = _)) : ((A = _), (N = this));
        for (var L = 0; L < N.length; L++)
          this.words[L] = A.words[L] ^ N.words[L];
        if (this !== A) for (; L < A.length; L++) this.words[L] = A.words[L];
        return (this.length = A.length), this._strip();
      }),
      (s.prototype.ixor = function (_) {
        return r((this.negative | _.negative) === 0), this.iuxor(_);
      }),
      (s.prototype.xor = function (_) {
        return this.length > _.length
          ? this.clone().ixor(_)
          : _.clone().ixor(this);
      }),
      (s.prototype.uxor = function (_) {
        return this.length > _.length
          ? this.clone().iuxor(_)
          : _.clone().iuxor(this);
      }),
      (s.prototype.inotn = function (_) {
        r(typeof _ == "number" && _ >= 0);
        var A = Math.ceil(_ / 26) | 0,
          N = _ % 26;
        this._expand(A), N > 0 && A--;
        for (var L = 0; L < A; L++) this.words[L] = ~this.words[L] & 67108863;
        return (
          N > 0 && (this.words[L] = ~this.words[L] & (67108863 >> (26 - N))),
          this._strip()
        );
      }),
      (s.prototype.notn = function (_) {
        return this.clone().inotn(_);
      }),
      (s.prototype.setn = function (_, A) {
        r(typeof _ == "number" && _ >= 0);
        var N = (_ / 26) | 0,
          L = _ % 26;
        return (
          this._expand(N + 1),
          A
            ? (this.words[N] = this.words[N] | (1 << L))
            : (this.words[N] = this.words[N] & ~(1 << L)),
          this._strip()
        );
      }),
      (s.prototype.iadd = function (_) {
        var A;
        if (this.negative !== 0 && _.negative === 0)
          return (
            (this.negative = 0),
            (A = this.isub(_)),
            (this.negative ^= 1),
            this._normSign()
          );
        if (this.negative === 0 && _.negative !== 0)
          return (
            (_.negative = 0),
            (A = this.isub(_)),
            (_.negative = 1),
            A._normSign()
          );
        var N, L;
        this.length > _.length ? ((N = this), (L = _)) : ((N = _), (L = this));
        for (var F = 0, D = 0; D < L.length; D++)
          (A = (N.words[D] | 0) + (L.words[D] | 0) + F),
            (this.words[D] = A & 67108863),
            (F = A >>> 26);
        for (; F !== 0 && D < N.length; D++)
          (A = (N.words[D] | 0) + F),
            (this.words[D] = A & 67108863),
            (F = A >>> 26);
        if (((this.length = N.length), F !== 0))
          (this.words[this.length] = F), this.length++;
        else if (N !== this)
          for (; D < N.length; D++) this.words[D] = N.words[D];
        return this;
      }),
      (s.prototype.add = function (_) {
        var A;
        return _.negative !== 0 && this.negative === 0
          ? ((_.negative = 0), (A = this.sub(_)), (_.negative ^= 1), A)
          : _.negative === 0 && this.negative !== 0
          ? ((this.negative = 0), (A = _.sub(this)), (this.negative = 1), A)
          : this.length > _.length
          ? this.clone().iadd(_)
          : _.clone().iadd(this);
      }),
      (s.prototype.isub = function (_) {
        if (_.negative !== 0) {
          _.negative = 0;
          var A = this.iadd(_);
          return (_.negative = 1), A._normSign();
        } else if (this.negative !== 0)
          return (
            (this.negative = 0),
            this.iadd(_),
            (this.negative = 1),
            this._normSign()
          );
        var N = this.cmp(_);
        if (N === 0)
          return (
            (this.negative = 0), (this.length = 1), (this.words[0] = 0), this
          );
        var L, F;
        N > 0 ? ((L = this), (F = _)) : ((L = _), (F = this));
        for (var D = 0, j = 0; j < F.length; j++)
          (A = (L.words[j] | 0) - (F.words[j] | 0) + D),
            (D = A >> 26),
            (this.words[j] = A & 67108863);
        for (; D !== 0 && j < L.length; j++)
          (A = (L.words[j] | 0) + D),
            (D = A >> 26),
            (this.words[j] = A & 67108863);
        if (D === 0 && j < L.length && L !== this)
          for (; j < L.length; j++) this.words[j] = L.words[j];
        return (
          (this.length = Math.max(this.length, j)),
          L !== this && (this.negative = 1),
          this._strip()
        );
      }),
      (s.prototype.sub = function (_) {
        return this.clone().isub(_);
      });
    function v(T, _, A) {
      A.negative = _.negative ^ T.negative;
      var N = (T.length + _.length) | 0;
      (A.length = N), (N = (N - 1) | 0);
      var L = T.words[0] | 0,
        F = _.words[0] | 0,
        D = L * F,
        j = D & 67108863,
        z = (D / 67108864) | 0;
      A.words[0] = j;
      for (var $ = 1; $ < N; $++) {
        for (
          var K = z >>> 26,
            re = z & 67108863,
            G = Math.min($, _.length - 1),
            ne = Math.max(0, $ - T.length + 1);
          ne <= G;
          ne++
        ) {
          var ae = ($ - ne) | 0;
          (L = T.words[ae] | 0),
            (F = _.words[ne] | 0),
            (D = L * F + re),
            (K += (D / 67108864) | 0),
            (re = D & 67108863);
        }
        (A.words[$] = re | 0), (z = K | 0);
      }
      return z !== 0 ? (A.words[$] = z | 0) : A.length--, A._strip();
    }
    var w = function (_, A, N) {
      var L = _.words,
        F = A.words,
        D = N.words,
        j = 0,
        z,
        $,
        K,
        re = L[0] | 0,
        G = re & 8191,
        ne = re >>> 13,
        ae = L[1] | 0,
        le = ae & 8191,
        ge = ae >>> 13,
        Oe = L[2] | 0,
        _e = Oe & 8191,
        Ee = Oe >>> 13,
        He = L[3] | 0,
        je = He & 8191,
        Be = He >>> 13,
        rn = L[4] | 0,
        Wt = rn & 8191,
        Mt = rn >>> 13,
        an = L[5] | 0,
        kt = an & 8191,
        Qe = an >>> 13,
        Vt = L[6] | 0,
        Rt = Vt & 8191,
        mt = Vt >>> 13,
        Pt = L[7] | 0,
        wn = Pt & 8191,
        xt = Pt >>> 13,
        Tt = L[8] | 0,
        _n = Tt & 8191,
        Q = Tt >>> 13,
        H = L[9] | 0,
        q = H & 8191,
        ee = H >>> 13,
        ce = F[0] | 0,
        pe = ce & 8191,
        we = ce >>> 13,
        ht = F[1] | 0,
        vt = ht & 8191,
        ct = ht >>> 13,
        Lt = F[2] | 0,
        wt = Lt & 8191,
        Ht = Lt >>> 13,
        mn = F[3] | 0,
        jn = mn & 8191,
        Gt = mn >>> 13,
        Cn = F[4] | 0,
        cn = Cn & 8191,
        Yt = Cn >>> 13,
        ln = F[5] | 0,
        oe = ln & 8191,
        de = ln >>> 13,
        be = F[6] | 0,
        Me = be & 8191,
        Fe = be >>> 13,
        it = F[7] | 0,
        ft = it & 8191,
        ze = it >>> 13,
        nt = F[8] | 0,
        Xe = nt & 8191,
        Ve = nt >>> 13,
        bt = F[9] | 0,
        gt = bt & 8191,
        un = bt >>> 13;
      (N.negative = _.negative ^ A.negative),
        (N.length = 19),
        (z = Math.imul(G, pe)),
        ($ = Math.imul(G, we)),
        ($ = ($ + Math.imul(ne, pe)) | 0),
        (K = Math.imul(ne, we));
      var Rn = (((j + z) | 0) + (($ & 8191) << 13)) | 0;
      (j = (((K + ($ >>> 13)) | 0) + (Rn >>> 26)) | 0),
        (Rn &= 67108863),
        (z = Math.imul(le, pe)),
        ($ = Math.imul(le, we)),
        ($ = ($ + Math.imul(ge, pe)) | 0),
        (K = Math.imul(ge, we)),
        (z = (z + Math.imul(G, vt)) | 0),
        ($ = ($ + Math.imul(G, ct)) | 0),
        ($ = ($ + Math.imul(ne, vt)) | 0),
        (K = (K + Math.imul(ne, ct)) | 0);
      var bn = (((j + z) | 0) + (($ & 8191) << 13)) | 0;
      (j = (((K + ($ >>> 13)) | 0) + (bn >>> 26)) | 0),
        (bn &= 67108863),
        (z = Math.imul(_e, pe)),
        ($ = Math.imul(_e, we)),
        ($ = ($ + Math.imul(Ee, pe)) | 0),
        (K = Math.imul(Ee, we)),
        (z = (z + Math.imul(le, vt)) | 0),
        ($ = ($ + Math.imul(le, ct)) | 0),
        ($ = ($ + Math.imul(ge, vt)) | 0),
        (K = (K + Math.imul(ge, ct)) | 0),
        (z = (z + Math.imul(G, wt)) | 0),
        ($ = ($ + Math.imul(G, Ht)) | 0),
        ($ = ($ + Math.imul(ne, wt)) | 0),
        (K = (K + Math.imul(ne, Ht)) | 0);
      var Sn = (((j + z) | 0) + (($ & 8191) << 13)) | 0;
      (j = (((K + ($ >>> 13)) | 0) + (Sn >>> 26)) | 0),
        (Sn &= 67108863),
        (z = Math.imul(je, pe)),
        ($ = Math.imul(je, we)),
        ($ = ($ + Math.imul(Be, pe)) | 0),
        (K = Math.imul(Be, we)),
        (z = (z + Math.imul(_e, vt)) | 0),
        ($ = ($ + Math.imul(_e, ct)) | 0),
        ($ = ($ + Math.imul(Ee, vt)) | 0),
        (K = (K + Math.imul(Ee, ct)) | 0),
        (z = (z + Math.imul(le, wt)) | 0),
        ($ = ($ + Math.imul(le, Ht)) | 0),
        ($ = ($ + Math.imul(ge, wt)) | 0),
        (K = (K + Math.imul(ge, Ht)) | 0),
        (z = (z + Math.imul(G, jn)) | 0),
        ($ = ($ + Math.imul(G, Gt)) | 0),
        ($ = ($ + Math.imul(ne, jn)) | 0),
        (K = (K + Math.imul(ne, Gt)) | 0);
      var Si = (((j + z) | 0) + (($ & 8191) << 13)) | 0;
      (j = (((K + ($ >>> 13)) | 0) + (Si >>> 26)) | 0),
        (Si &= 67108863),
        (z = Math.imul(Wt, pe)),
        ($ = Math.imul(Wt, we)),
        ($ = ($ + Math.imul(Mt, pe)) | 0),
        (K = Math.imul(Mt, we)),
        (z = (z + Math.imul(je, vt)) | 0),
        ($ = ($ + Math.imul(je, ct)) | 0),
        ($ = ($ + Math.imul(Be, vt)) | 0),
        (K = (K + Math.imul(Be, ct)) | 0),
        (z = (z + Math.imul(_e, wt)) | 0),
        ($ = ($ + Math.imul(_e, Ht)) | 0),
        ($ = ($ + Math.imul(Ee, wt)) | 0),
        (K = (K + Math.imul(Ee, Ht)) | 0),
        (z = (z + Math.imul(le, jn)) | 0),
        ($ = ($ + Math.imul(le, Gt)) | 0),
        ($ = ($ + Math.imul(ge, jn)) | 0),
        (K = (K + Math.imul(ge, Gt)) | 0),
        (z = (z + Math.imul(G, cn)) | 0),
        ($ = ($ + Math.imul(G, Yt)) | 0),
        ($ = ($ + Math.imul(ne, cn)) | 0),
        (K = (K + Math.imul(ne, Yt)) | 0);
      var vr = (((j + z) | 0) + (($ & 8191) << 13)) | 0;
      (j = (((K + ($ >>> 13)) | 0) + (vr >>> 26)) | 0),
        (vr &= 67108863),
        (z = Math.imul(kt, pe)),
        ($ = Math.imul(kt, we)),
        ($ = ($ + Math.imul(Qe, pe)) | 0),
        (K = Math.imul(Qe, we)),
        (z = (z + Math.imul(Wt, vt)) | 0),
        ($ = ($ + Math.imul(Wt, ct)) | 0),
        ($ = ($ + Math.imul(Mt, vt)) | 0),
        (K = (K + Math.imul(Mt, ct)) | 0),
        (z = (z + Math.imul(je, wt)) | 0),
        ($ = ($ + Math.imul(je, Ht)) | 0),
        ($ = ($ + Math.imul(Be, wt)) | 0),
        (K = (K + Math.imul(Be, Ht)) | 0),
        (z = (z + Math.imul(_e, jn)) | 0),
        ($ = ($ + Math.imul(_e, Gt)) | 0),
        ($ = ($ + Math.imul(Ee, jn)) | 0),
        (K = (K + Math.imul(Ee, Gt)) | 0),
        (z = (z + Math.imul(le, cn)) | 0),
        ($ = ($ + Math.imul(le, Yt)) | 0),
        ($ = ($ + Math.imul(ge, cn)) | 0),
        (K = (K + Math.imul(ge, Yt)) | 0),
        (z = (z + Math.imul(G, oe)) | 0),
        ($ = ($ + Math.imul(G, de)) | 0),
        ($ = ($ + Math.imul(ne, oe)) | 0),
        (K = (K + Math.imul(ne, de)) | 0);
      var pi = (((j + z) | 0) + (($ & 8191) << 13)) | 0;
      (j = (((K + ($ >>> 13)) | 0) + (pi >>> 26)) | 0),
        (pi &= 67108863),
        (z = Math.imul(Rt, pe)),
        ($ = Math.imul(Rt, we)),
        ($ = ($ + Math.imul(mt, pe)) | 0),
        (K = Math.imul(mt, we)),
        (z = (z + Math.imul(kt, vt)) | 0),
        ($ = ($ + Math.imul(kt, ct)) | 0),
        ($ = ($ + Math.imul(Qe, vt)) | 0),
        (K = (K + Math.imul(Qe, ct)) | 0),
        (z = (z + Math.imul(Wt, wt)) | 0),
        ($ = ($ + Math.imul(Wt, Ht)) | 0),
        ($ = ($ + Math.imul(Mt, wt)) | 0),
        (K = (K + Math.imul(Mt, Ht)) | 0),
        (z = (z + Math.imul(je, jn)) | 0),
        ($ = ($ + Math.imul(je, Gt)) | 0),
        ($ = ($ + Math.imul(Be, jn)) | 0),
        (K = (K + Math.imul(Be, Gt)) | 0),
        (z = (z + Math.imul(_e, cn)) | 0),
        ($ = ($ + Math.imul(_e, Yt)) | 0),
        ($ = ($ + Math.imul(Ee, cn)) | 0),
        (K = (K + Math.imul(Ee, Yt)) | 0),
        (z = (z + Math.imul(le, oe)) | 0),
        ($ = ($ + Math.imul(le, de)) | 0),
        ($ = ($ + Math.imul(ge, oe)) | 0),
        (K = (K + Math.imul(ge, de)) | 0),
        (z = (z + Math.imul(G, Me)) | 0),
        ($ = ($ + Math.imul(G, Fe)) | 0),
        ($ = ($ + Math.imul(ne, Me)) | 0),
        (K = (K + Math.imul(ne, Fe)) | 0);
      var ii = (((j + z) | 0) + (($ & 8191) << 13)) | 0;
      (j = (((K + ($ >>> 13)) | 0) + (ii >>> 26)) | 0),
        (ii &= 67108863),
        (z = Math.imul(wn, pe)),
        ($ = Math.imul(wn, we)),
        ($ = ($ + Math.imul(xt, pe)) | 0),
        (K = Math.imul(xt, we)),
        (z = (z + Math.imul(Rt, vt)) | 0),
        ($ = ($ + Math.imul(Rt, ct)) | 0),
        ($ = ($ + Math.imul(mt, vt)) | 0),
        (K = (K + Math.imul(mt, ct)) | 0),
        (z = (z + Math.imul(kt, wt)) | 0),
        ($ = ($ + Math.imul(kt, Ht)) | 0),
        ($ = ($ + Math.imul(Qe, wt)) | 0),
        (K = (K + Math.imul(Qe, Ht)) | 0),
        (z = (z + Math.imul(Wt, jn)) | 0),
        ($ = ($ + Math.imul(Wt, Gt)) | 0),
        ($ = ($ + Math.imul(Mt, jn)) | 0),
        (K = (K + Math.imul(Mt, Gt)) | 0),
        (z = (z + Math.imul(je, cn)) | 0),
        ($ = ($ + Math.imul(je, Yt)) | 0),
        ($ = ($ + Math.imul(Be, cn)) | 0),
        (K = (K + Math.imul(Be, Yt)) | 0),
        (z = (z + Math.imul(_e, oe)) | 0),
        ($ = ($ + Math.imul(_e, de)) | 0),
        ($ = ($ + Math.imul(Ee, oe)) | 0),
        (K = (K + Math.imul(Ee, de)) | 0),
        (z = (z + Math.imul(le, Me)) | 0),
        ($ = ($ + Math.imul(le, Fe)) | 0),
        ($ = ($ + Math.imul(ge, Me)) | 0),
        (K = (K + Math.imul(ge, Fe)) | 0),
        (z = (z + Math.imul(G, ft)) | 0),
        ($ = ($ + Math.imul(G, ze)) | 0),
        ($ = ($ + Math.imul(ne, ft)) | 0),
        (K = (K + Math.imul(ne, ze)) | 0);
      var Ki = (((j + z) | 0) + (($ & 8191) << 13)) | 0;
      (j = (((K + ($ >>> 13)) | 0) + (Ki >>> 26)) | 0),
        (Ki &= 67108863),
        (z = Math.imul(_n, pe)),
        ($ = Math.imul(_n, we)),
        ($ = ($ + Math.imul(Q, pe)) | 0),
        (K = Math.imul(Q, we)),
        (z = (z + Math.imul(wn, vt)) | 0),
        ($ = ($ + Math.imul(wn, ct)) | 0),
        ($ = ($ + Math.imul(xt, vt)) | 0),
        (K = (K + Math.imul(xt, ct)) | 0),
        (z = (z + Math.imul(Rt, wt)) | 0),
        ($ = ($ + Math.imul(Rt, Ht)) | 0),
        ($ = ($ + Math.imul(mt, wt)) | 0),
        (K = (K + Math.imul(mt, Ht)) | 0),
        (z = (z + Math.imul(kt, jn)) | 0),
        ($ = ($ + Math.imul(kt, Gt)) | 0),
        ($ = ($ + Math.imul(Qe, jn)) | 0),
        (K = (K + Math.imul(Qe, Gt)) | 0),
        (z = (z + Math.imul(Wt, cn)) | 0),
        ($ = ($ + Math.imul(Wt, Yt)) | 0),
        ($ = ($ + Math.imul(Mt, cn)) | 0),
        (K = (K + Math.imul(Mt, Yt)) | 0),
        (z = (z + Math.imul(je, oe)) | 0),
        ($ = ($ + Math.imul(je, de)) | 0),
        ($ = ($ + Math.imul(Be, oe)) | 0),
        (K = (K + Math.imul(Be, de)) | 0),
        (z = (z + Math.imul(_e, Me)) | 0),
        ($ = ($ + Math.imul(_e, Fe)) | 0),
        ($ = ($ + Math.imul(Ee, Me)) | 0),
        (K = (K + Math.imul(Ee, Fe)) | 0),
        (z = (z + Math.imul(le, ft)) | 0),
        ($ = ($ + Math.imul(le, ze)) | 0),
        ($ = ($ + Math.imul(ge, ft)) | 0),
        (K = (K + Math.imul(ge, ze)) | 0),
        (z = (z + Math.imul(G, Xe)) | 0),
        ($ = ($ + Math.imul(G, Ve)) | 0),
        ($ = ($ + Math.imul(ne, Xe)) | 0),
        (K = (K + Math.imul(ne, Ve)) | 0);
      var si = (((j + z) | 0) + (($ & 8191) << 13)) | 0;
      (j = (((K + ($ >>> 13)) | 0) + (si >>> 26)) | 0),
        (si &= 67108863),
        (z = Math.imul(q, pe)),
        ($ = Math.imul(q, we)),
        ($ = ($ + Math.imul(ee, pe)) | 0),
        (K = Math.imul(ee, we)),
        (z = (z + Math.imul(_n, vt)) | 0),
        ($ = ($ + Math.imul(_n, ct)) | 0),
        ($ = ($ + Math.imul(Q, vt)) | 0),
        (K = (K + Math.imul(Q, ct)) | 0),
        (z = (z + Math.imul(wn, wt)) | 0),
        ($ = ($ + Math.imul(wn, Ht)) | 0),
        ($ = ($ + Math.imul(xt, wt)) | 0),
        (K = (K + Math.imul(xt, Ht)) | 0),
        (z = (z + Math.imul(Rt, jn)) | 0),
        ($ = ($ + Math.imul(Rt, Gt)) | 0),
        ($ = ($ + Math.imul(mt, jn)) | 0),
        (K = (K + Math.imul(mt, Gt)) | 0),
        (z = (z + Math.imul(kt, cn)) | 0),
        ($ = ($ + Math.imul(kt, Yt)) | 0),
        ($ = ($ + Math.imul(Qe, cn)) | 0),
        (K = (K + Math.imul(Qe, Yt)) | 0),
        (z = (z + Math.imul(Wt, oe)) | 0),
        ($ = ($ + Math.imul(Wt, de)) | 0),
        ($ = ($ + Math.imul(Mt, oe)) | 0),
        (K = (K + Math.imul(Mt, de)) | 0),
        (z = (z + Math.imul(je, Me)) | 0),
        ($ = ($ + Math.imul(je, Fe)) | 0),
        ($ = ($ + Math.imul(Be, Me)) | 0),
        (K = (K + Math.imul(Be, Fe)) | 0),
        (z = (z + Math.imul(_e, ft)) | 0),
        ($ = ($ + Math.imul(_e, ze)) | 0),
        ($ = ($ + Math.imul(Ee, ft)) | 0),
        (K = (K + Math.imul(Ee, ze)) | 0),
        (z = (z + Math.imul(le, Xe)) | 0),
        ($ = ($ + Math.imul(le, Ve)) | 0),
        ($ = ($ + Math.imul(ge, Xe)) | 0),
        (K = (K + Math.imul(ge, Ve)) | 0),
        (z = (z + Math.imul(G, gt)) | 0),
        ($ = ($ + Math.imul(G, un)) | 0),
        ($ = ($ + Math.imul(ne, gt)) | 0),
        (K = (K + Math.imul(ne, un)) | 0);
      var Ti = (((j + z) | 0) + (($ & 8191) << 13)) | 0;
      (j = (((K + ($ >>> 13)) | 0) + (Ti >>> 26)) | 0),
        (Ti &= 67108863),
        (z = Math.imul(q, vt)),
        ($ = Math.imul(q, ct)),
        ($ = ($ + Math.imul(ee, vt)) | 0),
        (K = Math.imul(ee, ct)),
        (z = (z + Math.imul(_n, wt)) | 0),
        ($ = ($ + Math.imul(_n, Ht)) | 0),
        ($ = ($ + Math.imul(Q, wt)) | 0),
        (K = (K + Math.imul(Q, Ht)) | 0),
        (z = (z + Math.imul(wn, jn)) | 0),
        ($ = ($ + Math.imul(wn, Gt)) | 0),
        ($ = ($ + Math.imul(xt, jn)) | 0),
        (K = (K + Math.imul(xt, Gt)) | 0),
        (z = (z + Math.imul(Rt, cn)) | 0),
        ($ = ($ + Math.imul(Rt, Yt)) | 0),
        ($ = ($ + Math.imul(mt, cn)) | 0),
        (K = (K + Math.imul(mt, Yt)) | 0),
        (z = (z + Math.imul(kt, oe)) | 0),
        ($ = ($ + Math.imul(kt, de)) | 0),
        ($ = ($ + Math.imul(Qe, oe)) | 0),
        (K = (K + Math.imul(Qe, de)) | 0),
        (z = (z + Math.imul(Wt, Me)) | 0),
        ($ = ($ + Math.imul(Wt, Fe)) | 0),
        ($ = ($ + Math.imul(Mt, Me)) | 0),
        (K = (K + Math.imul(Mt, Fe)) | 0),
        (z = (z + Math.imul(je, ft)) | 0),
        ($ = ($ + Math.imul(je, ze)) | 0),
        ($ = ($ + Math.imul(Be, ft)) | 0),
        (K = (K + Math.imul(Be, ze)) | 0),
        (z = (z + Math.imul(_e, Xe)) | 0),
        ($ = ($ + Math.imul(_e, Ve)) | 0),
        ($ = ($ + Math.imul(Ee, Xe)) | 0),
        (K = (K + Math.imul(Ee, Ve)) | 0),
        (z = (z + Math.imul(le, gt)) | 0),
        ($ = ($ + Math.imul(le, un)) | 0),
        ($ = ($ + Math.imul(ge, gt)) | 0),
        (K = (K + Math.imul(ge, un)) | 0);
      var Yi = (((j + z) | 0) + (($ & 8191) << 13)) | 0;
      (j = (((K + ($ >>> 13)) | 0) + (Yi >>> 26)) | 0),
        (Yi &= 67108863),
        (z = Math.imul(q, wt)),
        ($ = Math.imul(q, Ht)),
        ($ = ($ + Math.imul(ee, wt)) | 0),
        (K = Math.imul(ee, Ht)),
        (z = (z + Math.imul(_n, jn)) | 0),
        ($ = ($ + Math.imul(_n, Gt)) | 0),
        ($ = ($ + Math.imul(Q, jn)) | 0),
        (K = (K + Math.imul(Q, Gt)) | 0),
        (z = (z + Math.imul(wn, cn)) | 0),
        ($ = ($ + Math.imul(wn, Yt)) | 0),
        ($ = ($ + Math.imul(xt, cn)) | 0),
        (K = (K + Math.imul(xt, Yt)) | 0),
        (z = (z + Math.imul(Rt, oe)) | 0),
        ($ = ($ + Math.imul(Rt, de)) | 0),
        ($ = ($ + Math.imul(mt, oe)) | 0),
        (K = (K + Math.imul(mt, de)) | 0),
        (z = (z + Math.imul(kt, Me)) | 0),
        ($ = ($ + Math.imul(kt, Fe)) | 0),
        ($ = ($ + Math.imul(Qe, Me)) | 0),
        (K = (K + Math.imul(Qe, Fe)) | 0),
        (z = (z + Math.imul(Wt, ft)) | 0),
        ($ = ($ + Math.imul(Wt, ze)) | 0),
        ($ = ($ + Math.imul(Mt, ft)) | 0),
        (K = (K + Math.imul(Mt, ze)) | 0),
        (z = (z + Math.imul(je, Xe)) | 0),
        ($ = ($ + Math.imul(je, Ve)) | 0),
        ($ = ($ + Math.imul(Be, Xe)) | 0),
        (K = (K + Math.imul(Be, Ve)) | 0),
        (z = (z + Math.imul(_e, gt)) | 0),
        ($ = ($ + Math.imul(_e, un)) | 0),
        ($ = ($ + Math.imul(Ee, gt)) | 0),
        (K = (K + Math.imul(Ee, un)) | 0);
      var Es = (((j + z) | 0) + (($ & 8191) << 13)) | 0;
      (j = (((K + ($ >>> 13)) | 0) + (Es >>> 26)) | 0),
        (Es &= 67108863),
        (z = Math.imul(q, jn)),
        ($ = Math.imul(q, Gt)),
        ($ = ($ + Math.imul(ee, jn)) | 0),
        (K = Math.imul(ee, Gt)),
        (z = (z + Math.imul(_n, cn)) | 0),
        ($ = ($ + Math.imul(_n, Yt)) | 0),
        ($ = ($ + Math.imul(Q, cn)) | 0),
        (K = (K + Math.imul(Q, Yt)) | 0),
        (z = (z + Math.imul(wn, oe)) | 0),
        ($ = ($ + Math.imul(wn, de)) | 0),
        ($ = ($ + Math.imul(xt, oe)) | 0),
        (K = (K + Math.imul(xt, de)) | 0),
        (z = (z + Math.imul(Rt, Me)) | 0),
        ($ = ($ + Math.imul(Rt, Fe)) | 0),
        ($ = ($ + Math.imul(mt, Me)) | 0),
        (K = (K + Math.imul(mt, Fe)) | 0),
        (z = (z + Math.imul(kt, ft)) | 0),
        ($ = ($ + Math.imul(kt, ze)) | 0),
        ($ = ($ + Math.imul(Qe, ft)) | 0),
        (K = (K + Math.imul(Qe, ze)) | 0),
        (z = (z + Math.imul(Wt, Xe)) | 0),
        ($ = ($ + Math.imul(Wt, Ve)) | 0),
        ($ = ($ + Math.imul(Mt, Xe)) | 0),
        (K = (K + Math.imul(Mt, Ve)) | 0),
        (z = (z + Math.imul(je, gt)) | 0),
        ($ = ($ + Math.imul(je, un)) | 0),
        ($ = ($ + Math.imul(Be, gt)) | 0),
        (K = (K + Math.imul(Be, un)) | 0);
      var In = (((j + z) | 0) + (($ & 8191) << 13)) | 0;
      (j = (((K + ($ >>> 13)) | 0) + (In >>> 26)) | 0),
        (In &= 67108863),
        (z = Math.imul(q, cn)),
        ($ = Math.imul(q, Yt)),
        ($ = ($ + Math.imul(ee, cn)) | 0),
        (K = Math.imul(ee, Yt)),
        (z = (z + Math.imul(_n, oe)) | 0),
        ($ = ($ + Math.imul(_n, de)) | 0),
        ($ = ($ + Math.imul(Q, oe)) | 0),
        (K = (K + Math.imul(Q, de)) | 0),
        (z = (z + Math.imul(wn, Me)) | 0),
        ($ = ($ + Math.imul(wn, Fe)) | 0),
        ($ = ($ + Math.imul(xt, Me)) | 0),
        (K = (K + Math.imul(xt, Fe)) | 0),
        (z = (z + Math.imul(Rt, ft)) | 0),
        ($ = ($ + Math.imul(Rt, ze)) | 0),
        ($ = ($ + Math.imul(mt, ft)) | 0),
        (K = (K + Math.imul(mt, ze)) | 0),
        (z = (z + Math.imul(kt, Xe)) | 0),
        ($ = ($ + Math.imul(kt, Ve)) | 0),
        ($ = ($ + Math.imul(Qe, Xe)) | 0),
        (K = (K + Math.imul(Qe, Ve)) | 0),
        (z = (z + Math.imul(Wt, gt)) | 0),
        ($ = ($ + Math.imul(Wt, un)) | 0),
        ($ = ($ + Math.imul(Mt, gt)) | 0),
        (K = (K + Math.imul(Mt, un)) | 0);
      var On = (((j + z) | 0) + (($ & 8191) << 13)) | 0;
      (j = (((K + ($ >>> 13)) | 0) + (On >>> 26)) | 0),
        (On &= 67108863),
        (z = Math.imul(q, oe)),
        ($ = Math.imul(q, de)),
        ($ = ($ + Math.imul(ee, oe)) | 0),
        (K = Math.imul(ee, de)),
        (z = (z + Math.imul(_n, Me)) | 0),
        ($ = ($ + Math.imul(_n, Fe)) | 0),
        ($ = ($ + Math.imul(Q, Me)) | 0),
        (K = (K + Math.imul(Q, Fe)) | 0),
        (z = (z + Math.imul(wn, ft)) | 0),
        ($ = ($ + Math.imul(wn, ze)) | 0),
        ($ = ($ + Math.imul(xt, ft)) | 0),
        (K = (K + Math.imul(xt, ze)) | 0),
        (z = (z + Math.imul(Rt, Xe)) | 0),
        ($ = ($ + Math.imul(Rt, Ve)) | 0),
        ($ = ($ + Math.imul(mt, Xe)) | 0),
        (K = (K + Math.imul(mt, Ve)) | 0),
        (z = (z + Math.imul(kt, gt)) | 0),
        ($ = ($ + Math.imul(kt, un)) | 0),
        ($ = ($ + Math.imul(Qe, gt)) | 0),
        (K = (K + Math.imul(Qe, un)) | 0);
      var Ei = (((j + z) | 0) + (($ & 8191) << 13)) | 0;
      (j = (((K + ($ >>> 13)) | 0) + (Ei >>> 26)) | 0),
        (Ei &= 67108863),
        (z = Math.imul(q, Me)),
        ($ = Math.imul(q, Fe)),
        ($ = ($ + Math.imul(ee, Me)) | 0),
        (K = Math.imul(ee, Fe)),
        (z = (z + Math.imul(_n, ft)) | 0),
        ($ = ($ + Math.imul(_n, ze)) | 0),
        ($ = ($ + Math.imul(Q, ft)) | 0),
        (K = (K + Math.imul(Q, ze)) | 0),
        (z = (z + Math.imul(wn, Xe)) | 0),
        ($ = ($ + Math.imul(wn, Ve)) | 0),
        ($ = ($ + Math.imul(xt, Xe)) | 0),
        (K = (K + Math.imul(xt, Ve)) | 0),
        (z = (z + Math.imul(Rt, gt)) | 0),
        ($ = ($ + Math.imul(Rt, un)) | 0),
        ($ = ($ + Math.imul(mt, gt)) | 0),
        (K = (K + Math.imul(mt, un)) | 0);
      var As = (((j + z) | 0) + (($ & 8191) << 13)) | 0;
      (j = (((K + ($ >>> 13)) | 0) + (As >>> 26)) | 0),
        (As &= 67108863),
        (z = Math.imul(q, ft)),
        ($ = Math.imul(q, ze)),
        ($ = ($ + Math.imul(ee, ft)) | 0),
        (K = Math.imul(ee, ze)),
        (z = (z + Math.imul(_n, Xe)) | 0),
        ($ = ($ + Math.imul(_n, Ve)) | 0),
        ($ = ($ + Math.imul(Q, Xe)) | 0),
        (K = (K + Math.imul(Q, Ve)) | 0),
        (z = (z + Math.imul(wn, gt)) | 0),
        ($ = ($ + Math.imul(wn, un)) | 0),
        ($ = ($ + Math.imul(xt, gt)) | 0),
        (K = (K + Math.imul(xt, un)) | 0);
      var wr = (((j + z) | 0) + (($ & 8191) << 13)) | 0;
      (j = (((K + ($ >>> 13)) | 0) + (wr >>> 26)) | 0),
        (wr &= 67108863),
        (z = Math.imul(q, Xe)),
        ($ = Math.imul(q, Ve)),
        ($ = ($ + Math.imul(ee, Xe)) | 0),
        (K = Math.imul(ee, Ve)),
        (z = (z + Math.imul(_n, gt)) | 0),
        ($ = ($ + Math.imul(_n, un)) | 0),
        ($ = ($ + Math.imul(Q, gt)) | 0),
        (K = (K + Math.imul(Q, un)) | 0);
      var Mi = (((j + z) | 0) + (($ & 8191) << 13)) | 0;
      (j = (((K + ($ >>> 13)) | 0) + (Mi >>> 26)) | 0),
        (Mi &= 67108863),
        (z = Math.imul(q, gt)),
        ($ = Math.imul(q, un)),
        ($ = ($ + Math.imul(ee, gt)) | 0),
        (K = Math.imul(ee, un));
      var ha = (((j + z) | 0) + (($ & 8191) << 13)) | 0;
      return (
        (j = (((K + ($ >>> 13)) | 0) + (ha >>> 26)) | 0),
        (ha &= 67108863),
        (D[0] = Rn),
        (D[1] = bn),
        (D[2] = Sn),
        (D[3] = Si),
        (D[4] = vr),
        (D[5] = pi),
        (D[6] = ii),
        (D[7] = Ki),
        (D[8] = si),
        (D[9] = Ti),
        (D[10] = Yi),
        (D[11] = Es),
        (D[12] = In),
        (D[13] = On),
        (D[14] = Ei),
        (D[15] = As),
        (D[16] = wr),
        (D[17] = Mi),
        (D[18] = ha),
        j !== 0 && ((D[19] = j), N.length++),
        N
      );
    };
    Math.imul || (w = v);
    function x(T, _, A) {
      (A.negative = _.negative ^ T.negative), (A.length = T.length + _.length);
      for (var N = 0, L = 0, F = 0; F < A.length - 1; F++) {
        var D = L;
        L = 0;
        for (
          var j = N & 67108863,
            z = Math.min(F, _.length - 1),
            $ = Math.max(0, F - T.length + 1);
          $ <= z;
          $++
        ) {
          var K = F - $,
            re = T.words[K] | 0,
            G = _.words[$] | 0,
            ne = re * G,
            ae = ne & 67108863;
          (D = (D + ((ne / 67108864) | 0)) | 0),
            (ae = (ae + j) | 0),
            (j = ae & 67108863),
            (D = (D + (ae >>> 26)) | 0),
            (L += D >>> 26),
            (D &= 67108863);
        }
        (A.words[F] = j), (N = D), (D = L);
      }
      return N !== 0 ? (A.words[F] = N) : A.length--, A._strip();
    }
    function S(T, _, A) {
      return x(T, _, A);
    }
    (s.prototype.mulTo = function (_, A) {
      var N,
        L = this.length + _.length;
      return (
        this.length === 10 && _.length === 10
          ? (N = w(this, _, A))
          : L < 63
          ? (N = v(this, _, A))
          : L < 1024
          ? (N = x(this, _, A))
          : (N = S(this, _, A)),
        N
      );
    }),
      (s.prototype.mul = function (_) {
        var A = new s(null);
        return (A.words = new Array(this.length + _.length)), this.mulTo(_, A);
      }),
      (s.prototype.mulf = function (_) {
        var A = new s(null);
        return (A.words = new Array(this.length + _.length)), S(this, _, A);
      }),
      (s.prototype.imul = function (_) {
        return this.clone().mulTo(_, this);
      }),
      (s.prototype.imuln = function (_) {
        var A = _ < 0;
        A && (_ = -_), r(typeof _ == "number"), r(_ < 67108864);
        for (var N = 0, L = 0; L < this.length; L++) {
          var F = (this.words[L] | 0) * _,
            D = (F & 67108863) + (N & 67108863);
          (N >>= 26),
            (N += (F / 67108864) | 0),
            (N += D >>> 26),
            (this.words[L] = D & 67108863);
        }
        return (
          N !== 0 && ((this.words[L] = N), this.length++),
          A ? this.ineg() : this
        );
      }),
      (s.prototype.muln = function (_) {
        return this.clone().imuln(_);
      }),
      (s.prototype.sqr = function () {
        return this.mul(this);
      }),
      (s.prototype.isqr = function () {
        return this.imul(this.clone());
      }),
      (s.prototype.pow = function (_) {
        var A = b(_);
        if (A.length === 0) return new s(1);
        for (var N = this, L = 0; L < A.length && A[L] === 0; L++, N = N.sqr());
        if (++L < A.length)
          for (var F = N.sqr(); L < A.length; L++, F = F.sqr())
            A[L] !== 0 && (N = N.mul(F));
        return N;
      }),
      (s.prototype.iushln = function (_) {
        r(typeof _ == "number" && _ >= 0);
        var A = _ % 26,
          N = (_ - A) / 26,
          L = (67108863 >>> (26 - A)) << (26 - A),
          F;
        if (A !== 0) {
          var D = 0;
          for (F = 0; F < this.length; F++) {
            var j = this.words[F] & L,
              z = ((this.words[F] | 0) - j) << A;
            (this.words[F] = z | D), (D = j >>> (26 - A));
          }
          D && ((this.words[F] = D), this.length++);
        }
        if (N !== 0) {
          for (F = this.length - 1; F >= 0; F--)
            this.words[F + N] = this.words[F];
          for (F = 0; F < N; F++) this.words[F] = 0;
          this.length += N;
        }
        return this._strip();
      }),
      (s.prototype.ishln = function (_) {
        return r(this.negative === 0), this.iushln(_);
      }),
      (s.prototype.iushrn = function (_, A, N) {
        r(typeof _ == "number" && _ >= 0);
        var L;
        A ? (L = (A - (A % 26)) / 26) : (L = 0);
        var F = _ % 26,
          D = Math.min((_ - F) / 26, this.length),
          j = 67108863 ^ ((67108863 >>> F) << F),
          z = N;
        if (((L -= D), (L = Math.max(0, L)), z)) {
          for (var $ = 0; $ < D; $++) z.words[$] = this.words[$];
          z.length = D;
        }
        if (D !== 0)
          if (this.length > D)
            for (this.length -= D, $ = 0; $ < this.length; $++)
              this.words[$] = this.words[$ + D];
          else (this.words[0] = 0), (this.length = 1);
        var K = 0;
        for ($ = this.length - 1; $ >= 0 && (K !== 0 || $ >= L); $--) {
          var re = this.words[$] | 0;
          (this.words[$] = (K << (26 - F)) | (re >>> F)), (K = re & j);
        }
        return (
          z && K !== 0 && (z.words[z.length++] = K),
          this.length === 0 && ((this.words[0] = 0), (this.length = 1)),
          this._strip()
        );
      }),
      (s.prototype.ishrn = function (_, A, N) {
        return r(this.negative === 0), this.iushrn(_, A, N);
      }),
      (s.prototype.shln = function (_) {
        return this.clone().ishln(_);
      }),
      (s.prototype.ushln = function (_) {
        return this.clone().iushln(_);
      }),
      (s.prototype.shrn = function (_) {
        return this.clone().ishrn(_);
      }),
      (s.prototype.ushrn = function (_) {
        return this.clone().iushrn(_);
      }),
      (s.prototype.testn = function (_) {
        r(typeof _ == "number" && _ >= 0);
        var A = _ % 26,
          N = (_ - A) / 26,
          L = 1 << A;
        if (this.length <= N) return !1;
        var F = this.words[N];
        return !!(F & L);
      }),
      (s.prototype.imaskn = function (_) {
        r(typeof _ == "number" && _ >= 0);
        var A = _ % 26,
          N = (_ - A) / 26;
        if (
          (r(this.negative === 0, "imaskn works only with positive numbers"),
          this.length <= N)
        )
          return this;
        if (
          (A !== 0 && N++, (this.length = Math.min(N, this.length)), A !== 0)
        ) {
          var L = 67108863 ^ ((67108863 >>> A) << A);
          this.words[this.length - 1] &= L;
        }
        return this._strip();
      }),
      (s.prototype.maskn = function (_) {
        return this.clone().imaskn(_);
      }),
      (s.prototype.iaddn = function (_) {
        return (
          r(typeof _ == "number"),
          r(_ < 67108864),
          _ < 0
            ? this.isubn(-_)
            : this.negative !== 0
            ? this.length === 1 && (this.words[0] | 0) <= _
              ? ((this.words[0] = _ - (this.words[0] | 0)),
                (this.negative = 0),
                this)
              : ((this.negative = 0), this.isubn(_), (this.negative = 1), this)
            : this._iaddn(_)
        );
      }),
      (s.prototype._iaddn = function (_) {
        this.words[0] += _;
        for (var A = 0; A < this.length && this.words[A] >= 67108864; A++)
          (this.words[A] -= 67108864),
            A === this.length - 1
              ? (this.words[A + 1] = 1)
              : this.words[A + 1]++;
        return (this.length = Math.max(this.length, A + 1)), this;
      }),
      (s.prototype.isubn = function (_) {
        if ((r(typeof _ == "number"), r(_ < 67108864), _ < 0))
          return this.iaddn(-_);
        if (this.negative !== 0)
          return (this.negative = 0), this.iaddn(_), (this.negative = 1), this;
        if (((this.words[0] -= _), this.length === 1 && this.words[0] < 0))
          (this.words[0] = -this.words[0]), (this.negative = 1);
        else
          for (var A = 0; A < this.length && this.words[A] < 0; A++)
            (this.words[A] += 67108864), (this.words[A + 1] -= 1);
        return this._strip();
      }),
      (s.prototype.addn = function (_) {
        return this.clone().iaddn(_);
      }),
      (s.prototype.subn = function (_) {
        return this.clone().isubn(_);
      }),
      (s.prototype.iabs = function () {
        return (this.negative = 0), this;
      }),
      (s.prototype.abs = function () {
        return this.clone().iabs();
      }),
      (s.prototype._ishlnsubmul = function (_, A, N) {
        var L = _.length + N,
          F;
        this._expand(L);
        var D,
          j = 0;
        for (F = 0; F < _.length; F++) {
          D = (this.words[F + N] | 0) + j;
          var z = (_.words[F] | 0) * A;
          (D -= z & 67108863),
            (j = (D >> 26) - ((z / 67108864) | 0)),
            (this.words[F + N] = D & 67108863);
        }
        for (; F < this.length - N; F++)
          (D = (this.words[F + N] | 0) + j),
            (j = D >> 26),
            (this.words[F + N] = D & 67108863);
        if (j === 0) return this._strip();
        for (r(j === -1), j = 0, F = 0; F < this.length; F++)
          (D = -(this.words[F] | 0) + j),
            (j = D >> 26),
            (this.words[F] = D & 67108863);
        return (this.negative = 1), this._strip();
      }),
      (s.prototype._wordDiv = function (_, A) {
        var N = this.length - _.length,
          L = this.clone(),
          F = _,
          D = F.words[F.length - 1] | 0,
          j = this._countBits(D);
        (N = 26 - j),
          N !== 0 &&
            ((F = F.ushln(N)), L.iushln(N), (D = F.words[F.length - 1] | 0));
        var z = L.length - F.length,
          $;
        if (A !== "mod") {
          ($ = new s(null)),
            ($.length = z + 1),
            ($.words = new Array($.length));
          for (var K = 0; K < $.length; K++) $.words[K] = 0;
        }
        var re = L.clone()._ishlnsubmul(F, 1, z);
        re.negative === 0 && ((L = re), $ && ($.words[z] = 1));
        for (var G = z - 1; G >= 0; G--) {
          var ne =
            (L.words[F.length + G] | 0) * 67108864 +
            (L.words[F.length + G - 1] | 0);
          for (
            ne = Math.min((ne / D) | 0, 67108863), L._ishlnsubmul(F, ne, G);
            L.negative !== 0;

          )
            ne--,
              (L.negative = 0),
              L._ishlnsubmul(F, 1, G),
              L.isZero() || (L.negative ^= 1);
          $ && ($.words[G] = ne);
        }
        return (
          $ && $._strip(),
          L._strip(),
          A !== "div" && N !== 0 && L.iushrn(N),
          { div: $ || null, mod: L }
        );
      }),
      (s.prototype.divmod = function (_, A, N) {
        if ((r(!_.isZero()), this.isZero()))
          return { div: new s(0), mod: new s(0) };
        var L, F, D;
        return this.negative !== 0 && _.negative === 0
          ? ((D = this.neg().divmod(_, A)),
            A !== "mod" && (L = D.div.neg()),
            A !== "div" &&
              ((F = D.mod.neg()), N && F.negative !== 0 && F.iadd(_)),
            { div: L, mod: F })
          : this.negative === 0 && _.negative !== 0
          ? ((D = this.divmod(_.neg(), A)),
            A !== "mod" && (L = D.div.neg()),
            { div: L, mod: D.mod })
          : this.negative & _.negative
          ? ((D = this.neg().divmod(_.neg(), A)),
            A !== "div" &&
              ((F = D.mod.neg()), N && F.negative !== 0 && F.isub(_)),
            { div: D.div, mod: F })
          : _.length > this.length || this.cmp(_) < 0
          ? { div: new s(0), mod: this }
          : _.length === 1
          ? A === "div"
            ? { div: this.divn(_.words[0]), mod: null }
            : A === "mod"
            ? { div: null, mod: new s(this.modrn(_.words[0])) }
            : { div: this.divn(_.words[0]), mod: new s(this.modrn(_.words[0])) }
          : this._wordDiv(_, A);
      }),
      (s.prototype.div = function (_) {
        return this.divmod(_, "div", !1).div;
      }),
      (s.prototype.mod = function (_) {
        return this.divmod(_, "mod", !1).mod;
      }),
      (s.prototype.umod = function (_) {
        return this.divmod(_, "mod", !0).mod;
      }),
      (s.prototype.divRound = function (_) {
        var A = this.divmod(_);
        if (A.mod.isZero()) return A.div;
        var N = A.div.negative !== 0 ? A.mod.isub(_) : A.mod,
          L = _.ushrn(1),
          F = _.andln(1),
          D = N.cmp(L);
        return D < 0 || (F === 1 && D === 0)
          ? A.div
          : A.div.negative !== 0
          ? A.div.isubn(1)
          : A.div.iaddn(1);
      }),
      (s.prototype.modrn = function (_) {
        var A = _ < 0;
        A && (_ = -_), r(_ <= 67108863);
        for (var N = (1 << 26) % _, L = 0, F = this.length - 1; F >= 0; F--)
          L = (N * L + (this.words[F] | 0)) % _;
        return A ? -L : L;
      }),
      (s.prototype.modn = function (_) {
        return this.modrn(_);
      }),
      (s.prototype.idivn = function (_) {
        var A = _ < 0;
        A && (_ = -_), r(_ <= 67108863);
        for (var N = 0, L = this.length - 1; L >= 0; L--) {
          var F = (this.words[L] | 0) + N * 67108864;
          (this.words[L] = (F / _) | 0), (N = F % _);
        }
        return this._strip(), A ? this.ineg() : this;
      }),
      (s.prototype.divn = function (_) {
        return this.clone().idivn(_);
      }),
      (s.prototype.egcd = function (_) {
        r(_.negative === 0), r(!_.isZero());
        var A = this,
          N = _.clone();
        A.negative !== 0 ? (A = A.umod(_)) : (A = A.clone());
        for (
          var L = new s(1), F = new s(0), D = new s(0), j = new s(1), z = 0;
          A.isEven() && N.isEven();

        )
          A.iushrn(1), N.iushrn(1), ++z;
        for (var $ = N.clone(), K = A.clone(); !A.isZero(); ) {
          for (var re = 0, G = 1; !(A.words[0] & G) && re < 26; ++re, G <<= 1);
          if (re > 0)
            for (A.iushrn(re); re-- > 0; )
              (L.isOdd() || F.isOdd()) && (L.iadd($), F.isub(K)),
                L.iushrn(1),
                F.iushrn(1);
          for (
            var ne = 0, ae = 1;
            !(N.words[0] & ae) && ne < 26;
            ++ne, ae <<= 1
          );
          if (ne > 0)
            for (N.iushrn(ne); ne-- > 0; )
              (D.isOdd() || j.isOdd()) && (D.iadd($), j.isub(K)),
                D.iushrn(1),
                j.iushrn(1);
          A.cmp(N) >= 0
            ? (A.isub(N), L.isub(D), F.isub(j))
            : (N.isub(A), D.isub(L), j.isub(F));
        }
        return { a: D, b: j, gcd: N.iushln(z) };
      }),
      (s.prototype._invmp = function (_) {
        r(_.negative === 0), r(!_.isZero());
        var A = this,
          N = _.clone();
        A.negative !== 0 ? (A = A.umod(_)) : (A = A.clone());
        for (
          var L = new s(1), F = new s(0), D = N.clone();
          A.cmpn(1) > 0 && N.cmpn(1) > 0;

        ) {
          for (var j = 0, z = 1; !(A.words[0] & z) && j < 26; ++j, z <<= 1);
          if (j > 0)
            for (A.iushrn(j); j-- > 0; ) L.isOdd() && L.iadd(D), L.iushrn(1);
          for (var $ = 0, K = 1; !(N.words[0] & K) && $ < 26; ++$, K <<= 1);
          if ($ > 0)
            for (N.iushrn($); $-- > 0; ) F.isOdd() && F.iadd(D), F.iushrn(1);
          A.cmp(N) >= 0 ? (A.isub(N), L.isub(F)) : (N.isub(A), F.isub(L));
        }
        var re;
        return (
          A.cmpn(1) === 0 ? (re = L) : (re = F),
          re.cmpn(0) < 0 && re.iadd(_),
          re
        );
      }),
      (s.prototype.gcd = function (_) {
        if (this.isZero()) return _.abs();
        if (_.isZero()) return this.abs();
        var A = this.clone(),
          N = _.clone();
        (A.negative = 0), (N.negative = 0);
        for (var L = 0; A.isEven() && N.isEven(); L++) A.iushrn(1), N.iushrn(1);
        do {
          for (; A.isEven(); ) A.iushrn(1);
          for (; N.isEven(); ) N.iushrn(1);
          var F = A.cmp(N);
          if (F < 0) {
            var D = A;
            (A = N), (N = D);
          } else if (F === 0 || N.cmpn(1) === 0) break;
          A.isub(N);
        } while (!0);
        return N.iushln(L);
      }),
      (s.prototype.invm = function (_) {
        return this.egcd(_).a.umod(_);
      }),
      (s.prototype.isEven = function () {
        return (this.words[0] & 1) === 0;
      }),
      (s.prototype.isOdd = function () {
        return (this.words[0] & 1) === 1;
      }),
      (s.prototype.andln = function (_) {
        return this.words[0] & _;
      }),
      (s.prototype.bincn = function (_) {
        r(typeof _ == "number");
        var A = _ % 26,
          N = (_ - A) / 26,
          L = 1 << A;
        if (this.length <= N)
          return this._expand(N + 1), (this.words[N] |= L), this;
        for (var F = L, D = N; F !== 0 && D < this.length; D++) {
          var j = this.words[D] | 0;
          (j += F), (F = j >>> 26), (j &= 67108863), (this.words[D] = j);
        }
        return F !== 0 && ((this.words[D] = F), this.length++), this;
      }),
      (s.prototype.isZero = function () {
        return this.length === 1 && this.words[0] === 0;
      }),
      (s.prototype.cmpn = function (_) {
        var A = _ < 0;
        if (this.negative !== 0 && !A) return -1;
        if (this.negative === 0 && A) return 1;
        this._strip();
        var N;
        if (this.length > 1) N = 1;
        else {
          A && (_ = -_), r(_ <= 67108863, "Number is too big");
          var L = this.words[0] | 0;
          N = L === _ ? 0 : L < _ ? -1 : 1;
        }
        return this.negative !== 0 ? -N | 0 : N;
      }),
      (s.prototype.cmp = function (_) {
        if (this.negative !== 0 && _.negative === 0) return -1;
        if (this.negative === 0 && _.negative !== 0) return 1;
        var A = this.ucmp(_);
        return this.negative !== 0 ? -A | 0 : A;
      }),
      (s.prototype.ucmp = function (_) {
        if (this.length > _.length) return 1;
        if (this.length < _.length) return -1;
        for (var A = 0, N = this.length - 1; N >= 0; N--) {
          var L = this.words[N] | 0,
            F = _.words[N] | 0;
          if (L !== F) {
            L < F ? (A = -1) : L > F && (A = 1);
            break;
          }
        }
        return A;
      }),
      (s.prototype.gtn = function (_) {
        return this.cmpn(_) === 1;
      }),
      (s.prototype.gt = function (_) {
        return this.cmp(_) === 1;
      }),
      (s.prototype.gten = function (_) {
        return this.cmpn(_) >= 0;
      }),
      (s.prototype.gte = function (_) {
        return this.cmp(_) >= 0;
      }),
      (s.prototype.ltn = function (_) {
        return this.cmpn(_) === -1;
      }),
      (s.prototype.lt = function (_) {
        return this.cmp(_) === -1;
      }),
      (s.prototype.lten = function (_) {
        return this.cmpn(_) <= 0;
      }),
      (s.prototype.lte = function (_) {
        return this.cmp(_) <= 0;
      }),
      (s.prototype.eqn = function (_) {
        return this.cmpn(_) === 0;
      }),
      (s.prototype.eq = function (_) {
        return this.cmp(_) === 0;
      }),
      (s.red = function (_) {
        return new M(_);
      }),
      (s.prototype.toRed = function (_) {
        return (
          r(!this.red, "Already a number in reduction context"),
          r(this.negative === 0, "red works only with positives"),
          _.convertTo(this)._forceRed(_)
        );
      }),
      (s.prototype.fromRed = function () {
        return (
          r(this.red, "fromRed works only with numbers in reduction context"),
          this.red.convertFrom(this)
        );
      }),
      (s.prototype._forceRed = function (_) {
        return (this.red = _), this;
      }),
      (s.prototype.forceRed = function (_) {
        return (
          r(!this.red, "Already a number in reduction context"),
          this._forceRed(_)
        );
      }),
      (s.prototype.redAdd = function (_) {
        return (
          r(this.red, "redAdd works only with red numbers"),
          this.red.add(this, _)
        );
      }),
      (s.prototype.redIAdd = function (_) {
        return (
          r(this.red, "redIAdd works only with red numbers"),
          this.red.iadd(this, _)
        );
      }),
      (s.prototype.redSub = function (_) {
        return (
          r(this.red, "redSub works only with red numbers"),
          this.red.sub(this, _)
        );
      }),
      (s.prototype.redISub = function (_) {
        return (
          r(this.red, "redISub works only with red numbers"),
          this.red.isub(this, _)
        );
      }),
      (s.prototype.redShl = function (_) {
        return (
          r(this.red, "redShl works only with red numbers"),
          this.red.shl(this, _)
        );
      }),
      (s.prototype.redMul = function (_) {
        return (
          r(this.red, "redMul works only with red numbers"),
          this.red._verify2(this, _),
          this.red.mul(this, _)
        );
      }),
      (s.prototype.redIMul = function (_) {
        return (
          r(this.red, "redMul works only with red numbers"),
          this.red._verify2(this, _),
          this.red.imul(this, _)
        );
      }),
      (s.prototype.redSqr = function () {
        return (
          r(this.red, "redSqr works only with red numbers"),
          this.red._verify1(this),
          this.red.sqr(this)
        );
      }),
      (s.prototype.redISqr = function () {
        return (
          r(this.red, "redISqr works only with red numbers"),
          this.red._verify1(this),
          this.red.isqr(this)
        );
      }),
      (s.prototype.redSqrt = function () {
        return (
          r(this.red, "redSqrt works only with red numbers"),
          this.red._verify1(this),
          this.red.sqrt(this)
        );
      }),
      (s.prototype.redInvm = function () {
        return (
          r(this.red, "redInvm works only with red numbers"),
          this.red._verify1(this),
          this.red.invm(this)
        );
      }),
      (s.prototype.redNeg = function () {
        return (
          r(this.red, "redNeg works only with red numbers"),
          this.red._verify1(this),
          this.red.neg(this)
        );
      }),
      (s.prototype.redPow = function (_) {
        return (
          r(this.red && !_.red, "redPow(normalNum)"),
          this.red._verify1(this),
          this.red.pow(this, _)
        );
      });
    var R = { k256: null, p224: null, p192: null, p25519: null };
    function O(T, _) {
      (this.name = T),
        (this.p = new s(_, 16)),
        (this.n = this.p.bitLength()),
        (this.k = new s(1).iushln(this.n).isub(this.p)),
        (this.tmp = this._tmp());
    }
    (O.prototype._tmp = function () {
      var _ = new s(null);
      return (_.words = new Array(Math.ceil(this.n / 13))), _;
    }),
      (O.prototype.ireduce = function (_) {
        var A = _,
          N;
        do
          this.split(A, this.tmp),
            (A = this.imulK(A)),
            (A = A.iadd(this.tmp)),
            (N = A.bitLength());
        while (N > this.n);
        var L = N < this.n ? -1 : A.ucmp(this.p);
        return (
          L === 0
            ? ((A.words[0] = 0), (A.length = 1))
            : L > 0
            ? A.isub(this.p)
            : A.strip !== void 0
            ? A.strip()
            : A._strip(),
          A
        );
      }),
      (O.prototype.split = function (_, A) {
        _.iushrn(this.n, 0, A);
      }),
      (O.prototype.imulK = function (_) {
        return _.imul(this.k);
      });
    function B() {
      O.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    i(B, O),
      (B.prototype.split = function (_, A) {
        for (var N = 4194303, L = Math.min(_.length, 9), F = 0; F < L; F++)
          A.words[F] = _.words[F];
        if (((A.length = L), _.length <= 9)) {
          (_.words[0] = 0), (_.length = 1);
          return;
        }
        var D = _.words[9];
        for (A.words[A.length++] = D & N, F = 10; F < _.length; F++) {
          var j = _.words[F] | 0;
          (_.words[F - 10] = ((j & N) << 4) | (D >>> 22)), (D = j);
        }
        (D >>>= 22),
          (_.words[F - 10] = D),
          D === 0 && _.length > 10 ? (_.length -= 10) : (_.length -= 9);
      }),
      (B.prototype.imulK = function (_) {
        (_.words[_.length] = 0), (_.words[_.length + 1] = 0), (_.length += 2);
        for (var A = 0, N = 0; N < _.length; N++) {
          var L = _.words[N] | 0;
          (A += L * 977),
            (_.words[N] = A & 67108863),
            (A = L * 64 + ((A / 67108864) | 0));
        }
        return (
          _.words[_.length - 1] === 0 &&
            (_.length--, _.words[_.length - 1] === 0 && _.length--),
          _
        );
      });
    function C() {
      O.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    i(C, O);
    function I() {
      O.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    i(I, O);
    function P() {
      O.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    i(P, O),
      (P.prototype.imulK = function (_) {
        for (var A = 0, N = 0; N < _.length; N++) {
          var L = (_.words[N] | 0) * 19 + A,
            F = L & 67108863;
          (L >>>= 26), (_.words[N] = F), (A = L);
        }
        return A !== 0 && (_.words[_.length++] = A), _;
      }),
      (s._prime = function (_) {
        if (R[_]) return R[_];
        var A;
        if (_ === "k256") A = new B();
        else if (_ === "p224") A = new C();
        else if (_ === "p192") A = new I();
        else if (_ === "p25519") A = new P();
        else throw new Error("Unknown prime " + _);
        return (R[_] = A), A;
      });
    function M(T) {
      if (typeof T == "string") {
        var _ = s._prime(T);
        (this.m = _.p), (this.prime = _);
      } else
        r(T.gtn(1), "modulus must be greater than 1"),
          (this.m = T),
          (this.prime = null);
    }
    (M.prototype._verify1 = function (_) {
      r(_.negative === 0, "red works only with positives"),
        r(_.red, "red works only with red numbers");
    }),
      (M.prototype._verify2 = function (_, A) {
        r((_.negative | A.negative) === 0, "red works only with positives"),
          r(_.red && _.red === A.red, "red works only with red numbers");
      }),
      (M.prototype.imod = function (_) {
        return this.prime
          ? this.prime.ireduce(_)._forceRed(this)
          : (u(_, _.umod(this.m)._forceRed(this)), _);
      }),
      (M.prototype.neg = function (_) {
        return _.isZero() ? _.clone() : this.m.sub(_)._forceRed(this);
      }),
      (M.prototype.add = function (_, A) {
        this._verify2(_, A);
        var N = _.add(A);
        return N.cmp(this.m) >= 0 && N.isub(this.m), N._forceRed(this);
      }),
      (M.prototype.iadd = function (_, A) {
        this._verify2(_, A);
        var N = _.iadd(A);
        return N.cmp(this.m) >= 0 && N.isub(this.m), N;
      }),
      (M.prototype.sub = function (_, A) {
        this._verify2(_, A);
        var N = _.sub(A);
        return N.cmpn(0) < 0 && N.iadd(this.m), N._forceRed(this);
      }),
      (M.prototype.isub = function (_, A) {
        this._verify2(_, A);
        var N = _.isub(A);
        return N.cmpn(0) < 0 && N.iadd(this.m), N;
      }),
      (M.prototype.shl = function (_, A) {
        return this._verify1(_), this.imod(_.ushln(A));
      }),
      (M.prototype.imul = function (_, A) {
        return this._verify2(_, A), this.imod(_.imul(A));
      }),
      (M.prototype.mul = function (_, A) {
        return this._verify2(_, A), this.imod(_.mul(A));
      }),
      (M.prototype.isqr = function (_) {
        return this.imul(_, _.clone());
      }),
      (M.prototype.sqr = function (_) {
        return this.mul(_, _);
      }),
      (M.prototype.sqrt = function (_) {
        if (_.isZero()) return _.clone();
        var A = this.m.andln(3);
        if ((r(A % 2 === 1), A === 3)) {
          var N = this.m.add(new s(1)).iushrn(2);
          return this.pow(_, N);
        }
        for (var L = this.m.subn(1), F = 0; !L.isZero() && L.andln(1) === 0; )
          F++, L.iushrn(1);
        r(!L.isZero());
        var D = new s(1).toRed(this),
          j = D.redNeg(),
          z = this.m.subn(1).iushrn(1),
          $ = this.m.bitLength();
        for ($ = new s(2 * $ * $).toRed(this); this.pow($, z).cmp(j) !== 0; )
          $.redIAdd(j);
        for (
          var K = this.pow($, L),
            re = this.pow(_, L.addn(1).iushrn(1)),
            G = this.pow(_, L),
            ne = F;
          G.cmp(D) !== 0;

        ) {
          for (var ae = G, le = 0; ae.cmp(D) !== 0; le++) ae = ae.redSqr();
          r(le < ne);
          var ge = this.pow(K, new s(1).iushln(ne - le - 1));
          (re = re.redMul(ge)), (K = ge.redSqr()), (G = G.redMul(K)), (ne = le);
        }
        return re;
      }),
      (M.prototype.invm = function (_) {
        var A = _._invmp(this.m);
        return A.negative !== 0
          ? ((A.negative = 0), this.imod(A).redNeg())
          : this.imod(A);
      }),
      (M.prototype.pow = function (_, A) {
        if (A.isZero()) return new s(1).toRed(this);
        if (A.cmpn(1) === 0) return _.clone();
        var N = 4,
          L = new Array(1 << N);
        (L[0] = new s(1).toRed(this)), (L[1] = _);
        for (var F = 2; F < L.length; F++) L[F] = this.mul(L[F - 1], _);
        var D = L[0],
          j = 0,
          z = 0,
          $ = A.bitLength() % 26;
        for ($ === 0 && ($ = 26), F = A.length - 1; F >= 0; F--) {
          for (var K = A.words[F], re = $ - 1; re >= 0; re--) {
            var G = (K >> re) & 1;
            if ((D !== L[0] && (D = this.sqr(D)), G === 0 && j === 0)) {
              z = 0;
              continue;
            }
            (j <<= 1),
              (j |= G),
              z++,
              !(z !== N && (F !== 0 || re !== 0)) &&
                ((D = this.mul(D, L[j])), (z = 0), (j = 0));
          }
          $ = 26;
        }
        return D;
      }),
      (M.prototype.convertTo = function (_) {
        var A = _.umod(this.m);
        return A === _ ? A.clone() : A;
      }),
      (M.prototype.convertFrom = function (_) {
        var A = _.clone();
        return (A.red = null), A;
      }),
      (s.mont = function (_) {
        return new k(_);
      });
    function k(T) {
      M.call(this, T),
        (this.shift = this.m.bitLength()),
        this.shift % 26 !== 0 && (this.shift += 26 - (this.shift % 26)),
        (this.r = new s(1).iushln(this.shift)),
        (this.r2 = this.imod(this.r.sqr())),
        (this.rinv = this.r._invmp(this.m)),
        (this.minv = this.rinv.mul(this.r).isubn(1).div(this.m)),
        (this.minv = this.minv.umod(this.r)),
        (this.minv = this.r.sub(this.minv));
    }
    i(k, M),
      (k.prototype.convertTo = function (_) {
        return this.imod(_.ushln(this.shift));
      }),
      (k.prototype.convertFrom = function (_) {
        var A = this.imod(_.mul(this.rinv));
        return (A.red = null), A;
      }),
      (k.prototype.imul = function (_, A) {
        if (_.isZero() || A.isZero())
          return (_.words[0] = 0), (_.length = 1), _;
        var N = _.imul(A),
          L = N.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
          F = N.isub(L).iushrn(this.shift),
          D = F;
        return (
          F.cmp(this.m) >= 0
            ? (D = F.isub(this.m))
            : F.cmpn(0) < 0 && (D = F.iadd(this.m)),
          D._forceRed(this)
        );
      }),
      (k.prototype.mul = function (_, A) {
        if (_.isZero() || A.isZero()) return new s(0)._forceRed(this);
        var N = _.mul(A),
          L = N.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
          F = N.isub(L).iushrn(this.shift),
          D = F;
        return (
          F.cmp(this.m) >= 0
            ? (D = F.isub(this.m))
            : F.cmpn(0) < 0 && (D = F.iadd(this.m)),
          D._forceRed(this)
        );
      }),
      (k.prototype.invm = function (_) {
        var A = this.imod(_._invmp(this.m).mul(this.r2));
        return A._forceRed(this);
      });
  })(e, Bn);
})(qN);
var KN = qN.exports;
const sn = Gi(KN);
var oT = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ (function (
  e,
  t
) {
  var n = px,
    r = n.Buffer;
  function i(o, a) {
    for (var l in o) a[l] = o[l];
  }
  r.from && r.alloc && r.allocUnsafe && r.allocUnsafeSlow
    ? (e.exports = n)
    : (i(n, t), (t.Buffer = s));
  function s(o, a, l) {
    return r(o, a, l);
  }
  (s.prototype = Object.create(r.prototype)),
    i(r, s),
    (s.from = function (o, a, l) {
      if (typeof o == "number")
        throw new TypeError("Argument must not be a number");
      return r(o, a, l);
    }),
    (s.alloc = function (o, a, l) {
      if (typeof o != "number")
        throw new TypeError("Argument must be a number");
      var c = r(o);
      return (
        a !== void 0
          ? typeof l == "string"
            ? c.fill(a, l)
            : c.fill(a)
          : c.fill(0),
        c
      );
    }),
    (s.allocUnsafe = function (o) {
      if (typeof o != "number")
        throw new TypeError("Argument must be a number");
      return r(o);
    }),
    (s.allocUnsafeSlow = function (o) {
      if (typeof o != "number")
        throw new TypeError("Argument must be a number");
      return n.SlowBuffer(o);
    });
})(oT, oT.exports);
var u2e = oT.exports,
  E_ = u2e.Buffer;
function d2e(e) {
  if (e.length >= 255) throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), n = 0; n < t.length; n++) t[n] = 255;
  for (var r = 0; r < e.length; r++) {
    var i = e.charAt(r),
      s = i.charCodeAt(0);
    if (t[s] !== 255) throw new TypeError(i + " is ambiguous");
    t[s] = r;
  }
  var o = e.length,
    a = e.charAt(0),
    l = Math.log(o) / Math.log(256),
    c = Math.log(256) / Math.log(o);
  function u(h) {
    if (
      ((Array.isArray(h) || h instanceof Uint8Array) && (h = E_.from(h)),
      !E_.isBuffer(h))
    )
      throw new TypeError("Expected Buffer");
    if (h.length === 0) return "";
    for (var p = 0, g = 0, b = 0, v = h.length; b !== v && h[b] === 0; )
      b++, p++;
    for (var w = ((v - b) * c + 1) >>> 0, x = new Uint8Array(w); b !== v; ) {
      for (
        var S = h[b], R = 0, O = w - 1;
        (S !== 0 || R < g) && O !== -1;
        O--, R++
      )
        (S += (256 * x[O]) >>> 0), (x[O] = S % o >>> 0), (S = (S / o) >>> 0);
      if (S !== 0) throw new Error("Non-zero carry");
      (g = R), b++;
    }
    for (var B = w - g; B !== w && x[B] === 0; ) B++;
    for (var C = a.repeat(p); B < w; ++B) C += e.charAt(x[B]);
    return C;
  }
  function d(h) {
    if (typeof h != "string") throw new TypeError("Expected String");
    if (h.length === 0) return E_.alloc(0);
    for (var p = 0, g = 0, b = 0; h[p] === a; ) g++, p++;
    for (
      var v = ((h.length - p) * l + 1) >>> 0, w = new Uint8Array(v);
      p < h.length;

    ) {
      var x = t[h.charCodeAt(p)];
      if (x === 255) return;
      for (var S = 0, R = v - 1; (x !== 0 || S < b) && R !== -1; R--, S++)
        (x += (o * w[R]) >>> 0), (w[R] = x % 256 >>> 0), (x = (x / 256) >>> 0);
      if (x !== 0) throw new Error("Non-zero carry");
      (b = S), p++;
    }
    for (var O = v - b; O !== v && w[O] === 0; ) O++;
    var B = E_.allocUnsafe(g + (v - O));
    B.fill(0, 0, g);
    for (var C = g; O !== v; ) B[C++] = w[O++];
    return B;
  }
  function f(h) {
    var p = d(h);
    if (p) return p;
    throw new Error("Non-base" + o + " character");
  }
  return { encode: u, decodeUnsafe: d, decode: f };
}
var f2e = d2e,
  h2e = f2e,
  p2e = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
  EZ = h2e(p2e);
const fs = Gi(EZ),
  m2e = new Uint32Array([
    1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
    2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
    1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774,
    264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
    2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711,
    113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
    1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
    3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
    430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
    1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424,
    2428436474, 2756734187, 3204031479, 3329325298,
  ]),
  Zh = new Uint32Array([
    1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924,
    528734635, 1541459225,
  ]),
  Qh = new Uint32Array(64);
let g2e = class extends uZ {
  constructor() {
    super(64, 32, 8, !1),
      (this.A = Zh[0] | 0),
      (this.B = Zh[1] | 0),
      (this.C = Zh[2] | 0),
      (this.D = Zh[3] | 0),
      (this.E = Zh[4] | 0),
      (this.F = Zh[5] | 0),
      (this.G = Zh[6] | 0),
      (this.H = Zh[7] | 0);
  }
  get() {
    const { A: t, B: n, C: r, D: i, E: s, F: o, G: a, H: l } = this;
    return [t, n, r, i, s, o, a, l];
  }
  set(t, n, r, i, s, o, a, l) {
    (this.A = t | 0),
      (this.B = n | 0),
      (this.C = r | 0),
      (this.D = i | 0),
      (this.E = s | 0),
      (this.F = o | 0),
      (this.G = a | 0),
      (this.H = l | 0);
  }
  process(t, n) {
    for (let d = 0; d < 16; d++, n += 4) Qh[d] = t.getUint32(n, !1);
    for (let d = 16; d < 64; d++) {
      const f = Qh[d - 15],
        h = Qh[d - 2],
        p = Gu(f, 7) ^ Gu(f, 18) ^ (f >>> 3),
        g = Gu(h, 17) ^ Gu(h, 19) ^ (h >>> 10);
      Qh[d] = (g + Qh[d - 7] + p + Qh[d - 16]) | 0;
    }
    let { A: r, B: i, C: s, D: o, E: a, F: l, G: c, H: u } = this;
    for (let d = 0; d < 64; d++) {
      const f = Gu(a, 6) ^ Gu(a, 11) ^ Gu(a, 25),
        h = (u + f + cve(a, l, c) + m2e[d] + Qh[d]) | 0,
        g = ((Gu(r, 2) ^ Gu(r, 13) ^ Gu(r, 22)) + uve(r, i, s)) | 0;
      (u = c),
        (c = l),
        (l = a),
        (a = (o + h) | 0),
        (o = s),
        (s = i),
        (i = r),
        (r = (h + g) | 0);
    }
    (r = (r + this.A) | 0),
      (i = (i + this.B) | 0),
      (s = (s + this.C) | 0),
      (o = (o + this.D) | 0),
      (a = (a + this.E) | 0),
      (l = (l + this.F) | 0),
      (c = (c + this.G) | 0),
      (u = (u + this.H) | 0),
      this.set(r, i, s, o, a, l, c, u);
  }
  roundClean() {
    Qh.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
const aT = $N(() => new g2e());
var jo = {};
function If(e, t, n) {
  return t <= e && e <= n;
}
function a8(e) {
  if (e === void 0) return {};
  if (e === Object(e)) return e;
  throw TypeError("Could not convert argument to dictionary");
}
function y2e(e) {
  for (var t = String(e), n = t.length, r = 0, i = []; r < n; ) {
    var s = t.charCodeAt(r);
    if (s < 55296 || s > 57343) i.push(s);
    else if (56320 <= s && s <= 57343) i.push(65533);
    else if (55296 <= s && s <= 56319)
      if (r === n - 1) i.push(65533);
      else {
        var o = e.charCodeAt(r + 1);
        if (56320 <= o && o <= 57343) {
          var a = s & 1023,
            l = o & 1023;
          i.push(65536 + (a << 10) + l), (r += 1);
        } else i.push(65533);
      }
    r += 1;
  }
  return i;
}
function v2e(e) {
  for (var t = "", n = 0; n < e.length; ++n) {
    var r = e[n];
    r <= 65535
      ? (t += String.fromCharCode(r))
      : ((r -= 65536),
        (t += String.fromCharCode((r >> 10) + 55296, (r & 1023) + 56320)));
  }
  return t;
}
var n5 = -1;
function YN(e) {
  this.tokens = [].slice.call(e);
}
YN.prototype = {
  endOfStream: function () {
    return !this.tokens.length;
  },
  read: function () {
    return this.tokens.length ? this.tokens.shift() : n5;
  },
  prepend: function (e) {
    if (Array.isArray(e))
      for (var t = e; t.length; ) this.tokens.unshift(t.pop());
    else this.tokens.unshift(e);
  },
  push: function (e) {
    if (Array.isArray(e))
      for (var t = e; t.length; ) this.tokens.push(t.shift());
    else this.tokens.push(e);
  },
};
var Ey = -1;
function BA(e, t) {
  if (e) throw TypeError("Decoder error");
  return t || 65533;
}
var r5 = "utf-8";
function i5(e, t) {
  if (!(this instanceof i5)) return new i5(e, t);
  if (((e = e !== void 0 ? String(e).toLowerCase() : r5), e !== r5))
    throw new Error("Encoding not supported. Only utf-8 is supported");
  (t = a8(t)),
    (this._streaming = !1),
    (this._BOMseen = !1),
    (this._decoder = null),
    (this._fatal = !!t.fatal),
    (this._ignoreBOM = !!t.ignoreBOM),
    Object.defineProperty(this, "encoding", { value: "utf-8" }),
    Object.defineProperty(this, "fatal", { value: this._fatal }),
    Object.defineProperty(this, "ignoreBOM", { value: this._ignoreBOM });
}
i5.prototype = {
  decode: function (t, n) {
    var r;
    typeof t == "object" && t instanceof ArrayBuffer
      ? (r = new Uint8Array(t))
      : typeof t == "object" && "buffer" in t && t.buffer instanceof ArrayBuffer
      ? (r = new Uint8Array(t.buffer, t.byteOffset, t.byteLength))
      : (r = new Uint8Array(0)),
      (n = a8(n)),
      this._streaming ||
        ((this._decoder = new w2e({ fatal: this._fatal })),
        (this._BOMseen = !1)),
      (this._streaming = !!n.stream);
    for (
      var i = new YN(r), s = [], o;
      !i.endOfStream() && ((o = this._decoder.handler(i, i.read())), o !== Ey);

    )
      o !== null && (Array.isArray(o) ? s.push.apply(s, o) : s.push(o));
    if (!this._streaming) {
      do {
        if (((o = this._decoder.handler(i, i.read())), o === Ey)) break;
        o !== null && (Array.isArray(o) ? s.push.apply(s, o) : s.push(o));
      } while (!i.endOfStream());
      this._decoder = null;
    }
    return (
      s.length &&
        ["utf-8"].indexOf(this.encoding) !== -1 &&
        !this._ignoreBOM &&
        !this._BOMseen &&
        (s[0] === 65279
          ? ((this._BOMseen = !0), s.shift())
          : (this._BOMseen = !0)),
      v2e(s)
    );
  },
};
function s5(e, t) {
  if (!(this instanceof s5)) return new s5(e, t);
  if (((e = e !== void 0 ? String(e).toLowerCase() : r5), e !== r5))
    throw new Error("Encoding not supported. Only utf-8 is supported");
  (t = a8(t)),
    (this._streaming = !1),
    (this._encoder = null),
    (this._options = { fatal: !!t.fatal }),
    Object.defineProperty(this, "encoding", { value: "utf-8" });
}
s5.prototype = {
  encode: function (t, n) {
    (t = t ? String(t) : ""),
      (n = a8(n)),
      this._streaming || (this._encoder = new b2e(this._options)),
      (this._streaming = !!n.stream);
    for (
      var r = [], i = new YN(y2e(t)), s;
      !i.endOfStream() && ((s = this._encoder.handler(i, i.read())), s !== Ey);

    )
      Array.isArray(s) ? r.push.apply(r, s) : r.push(s);
    if (!this._streaming) {
      for (; (s = this._encoder.handler(i, i.read())), s !== Ey; )
        Array.isArray(s) ? r.push.apply(r, s) : r.push(s);
      this._encoder = null;
    }
    return new Uint8Array(r);
  },
};
function w2e(e) {
  var t = e.fatal,
    n = 0,
    r = 0,
    i = 0,
    s = 128,
    o = 191;
  this.handler = function (a, l) {
    if (l === n5 && i !== 0) return (i = 0), BA(t);
    if (l === n5) return Ey;
    if (i === 0) {
      if (If(l, 0, 127)) return l;
      if (If(l, 194, 223)) (i = 1), (n = l - 192);
      else if (If(l, 224, 239))
        l === 224 && (s = 160), l === 237 && (o = 159), (i = 2), (n = l - 224);
      else if (If(l, 240, 244))
        l === 240 && (s = 144), l === 244 && (o = 143), (i = 3), (n = l - 240);
      else return BA(t);
      return (n = n << (6 * i)), null;
    }
    if (!If(l, s, o))
      return (n = i = r = 0), (s = 128), (o = 191), a.prepend(l), BA(t);
    if (
      ((s = 128),
      (o = 191),
      (r += 1),
      (n += (l - 128) << (6 * (i - r))),
      r !== i)
    )
      return null;
    var c = n;
    return (n = i = r = 0), c;
  };
}
function b2e(e) {
  e.fatal,
    (this.handler = function (t, n) {
      if (n === n5) return Ey;
      if (If(n, 0, 127)) return n;
      var r, i;
      If(n, 128, 2047)
        ? ((r = 1), (i = 192))
        : If(n, 2048, 65535)
        ? ((r = 2), (i = 224))
        : If(n, 65536, 1114111) && ((r = 3), (i = 240));
      for (var s = [(n >> (6 * r)) + i]; r > 0; ) {
        var o = n >> (6 * (r - 1));
        s.push(128 | (o & 63)), (r -= 1);
      }
      return s;
    });
}
const x2e = Object.freeze(
    Object.defineProperty(
      { __proto__: null, TextDecoder: i5, TextEncoder: s5 },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  _2e = ix(x2e);
var S2e =
    (Bn && Bn.__createBinding) ||
    (Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n),
            Object.defineProperty(e, r, {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            });
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n]);
        }),
  E2e =
    (Bn && Bn.__setModuleDefault) ||
    (Object.create
      ? function (e, t) {
          Object.defineProperty(e, "default", { enumerable: !0, value: t });
        }
      : function (e, t) {
          e.default = t;
        }),
  $d =
    (Bn && Bn.__decorate) ||
    function (e, t, n, r) {
      var i = arguments.length,
        s =
          i < 3
            ? t
            : r === null
            ? (r = Object.getOwnPropertyDescriptor(t, n))
            : r,
        o;
      if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        s = Reflect.decorate(e, t, n, r);
      else
        for (var a = e.length - 1; a >= 0; a--)
          (o = e[a]) &&
            (s = (i < 3 ? o(s) : i > 3 ? o(t, n, s) : o(t, n)) || s);
      return i > 3 && s && Object.defineProperty(t, n, s), s;
    },
  A2e =
    (Bn && Bn.__importStar) ||
    function (e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null)
        for (var n in e)
          n !== "default" && Object.hasOwnProperty.call(e, n) && S2e(t, e, n);
      return E2e(t, e), t;
    },
  AZ =
    (Bn && Bn.__importDefault) ||
    function (e) {
      return e && e.__esModule ? e : { default: e };
    };
Object.defineProperty(jo, "__esModule", { value: !0 });
var CZ =
  (jo.deserializeUnchecked =
  RZ =
  jo.deserialize =
  NZ =
  jo.serialize =
  jo.BinaryReader =
  jo.BinaryWriter =
  jo.BorshError =
  jo.baseDecode =
  jo.baseEncode =
    void 0);
const _p = AZ(KN),
  kZ = AZ(EZ),
  C2e = A2e(_2e),
  k2e = typeof TextDecoder != "function" ? C2e.TextDecoder : TextDecoder,
  T2e = new k2e("utf-8", { fatal: !0 });
function M2e(e) {
  return (
    typeof e == "string" && (e = It.from(e, "utf8")),
    kZ.default.encode(It.from(e))
  );
}
jo.baseEncode = M2e;
function I2e(e) {
  return It.from(kZ.default.decode(e));
}
jo.baseDecode = I2e;
const FA = 1024;
class _a extends Error {
  constructor(t) {
    super(t), (this.fieldPath = []), (this.originalMessage = t);
  }
  addToFieldPath(t) {
    this.fieldPath.splice(0, 0, t),
      (this.message = this.originalMessage + ": " + this.fieldPath.join("."));
  }
}
jo.BorshError = _a;
class TZ {
  constructor() {
    (this.buf = It.alloc(FA)), (this.length = 0);
  }
  maybeResize() {
    this.buf.length < 16 + this.length &&
      (this.buf = It.concat([this.buf, It.alloc(FA)]));
  }
  writeU8(t) {
    this.maybeResize(), this.buf.writeUInt8(t, this.length), (this.length += 1);
  }
  writeU16(t) {
    this.maybeResize(),
      this.buf.writeUInt16LE(t, this.length),
      (this.length += 2);
  }
  writeU32(t) {
    this.maybeResize(),
      this.buf.writeUInt32LE(t, this.length),
      (this.length += 4);
  }
  writeU64(t) {
    this.maybeResize(),
      this.writeBuffer(It.from(new _p.default(t).toArray("le", 8)));
  }
  writeU128(t) {
    this.maybeResize(),
      this.writeBuffer(It.from(new _p.default(t).toArray("le", 16)));
  }
  writeU256(t) {
    this.maybeResize(),
      this.writeBuffer(It.from(new _p.default(t).toArray("le", 32)));
  }
  writeU512(t) {
    this.maybeResize(),
      this.writeBuffer(It.from(new _p.default(t).toArray("le", 64)));
  }
  writeBuffer(t) {
    (this.buf = It.concat([
      It.from(this.buf.subarray(0, this.length)),
      t,
      It.alloc(FA),
    ])),
      (this.length += t.length);
  }
  writeString(t) {
    this.maybeResize();
    const n = It.from(t, "utf8");
    this.writeU32(n.length), this.writeBuffer(n);
  }
  writeFixedArray(t) {
    this.writeBuffer(It.from(t));
  }
  writeArray(t, n) {
    this.maybeResize(), this.writeU32(t.length);
    for (const r of t) this.maybeResize(), n(r);
  }
  toArray() {
    return this.buf.subarray(0, this.length);
  }
}
jo.BinaryWriter = TZ;
function zd(e, t, n) {
  const r = n.value;
  n.value = function (...i) {
    try {
      return r.apply(this, i);
    } catch (s) {
      if (s instanceof RangeError) {
        const o = s.code;
        if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(o) >= 0)
          throw new _a("Reached the end of buffer when deserializing");
      }
      throw s;
    }
  };
}
class Vl {
  constructor(t) {
    (this.buf = t), (this.offset = 0);
  }
  readU8() {
    const t = this.buf.readUInt8(this.offset);
    return (this.offset += 1), t;
  }
  readU16() {
    const t = this.buf.readUInt16LE(this.offset);
    return (this.offset += 2), t;
  }
  readU32() {
    const t = this.buf.readUInt32LE(this.offset);
    return (this.offset += 4), t;
  }
  readU64() {
    const t = this.readBuffer(8);
    return new _p.default(t, "le");
  }
  readU128() {
    const t = this.readBuffer(16);
    return new _p.default(t, "le");
  }
  readU256() {
    const t = this.readBuffer(32);
    return new _p.default(t, "le");
  }
  readU512() {
    const t = this.readBuffer(64);
    return new _p.default(t, "le");
  }
  readBuffer(t) {
    if (this.offset + t > this.buf.length)
      throw new _a(`Expected buffer length ${t} isn't within bounds`);
    const n = this.buf.slice(this.offset, this.offset + t);
    return (this.offset += t), n;
  }
  readString() {
    const t = this.readU32(),
      n = this.readBuffer(t);
    try {
      return T2e.decode(n);
    } catch (r) {
      throw new _a(`Error decoding UTF-8 string: ${r}`);
    }
  }
  readFixedArray(t) {
    return new Uint8Array(this.readBuffer(t));
  }
  readArray(t) {
    const n = this.readU32(),
      r = Array();
    for (let i = 0; i < n; ++i) r.push(t());
    return r;
  }
}
$d([zd], Vl.prototype, "readU8", null);
$d([zd], Vl.prototype, "readU16", null);
$d([zd], Vl.prototype, "readU32", null);
$d([zd], Vl.prototype, "readU64", null);
$d([zd], Vl.prototype, "readU128", null);
$d([zd], Vl.prototype, "readU256", null);
$d([zd], Vl.prototype, "readU512", null);
$d([zd], Vl.prototype, "readString", null);
$d([zd], Vl.prototype, "readFixedArray", null);
$d([zd], Vl.prototype, "readArray", null);
jo.BinaryReader = Vl;
function MZ(e) {
  return e.charAt(0).toUpperCase() + e.slice(1);
}
function Z0(e, t, n, r, i) {
  try {
    if (typeof r == "string") i[`write${MZ(r)}`](n);
    else if (r instanceof Array)
      if (typeof r[0] == "number") {
        if (n.length !== r[0])
          throw new _a(
            `Expecting byte array of length ${r[0]}, but got ${n.length} bytes`
          );
        i.writeFixedArray(n);
      } else if (r.length === 2 && typeof r[1] == "number") {
        if (n.length !== r[1])
          throw new _a(
            `Expecting byte array of length ${r[1]}, but got ${n.length} bytes`
          );
        for (let s = 0; s < r[1]; s++) Z0(e, null, n[s], r[0], i);
      } else
        i.writeArray(n, (s) => {
          Z0(e, t, s, r[0], i);
        });
    else if (r.kind !== void 0)
      switch (r.kind) {
        case "option": {
          n == null ? i.writeU8(0) : (i.writeU8(1), Z0(e, t, n, r.type, i));
          break;
        }
        case "map": {
          i.writeU32(n.size),
            n.forEach((s, o) => {
              Z0(e, t, o, r.key, i), Z0(e, t, s, r.value, i);
            });
          break;
        }
        default:
          throw new _a(`FieldType ${r} unrecognized`);
      }
    else IZ(e, n, i);
  } catch (s) {
    throw (s instanceof _a && s.addToFieldPath(t), s);
  }
}
function IZ(e, t, n) {
  if (typeof t.borshSerialize == "function") {
    t.borshSerialize(n);
    return;
  }
  const r = e.get(t.constructor);
  if (!r) throw new _a(`Class ${t.constructor.name} is missing in schema`);
  if (r.kind === "struct")
    r.fields.map(([i, s]) => {
      Z0(e, i, t[i], s, n);
    });
  else if (r.kind === "enum") {
    const i = t[r.field];
    for (let s = 0; s < r.values.length; ++s) {
      const [o, a] = r.values[s];
      if (o === i) {
        n.writeU8(s), Z0(e, o, t[o], a, n);
        break;
      }
    }
  } else
    throw new _a(`Unexpected schema kind: ${r.kind} for ${t.constructor.name}`);
}
function N2e(e, t, n = TZ) {
  const r = new n();
  return IZ(e, t, r), r.toArray();
}
var NZ = (jo.serialize = N2e);
function Q0(e, t, n, r) {
  try {
    if (typeof n == "string") return r[`read${MZ(n)}`]();
    if (n instanceof Array) {
      if (typeof n[0] == "number") return r.readFixedArray(n[0]);
      if (typeof n[1] == "number") {
        const i = [];
        for (let s = 0; s < n[1]; s++) i.push(Q0(e, null, n[0], r));
        return i;
      } else return r.readArray(() => Q0(e, t, n[0], r));
    }
    if (n.kind === "option") return r.readU8() ? Q0(e, t, n.type, r) : void 0;
    if (n.kind === "map") {
      let i = new Map();
      const s = r.readU32();
      for (let o = 0; o < s; o++) {
        const a = Q0(e, t, n.key, r),
          l = Q0(e, t, n.value, r);
        i.set(a, l);
      }
      return i;
    }
    return ZN(e, n, r);
  } catch (i) {
    throw (i instanceof _a && i.addToFieldPath(t), i);
  }
}
function ZN(e, t, n) {
  if (typeof t.borshDeserialize == "function") return t.borshDeserialize(n);
  const r = e.get(t);
  if (!r) throw new _a(`Class ${t.name} is missing in schema`);
  if (r.kind === "struct") {
    const i = {};
    for (const [s, o] of e.get(t).fields) i[s] = Q0(e, s, o, n);
    return new t(i);
  }
  if (r.kind === "enum") {
    const i = n.readU8();
    if (i >= r.values.length) throw new _a(`Enum index: ${i} is out of range`);
    const [s, o] = r.values[i],
      a = Q0(e, s, o, n);
    return new t({ [s]: a });
  }
  throw new _a(`Unexpected schema kind: ${r.kind} for ${t.constructor.name}`);
}
function R2e(e, t, n, r = Vl) {
  const i = new r(n),
    s = ZN(e, t, i);
  if (i.offset < n.length)
    throw new _a(
      `Unexpected ${n.length - i.offset} bytes after deserialized data`
    );
  return s;
}
var RZ = (jo.deserialize = R2e);
function O2e(e, t, n, r = Vl) {
  const i = new r(n);
  return ZN(e, t, i);
}
CZ = jo.deserializeUnchecked = O2e;
var ke = {};
Object.defineProperty(ke, "__esModule", { value: !0 });
ke.s16 =
  ke.s8 =
  ke.nu64be =
  ke.u48be =
  ke.u40be =
  ke.u32be =
  ke.u24be =
  ke.u16be =
  Io =
  ke.nu64 =
  ke.u48 =
  ke.u40 =
  Zt =
  ke.u32 =
  ke.u24 =
  gc =
  ke.u16 =
  Ur =
  ke.u8 =
  Dp =
  ke.offset =
  ke.greedy =
  ke.Constant =
  ke.UTF8 =
  ke.CString =
  ke.Blob =
  ke.Boolean =
  ke.BitField =
  ke.BitStructure =
  ke.VariantLayout =
  ke.Union =
  ke.UnionLayoutDiscriminator =
  ke.UnionDiscriminator =
  ke.Structure =
  ke.Sequence =
  ke.DoubleBE =
  ke.Double =
  ke.FloatBE =
  ke.Float =
  ke.NearInt64BE =
  ke.NearInt64 =
  ke.NearUInt64BE =
  ke.NearUInt64 =
  ke.IntBE =
  ke.Int =
  ke.UIntBE =
  ke.UInt =
  ke.OffsetLayout =
  ke.GreedyCount =
  ke.ExternalLayout =
  ke.bindConstructorLayout =
  ke.nameWithProperty =
  ke.Layout =
  ke.uint8ArrayToBuffer =
  ke.checkUint8Array =
    void 0;
ke.constant =
  ke.utf8 =
  ke.cstr =
  $i =
  ke.blob =
  ke.unionLayoutDiscriminator =
  ke.union =
  Fo =
  ke.seq =
  ke.bits =
  Qt =
  ke.struct =
  ke.f64be =
  ke.f64 =
  ke.f32be =
  ke.f32 =
  ke.ns64be =
  ke.s48be =
  ke.s40be =
  ke.s32be =
  ke.s24be =
  ke.s16be =
  Tl =
  ke.ns64 =
  ke.s48 =
  ke.s40 =
  ke.s32 =
  ke.s24 =
    void 0;
const QN = px;
function lv(e) {
  if (!(e instanceof Uint8Array)) throw new TypeError("b must be a Uint8Array");
}
ke.checkUint8Array = lv;
function Kr(e) {
  return lv(e), QN.Buffer.from(e.buffer, e.byteOffset, e.length);
}
ke.uint8ArrayToBuffer = Kr;
let di = class {
  constructor(t, n) {
    if (!Number.isInteger(t)) throw new TypeError("span must be an integer");
    (this.span = t), (this.property = n);
  }
  makeDestinationObject() {
    return {};
  }
  getSpan(t, n) {
    if (0 > this.span) throw new RangeError("indeterminate span");
    return this.span;
  }
  replicate(t) {
    const n = Object.create(this.constructor.prototype);
    return Object.assign(n, this), (n.property = t), n;
  }
  fromArray(t) {}
};
ke.Layout = di;
function XN(e, t) {
  return t.property ? e + "[" + t.property + "]" : e;
}
ke.nameWithProperty = XN;
function P2e(e, t) {
  if (typeof e != "function") throw new TypeError("Class must be constructor");
  if (Object.prototype.hasOwnProperty.call(e, "layout_"))
    throw new Error("Class is already bound to a layout");
  if (!(t && t instanceof di)) throw new TypeError("layout must be a Layout");
  if (Object.prototype.hasOwnProperty.call(t, "boundConstructor_"))
    throw new Error("layout is already bound to a constructor");
  (e.layout_ = t),
    (t.boundConstructor_ = e),
    (t.makeDestinationObject = () => new e()),
    Object.defineProperty(e.prototype, "encode", {
      value(n, r) {
        return t.encode(this, n, r);
      },
      writable: !0,
    }),
    Object.defineProperty(e, "decode", {
      value(n, r) {
        return t.decode(n, r);
      },
      writable: !0,
    });
}
ke.bindConstructorLayout = P2e;
let Qa = class extends di {
  isCount() {
    throw new Error("ExternalLayout is abstract");
  }
};
ke.ExternalLayout = Qa;
let OZ = class extends Qa {
  constructor(t = 1, n) {
    if (!Number.isInteger(t) || 0 >= t)
      throw new TypeError("elementSpan must be a (positive) integer");
    super(-1, n), (this.elementSpan = t);
  }
  isCount() {
    return !0;
  }
  decode(t, n = 0) {
    lv(t);
    const r = t.length - n;
    return Math.floor(r / this.elementSpan);
  }
  encode(t, n, r) {
    return 0;
  }
};
ke.GreedyCount = OZ;
let JN = class extends Qa {
  constructor(t, n = 0, r) {
    if (!(t instanceof di)) throw new TypeError("layout must be a Layout");
    if (!Number.isInteger(n))
      throw new TypeError("offset must be integer or undefined");
    super(t.span, r || t.property), (this.layout = t), (this.offset = n);
  }
  isCount() {
    return this.layout instanceof Cc || this.layout instanceof xu;
  }
  decode(t, n = 0) {
    return this.layout.decode(t, n + this.offset);
  }
  encode(t, n, r = 0) {
    return this.layout.encode(t, n, r + this.offset);
  }
};
ke.OffsetLayout = JN;
let Cc = class extends di {
  constructor(t, n) {
    if ((super(t, n), 6 < this.span))
      throw new RangeError("span must not exceed 6 bytes");
  }
  decode(t, n = 0) {
    return Kr(t).readUIntLE(n, this.span);
  }
  encode(t, n, r = 0) {
    return Kr(n).writeUIntLE(t, r, this.span), this.span;
  }
};
ke.UInt = Cc;
let xu = class extends di {
  constructor(t, n) {
    if ((super(t, n), 6 < this.span))
      throw new RangeError("span must not exceed 6 bytes");
  }
  decode(t, n = 0) {
    return Kr(t).readUIntBE(n, this.span);
  }
  encode(t, n, r = 0) {
    return Kr(n).writeUIntBE(t, r, this.span), this.span;
  }
};
ke.UIntBE = xu;
let f1 = class extends di {
  constructor(t, n) {
    if ((super(t, n), 6 < this.span))
      throw new RangeError("span must not exceed 6 bytes");
  }
  decode(t, n = 0) {
    return Kr(t).readIntLE(n, this.span);
  }
  encode(t, n, r = 0) {
    return Kr(n).writeIntLE(t, r, this.span), this.span;
  }
};
ke.Int = f1;
let cv = class extends di {
  constructor(t, n) {
    if ((super(t, n), 6 < this.span))
      throw new RangeError("span must not exceed 6 bytes");
  }
  decode(t, n = 0) {
    return Kr(t).readIntBE(n, this.span);
  }
  encode(t, n, r = 0) {
    return Kr(n).writeIntBE(t, r, this.span), this.span;
  }
};
ke.IntBE = cv;
const lT = Math.pow(2, 32);
function l8(e) {
  const t = Math.floor(e / lT),
    n = e - t * lT;
  return { hi32: t, lo32: n };
}
function c8(e, t) {
  return e * lT + t;
}
let PZ = class extends di {
  constructor(t) {
    super(8, t);
  }
  decode(t, n = 0) {
    const r = Kr(t),
      i = r.readUInt32LE(n),
      s = r.readUInt32LE(n + 4);
    return c8(s, i);
  }
  encode(t, n, r = 0) {
    const i = l8(t),
      s = Kr(n);
    return s.writeUInt32LE(i.lo32, r), s.writeUInt32LE(i.hi32, r + 4), 8;
  }
};
ke.NearUInt64 = PZ;
let LZ = class extends di {
  constructor(t) {
    super(8, t);
  }
  decode(t, n = 0) {
    const r = Kr(t),
      i = r.readUInt32BE(n),
      s = r.readUInt32BE(n + 4);
    return c8(i, s);
  }
  encode(t, n, r = 0) {
    const i = l8(t),
      s = Kr(n);
    return s.writeUInt32BE(i.hi32, r), s.writeUInt32BE(i.lo32, r + 4), 8;
  }
};
ke.NearUInt64BE = LZ;
let jZ = class extends di {
  constructor(t) {
    super(8, t);
  }
  decode(t, n = 0) {
    const r = Kr(t),
      i = r.readUInt32LE(n),
      s = r.readInt32LE(n + 4);
    return c8(s, i);
  }
  encode(t, n, r = 0) {
    const i = l8(t),
      s = Kr(n);
    return s.writeUInt32LE(i.lo32, r), s.writeInt32LE(i.hi32, r + 4), 8;
  }
};
ke.NearInt64 = jZ;
let DZ = class extends di {
  constructor(t) {
    super(8, t);
  }
  decode(t, n = 0) {
    const r = Kr(t),
      i = r.readInt32BE(n),
      s = r.readUInt32BE(n + 4);
    return c8(i, s);
  }
  encode(t, n, r = 0) {
    const i = l8(t),
      s = Kr(n);
    return s.writeInt32BE(i.hi32, r), s.writeUInt32BE(i.lo32, r + 4), 8;
  }
};
ke.NearInt64BE = DZ;
let BZ = class extends di {
  constructor(t) {
    super(4, t);
  }
  decode(t, n = 0) {
    return Kr(t).readFloatLE(n);
  }
  encode(t, n, r = 0) {
    return Kr(n).writeFloatLE(t, r), 4;
  }
};
ke.Float = BZ;
let FZ = class extends di {
  constructor(t) {
    super(4, t);
  }
  decode(t, n = 0) {
    return Kr(t).readFloatBE(n);
  }
  encode(t, n, r = 0) {
    return Kr(n).writeFloatBE(t, r), 4;
  }
};
ke.FloatBE = FZ;
let UZ = class extends di {
  constructor(t) {
    super(8, t);
  }
  decode(t, n = 0) {
    return Kr(t).readDoubleLE(n);
  }
  encode(t, n, r = 0) {
    return Kr(n).writeDoubleLE(t, r), 8;
  }
};
ke.Double = UZ;
let $Z = class extends di {
  constructor(t) {
    super(8, t);
  }
  decode(t, n = 0) {
    return Kr(t).readDoubleBE(n);
  }
  encode(t, n, r = 0) {
    return Kr(n).writeDoubleBE(t, r), 8;
  }
};
ke.DoubleBE = $Z;
let zZ = class extends di {
  constructor(t, n, r) {
    if (!(t instanceof di))
      throw new TypeError("elementLayout must be a Layout");
    if (!((n instanceof Qa && n.isCount()) || (Number.isInteger(n) && 0 <= n)))
      throw new TypeError(
        "count must be non-negative integer or an unsigned integer ExternalLayout"
      );
    let i = -1;
    !(n instanceof Qa) && 0 < t.span && (i = n * t.span),
      super(i, r),
      (this.elementLayout = t),
      (this.count = n);
  }
  getSpan(t, n = 0) {
    if (0 <= this.span) return this.span;
    let r = 0,
      i = this.count;
    if ((i instanceof Qa && (i = i.decode(t, n)), 0 < this.elementLayout.span))
      r = i * this.elementLayout.span;
    else {
      let s = 0;
      for (; s < i; ) (r += this.elementLayout.getSpan(t, n + r)), ++s;
    }
    return r;
  }
  decode(t, n = 0) {
    const r = [];
    let i = 0,
      s = this.count;
    for (s instanceof Qa && (s = s.decode(t, n)); i < s; )
      r.push(this.elementLayout.decode(t, n)),
        (n += this.elementLayout.getSpan(t, n)),
        (i += 1);
    return r;
  }
  encode(t, n, r = 0) {
    const i = this.elementLayout,
      s = t.reduce((o, a) => o + i.encode(a, n, r + o), 0);
    return this.count instanceof Qa && this.count.encode(t.length, n, r), s;
  }
};
ke.Sequence = zZ;
let WZ = class extends di {
  constructor(t, n, r) {
    if (!(Array.isArray(t) && t.reduce((s, o) => s && o instanceof di, !0)))
      throw new TypeError("fields must be array of Layout instances");
    typeof n == "boolean" && r === void 0 && ((r = n), (n = void 0));
    for (const s of t)
      if (0 > s.span && s.property === void 0)
        throw new Error("fields cannot contain unnamed variable-length layout");
    let i = -1;
    try {
      i = t.reduce((s, o) => s + o.getSpan(), 0);
    } catch {}
    super(i, n), (this.fields = t), (this.decodePrefixes = !!r);
  }
  getSpan(t, n = 0) {
    if (0 <= this.span) return this.span;
    let r = 0;
    try {
      r = this.fields.reduce((i, s) => {
        const o = s.getSpan(t, n);
        return (n += o), i + o;
      }, 0);
    } catch {
      throw new RangeError("indeterminate span");
    }
    return r;
  }
  decode(t, n = 0) {
    lv(t);
    const r = this.makeDestinationObject();
    for (const i of this.fields)
      if (
        (i.property !== void 0 && (r[i.property] = i.decode(t, n)),
        (n += i.getSpan(t, n)),
        this.decodePrefixes && t.length === n)
      )
        break;
    return r;
  }
  encode(t, n, r = 0) {
    const i = r;
    let s = 0,
      o = 0;
    for (const a of this.fields) {
      let l = a.span;
      if (((o = 0 < l ? l : 0), a.property !== void 0)) {
        const c = t[a.property];
        c !== void 0 &&
          ((o = a.encode(c, n, r)), 0 > l && (l = a.getSpan(n, r)));
      }
      (s = r), (r += l);
    }
    return s + o - i;
  }
  fromArray(t) {
    const n = this.makeDestinationObject();
    for (const r of this.fields)
      r.property !== void 0 && 0 < t.length && (n[r.property] = t.shift());
    return n;
  }
  layoutFor(t) {
    if (typeof t != "string") throw new TypeError("property must be string");
    for (const n of this.fields) if (n.property === t) return n;
  }
  offsetOf(t) {
    if (typeof t != "string") throw new TypeError("property must be string");
    let n = 0;
    for (const r of this.fields) {
      if (r.property === t) return n;
      0 > r.span ? (n = -1) : 0 <= n && (n += r.span);
    }
  }
};
ke.Structure = WZ;
let eR = class {
  constructor(t) {
    this.property = t;
  }
  decode(t, n) {
    throw new Error("UnionDiscriminator is abstract");
  }
  encode(t, n, r) {
    throw new Error("UnionDiscriminator is abstract");
  }
};
ke.UnionDiscriminator = eR;
let o5 = class extends eR {
  constructor(t, n) {
    if (!(t instanceof Qa && t.isCount()))
      throw new TypeError("layout must be an unsigned integer ExternalLayout");
    super(n || t.property || "variant"), (this.layout = t);
  }
  decode(t, n) {
    return this.layout.decode(t, n);
  }
  encode(t, n, r) {
    return this.layout.encode(t, n, r);
  }
};
ke.UnionLayoutDiscriminator = o5;
let tR = class extends di {
  constructor(t, n, r) {
    let i;
    if (t instanceof Cc || t instanceof xu) i = new o5(new JN(t));
    else if (t instanceof Qa && t.isCount()) i = new o5(t);
    else if (t instanceof eR) i = t;
    else
      throw new TypeError(
        "discr must be a UnionDiscriminator or an unsigned integer layout"
      );
    if ((n === void 0 && (n = null), !(n === null || n instanceof di)))
      throw new TypeError("defaultLayout must be null or a Layout");
    if (n !== null) {
      if (0 > n.span) throw new Error("defaultLayout must have constant span");
      n.property === void 0 && (n = n.replicate("content"));
    }
    let s = -1;
    n &&
      ((s = n.span),
      0 <= s && (t instanceof Cc || t instanceof xu) && (s += i.layout.span)),
      super(s, r),
      (this.discriminator = i),
      (this.usesPrefixDiscriminator = t instanceof Cc || t instanceof xu),
      (this.defaultLayout = n),
      (this.registry = {});
    let o = this.defaultGetSourceVariant.bind(this);
    (this.getSourceVariant = function (a) {
      return o(a);
    }),
      (this.configGetSourceVariant = function (a) {
        o = a.bind(this);
      });
  }
  getSpan(t, n = 0) {
    if (0 <= this.span) return this.span;
    const r = this.getVariant(t, n);
    if (!r)
      throw new Error("unable to determine span for unrecognized variant");
    return r.getSpan(t, n);
  }
  defaultGetSourceVariant(t) {
    if (Object.prototype.hasOwnProperty.call(t, this.discriminator.property)) {
      if (
        this.defaultLayout &&
        this.defaultLayout.property &&
        Object.prototype.hasOwnProperty.call(t, this.defaultLayout.property)
      )
        return;
      const n = this.registry[t[this.discriminator.property]];
      if (
        n &&
        (!n.layout ||
          (n.property && Object.prototype.hasOwnProperty.call(t, n.property)))
      )
        return n;
    } else
      for (const n in this.registry) {
        const r = this.registry[n];
        if (r.property && Object.prototype.hasOwnProperty.call(t, r.property))
          return r;
      }
    throw new Error("unable to infer src variant");
  }
  decode(t, n = 0) {
    let r;
    const i = this.discriminator,
      s = i.decode(t, n),
      o = this.registry[s];
    if (o === void 0) {
      const a = this.defaultLayout;
      let l = 0;
      this.usesPrefixDiscriminator && (l = i.layout.span),
        (r = this.makeDestinationObject()),
        (r[i.property] = s),
        (r[a.property] = a.decode(t, n + l));
    } else r = o.decode(t, n);
    return r;
  }
  encode(t, n, r = 0) {
    const i = this.getSourceVariant(t);
    if (i === void 0) {
      const s = this.discriminator,
        o = this.defaultLayout;
      let a = 0;
      return (
        this.usesPrefixDiscriminator && (a = s.layout.span),
        s.encode(t[s.property], n, r),
        a + o.encode(t[o.property], n, r + a)
      );
    }
    return i.encode(t, n, r);
  }
  addVariant(t, n, r) {
    const i = new HZ(this, t, n, r);
    return (this.registry[t] = i), i;
  }
  getVariant(t, n = 0) {
    let r;
    return (
      t instanceof Uint8Array ? (r = this.discriminator.decode(t, n)) : (r = t),
      this.registry[r]
    );
  }
};
ke.Union = tR;
let HZ = class extends di {
  constructor(t, n, r, i) {
    if (!(t instanceof tR)) throw new TypeError("union must be a Union");
    if (!Number.isInteger(n) || 0 > n)
      throw new TypeError("variant must be a (non-negative) integer");
    if ((typeof r == "string" && i === void 0 && ((i = r), (r = null)), r)) {
      if (!(r instanceof di)) throw new TypeError("layout must be a Layout");
      if (
        t.defaultLayout !== null &&
        0 <= r.span &&
        r.span > t.defaultLayout.span
      )
        throw new Error("variant span exceeds span of containing union");
      if (typeof i != "string")
        throw new TypeError("variant must have a String property");
    }
    let s = t.span;
    0 > t.span &&
      ((s = r ? r.span : 0),
      0 <= s &&
        t.usesPrefixDiscriminator &&
        (s += t.discriminator.layout.span)),
      super(s, i),
      (this.union = t),
      (this.variant = n),
      (this.layout = r || null);
  }
  getSpan(t, n = 0) {
    if (0 <= this.span) return this.span;
    let r = 0;
    this.union.usesPrefixDiscriminator &&
      (r = this.union.discriminator.layout.span);
    let i = 0;
    return this.layout && (i = this.layout.getSpan(t, n + r)), r + i;
  }
  decode(t, n = 0) {
    const r = this.makeDestinationObject();
    if (this !== this.union.getVariant(t, n))
      throw new Error("variant mismatch");
    let i = 0;
    return (
      this.union.usesPrefixDiscriminator &&
        (i = this.union.discriminator.layout.span),
      this.layout
        ? (r[this.property] = this.layout.decode(t, n + i))
        : this.property
        ? (r[this.property] = !0)
        : this.union.usesPrefixDiscriminator &&
          (r[this.union.discriminator.property] = this.variant),
      r
    );
  }
  encode(t, n, r = 0) {
    let i = 0;
    if (
      (this.union.usesPrefixDiscriminator &&
        (i = this.union.discriminator.layout.span),
      this.layout && !Object.prototype.hasOwnProperty.call(t, this.property))
    )
      throw new TypeError("variant lacks property " + this.property);
    this.union.discriminator.encode(this.variant, n, r);
    let s = i;
    if (
      this.layout &&
      (this.layout.encode(t[this.property], n, r + i),
      (s += this.layout.getSpan(n, r + i)),
      0 <= this.union.span && s > this.union.span)
    )
      throw new Error("encoded variant overruns containing union");
    return s;
  }
  fromArray(t) {
    if (this.layout) return this.layout.fromArray(t);
  }
};
ke.VariantLayout = HZ;
function tg(e) {
  return 0 > e && (e += 4294967296), e;
}
let nR = class extends di {
  constructor(t, n, r) {
    if (!(t instanceof Cc || t instanceof xu))
      throw new TypeError("word must be a UInt or UIntBE layout");
    if (
      (typeof n == "string" && r === void 0 && ((r = n), (n = !1)), 4 < t.span)
    )
      throw new RangeError("word cannot exceed 32 bits");
    super(t.span, r), (this.word = t), (this.msb = !!n), (this.fields = []);
    let i = 0;
    (this._packedSetValue = function (s) {
      return (i = tg(s)), this;
    }),
      (this._packedGetValue = function () {
        return i;
      });
  }
  decode(t, n = 0) {
    const r = this.makeDestinationObject(),
      i = this.word.decode(t, n);
    this._packedSetValue(i);
    for (const s of this.fields)
      s.property !== void 0 && (r[s.property] = s.decode(t));
    return r;
  }
  encode(t, n, r = 0) {
    const i = this.word.decode(n, r);
    this._packedSetValue(i);
    for (const s of this.fields)
      if (s.property !== void 0) {
        const o = t[s.property];
        o !== void 0 && s.encode(o);
      }
    return this.word.encode(this._packedGetValue(), n, r);
  }
  addField(t, n) {
    const r = new rR(this, t, n);
    return this.fields.push(r), r;
  }
  addBoolean(t) {
    const n = new VZ(this, t);
    return this.fields.push(n), n;
  }
  fieldFor(t) {
    if (typeof t != "string") throw new TypeError("property must be string");
    for (const n of this.fields) if (n.property === t) return n;
  }
};
ke.BitStructure = nR;
let rR = class {
  constructor(t, n, r) {
    if (!(t instanceof nR))
      throw new TypeError("container must be a BitStructure");
    if (!Number.isInteger(n) || 0 >= n)
      throw new TypeError("bits must be positive integer");
    const i = 8 * t.span,
      s = t.fields.reduce((o, a) => o + a.bits, 0);
    if (n + s > i)
      throw new Error(
        "bits too long for span remainder (" + (i - s) + " of " + i + " remain)"
      );
    (this.container = t),
      (this.bits = n),
      (this.valueMask = (1 << n) - 1),
      n === 32 && (this.valueMask = 4294967295),
      (this.start = s),
      this.container.msb && (this.start = i - s - n),
      (this.wordMask = tg(this.valueMask << this.start)),
      (this.property = r);
  }
  decode(t, n) {
    const r = this.container._packedGetValue();
    return tg(r & this.wordMask) >>> this.start;
  }
  encode(t) {
    if (
      typeof t != "number" ||
      !Number.isInteger(t) ||
      t !== tg(t & this.valueMask)
    )
      throw new TypeError(
        XN("BitField.encode", this) +
          " value must be integer not exceeding " +
          this.valueMask
      );
    const n = this.container._packedGetValue(),
      r = tg(t << this.start);
    this.container._packedSetValue(tg(n & ~this.wordMask) | r);
  }
};
ke.BitField = rR;
let VZ = class extends rR {
  constructor(t, n) {
    super(t, 1, n);
  }
  decode(t, n) {
    return !!super.decode(t, n);
  }
  encode(t) {
    typeof t == "boolean" && (t = +t), super.encode(t);
  }
};
ke.Boolean = VZ;
let GZ = class extends di {
  constructor(t, n) {
    if (!((t instanceof Qa && t.isCount()) || (Number.isInteger(t) && 0 <= t)))
      throw new TypeError(
        "length must be positive integer or an unsigned integer ExternalLayout"
      );
    let r = -1;
    t instanceof Qa || (r = t), super(r, n), (this.length = t);
  }
  getSpan(t, n) {
    let r = this.span;
    return 0 > r && (r = this.length.decode(t, n)), r;
  }
  decode(t, n = 0) {
    let r = this.span;
    return 0 > r && (r = this.length.decode(t, n)), Kr(t).slice(n, n + r);
  }
  encode(t, n, r) {
    let i = this.length;
    if (
      (this.length instanceof Qa && (i = t.length),
      !(t instanceof Uint8Array && i === t.length))
    )
      throw new TypeError(
        XN("Blob.encode", this) +
          " requires (length " +
          i +
          ") Uint8Array as src"
      );
    if (r + i > n.length) throw new RangeError("encoding overruns Uint8Array");
    const s = Kr(t);
    return (
      Kr(n).write(s.toString("hex"), r, i, "hex"),
      this.length instanceof Qa && this.length.encode(i, n, r),
      i
    );
  }
};
ke.Blob = GZ;
let qZ = class extends di {
  constructor(t) {
    super(-1, t);
  }
  getSpan(t, n = 0) {
    lv(t);
    let r = n;
    for (; r < t.length && t[r] !== 0; ) r += 1;
    return 1 + r - n;
  }
  decode(t, n = 0) {
    const r = this.getSpan(t, n);
    return Kr(t)
      .slice(n, n + r - 1)
      .toString("utf-8");
  }
  encode(t, n, r = 0) {
    typeof t != "string" && (t = String(t));
    const i = QN.Buffer.from(t, "utf8"),
      s = i.length;
    if (r + s > n.length) throw new RangeError("encoding overruns Buffer");
    const o = Kr(n);
    return i.copy(o, r), (o[r + s] = 0), s + 1;
  }
};
ke.CString = qZ;
let KZ = class extends di {
  constructor(t, n) {
    if (
      (typeof t == "string" && n === void 0 && ((n = t), (t = void 0)),
      t === void 0)
    )
      t = -1;
    else if (!Number.isInteger(t))
      throw new TypeError("maxSpan must be an integer");
    super(-1, n), (this.maxSpan = t);
  }
  getSpan(t, n = 0) {
    return lv(t), t.length - n;
  }
  decode(t, n = 0) {
    const r = this.getSpan(t, n);
    if (0 <= this.maxSpan && this.maxSpan < r)
      throw new RangeError("text length exceeds maxSpan");
    return Kr(t)
      .slice(n, n + r)
      .toString("utf-8");
  }
  encode(t, n, r = 0) {
    typeof t != "string" && (t = String(t));
    const i = QN.Buffer.from(t, "utf8"),
      s = i.length;
    if (0 <= this.maxSpan && this.maxSpan < s)
      throw new RangeError("text length exceeds maxSpan");
    if (r + s > n.length) throw new RangeError("encoding overruns Buffer");
    return i.copy(Kr(n), r), s;
  }
};
ke.UTF8 = KZ;
let YZ = class extends di {
  constructor(t, n) {
    super(0, n), (this.value = t);
  }
  decode(t, n) {
    return this.value;
  }
  encode(t, n, r) {
    return 0;
  }
};
ke.Constant = YZ;
ke.greedy = (e, t) => new OZ(e, t);
var Dp = (ke.offset = (e, t, n) => new JN(e, t, n)),
  Ur = (ke.u8 = (e) => new Cc(1, e)),
  gc = (ke.u16 = (e) => new Cc(2, e));
ke.u24 = (e) => new Cc(3, e);
var Zt = (ke.u32 = (e) => new Cc(4, e));
ke.u40 = (e) => new Cc(5, e);
ke.u48 = (e) => new Cc(6, e);
var Io = (ke.nu64 = (e) => new PZ(e));
ke.u16be = (e) => new xu(2, e);
ke.u24be = (e) => new xu(3, e);
ke.u32be = (e) => new xu(4, e);
ke.u40be = (e) => new xu(5, e);
ke.u48be = (e) => new xu(6, e);
ke.nu64be = (e) => new LZ(e);
ke.s8 = (e) => new f1(1, e);
ke.s16 = (e) => new f1(2, e);
ke.s24 = (e) => new f1(3, e);
ke.s32 = (e) => new f1(4, e);
ke.s40 = (e) => new f1(5, e);
ke.s48 = (e) => new f1(6, e);
var Tl = (ke.ns64 = (e) => new jZ(e));
ke.s16be = (e) => new cv(2, e);
ke.s24be = (e) => new cv(3, e);
ke.s32be = (e) => new cv(4, e);
ke.s40be = (e) => new cv(5, e);
ke.s48be = (e) => new cv(6, e);
ke.ns64be = (e) => new DZ(e);
ke.f32 = (e) => new BZ(e);
ke.f32be = (e) => new FZ(e);
ke.f64 = (e) => new UZ(e);
ke.f64be = (e) => new $Z(e);
var Qt = (ke.struct = (e, t, n) => new WZ(e, t, n));
ke.bits = (e, t, n) => new nR(e, t, n);
var Fo = (ke.seq = (e, t, n) => new zZ(e, t, n));
ke.union = (e, t, n) => new tR(e, t, n);
ke.unionLayoutDiscriminator = (e, t) => new o5(e, t);
var $i = (ke.blob = (e, t) => new GZ(e, t));
ke.cstr = (e) => new qZ(e);
ke.utf8 = (e, t) => new KZ(e, t);
ke.constant = (e, t) => new YZ(e, t);
var mx = {};
Object.defineProperty(mx, "__esModule", { value: !0 });
function L2e(e) {
  {
    const t = It.from(e);
    t.reverse();
    const n = t.toString("hex");
    return n.length === 0 ? BigInt(0) : BigInt(`0x${n}`);
  }
}
var j2e = (mx.toBigIntLE = L2e);
function D2e(e) {
  {
    const t = e.toString("hex");
    return t.length === 0 ? BigInt(0) : BigInt(`0x${t}`);
  }
}
mx.toBigIntBE = D2e;
function B2e(e, t) {
  {
    const n = e.toString(16),
      r = It.from(n.padStart(t * 2, "0").slice(0, t * 2), "hex");
    return r.reverse(), r;
  }
}
var ZZ = (mx.toBufferLE = B2e);
function F2e(e, t) {
  {
    const n = e.toString(16);
    return It.from(n.padStart(t * 2, "0").slice(0, t * 2), "hex");
  }
}
mx.toBufferBE = F2e;
let U2e = class extends TypeError {
  constructor(t, n) {
    let r;
    const { message: i, explanation: s, ...o } = t,
      { path: a } = t,
      l = a.length === 0 ? i : `At path: ${a.join(".")} -- ${i}`;
    super(s ?? l),
      s != null && (this.cause = l),
      Object.assign(this, o),
      (this.name = this.constructor.name),
      (this.failures = () => r ?? (r = [t, ...n()]));
  }
};
function $2e(e) {
  return gx(e) && typeof e[Symbol.iterator] == "function";
}
function gx(e) {
  return typeof e == "object" && e != null;
}
function a5(e) {
  return gx(e) && !Array.isArray(e);
}
function Eu(e) {
  return typeof e == "symbol"
    ? e.toString()
    : typeof e == "string"
    ? JSON.stringify(e)
    : `${e}`;
}
function z2e(e) {
  const { done: t, value: n } = e.next();
  return t ? void 0 : n;
}
function W2e(e, t, n, r) {
  if (e === !0) return;
  e === !1 ? (e = {}) : typeof e == "string" && (e = { message: e });
  const { path: i, branch: s } = t,
    { type: o } = n,
    {
      refinement: a,
      message: l = `Expected a value of type \`${o}\`${
        a ? ` with refinement \`${a}\`` : ""
      }, but received: \`${Eu(r)}\``,
    } = e;
  return {
    value: r,
    type: o,
    refinement: a,
    key: i[i.length - 1],
    path: i,
    branch: s,
    ...e,
    message: l,
  };
}
function* BF(e, t, n, r) {
  $2e(e) || (e = [e]);
  for (const i of e) {
    const s = W2e(i, t, n, r);
    s && (yield s);
  }
}
function* iR(e, t, n = {}) {
  const { path: r = [], branch: i = [e], coerce: s = !1, mask: o = !1 } = n,
    a = { path: r, branch: i, mask: o };
  s && (e = t.coercer(e, a));
  let l = "valid";
  for (const c of t.validator(e, a))
    (c.explanation = n.message), (l = "not_valid"), yield [c, void 0];
  for (let [c, u, d] of t.entries(e, a)) {
    const f = iR(u, d, {
      path: c === void 0 ? r : [...r, c],
      branch: c === void 0 ? i : [...i, u],
      coerce: s,
      mask: o,
      message: n.message,
    });
    for (const h of f)
      h[0]
        ? ((l = h[0].refinement != null ? "not_refined" : "not_valid"),
          yield [h[0], void 0])
        : s &&
          ((u = h[1]),
          c === void 0
            ? (e = u)
            : e instanceof Map
            ? e.set(c, u)
            : e instanceof Set
            ? e.add(u)
            : gx(e) && (u !== void 0 || c in e) && (e[c] = u));
  }
  if (l !== "not_valid")
    for (const c of t.refiner(e, a))
      (c.explanation = n.message), (l = "not_refined"), yield [c, void 0];
  l === "valid" && (yield [void 0, e]);
}
let Wd = class {
  constructor(t) {
    const {
      type: n,
      schema: r,
      validator: i,
      refiner: s,
      coercer: o = (l) => l,
      entries: a = function* () {},
    } = t;
    (this.type = n),
      (this.schema = r),
      (this.entries = a),
      (this.coercer = o),
      i
        ? (this.validator = (l, c) => {
            const u = i(l, c);
            return BF(u, c, this, l);
          })
        : (this.validator = () => []),
      s
        ? (this.refiner = (l, c) => {
            const u = s(l, c);
            return BF(u, c, this, l);
          })
        : (this.refiner = () => []);
  }
  assert(t, n) {
    return QZ(t, this, n);
  }
  create(t, n) {
    return yt(t, this, n);
  }
  is(t) {
    return XZ(t, this);
  }
  mask(t, n) {
    return H2e(t, this, n);
  }
  validate(t, n = {}) {
    return yx(t, this, n);
  }
};
function QZ(e, t, n) {
  const r = yx(e, t, { message: n });
  if (r[0]) throw r[0];
}
function yt(e, t, n) {
  const r = yx(e, t, { coerce: !0, message: n });
  if (r[0]) throw r[0];
  return r[1];
}
function H2e(e, t, n) {
  const r = yx(e, t, { coerce: !0, mask: !0, message: n });
  if (r[0]) throw r[0];
  return r[1];
}
function XZ(e, t) {
  return !yx(e, t)[0];
}
function yx(e, t, n = {}) {
  const r = iR(e, t, n),
    i = z2e(r);
  return i[0]
    ? [
        new U2e(i[0], function* () {
          for (const o of r) o[0] && (yield o[0]);
        }),
        void 0,
      ]
    : [void 0, i[1]];
}
function h1(e, t) {
  return new Wd({ type: e, schema: null, validator: t });
}
function V2e() {
  return h1("any", () => !0);
}
function Et(e) {
  return new Wd({
    type: "array",
    schema: e,
    *entries(t) {
      if (e && Array.isArray(t))
        for (const [n, r] of t.entries()) yield [n, r, e];
    },
    coercer(t) {
      return Array.isArray(t) ? t.slice() : t;
    },
    validator(t) {
      return (
        Array.isArray(t) || `Expected an array value, but received: ${Eu(t)}`
      );
    },
  });
}
function Id() {
  return h1("boolean", (e) => typeof e == "boolean");
}
function sR(e) {
  return h1(
    "instance",
    (t) =>
      t instanceof e ||
      `Expected a \`${e.name}\` instance, but received: ${Eu(t)}`
  );
}
function us(e) {
  const t = Eu(e),
    n = typeof e;
  return new Wd({
    type: "literal",
    schema: n === "string" || n === "number" || n === "boolean" ? e : null,
    validator(r) {
      return r === e || `Expected the literal \`${t}\`, but received: ${Eu(r)}`;
    },
  });
}
function G2e() {
  return h1("never", () => !1);
}
function Ct(e) {
  return new Wd({
    ...e,
    validator: (t, n) => t === null || e.validator(t, n),
    refiner: (t, n) => t === null || e.refiner(t, n),
  });
}
function Ae() {
  return h1(
    "number",
    (e) =>
      (typeof e == "number" && !isNaN(e)) ||
      `Expected a number, but received: ${Eu(e)}`
  );
}
function An(e) {
  return new Wd({
    ...e,
    validator: (t, n) => t === void 0 || e.validator(t, n),
    refiner: (t, n) => t === void 0 || e.refiner(t, n),
  });
}
function JZ(e, t) {
  return new Wd({
    type: "record",
    schema: null,
    *entries(n) {
      if (gx(n))
        for (const r in n) {
          const i = n[r];
          yield [r, r, e], yield [r, i, t];
        }
    },
    validator(n) {
      return a5(n) || `Expected an object, but received: ${Eu(n)}`;
    },
    coercer(n) {
      return a5(n) ? { ...n } : n;
    },
  });
}
function pt() {
  return h1(
    "string",
    (e) => typeof e == "string" || `Expected a string, but received: ${Eu(e)}`
  );
}
function oR(e) {
  const t = G2e();
  return new Wd({
    type: "tuple",
    schema: null,
    *entries(n) {
      if (Array.isArray(n)) {
        const r = Math.max(e.length, n.length);
        for (let i = 0; i < r; i++) yield [i, n[i], e[i] || t];
      }
    },
    validator(n) {
      return Array.isArray(n) || `Expected an array, but received: ${Eu(n)}`;
    },
    coercer(n) {
      return Array.isArray(n) ? n.slice() : n;
    },
  });
}
function tt(e) {
  const t = Object.keys(e);
  return new Wd({
    type: "type",
    schema: e,
    *entries(n) {
      if (gx(n)) for (const r of t) yield [r, n[r], e[r]];
    },
    validator(n) {
      return a5(n) || `Expected an object, but received: ${Eu(n)}`;
    },
    coercer(n) {
      return a5(n) ? { ...n } : n;
    },
  });
}
function Ma(e) {
  const t = e.map((n) => n.type).join(" | ");
  return new Wd({
    type: "union",
    schema: null,
    coercer(n, r) {
      for (const i of e) {
        const [s, o] = i.validate(n, { coerce: !0, mask: r.mask });
        if (!s) return o;
      }
      return n;
    },
    validator(n, r) {
      const i = [];
      for (const s of e) {
        const [...o] = iR(n, s, r),
          [a] = o;
        if (a[0]) for (const [l] of o) l && i.push(l);
        else return [];
      }
      return [
        `Expected the value to satisfy a union of \`${t}\`, but received: ${Eu(
          n
        )}`,
        ...i,
      ];
    },
  });
}
function uv() {
  return h1("unknown", () => !0);
}
function vx(e, t, n) {
  return new Wd({
    ...e,
    coercer: (r, i) => (XZ(r, t) ? e.coercer(n(r, i), i) : e.coercer(r, i)),
  });
}
var A_,
  q2e = new Uint8Array(16);
function eQ() {
  if (
    !A_ &&
    ((A_ =
      (typeof crypto < "u" &&
        crypto.getRandomValues &&
        crypto.getRandomValues.bind(crypto)) ||
      (typeof msCrypto < "u" &&
        typeof msCrypto.getRandomValues == "function" &&
        msCrypto.getRandomValues.bind(msCrypto))),
    !A_)
  )
    throw new Error(
      "crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported"
    );
  return A_(q2e);
}
const K2e =
  /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function u8(e) {
  return typeof e == "string" && K2e.test(e);
}
var Mo = [];
for (var UA = 0; UA < 256; ++UA) Mo.push((UA + 256).toString(16).substr(1));
function d8(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,
    n = (
      Mo[e[t + 0]] +
      Mo[e[t + 1]] +
      Mo[e[t + 2]] +
      Mo[e[t + 3]] +
      "-" +
      Mo[e[t + 4]] +
      Mo[e[t + 5]] +
      "-" +
      Mo[e[t + 6]] +
      Mo[e[t + 7]] +
      "-" +
      Mo[e[t + 8]] +
      Mo[e[t + 9]] +
      "-" +
      Mo[e[t + 10]] +
      Mo[e[t + 11]] +
      Mo[e[t + 12]] +
      Mo[e[t + 13]] +
      Mo[e[t + 14]] +
      Mo[e[t + 15]]
    ).toLowerCase();
  if (!u8(n)) throw TypeError("Stringified UUID is invalid");
  return n;
}
var FF,
  $A,
  zA = 0,
  WA = 0;
function Y2e(e, t, n) {
  var r = (t && n) || 0,
    i = t || new Array(16);
  e = e || {};
  var s = e.node || FF,
    o = e.clockseq !== void 0 ? e.clockseq : $A;
  if (s == null || o == null) {
    var a = e.random || (e.rng || eQ)();
    s == null && (s = FF = [a[0] | 1, a[1], a[2], a[3], a[4], a[5]]),
      o == null && (o = $A = ((a[6] << 8) | a[7]) & 16383);
  }
  var l = e.msecs !== void 0 ? e.msecs : Date.now(),
    c = e.nsecs !== void 0 ? e.nsecs : WA + 1,
    u = l - zA + (c - WA) / 1e4;
  if (
    (u < 0 && e.clockseq === void 0 && (o = (o + 1) & 16383),
    (u < 0 || l > zA) && e.nsecs === void 0 && (c = 0),
    c >= 1e4)
  )
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  (zA = l), (WA = c), ($A = o), (l += 122192928e5);
  var d = ((l & 268435455) * 1e4 + c) % 4294967296;
  (i[r++] = (d >>> 24) & 255),
    (i[r++] = (d >>> 16) & 255),
    (i[r++] = (d >>> 8) & 255),
    (i[r++] = d & 255);
  var f = ((l / 4294967296) * 1e4) & 268435455;
  (i[r++] = (f >>> 8) & 255),
    (i[r++] = f & 255),
    (i[r++] = ((f >>> 24) & 15) | 16),
    (i[r++] = (f >>> 16) & 255),
    (i[r++] = (o >>> 8) | 128),
    (i[r++] = o & 255);
  for (var h = 0; h < 6; ++h) i[r + h] = s[h];
  return t || d8(i);
}
function tQ(e) {
  if (!u8(e)) throw TypeError("Invalid UUID");
  var t,
    n = new Uint8Array(16);
  return (
    (n[0] = (t = parseInt(e.slice(0, 8), 16)) >>> 24),
    (n[1] = (t >>> 16) & 255),
    (n[2] = (t >>> 8) & 255),
    (n[3] = t & 255),
    (n[4] = (t = parseInt(e.slice(9, 13), 16)) >>> 8),
    (n[5] = t & 255),
    (n[6] = (t = parseInt(e.slice(14, 18), 16)) >>> 8),
    (n[7] = t & 255),
    (n[8] = (t = parseInt(e.slice(19, 23), 16)) >>> 8),
    (n[9] = t & 255),
    (n[10] = ((t = parseInt(e.slice(24, 36), 16)) / 1099511627776) & 255),
    (n[11] = (t / 4294967296) & 255),
    (n[12] = (t >>> 24) & 255),
    (n[13] = (t >>> 16) & 255),
    (n[14] = (t >>> 8) & 255),
    (n[15] = t & 255),
    n
  );
}
function Z2e(e) {
  e = unescape(encodeURIComponent(e));
  for (var t = [], n = 0; n < e.length; ++n) t.push(e.charCodeAt(n));
  return t;
}
var Q2e = "6ba7b810-9dad-11d1-80b4-00c04fd430c8",
  X2e = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function nQ(e, t, n) {
  function r(i, s, o, a) {
    if (
      (typeof i == "string" && (i = Z2e(i)),
      typeof s == "string" && (s = tQ(s)),
      s.length !== 16)
    )
      throw TypeError(
        "Namespace must be array-like (16 iterable integer values, 0-255)"
      );
    var l = new Uint8Array(16 + i.length);
    if (
      (l.set(s),
      l.set(i, s.length),
      (l = n(l)),
      (l[6] = (l[6] & 15) | t),
      (l[8] = (l[8] & 63) | 128),
      o)
    ) {
      a = a || 0;
      for (var c = 0; c < 16; ++c) o[a + c] = l[c];
      return o;
    }
    return d8(l);
  }
  try {
    r.name = e;
  } catch {}
  return (r.DNS = Q2e), (r.URL = X2e), r;
}
function J2e(e) {
  if (typeof e == "string") {
    var t = unescape(encodeURIComponent(e));
    e = new Uint8Array(t.length);
    for (var n = 0; n < t.length; ++n) e[n] = t.charCodeAt(n);
  }
  return ewe(twe(nwe(e), e.length * 8));
}
function ewe(e) {
  for (
    var t = [], n = e.length * 32, r = "0123456789abcdef", i = 0;
    i < n;
    i += 8
  ) {
    var s = (e[i >> 5] >>> i % 32) & 255,
      o = parseInt(r.charAt((s >>> 4) & 15) + r.charAt(s & 15), 16);
    t.push(o);
  }
  return t;
}
function rQ(e) {
  return (((e + 64) >>> 9) << 4) + 14 + 1;
}
function twe(e, t) {
  (e[t >> 5] |= 128 << t % 32), (e[rQ(t) - 1] = t);
  for (
    var n = 1732584193, r = -271733879, i = -1732584194, s = 271733878, o = 0;
    o < e.length;
    o += 16
  ) {
    var a = n,
      l = r,
      c = i,
      u = s;
    (n = Zo(n, r, i, s, e[o], 7, -680876936)),
      (s = Zo(s, n, r, i, e[o + 1], 12, -389564586)),
      (i = Zo(i, s, n, r, e[o + 2], 17, 606105819)),
      (r = Zo(r, i, s, n, e[o + 3], 22, -1044525330)),
      (n = Zo(n, r, i, s, e[o + 4], 7, -176418897)),
      (s = Zo(s, n, r, i, e[o + 5], 12, 1200080426)),
      (i = Zo(i, s, n, r, e[o + 6], 17, -1473231341)),
      (r = Zo(r, i, s, n, e[o + 7], 22, -45705983)),
      (n = Zo(n, r, i, s, e[o + 8], 7, 1770035416)),
      (s = Zo(s, n, r, i, e[o + 9], 12, -1958414417)),
      (i = Zo(i, s, n, r, e[o + 10], 17, -42063)),
      (r = Zo(r, i, s, n, e[o + 11], 22, -1990404162)),
      (n = Zo(n, r, i, s, e[o + 12], 7, 1804603682)),
      (s = Zo(s, n, r, i, e[o + 13], 12, -40341101)),
      (i = Zo(i, s, n, r, e[o + 14], 17, -1502002290)),
      (r = Zo(r, i, s, n, e[o + 15], 22, 1236535329)),
      (n = Qo(n, r, i, s, e[o + 1], 5, -165796510)),
      (s = Qo(s, n, r, i, e[o + 6], 9, -1069501632)),
      (i = Qo(i, s, n, r, e[o + 11], 14, 643717713)),
      (r = Qo(r, i, s, n, e[o], 20, -373897302)),
      (n = Qo(n, r, i, s, e[o + 5], 5, -701558691)),
      (s = Qo(s, n, r, i, e[o + 10], 9, 38016083)),
      (i = Qo(i, s, n, r, e[o + 15], 14, -660478335)),
      (r = Qo(r, i, s, n, e[o + 4], 20, -405537848)),
      (n = Qo(n, r, i, s, e[o + 9], 5, 568446438)),
      (s = Qo(s, n, r, i, e[o + 14], 9, -1019803690)),
      (i = Qo(i, s, n, r, e[o + 3], 14, -187363961)),
      (r = Qo(r, i, s, n, e[o + 8], 20, 1163531501)),
      (n = Qo(n, r, i, s, e[o + 13], 5, -1444681467)),
      (s = Qo(s, n, r, i, e[o + 2], 9, -51403784)),
      (i = Qo(i, s, n, r, e[o + 7], 14, 1735328473)),
      (r = Qo(r, i, s, n, e[o + 12], 20, -1926607734)),
      (n = Xo(n, r, i, s, e[o + 5], 4, -378558)),
      (s = Xo(s, n, r, i, e[o + 8], 11, -2022574463)),
      (i = Xo(i, s, n, r, e[o + 11], 16, 1839030562)),
      (r = Xo(r, i, s, n, e[o + 14], 23, -35309556)),
      (n = Xo(n, r, i, s, e[o + 1], 4, -1530992060)),
      (s = Xo(s, n, r, i, e[o + 4], 11, 1272893353)),
      (i = Xo(i, s, n, r, e[o + 7], 16, -155497632)),
      (r = Xo(r, i, s, n, e[o + 10], 23, -1094730640)),
      (n = Xo(n, r, i, s, e[o + 13], 4, 681279174)),
      (s = Xo(s, n, r, i, e[o], 11, -358537222)),
      (i = Xo(i, s, n, r, e[o + 3], 16, -722521979)),
      (r = Xo(r, i, s, n, e[o + 6], 23, 76029189)),
      (n = Xo(n, r, i, s, e[o + 9], 4, -640364487)),
      (s = Xo(s, n, r, i, e[o + 12], 11, -421815835)),
      (i = Xo(i, s, n, r, e[o + 15], 16, 530742520)),
      (r = Xo(r, i, s, n, e[o + 2], 23, -995338651)),
      (n = Jo(n, r, i, s, e[o], 6, -198630844)),
      (s = Jo(s, n, r, i, e[o + 7], 10, 1126891415)),
      (i = Jo(i, s, n, r, e[o + 14], 15, -1416354905)),
      (r = Jo(r, i, s, n, e[o + 5], 21, -57434055)),
      (n = Jo(n, r, i, s, e[o + 12], 6, 1700485571)),
      (s = Jo(s, n, r, i, e[o + 3], 10, -1894986606)),
      (i = Jo(i, s, n, r, e[o + 10], 15, -1051523)),
      (r = Jo(r, i, s, n, e[o + 1], 21, -2054922799)),
      (n = Jo(n, r, i, s, e[o + 8], 6, 1873313359)),
      (s = Jo(s, n, r, i, e[o + 15], 10, -30611744)),
      (i = Jo(i, s, n, r, e[o + 6], 15, -1560198380)),
      (r = Jo(r, i, s, n, e[o + 13], 21, 1309151649)),
      (n = Jo(n, r, i, s, e[o + 4], 6, -145523070)),
      (s = Jo(s, n, r, i, e[o + 11], 10, -1120210379)),
      (i = Jo(i, s, n, r, e[o + 2], 15, 718787259)),
      (r = Jo(r, i, s, n, e[o + 9], 21, -343485551)),
      (n = Sp(n, a)),
      (r = Sp(r, l)),
      (i = Sp(i, c)),
      (s = Sp(s, u));
  }
  return [n, r, i, s];
}
function nwe(e) {
  if (e.length === 0) return [];
  for (var t = e.length * 8, n = new Uint32Array(rQ(t)), r = 0; r < t; r += 8)
    n[r >> 5] |= (e[r / 8] & 255) << r % 32;
  return n;
}
function Sp(e, t) {
  var n = (e & 65535) + (t & 65535),
    r = (e >> 16) + (t >> 16) + (n >> 16);
  return (r << 16) | (n & 65535);
}
function rwe(e, t) {
  return (e << t) | (e >>> (32 - t));
}
function f8(e, t, n, r, i, s) {
  return Sp(rwe(Sp(Sp(t, e), Sp(r, s)), i), n);
}
function Zo(e, t, n, r, i, s, o) {
  return f8((t & n) | (~t & r), e, t, i, s, o);
}
function Qo(e, t, n, r, i, s, o) {
  return f8((t & r) | (n & ~r), e, t, i, s, o);
}
function Xo(e, t, n, r, i, s, o) {
  return f8(t ^ n ^ r, e, t, i, s, o);
}
function Jo(e, t, n, r, i, s, o) {
  return f8(n ^ (t | ~r), e, t, i, s, o);
}
var iwe = nQ("v3", 48, J2e);
function swe(e, t, n) {
  e = e || {};
  var r = e.random || (e.rng || eQ)();
  if (((r[6] = (r[6] & 15) | 64), (r[8] = (r[8] & 63) | 128), t)) {
    n = n || 0;
    for (var i = 0; i < 16; ++i) t[n + i] = r[i];
    return t;
  }
  return d8(r);
}
function owe(e, t, n, r) {
  switch (e) {
    case 0:
      return (t & n) ^ (~t & r);
    case 1:
      return t ^ n ^ r;
    case 2:
      return (t & n) ^ (t & r) ^ (n & r);
    case 3:
      return t ^ n ^ r;
  }
}
function HA(e, t) {
  return (e << t) | (e >>> (32 - t));
}
function awe(e) {
  var t = [1518500249, 1859775393, 2400959708, 3395469782],
    n = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof e == "string") {
    var r = unescape(encodeURIComponent(e));
    e = [];
    for (var i = 0; i < r.length; ++i) e.push(r.charCodeAt(i));
  } else Array.isArray(e) || (e = Array.prototype.slice.call(e));
  e.push(128);
  for (
    var s = e.length / 4 + 2, o = Math.ceil(s / 16), a = new Array(o), l = 0;
    l < o;
    ++l
  ) {
    for (var c = new Uint32Array(16), u = 0; u < 16; ++u)
      c[u] =
        (e[l * 64 + u * 4] << 24) |
        (e[l * 64 + u * 4 + 1] << 16) |
        (e[l * 64 + u * 4 + 2] << 8) |
        e[l * 64 + u * 4 + 3];
    a[l] = c;
  }
  (a[o - 1][14] = ((e.length - 1) * 8) / Math.pow(2, 32)),
    (a[o - 1][14] = Math.floor(a[o - 1][14])),
    (a[o - 1][15] = ((e.length - 1) * 8) & 4294967295);
  for (var d = 0; d < o; ++d) {
    for (var f = new Uint32Array(80), h = 0; h < 16; ++h) f[h] = a[d][h];
    for (var p = 16; p < 80; ++p)
      f[p] = HA(f[p - 3] ^ f[p - 8] ^ f[p - 14] ^ f[p - 16], 1);
    for (
      var g = n[0], b = n[1], v = n[2], w = n[3], x = n[4], S = 0;
      S < 80;
      ++S
    ) {
      var R = Math.floor(S / 20),
        O = (HA(g, 5) + owe(R, b, v, w) + x + t[R] + f[S]) >>> 0;
      (x = w), (w = v), (v = HA(b, 30) >>> 0), (b = g), (g = O);
    }
    (n[0] = (n[0] + g) >>> 0),
      (n[1] = (n[1] + b) >>> 0),
      (n[2] = (n[2] + v) >>> 0),
      (n[3] = (n[3] + w) >>> 0),
      (n[4] = (n[4] + x) >>> 0);
  }
  return [
    (n[0] >> 24) & 255,
    (n[0] >> 16) & 255,
    (n[0] >> 8) & 255,
    n[0] & 255,
    (n[1] >> 24) & 255,
    (n[1] >> 16) & 255,
    (n[1] >> 8) & 255,
    n[1] & 255,
    (n[2] >> 24) & 255,
    (n[2] >> 16) & 255,
    (n[2] >> 8) & 255,
    n[2] & 255,
    (n[3] >> 24) & 255,
    (n[3] >> 16) & 255,
    (n[3] >> 8) & 255,
    n[3] & 255,
    (n[4] >> 24) & 255,
    (n[4] >> 16) & 255,
    (n[4] >> 8) & 255,
    n[4] & 255,
  ];
}
var lwe = nQ("v5", 80, awe);
const cwe = "00000000-0000-0000-0000-000000000000";
function uwe(e) {
  if (!u8(e)) throw TypeError("Invalid UUID");
  return parseInt(e.substr(14, 1), 16);
}
const dwe = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        NIL: cwe,
        parse: tQ,
        stringify: d8,
        v1: Y2e,
        v3: iwe,
        v4: swe,
        v5: lwe,
        validate: u8,
        version: uwe,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  iQ = ix(dwe),
  fwe = iQ.v4,
  hwe = function (e, t, n, r) {
    if (typeof e != "string") throw new TypeError(e + " must be a string");
    r = r || {};
    const i = typeof r.version == "number" ? r.version : 2;
    if (i !== 1 && i !== 2) throw new TypeError(i + " must be 1 or 2");
    const s = { method: e };
    if ((i === 2 && (s.jsonrpc = "2.0"), t)) {
      if (typeof t != "object" && !Array.isArray(t))
        throw new TypeError(t + " must be an object, array or omitted");
      s.params = t;
    }
    if (typeof n > "u") {
      const o =
        typeof r.generator == "function"
          ? r.generator
          : function () {
              return fwe();
            };
      s.id = o(s, r);
    } else
      i === 2 && n === null
        ? r.notificationIdNull && (s.id = null)
        : (s.id = n);
    return s;
  };
var pwe = hwe;
const mwe = iQ.v4,
  gwe = pwe,
  sb = function (e, t) {
    if (!(this instanceof sb)) return new sb(e, t);
    t || (t = {}),
      (this.options = {
        reviver: typeof t.reviver < "u" ? t.reviver : null,
        replacer: typeof t.replacer < "u" ? t.replacer : null,
        generator:
          typeof t.generator < "u"
            ? t.generator
            : function () {
                return mwe();
              },
        version: typeof t.version < "u" ? t.version : 2,
        notificationIdNull:
          typeof t.notificationIdNull == "boolean" ? t.notificationIdNull : !1,
      }),
      (this.callServer = e);
  };
var ywe = sb;
sb.prototype.request = function (e, t, n, r) {
  const i = this;
  let s = null;
  const o = Array.isArray(e) && typeof t == "function";
  if (this.options.version === 1 && o)
    throw new TypeError("JSON-RPC 1.0 does not support batching");
  if (o || (!o && e && typeof e == "object" && typeof t == "function"))
    (r = t), (s = e);
  else {
    typeof n == "function" && ((r = n), (n = void 0));
    const c = typeof r == "function";
    try {
      s = gwe(e, t, n, {
        generator: this.options.generator,
        version: this.options.version,
        notificationIdNull: this.options.notificationIdNull,
      });
    } catch (u) {
      if (c) return r(u);
      throw u;
    }
    if (!c) return s;
  }
  let l;
  try {
    l = JSON.stringify(s, this.options.replacer);
  } catch (c) {
    return r(c);
  }
  return (
    this.callServer(l, function (c, u) {
      i._parseResponse(c, u, r);
    }),
    s
  );
};
sb.prototype._parseResponse = function (e, t, n) {
  if (e) {
    n(e);
    return;
  }
  if (!t) return n();
  let r;
  try {
    r = JSON.parse(t, this.options.reviver);
  } catch (i) {
    return n(i);
  }
  if (n.length === 3)
    if (Array.isArray(r)) {
      const i = function (o) {
          return typeof o.error < "u";
        },
        s = function (o) {
          return !i(o);
        };
      return n(null, r.filter(i), r.filter(s));
    } else return n(null, r.error, r.result);
  n(null, r);
};
const vwe = Gi(ywe);
var sQ = { exports: {} };
(function (e) {
  var t = Object.prototype.hasOwnProperty,
    n = "~";
  function r() {}
  Object.create &&
    ((r.prototype = Object.create(null)), new r().__proto__ || (n = !1));
  function i(l, c, u) {
    (this.fn = l), (this.context = c), (this.once = u || !1);
  }
  function s(l, c, u, d, f) {
    if (typeof u != "function")
      throw new TypeError("The listener must be a function");
    var h = new i(u, d || l, f),
      p = n ? n + c : c;
    return (
      l._events[p]
        ? l._events[p].fn
          ? (l._events[p] = [l._events[p], h])
          : l._events[p].push(h)
        : ((l._events[p] = h), l._eventsCount++),
      l
    );
  }
  function o(l, c) {
    --l._eventsCount === 0 ? (l._events = new r()) : delete l._events[c];
  }
  function a() {
    (this._events = new r()), (this._eventsCount = 0);
  }
  (a.prototype.eventNames = function () {
    var c = [],
      u,
      d;
    if (this._eventsCount === 0) return c;
    for (d in (u = this._events)) t.call(u, d) && c.push(n ? d.slice(1) : d);
    return Object.getOwnPropertySymbols
      ? c.concat(Object.getOwnPropertySymbols(u))
      : c;
  }),
    (a.prototype.listeners = function (c) {
      var u = n ? n + c : c,
        d = this._events[u];
      if (!d) return [];
      if (d.fn) return [d.fn];
      for (var f = 0, h = d.length, p = new Array(h); f < h; f++)
        p[f] = d[f].fn;
      return p;
    }),
    (a.prototype.listenerCount = function (c) {
      var u = n ? n + c : c,
        d = this._events[u];
      return d ? (d.fn ? 1 : d.length) : 0;
    }),
    (a.prototype.emit = function (c, u, d, f, h, p) {
      var g = n ? n + c : c;
      if (!this._events[g]) return !1;
      var b = this._events[g],
        v = arguments.length,
        w,
        x;
      if (b.fn) {
        switch ((b.once && this.removeListener(c, b.fn, void 0, !0), v)) {
          case 1:
            return b.fn.call(b.context), !0;
          case 2:
            return b.fn.call(b.context, u), !0;
          case 3:
            return b.fn.call(b.context, u, d), !0;
          case 4:
            return b.fn.call(b.context, u, d, f), !0;
          case 5:
            return b.fn.call(b.context, u, d, f, h), !0;
          case 6:
            return b.fn.call(b.context, u, d, f, h, p), !0;
        }
        for (x = 1, w = new Array(v - 1); x < v; x++) w[x - 1] = arguments[x];
        b.fn.apply(b.context, w);
      } else {
        var S = b.length,
          R;
        for (x = 0; x < S; x++)
          switch (
            (b[x].once && this.removeListener(c, b[x].fn, void 0, !0), v)
          ) {
            case 1:
              b[x].fn.call(b[x].context);
              break;
            case 2:
              b[x].fn.call(b[x].context, u);
              break;
            case 3:
              b[x].fn.call(b[x].context, u, d);
              break;
            case 4:
              b[x].fn.call(b[x].context, u, d, f);
              break;
            default:
              if (!w)
                for (R = 1, w = new Array(v - 1); R < v; R++)
                  w[R - 1] = arguments[R];
              b[x].fn.apply(b[x].context, w);
          }
      }
      return !0;
    }),
    (a.prototype.on = function (c, u, d) {
      return s(this, c, u, d, !1);
    }),
    (a.prototype.once = function (c, u, d) {
      return s(this, c, u, d, !0);
    }),
    (a.prototype.removeListener = function (c, u, d, f) {
      var h = n ? n + c : c;
      if (!this._events[h]) return this;
      if (!u) return o(this, h), this;
      var p = this._events[h];
      if (p.fn)
        p.fn === u && (!f || p.once) && (!d || p.context === d) && o(this, h);
      else {
        for (var g = 0, b = [], v = p.length; g < v; g++)
          (p[g].fn !== u || (f && !p[g].once) || (d && p[g].context !== d)) &&
            b.push(p[g]);
        b.length ? (this._events[h] = b.length === 1 ? b[0] : b) : o(this, h);
      }
      return this;
    }),
    (a.prototype.removeAllListeners = function (c) {
      var u;
      return (
        c
          ? ((u = n ? n + c : c), this._events[u] && o(this, u))
          : ((this._events = new r()), (this._eventsCount = 0)),
        this
      );
    }),
    (a.prototype.off = a.prototype.removeListener),
    (a.prototype.addListener = a.prototype.on),
    (a.prefixed = n),
    (a.EventEmitter = a),
    (e.exports = a);
})(sQ);
var wwe = sQ.exports;
const oQ = Gi(wwe);
var bwe = class extends oQ {
  constructor(t, n, r) {
    super();
    Ls(this, "socket");
    (this.socket = new window.WebSocket(t, r)),
      (this.socket.onopen = () => this.emit("open")),
      (this.socket.onmessage = (i) => this.emit("message", i.data)),
      (this.socket.onerror = (i) => this.emit("error", i)),
      (this.socket.onclose = (i) => {
        this.emit("close", i.code, i.reason);
      });
  }
  send(t, n, r) {
    const i = r || n;
    try {
      this.socket.send(t), i();
    } catch (s) {
      i(s);
    }
  }
  close(t, n) {
    this.socket.close(t, n);
  }
  addEventListener(t, n, r) {
    this.socket.addEventListener(t, n, r);
  }
};
function xwe(e, t) {
  return new bwe(e, t);
}
var _we = class {
    encode(e) {
      return JSON.stringify(e);
    }
    decode(e) {
      return JSON.parse(e);
    }
  },
  Swe = class extends oQ {
    constructor(
      t,
      n = "ws://localhost:8080",
      {
        autoconnect: r = !0,
        reconnect: i = !0,
        reconnect_interval: s = 1e3,
        max_reconnects: o = 5,
        ...a
      } = {},
      l,
      c
    ) {
      super();
      Ls(this, "address");
      Ls(this, "rpc_id");
      Ls(this, "queue");
      Ls(this, "options");
      Ls(this, "autoconnect");
      Ls(this, "ready");
      Ls(this, "reconnect");
      Ls(this, "reconnect_timer_id");
      Ls(this, "reconnect_interval");
      Ls(this, "max_reconnects");
      Ls(this, "rest_options");
      Ls(this, "current_reconnects");
      Ls(this, "generate_request_id");
      Ls(this, "socket");
      Ls(this, "webSocketFactory");
      Ls(this, "dataPack");
      (this.webSocketFactory = t),
        (this.queue = {}),
        (this.rpc_id = 0),
        (this.address = n),
        (this.autoconnect = r),
        (this.ready = !1),
        (this.reconnect = i),
        (this.reconnect_timer_id = void 0),
        (this.reconnect_interval = s),
        (this.max_reconnects = o),
        (this.rest_options = a),
        (this.current_reconnects = 0),
        (this.generate_request_id = l || (() => ++this.rpc_id)),
        c ? (this.dataPack = c) : (this.dataPack = new _we()),
        this.autoconnect &&
          this._connect(this.address, {
            autoconnect: this.autoconnect,
            reconnect: this.reconnect,
            reconnect_interval: this.reconnect_interval,
            max_reconnects: this.max_reconnects,
            ...this.rest_options,
          });
    }
    connect() {
      this.socket ||
        this._connect(this.address, {
          autoconnect: this.autoconnect,
          reconnect: this.reconnect,
          reconnect_interval: this.reconnect_interval,
          max_reconnects: this.max_reconnects,
          ...this.rest_options,
        });
    }
    call(t, n, r, i) {
      return (
        !i && typeof r == "object" && ((i = r), (r = null)),
        new Promise((s, o) => {
          if (!this.ready) return o(new Error("socket not ready"));
          const a = this.generate_request_id(t, n),
            l = { jsonrpc: "2.0", method: t, params: n || void 0, id: a };
          this.socket.send(this.dataPack.encode(l), i, (c) => {
            if (c) return o(c);
            (this.queue[a] = { promise: [s, o] }),
              r &&
                (this.queue[a].timeout = setTimeout(() => {
                  delete this.queue[a], o(new Error("reply timeout"));
                }, r));
          });
        })
      );
    }
    async login(t) {
      const n = await this.call("rpc.login", t);
      if (!n) throw new Error("authentication failed");
      return n;
    }
    async listMethods() {
      return await this.call("__listMethods");
    }
    notify(t, n) {
      return new Promise((r, i) => {
        if (!this.ready) return i(new Error("socket not ready"));
        const s = { jsonrpc: "2.0", method: t, params: n };
        this.socket.send(this.dataPack.encode(s), (o) => {
          if (o) return i(o);
          r();
        });
      });
    }
    async subscribe(t) {
      typeof t == "string" && (t = [t]);
      const n = await this.call("rpc.on", t);
      if (typeof t == "string" && n[t] !== "ok")
        throw new Error(
          "Failed subscribing to an event '" + t + "' with: " + n[t]
        );
      return n;
    }
    async unsubscribe(t) {
      typeof t == "string" && (t = [t]);
      const n = await this.call("rpc.off", t);
      if (typeof t == "string" && n[t] !== "ok")
        throw new Error("Failed unsubscribing from an event with: " + n);
      return n;
    }
    close(t, n) {
      this.socket.close(t || 1e3, n);
    }
    setAutoReconnect(t) {
      this.reconnect = t;
    }
    setReconnectInterval(t) {
      this.reconnect_interval = t;
    }
    setMaxReconnects(t) {
      this.max_reconnects = t;
    }
    _connect(t, n) {
      clearTimeout(this.reconnect_timer_id),
        (this.socket = this.webSocketFactory(t, n)),
        this.socket.addEventListener("open", () => {
          (this.ready = !0), this.emit("open"), (this.current_reconnects = 0);
        }),
        this.socket.addEventListener("message", ({ data: r }) => {
          r instanceof ArrayBuffer && (r = Xt.from(r).toString());
          try {
            r = this.dataPack.decode(r);
          } catch {
            return;
          }
          if (r.notification && this.listeners(r.notification).length) {
            if (!Object.keys(r.params).length) return this.emit(r.notification);
            const i = [r.notification];
            if (r.params.constructor === Object) i.push(r.params);
            else for (let s = 0; s < r.params.length; s++) i.push(r.params[s]);
            return Promise.resolve().then(() => {
              this.emit.apply(this, i);
            });
          }
          if (!this.queue[r.id])
            return r.method
              ? Promise.resolve().then(() => {
                  this.emit(r.method, r == null ? void 0 : r.params);
                })
              : void 0;
          "error" in r == "result" in r &&
            this.queue[r.id].promise[1](
              new Error(
                'Server response malformed. Response must include either "result" or "error", but not both.'
              )
            ),
            this.queue[r.id].timeout && clearTimeout(this.queue[r.id].timeout),
            r.error
              ? this.queue[r.id].promise[1](r.error)
              : this.queue[r.id].promise[0](r.result),
            delete this.queue[r.id];
        }),
        this.socket.addEventListener("error", (r) => this.emit("error", r)),
        this.socket.addEventListener("close", ({ code: r, reason: i }) => {
          this.ready && setTimeout(() => this.emit("close", r, i), 0),
            (this.ready = !1),
            (this.socket = void 0),
            r !== 1e3 &&
              (this.current_reconnects++,
              this.reconnect &&
                (this.max_reconnects > this.current_reconnects ||
                  this.max_reconnects === 0) &&
                (this.reconnect_timer_id = setTimeout(
                  () => this._connect(t, n),
                  this.reconnect_interval
                )));
        });
    }
  };
const aQ = [],
  lQ = [],
  cQ = [],
  Ewe = BigInt(0),
  b2 = BigInt(1),
  Awe = BigInt(2),
  Cwe = BigInt(7),
  kwe = BigInt(256),
  Twe = BigInt(113);
for (let e = 0, t = b2, n = 1, r = 0; e < 24; e++) {
  ([n, r] = [r, (2 * n + 3 * r) % 5]),
    aQ.push(2 * (5 * r + n)),
    lQ.push((((e + 1) * (e + 2)) / 2) % 64);
  let i = Ewe;
  for (let s = 0; s < 7; s++)
    (t = ((t << b2) ^ ((t >> Cwe) * Twe)) % kwe),
      t & Awe && (i ^= b2 << ((b2 << BigInt(s)) - b2));
  cQ.push(i);
}
const [Mwe, Iwe] = fZ(cQ, !0),
  UF = (e, t, n) => (n > 32 ? mZ(e, t, n) : hZ(e, t, n)),
  $F = (e, t, n) => (n > 32 ? gZ(e, t, n) : pZ(e, t, n));
function Nwe(e, t = 24) {
  const n = new Uint32Array(10);
  for (let r = 24 - t; r < 24; r++) {
    for (let o = 0; o < 10; o++)
      n[o] = e[o] ^ e[o + 10] ^ e[o + 20] ^ e[o + 30] ^ e[o + 40];
    for (let o = 0; o < 10; o += 2) {
      const a = (o + 8) % 10,
        l = (o + 2) % 10,
        c = n[l],
        u = n[l + 1],
        d = UF(c, u, 1) ^ n[a],
        f = $F(c, u, 1) ^ n[a + 1];
      for (let h = 0; h < 50; h += 10) (e[o + h] ^= d), (e[o + h + 1] ^= f);
    }
    let i = e[2],
      s = e[3];
    for (let o = 0; o < 24; o++) {
      const a = lQ[o],
        l = UF(i, s, a),
        c = $F(i, s, a),
        u = aQ[o];
      (i = e[u]), (s = e[u + 1]), (e[u] = l), (e[u + 1] = c);
    }
    for (let o = 0; o < 50; o += 10) {
      for (let a = 0; a < 10; a++) n[a] = e[o + a];
      for (let a = 0; a < 10; a++)
        e[o + a] ^= ~n[(a + 2) % 10] & n[(a + 4) % 10];
    }
    (e[0] ^= Mwe[r]), (e[1] ^= Iwe[r]);
  }
  n.fill(0);
}
class aR extends UN {
  constructor(t, n, r, i = !1, s = 24) {
    if (
      (super(),
      (this.blockLen = t),
      (this.suffix = n),
      (this.outputLen = r),
      (this.enableXOF = i),
      (this.rounds = s),
      (this.pos = 0),
      (this.posOut = 0),
      (this.finished = !1),
      (this.destroyed = !1),
      t5(r),
      0 >= this.blockLen || this.blockLen >= 200)
    )
      throw new Error("Sha3 supports only keccak-f1600 function");
    (this.state = new Uint8Array(200)), (this.state32 = ive(this.state));
  }
  keccak() {
    MF || IF(this.state32),
      Nwe(this.state32, this.rounds),
      MF || IF(this.state32),
      (this.posOut = 0),
      (this.pos = 0);
  }
  update(t) {
    xy(this);
    const { blockLen: n, state: r } = this;
    t = r8(t);
    const i = t.length;
    for (let s = 0; s < i; ) {
      const o = Math.min(n - this.pos, i - s);
      for (let a = 0; a < o; a++) r[this.pos++] ^= t[s++];
      this.pos === n && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = !0;
    const { state: t, suffix: n, pos: r, blockLen: i } = this;
    (t[r] ^= n),
      n & 128 && r === i - 1 && this.keccak(),
      (t[i - 1] ^= 128),
      this.keccak();
  }
  writeInto(t) {
    xy(this, !1), fx(t), this.finish();
    const n = this.state,
      { blockLen: r } = this;
    for (let i = 0, s = t.length; i < s; ) {
      this.posOut >= r && this.keccak();
      const o = Math.min(r - this.posOut, s - i);
      t.set(n.subarray(this.posOut, this.posOut + o), i),
        (this.posOut += o),
        (i += o);
    }
    return t;
  }
  xofInto(t) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(t);
  }
  xof(t) {
    return t5(t), this.xofInto(new Uint8Array(t));
  }
  digestInto(t) {
    if ((lZ(t, this), this.finished))
      throw new Error("digest() was already called");
    return this.writeInto(t), this.destroy(), t;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    (this.destroyed = !0), this.state.fill(0);
  }
  _cloneInto(t) {
    const {
      blockLen: n,
      suffix: r,
      outputLen: i,
      rounds: s,
      enableXOF: o,
    } = this;
    return (
      t || (t = new aR(n, r, i, o, s)),
      t.state32.set(this.state32),
      (t.pos = this.pos),
      (t.posOut = this.posOut),
      (t.finished = this.finished),
      (t.rounds = s),
      (t.suffix = r),
      (t.outputLen = i),
      (t.enableXOF = o),
      (t.destroyed = this.destroyed),
      t
    );
  }
}
const Rwe = (e, t, n) => $N(() => new aR(t, e, n)),
  zF = Rwe(1, 136, 256 / 8);
class uQ extends UN {
  constructor(t, n) {
    super(), (this.finished = !1), (this.destroyed = !1), rve(t);
    const r = r8(n);
    if (((this.iHash = t.create()), typeof this.iHash.update != "function"))
      throw new Error("Expected instance of class which extends utils.Hash");
    (this.blockLen = this.iHash.blockLen),
      (this.outputLen = this.iHash.outputLen);
    const i = this.blockLen,
      s = new Uint8Array(i);
    s.set(r.length > i ? t.create().update(r).digest() : r);
    for (let o = 0; o < s.length; o++) s[o] ^= 54;
    this.iHash.update(s), (this.oHash = t.create());
    for (let o = 0; o < s.length; o++) s[o] ^= 106;
    this.oHash.update(s), s.fill(0);
  }
  update(t) {
    return xy(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    xy(this),
      fx(t, this.outputLen),
      (this.finished = !0),
      this.iHash.digestInto(t),
      this.oHash.update(t),
      this.oHash.digestInto(t),
      this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}));
    const {
      oHash: n,
      iHash: r,
      finished: i,
      destroyed: s,
      blockLen: o,
      outputLen: a,
    } = this;
    return (
      (t = t),
      (t.finished = i),
      (t.destroyed = s),
      (t.blockLen = o),
      (t.outputLen = a),
      (t.oHash = n._cloneInto(t.oHash)),
      (t.iHash = r._cloneInto(t.iHash)),
      t
    );
  }
  destroy() {
    (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
  }
}
const dQ = (e, t, n) => new uQ(e, t).update(n).digest();
dQ.create = (e, t) => new uQ(e, t);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function WF(
  e
) {
  e.lowS !== void 0 && Yf("lowS", e.lowS),
    e.prehash !== void 0 && Yf("prehash", e.prehash);
}
function Owe(e) {
  const t = VN(e);
  ov(
    t,
    { a: "field", b: "field" },
    {
      allowedPrivateKeyLengths: "array",
      wrapPrivateKey: "boolean",
      isTorsionFree: "function",
      clearCofactor: "function",
      allowInfinityPoint: "boolean",
      fromBytes: "function",
      toBytes: "function",
    }
  );
  const { endo: n, Fp: r, a: i } = t;
  if (n) {
    if (!r.eql(i, r.ZERO))
      throw new Error(
        "Endomorphism can only be defined for Koblitz curves that have a=0"
      );
    if (
      typeof n != "object" ||
      typeof n.beta != "bigint" ||
      typeof n.splitScalar != "function"
    )
      throw new Error(
        "Expected endomorphism with beta: bigint and splitScalar: function"
      );
  }
  return Object.freeze({ ...t });
}
const { bytesToNumberBE: Pwe, hexToBytes: Lwe } = Uve,
  Cf = {
    Err: class extends Error {
      constructor(t = "") {
        super(t);
      }
    },
    _tlv: {
      encode: (e, t) => {
        const { Err: n } = Cf;
        if (e < 0 || e > 256) throw new n("tlv.encode: wrong tag");
        if (t.length & 1) throw new n("tlv.encode: unpadded data");
        const r = t.length / 2,
          i = xg(r);
        if ((i.length / 2) & 128)
          throw new n("tlv.encode: long form length too big");
        const s = r > 127 ? xg((i.length / 2) | 128) : "";
        return `${xg(e)}${s}${i}${t}`;
      },
      decode(e, t) {
        const { Err: n } = Cf;
        let r = 0;
        if (e < 0 || e > 256) throw new n("tlv.encode: wrong tag");
        if (t.length < 2 || t[r++] !== e) throw new n("tlv.decode: wrong tlv");
        const i = t[r++],
          s = !!(i & 128);
        let o = 0;
        if (!s) o = i;
        else {
          const l = i & 127;
          if (!l)
            throw new n("tlv.decode(long): indefinite length not supported");
          if (l > 4) throw new n("tlv.decode(long): byte length is too big");
          const c = t.subarray(r, r + l);
          if (c.length !== l)
            throw new n("tlv.decode: length bytes not complete");
          if (c[0] === 0) throw new n("tlv.decode(long): zero leftmost byte");
          for (const u of c) o = (o << 8) | u;
          if (((r += l), o < 128))
            throw new n("tlv.decode(long): not minimal encoding");
        }
        const a = t.subarray(r, r + o);
        if (a.length !== o) throw new n("tlv.decode: wrong value length");
        return { v: a, l: t.subarray(r + o) };
      },
    },
    _int: {
      encode(e) {
        const { Err: t } = Cf;
        if (e < Nf) throw new t("integer: negative integers are not allowed");
        let n = xg(e);
        if ((Number.parseInt(n[0], 16) & 8 && (n = "00" + n), n.length & 1))
          throw new t("unexpected assertion");
        return n;
      },
      decode(e) {
        const { Err: t } = Cf;
        if (e[0] & 128) throw new t("Invalid signature integer: negative");
        if (e[0] === 0 && !(e[1] & 128))
          throw new t("Invalid signature integer: unnecessary leading zero");
        return Pwe(e);
      },
    },
    toSig(e) {
      const { Err: t, _int: n, _tlv: r } = Cf,
        i = typeof e == "string" ? Lwe(e) : e;
      hx(i);
      const { v: s, l: o } = r.decode(48, i);
      if (o.length) throw new t("Invalid signature: left bytes after parsing");
      const { v: a, l } = r.decode(2, s),
        { v: c, l: u } = r.decode(2, l);
      if (u.length) throw new t("Invalid signature: left bytes after parsing");
      return { r: n.decode(a), s: n.decode(c) };
    },
    hexFromSig(e) {
      const { _tlv: t, _int: n } = Cf,
        r = `${t.encode(2, n.encode(e.r))}${t.encode(2, n.encode(e.s))}`;
      return t.encode(48, r);
    },
  },
  Nf = BigInt(0),
  ho = BigInt(1);
BigInt(2);
const HF = BigInt(3);
BigInt(4);
function jwe(e) {
  const t = Owe(e),
    { Fp: n } = t,
    r = o8(t.n, t.nBitLength),
    i =
      t.toBytes ||
      ((g, b, v) => {
        const w = b.toAffine();
        return Hm(Uint8Array.from([4]), n.toBytes(w.x), n.toBytes(w.y));
      }),
    s =
      t.fromBytes ||
      ((g) => {
        const b = g.subarray(1),
          v = n.fromBytes(b.subarray(0, n.BYTES)),
          w = n.fromBytes(b.subarray(n.BYTES, 2 * n.BYTES));
        return { x: v, y: w };
      });
  function o(g) {
    const { a: b, b: v } = t,
      w = n.sqr(g),
      x = n.mul(w, g);
    return n.add(n.add(x, n.mul(g, b)), v);
  }
  if (!n.eql(n.sqr(t.Gy), o(t.Gx)))
    throw new Error("bad generator point: equation left != right");
  function a(g) {
    return s8(g, ho, t.n);
  }
  function l(g) {
    const {
      allowedPrivateKeyLengths: b,
      nByteLength: v,
      wrapPrivateKey: w,
      n: x,
    } = t;
    if (b && typeof g != "bigint") {
      if ((zm(g) && (g = Wm(g)), typeof g != "string" || !b.includes(g.length)))
        throw new Error("Invalid key");
      g = g.padStart(v * 2, "0");
    }
    let S;
    try {
      S = typeof g == "bigint" ? g : Am(Qs("private key", g, v));
    } catch {
      throw new Error(
        `private key must be ${v} bytes, hex or bigint, not ${typeof g}`
      );
    }
    return w && (S = ns(S, x)), bc("private key", S, ho, x), S;
  }
  function c(g) {
    if (!(g instanceof f)) throw new Error("ProjectivePoint expected");
  }
  const u = ib((g, b) => {
      const { px: v, py: w, pz: x } = g;
      if (n.eql(x, n.ONE)) return { x: v, y: w };
      const S = g.is0();
      b == null && (b = S ? n.ONE : n.inv(x));
      const R = n.mul(v, b),
        O = n.mul(w, b),
        B = n.mul(x, b);
      if (S) return { x: n.ZERO, y: n.ZERO };
      if (!n.eql(B, n.ONE)) throw new Error("invZ was invalid");
      return { x: R, y: O };
    }),
    d = ib((g) => {
      if (g.is0()) {
        if (t.allowInfinityPoint && !n.is0(g.py)) return;
        throw new Error("bad point: ZERO");
      }
      const { x: b, y: v } = g.toAffine();
      if (!n.isValid(b) || !n.isValid(v))
        throw new Error("bad point: x or y not FE");
      const w = n.sqr(v),
        x = o(b);
      if (!n.eql(w, x)) throw new Error("bad point: equation left != right");
      if (!g.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
      return !0;
    });
  class f {
    constructor(b, v, w) {
      if (
        ((this.px = b),
        (this.py = v),
        (this.pz = w),
        b == null || !n.isValid(b))
      )
        throw new Error("x required");
      if (v == null || !n.isValid(v)) throw new Error("y required");
      if (w == null || !n.isValid(w)) throw new Error("z required");
      Object.freeze(this);
    }
    static fromAffine(b) {
      const { x: v, y: w } = b || {};
      if (!b || !n.isValid(v) || !n.isValid(w))
        throw new Error("invalid affine point");
      if (b instanceof f) throw new Error("projective point not allowed");
      const x = (S) => n.eql(S, n.ZERO);
      return x(v) && x(w) ? f.ZERO : new f(v, w, n.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(b) {
      const v = n.invertBatch(b.map((w) => w.pz));
      return b.map((w, x) => w.toAffine(v[x])).map(f.fromAffine);
    }
    static fromHex(b) {
      const v = f.fromAffine(s(Qs("pointHex", b)));
      return v.assertValidity(), v;
    }
    static fromPrivateKey(b) {
      return f.BASE.multiply(l(b));
    }
    static msm(b, v) {
      return SZ(f, r, b, v);
    }
    _setWindowSize(b) {
      p.setWindowSize(this, b);
    }
    assertValidity() {
      d(this);
    }
    hasEvenY() {
      const { y: b } = this.toAffine();
      if (n.isOdd) return !n.isOdd(b);
      throw new Error("Field doesn't support isOdd");
    }
    equals(b) {
      c(b);
      const { px: v, py: w, pz: x } = this,
        { px: S, py: R, pz: O } = b,
        B = n.eql(n.mul(v, O), n.mul(S, x)),
        C = n.eql(n.mul(w, O), n.mul(R, x));
      return B && C;
    }
    negate() {
      return new f(this.px, n.neg(this.py), this.pz);
    }
    double() {
      const { a: b, b: v } = t,
        w = n.mul(v, HF),
        { px: x, py: S, pz: R } = this;
      let O = n.ZERO,
        B = n.ZERO,
        C = n.ZERO,
        I = n.mul(x, x),
        P = n.mul(S, S),
        M = n.mul(R, R),
        k = n.mul(x, S);
      return (
        (k = n.add(k, k)),
        (C = n.mul(x, R)),
        (C = n.add(C, C)),
        (O = n.mul(b, C)),
        (B = n.mul(w, M)),
        (B = n.add(O, B)),
        (O = n.sub(P, B)),
        (B = n.add(P, B)),
        (B = n.mul(O, B)),
        (O = n.mul(k, O)),
        (C = n.mul(w, C)),
        (M = n.mul(b, M)),
        (k = n.sub(I, M)),
        (k = n.mul(b, k)),
        (k = n.add(k, C)),
        (C = n.add(I, I)),
        (I = n.add(C, I)),
        (I = n.add(I, M)),
        (I = n.mul(I, k)),
        (B = n.add(B, I)),
        (M = n.mul(S, R)),
        (M = n.add(M, M)),
        (I = n.mul(M, k)),
        (O = n.sub(O, I)),
        (C = n.mul(M, P)),
        (C = n.add(C, C)),
        (C = n.add(C, C)),
        new f(O, B, C)
      );
    }
    add(b) {
      c(b);
      const { px: v, py: w, pz: x } = this,
        { px: S, py: R, pz: O } = b;
      let B = n.ZERO,
        C = n.ZERO,
        I = n.ZERO;
      const P = t.a,
        M = n.mul(t.b, HF);
      let k = n.mul(v, S),
        T = n.mul(w, R),
        _ = n.mul(x, O),
        A = n.add(v, w),
        N = n.add(S, R);
      (A = n.mul(A, N)),
        (N = n.add(k, T)),
        (A = n.sub(A, N)),
        (N = n.add(v, x));
      let L = n.add(S, O);
      return (
        (N = n.mul(N, L)),
        (L = n.add(k, _)),
        (N = n.sub(N, L)),
        (L = n.add(w, x)),
        (B = n.add(R, O)),
        (L = n.mul(L, B)),
        (B = n.add(T, _)),
        (L = n.sub(L, B)),
        (I = n.mul(P, N)),
        (B = n.mul(M, _)),
        (I = n.add(B, I)),
        (B = n.sub(T, I)),
        (I = n.add(T, I)),
        (C = n.mul(B, I)),
        (T = n.add(k, k)),
        (T = n.add(T, k)),
        (_ = n.mul(P, _)),
        (N = n.mul(M, N)),
        (T = n.add(T, _)),
        (_ = n.sub(k, _)),
        (_ = n.mul(P, _)),
        (N = n.add(N, _)),
        (k = n.mul(T, N)),
        (C = n.add(C, k)),
        (k = n.mul(L, N)),
        (B = n.mul(A, B)),
        (B = n.sub(B, k)),
        (k = n.mul(A, T)),
        (I = n.mul(L, I)),
        (I = n.add(I, k)),
        new f(B, C, I)
      );
    }
    subtract(b) {
      return this.add(b.negate());
    }
    is0() {
      return this.equals(f.ZERO);
    }
    wNAF(b) {
      return p.wNAFCached(this, b, f.normalizeZ);
    }
    multiplyUnsafe(b) {
      bc("scalar", b, Nf, t.n);
      const v = f.ZERO;
      if (b === Nf) return v;
      if (b === ho) return this;
      const { endo: w } = t;
      if (!w) return p.unsafeLadder(this, b);
      let { k1neg: x, k1: S, k2neg: R, k2: O } = w.splitScalar(b),
        B = v,
        C = v,
        I = this;
      for (; S > Nf || O > Nf; )
        S & ho && (B = B.add(I)),
          O & ho && (C = C.add(I)),
          (I = I.double()),
          (S >>= ho),
          (O >>= ho);
      return (
        x && (B = B.negate()),
        R && (C = C.negate()),
        (C = new f(n.mul(C.px, w.beta), C.py, C.pz)),
        B.add(C)
      );
    }
    multiply(b) {
      const { endo: v, n: w } = t;
      bc("scalar", b, ho, w);
      let x, S;
      if (v) {
        const { k1neg: R, k1: O, k2neg: B, k2: C } = v.splitScalar(b);
        let { p: I, f: P } = this.wNAF(O),
          { p: M, f: k } = this.wNAF(C);
        (I = p.constTimeNegate(R, I)),
          (M = p.constTimeNegate(B, M)),
          (M = new f(n.mul(M.px, v.beta), M.py, M.pz)),
          (x = I.add(M)),
          (S = P.add(k));
      } else {
        const { p: R, f: O } = this.wNAF(b);
        (x = R), (S = O);
      }
      return f.normalizeZ([x, S])[0];
    }
    multiplyAndAddUnsafe(b, v, w) {
      const x = f.BASE,
        S = (O, B) =>
          B === Nf || B === ho || !O.equals(x)
            ? O.multiplyUnsafe(B)
            : O.multiply(B),
        R = S(this, v).add(S(b, w));
      return R.is0() ? void 0 : R;
    }
    toAffine(b) {
      return u(this, b);
    }
    isTorsionFree() {
      const { h: b, isTorsionFree: v } = t;
      if (b === ho) return !0;
      if (v) return v(f, this);
      throw new Error(
        "isTorsionFree() has not been declared for the elliptic curve"
      );
    }
    clearCofactor() {
      const { h: b, clearCofactor: v } = t;
      return b === ho ? this : v ? v(f, this) : this.multiplyUnsafe(t.h);
    }
    toRawBytes(b = !0) {
      return Yf("isCompressed", b), this.assertValidity(), i(f, this, b);
    }
    toHex(b = !0) {
      return Yf("isCompressed", b), Wm(this.toRawBytes(b));
    }
  }
  (f.BASE = new f(t.Gx, t.Gy, n.ONE)), (f.ZERO = new f(n.ZERO, n.ONE, n.ZERO));
  const h = t.nBitLength,
    p = _Z(f, t.endo ? Math.ceil(h / 2) : h);
  return {
    CURVE: t,
    ProjectivePoint: f,
    normPrivateKeyToScalar: l,
    weierstrassEquation: o,
    isWithinCurveOrder: a,
  };
}
function Dwe(e) {
  const t = VN(e);
  return (
    ov(
      t,
      { hash: "hash", hmac: "function", randomBytes: "function" },
      { bits2int: "function", bits2int_modN: "function", lowS: "boolean" }
    ),
    Object.freeze({ lowS: !0, ...t })
  );
}
function Bwe(e) {
  const t = Dwe(e),
    { Fp: n, n: r } = t,
    i = n.BYTES + 1,
    s = 2 * n.BYTES + 1;
  function o(_) {
    return ns(_, r);
  }
  function a(_) {
    return sT(_, r);
  }
  const {
      ProjectivePoint: l,
      normPrivateKeyToScalar: c,
      weierstrassEquation: u,
      isWithinCurveOrder: d,
    } = jwe({
      ...t,
      toBytes(_, A, N) {
        const L = A.toAffine(),
          F = n.toBytes(L.x),
          D = Hm;
        return (
          Yf("isCompressed", N),
          N
            ? D(Uint8Array.from([A.hasEvenY() ? 2 : 3]), F)
            : D(Uint8Array.from([4]), F, n.toBytes(L.y))
        );
      },
      fromBytes(_) {
        const A = _.length,
          N = _[0],
          L = _.subarray(1);
        if (A === i && (N === 2 || N === 3)) {
          const F = Am(L);
          if (!s8(F, ho, n.ORDER)) throw new Error("Point is not on curve");
          const D = u(F);
          let j;
          try {
            j = n.sqrt(D);
          } catch (K) {
            const re = K instanceof Error ? ": " + K.message : "";
            throw new Error("Point is not on curve" + re);
          }
          const z = (j & ho) === ho;
          return ((N & 1) === 1) !== z && (j = n.neg(j)), { x: F, y: j };
        } else if (A === s && N === 4) {
          const F = n.fromBytes(L.subarray(0, n.BYTES)),
            D = n.fromBytes(L.subarray(n.BYTES, 2 * n.BYTES));
          return { x: F, y: D };
        } else
          throw new Error(
            `Point of length ${A} was invalid. Expected ${i} compressed bytes or ${s} uncompressed bytes`
          );
      },
    }),
    f = (_) => Wm(Sy(_, t.nByteLength));
  function h(_) {
    const A = r >> ho;
    return _ > A;
  }
  function p(_) {
    return h(_) ? o(-_) : _;
  }
  const g = (_, A, N) => Am(_.slice(A, N));
  class b {
    constructor(A, N, L) {
      (this.r = A), (this.s = N), (this.recovery = L), this.assertValidity();
    }
    static fromCompact(A) {
      const N = t.nByteLength;
      return (
        (A = Qs("compactSignature", A, N * 2)),
        new b(g(A, 0, N), g(A, N, 2 * N))
      );
    }
    static fromDER(A) {
      const { r: N, s: L } = Cf.toSig(Qs("DER", A));
      return new b(N, L);
    }
    assertValidity() {
      bc("r", this.r, ho, r), bc("s", this.s, ho, r);
    }
    addRecoveryBit(A) {
      return new b(this.r, this.s, A);
    }
    recoverPublicKey(A) {
      const { r: N, s: L, recovery: F } = this,
        D = O(Qs("msgHash", A));
      if (F == null || ![0, 1, 2, 3].includes(F))
        throw new Error("recovery id invalid");
      const j = F === 2 || F === 3 ? N + t.n : N;
      if (j >= n.ORDER) throw new Error("recovery id 2 or 3 invalid");
      const z = F & 1 ? "03" : "02",
        $ = l.fromHex(z + f(j)),
        K = a(j),
        re = o(-D * K),
        G = o(L * K),
        ne = l.BASE.multiplyAndAddUnsafe($, re, G);
      if (!ne) throw new Error("point at infinify");
      return ne.assertValidity(), ne;
    }
    hasHighS() {
      return h(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new b(this.r, o(-this.s), this.recovery) : this;
    }
    toDERRawBytes() {
      return _y(this.toDERHex());
    }
    toDERHex() {
      return Cf.hexFromSig({ r: this.r, s: this.s });
    }
    toCompactRawBytes() {
      return _y(this.toCompactHex());
    }
    toCompactHex() {
      return f(this.r) + f(this.s);
    }
  }
  const v = {
    isValidPrivateKey(_) {
      try {
        return c(_), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: c,
    randomPrivateKey: () => {
      const _ = xZ(t.n);
      return Zve(t.randomBytes(_), t.n);
    },
    precompute(_ = 8, A = l.BASE) {
      return A._setWindowSize(_), A.multiply(BigInt(3)), A;
    },
  };
  function w(_, A = !0) {
    return l.fromPrivateKey(_).toRawBytes(A);
  }
  function x(_) {
    const A = zm(_),
      N = typeof _ == "string",
      L = (A || N) && _.length;
    return A
      ? L === i || L === s
      : N
      ? L === 2 * i || L === 2 * s
      : _ instanceof l;
  }
  function S(_, A, N = !0) {
    if (x(_)) throw new Error("first arg must be private key");
    if (!x(A)) throw new Error("second arg must be public key");
    return l.fromHex(A).multiply(c(_)).toRawBytes(N);
  }
  const R =
      t.bits2int ||
      function (_) {
        const A = Am(_),
          N = _.length * 8 - t.nBitLength;
        return N > 0 ? A >> BigInt(N) : A;
      },
    O =
      t.bits2int_modN ||
      function (_) {
        return o(R(_));
      },
    B = HN(t.nBitLength);
  function C(_) {
    return bc(`num < 2^${t.nBitLength}`, _, Nf, B), Sy(_, t.nByteLength);
  }
  function I(_, A, N = P) {
    if (["recovered", "canonical"].some((le) => le in N))
      throw new Error("sign() legacy options not supported");
    const { hash: L, randomBytes: F } = t;
    let { lowS: D, prehash: j, extraEntropy: z } = N;
    D == null && (D = !0),
      (_ = Qs("msgHash", _)),
      WF(N),
      j && (_ = Qs("prehashed msgHash", L(_)));
    const $ = O(_),
      K = c(A),
      re = [C(K), C($)];
    if (z != null && z !== !1) {
      const le = z === !0 ? F(n.BYTES) : z;
      re.push(Qs("extraEntropy", le));
    }
    const G = Hm(...re),
      ne = $;
    function ae(le) {
      const ge = R(le);
      if (!d(ge)) return;
      const Oe = a(ge),
        _e = l.BASE.multiply(ge).toAffine(),
        Ee = o(_e.x);
      if (Ee === Nf) return;
      const He = o(Oe * o(ne + Ee * K));
      if (He === Nf) return;
      let je = (_e.x === Ee ? 0 : 2) | Number(_e.y & ho),
        Be = He;
      return D && h(He) && ((Be = p(He)), (je ^= 1)), new b(Ee, Be, je);
    }
    return { seed: G, k2sig: ae };
  }
  const P = { lowS: t.lowS, prehash: !1 },
    M = { lowS: t.lowS, prehash: !1 };
  function k(_, A, N = P) {
    const { seed: L, k2sig: F } = I(_, A, N),
      D = t;
    return vZ(D.hash.outputLen, D.nByteLength, D.hmac)(L, F);
  }
  l.BASE._setWindowSize(8);
  function T(_, A, N, L = M) {
    var _e;
    const F = _;
    if (((A = Qs("msgHash", A)), (N = Qs("publicKey", N)), "strict" in L))
      throw new Error("options.strict was renamed to lowS");
    WF(L);
    const { lowS: D, prehash: j } = L;
    let z, $;
    try {
      if (typeof F == "string" || zm(F))
        try {
          z = b.fromDER(F);
        } catch (Ee) {
          if (!(Ee instanceof Cf.Err)) throw Ee;
          z = b.fromCompact(F);
        }
      else if (
        typeof F == "object" &&
        typeof F.r == "bigint" &&
        typeof F.s == "bigint"
      ) {
        const { r: Ee, s: He } = F;
        z = new b(Ee, He);
      } else throw new Error("PARSE");
      $ = l.fromHex(N);
    } catch (Ee) {
      if (Ee.message === "PARSE")
        throw new Error(
          "signature must be Signature instance, Uint8Array or hex string"
        );
      return !1;
    }
    if (D && z.hasHighS()) return !1;
    j && (A = t.hash(A));
    const { r: K, s: re } = z,
      G = O(A),
      ne = a(re),
      ae = o(G * ne),
      le = o(K * ne),
      ge =
        (_e = l.BASE.multiplyAndAddUnsafe($, ae, le)) == null
          ? void 0
          : _e.toAffine();
    return ge ? o(ge.x) === K : !1;
  }
  return {
    CURVE: t,
    getPublicKey: w,
    getSharedSecret: S,
    sign: k,
    verify: T,
    ProjectivePoint: l,
    Signature: b,
    utils: v,
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function Fwe(
  e
) {
  return { hash: e, hmac: (t, ...n) => dQ(e, t, ave(...n)), randomBytes: cZ };
}
function Uwe(e, t) {
  const n = (r) => Bwe({ ...e, ...Fwe(r) });
  return Object.freeze({ ...n(t), create: n });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const fQ =
    BigInt(
      "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"
    ),
  VF = BigInt(
    "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"
  ),
  $we = BigInt(1),
  cT = BigInt(2),
  GF = (e, t) => (e + t / cT) / t;
function zwe(e) {
  const t = fQ,
    n = BigInt(3),
    r = BigInt(6),
    i = BigInt(11),
    s = BigInt(22),
    o = BigInt(23),
    a = BigInt(44),
    l = BigInt(88),
    c = (e * e * e) % t,
    u = (c * c * e) % t,
    d = (bs(u, n, t) * u) % t,
    f = (bs(d, n, t) * u) % t,
    h = (bs(f, cT, t) * c) % t,
    p = (bs(h, i, t) * h) % t,
    g = (bs(p, s, t) * p) % t,
    b = (bs(g, a, t) * g) % t,
    v = (bs(b, l, t) * b) % t,
    w = (bs(v, a, t) * g) % t,
    x = (bs(w, n, t) * u) % t,
    S = (bs(x, o, t) * p) % t,
    R = (bs(S, r, t) * c) % t,
    O = bs(R, cT, t);
  if (!uT.eql(uT.sqr(O), e)) throw new Error("Cannot find square root");
  return O;
}
const uT = o8(fQ, void 0, void 0, { sqrt: zwe }),
  h8 = Uwe(
    {
      a: BigInt(0),
      b: BigInt(7),
      Fp: uT,
      n: VF,
      Gx: BigInt(
        "55066263022277343669578718895168534326250603453777594175500187360389116729240"
      ),
      Gy: BigInt(
        "32670510020758816978083085130507043184471273380659243275938904335757337482424"
      ),
      h: BigInt(1),
      lowS: !0,
      endo: {
        beta: BigInt(
          "0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"
        ),
        splitScalar: (e) => {
          const t = VF,
            n = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
            r = -$we * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
            i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
            s = n,
            o = BigInt("0x100000000000000000000000000000000"),
            a = GF(s * e, t),
            l = GF(-r * e, t);
          let c = ns(e - a * n - l * i, t),
            u = ns(-a * r - l * s, t);
          const d = c > o,
            f = u > o;
          if ((d && (c = t - c), f && (u = t - u), c > o || u > o))
            throw new Error("splitScalar: Endomorphism failed, k=" + e);
          return { k1neg: d, k1: c, k2neg: f, k2: u };
        },
      },
    },
    aT
  );
BigInt(0);
h8.ProjectivePoint;
const Wwe = av.utils.randomPrivateKey,
  qF = () => {
    const e = av.utils.randomPrivateKey(),
      t = l5(e),
      n = new Uint8Array(64);
    return n.set(e), n.set(t, 32), { publicKey: t, secretKey: n };
  },
  l5 = av.getPublicKey;
function KF(e) {
  try {
    return av.ExtendedPoint.fromHex(e), !0;
  } catch {
    return !1;
  }
}
const lR = (e, t) => av.sign(e, t.slice(0, 32)),
  Hwe = av.verify,
  er = (e) =>
    Xt.isBuffer(e)
      ? e
      : e instanceof Uint8Array
      ? Xt.from(e.buffer, e.byteOffset, e.byteLength)
      : Xt.from(e);
let cR = class {
  constructor(t) {
    Object.assign(this, t);
  }
  encode() {
    return Xt.from(NZ(yw, this));
  }
  static decode(t) {
    return RZ(yw, this, t);
  }
  static decodeUnchecked(t) {
    return CZ(yw, this, t);
  }
};
class Vwe extends cR {
  constructor(t) {
    if ((super(t), (this.enum = ""), Object.keys(t).length !== 1))
      throw new Error("Enum can only take single value");
    Object.keys(t).map((n) => {
      this.enum = n;
    });
  }
}
const yw = new Map();
var hQ;
const pQ = 32,
  vd = 32;
function Gwe(e) {
  return e._bn !== void 0;
}
let YF = 1;
class Pe extends cR {
  constructor(t) {
    if ((super({}), (this._bn = void 0), Gwe(t))) this._bn = t._bn;
    else {
      if (typeof t == "string") {
        const n = fs.decode(t);
        if (n.length != vd) throw new Error("Invalid public key input");
        this._bn = new sn(n);
      } else this._bn = new sn(t);
      if (this._bn.byteLength() > vd)
        throw new Error("Invalid public key input");
    }
  }
  static unique() {
    const t = new Pe(YF);
    return (YF += 1), new Pe(t.toBuffer());
  }
  equals(t) {
    return this._bn.eq(t._bn);
  }
  toBase58() {
    return fs.encode(this.toBytes());
  }
  toJSON() {
    return this.toBase58();
  }
  toBytes() {
    const t = this.toBuffer();
    return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
  }
  toBuffer() {
    const t = this._bn.toArrayLike(Xt);
    if (t.length === vd) return t;
    const n = Xt.alloc(32);
    return t.copy(n, 32 - t.length), n;
  }
  get [Symbol.toStringTag]() {
    return `PublicKey(${this.toString()})`;
  }
  toString() {
    return this.toBase58();
  }
  static async createWithSeed(t, n, r) {
    const i = Xt.concat([t.toBuffer(), Xt.from(n), r.toBuffer()]),
      s = aT(i);
    return new Pe(s);
  }
  static createProgramAddressSync(t, n) {
    let r = Xt.alloc(0);
    t.forEach(function (s) {
      if (s.length > pQ) throw new TypeError("Max seed length exceeded");
      r = Xt.concat([r, er(s)]);
    }),
      (r = Xt.concat([r, n.toBuffer(), Xt.from("ProgramDerivedAddress")]));
    const i = aT(r);
    if (KF(i))
      throw new Error("Invalid seeds, address must fall off the curve");
    return new Pe(i);
  }
  static async createProgramAddress(t, n) {
    return this.createProgramAddressSync(t, n);
  }
  static findProgramAddressSync(t, n) {
    let r = 255,
      i;
    for (; r != 0; ) {
      try {
        const s = t.concat(Xt.from([r]));
        i = this.createProgramAddressSync(s, n);
      } catch (s) {
        if (s instanceof TypeError) throw s;
        r--;
        continue;
      }
      return [i, r];
    }
    throw new Error("Unable to find a viable program address nonce");
  }
  static async findProgramAddress(t, n) {
    return this.findProgramAddressSync(t, n);
  }
  static isOnCurve(t) {
    const n = new Pe(t);
    return KF(n.toBytes());
  }
}
hQ = Pe;
Pe.default = new hQ("11111111111111111111111111111111");
yw.set(Pe, { kind: "struct", fields: [["_bn", "u256"]] });
class qwe {
  constructor(t) {
    if (((this._publicKey = void 0), (this._secretKey = void 0), t)) {
      const n = er(t);
      if (t.length !== 64) throw new Error("bad secret key size");
      (this._publicKey = n.slice(32, 64)), (this._secretKey = n.slice(0, 32));
    } else
      (this._secretKey = er(Wwe())),
        (this._publicKey = er(l5(this._secretKey)));
  }
  get publicKey() {
    return new Pe(this._publicKey);
  }
  get secretKey() {
    return Xt.concat([this._secretKey, this._publicKey], 64);
  }
}
const Kwe = new Pe("BPFLoader1111111111111111111111111111111111"),
  Bp = 1232,
  p8 = 127,
  Ay = 64;
class uR extends Error {
  constructor(t) {
    super(`Signature ${t} has expired: block height exceeded.`),
      (this.signature = void 0),
      (this.signature = t);
  }
}
Object.defineProperty(uR.prototype, "name", {
  value: "TransactionExpiredBlockheightExceededError",
});
class dR extends Error {
  constructor(t, n) {
    super(
      `Transaction was not confirmed in ${n.toFixed(
        2
      )} seconds. It is unknown if it succeeded or failed. Check signature ${t} using the Solana Explorer or CLI tools.`
    ),
      (this.signature = void 0),
      (this.signature = t);
  }
}
Object.defineProperty(dR.prototype, "name", {
  value: "TransactionExpiredTimeoutError",
});
class _g extends Error {
  constructor(t) {
    super(`Signature ${t} has expired: the nonce is no longer valid.`),
      (this.signature = void 0),
      (this.signature = t);
  }
}
Object.defineProperty(_g.prototype, "name", {
  value: "TransactionExpiredNonceInvalidError",
});
class ob {
  constructor(t, n) {
    (this.staticAccountKeys = void 0),
      (this.accountKeysFromLookups = void 0),
      (this.staticAccountKeys = t),
      (this.accountKeysFromLookups = n);
  }
  keySegments() {
    const t = [this.staticAccountKeys];
    return (
      this.accountKeysFromLookups &&
        (t.push(this.accountKeysFromLookups.writable),
        t.push(this.accountKeysFromLookups.readonly)),
      t
    );
  }
  get(t) {
    for (const n of this.keySegments()) {
      if (t < n.length) return n[t];
      t -= n.length;
    }
  }
  get length() {
    return this.keySegments().flat().length;
  }
  compileInstructions(t) {
    if (this.length > 256)
      throw new Error("Account index overflow encountered during compilation");
    const r = new Map();
    this.keySegments()
      .flat()
      .forEach((s, o) => {
        r.set(s.toBase58(), o);
      });
    const i = (s) => {
      const o = r.get(s.toBase58());
      if (o === void 0)
        throw new Error(
          "Encountered an unknown instruction account key during compilation"
        );
      return o;
    };
    return t.map((s) => ({
      programIdIndex: i(s.programId),
      accountKeyIndexes: s.keys.map((o) => i(o.pubkey)),
      data: s.data,
    }));
  }
}
const gr = (e = "publicKey") => $i(32, e),
  Ywe = (e = "signature") => $i(64, e),
  im = (e = "string") => {
    const t = Qt(
        [Zt("length"), Zt("lengthPadding"), $i(Dp(Zt(), -8), "chars")],
        e
      ),
      n = t.decode.bind(t),
      r = t.encode.bind(t),
      i = t;
    return (
      (i.decode = (s, o) => n(s, o).chars.toString()),
      (i.encode = (s, o, a) => {
        const l = { chars: Xt.from(s, "utf8") };
        return r(l, o, a);
      }),
      (i.alloc = (s) => Zt().span + Zt().span + Xt.from(s, "utf8").length),
      i
    );
  },
  Zwe = (e = "authorized") => Qt([gr("staker"), gr("withdrawer")], e),
  Qwe = (e = "lockup") =>
    Qt([Tl("unixTimestamp"), Tl("epoch"), gr("custodian")], e),
  Xwe = (e = "voteInit") =>
    Qt(
      [
        gr("nodePubkey"),
        gr("authorizedVoter"),
        gr("authorizedWithdrawer"),
        Ur("commission"),
      ],
      e
    ),
  Jwe = (e = "voteAuthorizeWithSeedArgs") =>
    Qt(
      [
        Zt("voteAuthorizationType"),
        gr("currentAuthorityDerivedKeyOwnerPubkey"),
        im("currentAuthorityDerivedKeySeed"),
        gr("newAuthorized"),
      ],
      e
    );
function mQ(e, t) {
  const n = (i) => {
    if (i.span >= 0) return i.span;
    if (typeof i.alloc == "function") return i.alloc(t[i.property]);
    if ("count" in i && "elementLayout" in i) {
      const s = t[i.property];
      if (Array.isArray(s)) return s.length * n(i.elementLayout);
    } else if ("fields" in i) return mQ({ layout: i }, t[i.property]);
    return 0;
  };
  let r = 0;
  return (
    e.layout.fields.forEach((i) => {
      r += n(i);
    }),
    r
  );
}
function Ka(e) {
  let t = 0,
    n = 0;
  for (;;) {
    let r = e.shift();
    if (((t |= (r & 127) << (n * 7)), (n += 1), !(r & 128))) break;
  }
  return t;
}
function Ml(e, t) {
  let n = t;
  for (;;) {
    let r = n & 127;
    if (((n >>= 7), n == 0)) {
      e.push(r);
      break;
    } else (r |= 128), e.push(r);
  }
}
function Vr(e, t) {
  if (!e) throw new Error(t || "Assertion failed");
}
class m8 {
  constructor(t, n) {
    (this.payer = void 0),
      (this.keyMetaMap = void 0),
      (this.payer = t),
      (this.keyMetaMap = n);
  }
  static compile(t, n) {
    const r = new Map(),
      i = (o) => {
        const a = o.toBase58();
        let l = r.get(a);
        return (
          l === void 0 &&
            ((l = { isSigner: !1, isWritable: !1, isInvoked: !1 }),
            r.set(a, l)),
          l
        );
      },
      s = i(n);
    (s.isSigner = !0), (s.isWritable = !0);
    for (const o of t) {
      i(o.programId).isInvoked = !0;
      for (const a of o.keys) {
        const l = i(a.pubkey);
        l.isSigner || (l.isSigner = a.isSigner),
          l.isWritable || (l.isWritable = a.isWritable);
      }
    }
    return new m8(n, r);
  }
  getMessageComponents() {
    const t = [...this.keyMetaMap.entries()];
    Vr(t.length <= 256, "Max static account keys length exceeded");
    const n = t.filter(([, l]) => l.isSigner && l.isWritable),
      r = t.filter(([, l]) => l.isSigner && !l.isWritable),
      i = t.filter(([, l]) => !l.isSigner && l.isWritable),
      s = t.filter(([, l]) => !l.isSigner && !l.isWritable),
      o = {
        numRequiredSignatures: n.length + r.length,
        numReadonlySignedAccounts: r.length,
        numReadonlyUnsignedAccounts: s.length,
      };
    {
      Vr(n.length > 0, "Expected at least one writable signer key");
      const [l] = n[0];
      Vr(
        l === this.payer.toBase58(),
        "Expected first writable signer key to be the fee payer"
      );
    }
    const a = [
      ...n.map(([l]) => new Pe(l)),
      ...r.map(([l]) => new Pe(l)),
      ...i.map(([l]) => new Pe(l)),
      ...s.map(([l]) => new Pe(l)),
    ];
    return [o, a];
  }
  extractTableLookup(t) {
    const [n, r] = this.drainKeysFoundInLookupTable(
        t.state.addresses,
        (o) => !o.isSigner && !o.isInvoked && o.isWritable
      ),
      [i, s] = this.drainKeysFoundInLookupTable(
        t.state.addresses,
        (o) => !o.isSigner && !o.isInvoked && !o.isWritable
      );
    if (!(n.length === 0 && i.length === 0))
      return [
        { accountKey: t.key, writableIndexes: n, readonlyIndexes: i },
        { writable: r, readonly: s },
      ];
  }
  drainKeysFoundInLookupTable(t, n) {
    const r = new Array(),
      i = new Array();
    for (const [s, o] of this.keyMetaMap.entries())
      if (n(o)) {
        const a = new Pe(s),
          l = t.findIndex((c) => c.equals(a));
        l >= 0 &&
          (Vr(l < 256, "Max lookup table index exceeded"),
          r.push(l),
          i.push(a),
          this.keyMetaMap.delete(s));
      }
    return [r, i];
  }
}
const gQ = "Reached end of buffer unexpectedly";
function nd(e) {
  if (e.length === 0) throw new Error(gQ);
  return e.shift();
}
function Ya(e, ...t) {
  const [n] = t;
  if (t.length === 2 ? n + (t[1] ?? 0) > e.length : n >= e.length)
    throw new Error(gQ);
  return e.splice(...t);
}
class Au {
  constructor(t) {
    (this.header = void 0),
      (this.accountKeys = void 0),
      (this.recentBlockhash = void 0),
      (this.instructions = void 0),
      (this.indexToProgramIds = new Map()),
      (this.header = t.header),
      (this.accountKeys = t.accountKeys.map((n) => new Pe(n))),
      (this.recentBlockhash = t.recentBlockhash),
      (this.instructions = t.instructions),
      this.instructions.forEach((n) =>
        this.indexToProgramIds.set(
          n.programIdIndex,
          this.accountKeys[n.programIdIndex]
        )
      );
  }
  get version() {
    return "legacy";
  }
  get staticAccountKeys() {
    return this.accountKeys;
  }
  get compiledInstructions() {
    return this.instructions.map((t) => ({
      programIdIndex: t.programIdIndex,
      accountKeyIndexes: t.accounts,
      data: fs.decode(t.data),
    }));
  }
  get addressTableLookups() {
    return [];
  }
  getAccountKeys() {
    return new ob(this.staticAccountKeys);
  }
  static compile(t) {
    const n = m8.compile(t.instructions, t.payerKey),
      [r, i] = n.getMessageComponents(),
      o = new ob(i)
        .compileInstructions(t.instructions)
        .map((a) => ({
          programIdIndex: a.programIdIndex,
          accounts: a.accountKeyIndexes,
          data: fs.encode(a.data),
        }));
    return new Au({
      header: r,
      accountKeys: i,
      recentBlockhash: t.recentBlockhash,
      instructions: o,
    });
  }
  isAccountSigner(t) {
    return t < this.header.numRequiredSignatures;
  }
  isAccountWritable(t) {
    const n = this.header.numRequiredSignatures;
    if (t >= this.header.numRequiredSignatures) {
      const r = t - n,
        s =
          this.accountKeys.length - n - this.header.numReadonlyUnsignedAccounts;
      return r < s;
    } else {
      const r = n - this.header.numReadonlySignedAccounts;
      return t < r;
    }
  }
  isProgramId(t) {
    return this.indexToProgramIds.has(t);
  }
  programIds() {
    return [...this.indexToProgramIds.values()];
  }
  nonProgramIds() {
    return this.accountKeys.filter((t, n) => !this.isProgramId(n));
  }
  serialize() {
    const t = this.accountKeys.length;
    let n = [];
    Ml(n, t);
    const r = this.instructions.map((d) => {
      const { accounts: f, programIdIndex: h } = d,
        p = Array.from(fs.decode(d.data));
      let g = [];
      Ml(g, f.length);
      let b = [];
      return (
        Ml(b, p.length),
        {
          programIdIndex: h,
          keyIndicesCount: Xt.from(g),
          keyIndices: f,
          dataLength: Xt.from(b),
          data: p,
        }
      );
    });
    let i = [];
    Ml(i, r.length);
    let s = Xt.alloc(Bp);
    Xt.from(i).copy(s);
    let o = i.length;
    r.forEach((d) => {
      const h = Qt([
        Ur("programIdIndex"),
        $i(d.keyIndicesCount.length, "keyIndicesCount"),
        Fo(Ur("keyIndex"), d.keyIndices.length, "keyIndices"),
        $i(d.dataLength.length, "dataLength"),
        Fo(Ur("userdatum"), d.data.length, "data"),
      ]).encode(d, s, o);
      o += h;
    }),
      (s = s.slice(0, o));
    const a = Qt([
        $i(1, "numRequiredSignatures"),
        $i(1, "numReadonlySignedAccounts"),
        $i(1, "numReadonlyUnsignedAccounts"),
        $i(n.length, "keyCount"),
        Fo(gr("key"), t, "keys"),
        gr("recentBlockhash"),
      ]),
      l = {
        numRequiredSignatures: Xt.from([this.header.numRequiredSignatures]),
        numReadonlySignedAccounts: Xt.from([
          this.header.numReadonlySignedAccounts,
        ]),
        numReadonlyUnsignedAccounts: Xt.from([
          this.header.numReadonlyUnsignedAccounts,
        ]),
        keyCount: Xt.from(n),
        keys: this.accountKeys.map((d) => er(d.toBytes())),
        recentBlockhash: fs.decode(this.recentBlockhash),
      };
    let c = Xt.alloc(2048);
    const u = a.encode(l, c);
    return s.copy(c, u), c.slice(0, u + s.length);
  }
  static from(t) {
    let n = [...t];
    const r = nd(n);
    if (r !== (r & p8))
      throw new Error(
        "Versioned messages must be deserialized with VersionedMessage.deserialize()"
      );
    const i = nd(n),
      s = nd(n),
      o = Ka(n);
    let a = [];
    for (let f = 0; f < o; f++) {
      const h = Ya(n, 0, vd);
      a.push(new Pe(Xt.from(h)));
    }
    const l = Ya(n, 0, vd),
      c = Ka(n);
    let u = [];
    for (let f = 0; f < c; f++) {
      const h = nd(n),
        p = Ka(n),
        g = Ya(n, 0, p),
        b = Ka(n),
        v = Ya(n, 0, b),
        w = fs.encode(Xt.from(v));
      u.push({ programIdIndex: h, accounts: g, data: w });
    }
    const d = {
      header: {
        numRequiredSignatures: r,
        numReadonlySignedAccounts: i,
        numReadonlyUnsignedAccounts: s,
      },
      recentBlockhash: fs.encode(Xt.from(l)),
      accountKeys: a,
      instructions: u,
    };
    return new Au(d);
  }
}
class Vm {
  constructor(t) {
    (this.header = void 0),
      (this.staticAccountKeys = void 0),
      (this.recentBlockhash = void 0),
      (this.compiledInstructions = void 0),
      (this.addressTableLookups = void 0),
      (this.header = t.header),
      (this.staticAccountKeys = t.staticAccountKeys),
      (this.recentBlockhash = t.recentBlockhash),
      (this.compiledInstructions = t.compiledInstructions),
      (this.addressTableLookups = t.addressTableLookups);
  }
  get version() {
    return 0;
  }
  get numAccountKeysFromLookups() {
    let t = 0;
    for (const n of this.addressTableLookups)
      t += n.readonlyIndexes.length + n.writableIndexes.length;
    return t;
  }
  getAccountKeys(t) {
    let n;
    if (t && "accountKeysFromLookups" in t && t.accountKeysFromLookups) {
      if (
        this.numAccountKeysFromLookups !=
        t.accountKeysFromLookups.writable.length +
          t.accountKeysFromLookups.readonly.length
      )
        throw new Error(
          "Failed to get account keys because of a mismatch in the number of account keys from lookups"
        );
      n = t.accountKeysFromLookups;
    } else if (
      t &&
      "addressLookupTableAccounts" in t &&
      t.addressLookupTableAccounts
    )
      n = this.resolveAddressTableLookups(t.addressLookupTableAccounts);
    else if (this.addressTableLookups.length > 0)
      throw new Error(
        "Failed to get account keys because address table lookups were not resolved"
      );
    return new ob(this.staticAccountKeys, n);
  }
  isAccountSigner(t) {
    return t < this.header.numRequiredSignatures;
  }
  isAccountWritable(t) {
    const n = this.header.numRequiredSignatures,
      r = this.staticAccountKeys.length;
    if (t >= r) {
      const i = t - r,
        s = this.addressTableLookups.reduce(
          (o, a) => o + a.writableIndexes.length,
          0
        );
      return i < s;
    } else if (t >= this.header.numRequiredSignatures) {
      const i = t - n,
        o = r - n - this.header.numReadonlyUnsignedAccounts;
      return i < o;
    } else {
      const i = n - this.header.numReadonlySignedAccounts;
      return t < i;
    }
  }
  resolveAddressTableLookups(t) {
    const n = { writable: [], readonly: [] };
    for (const r of this.addressTableLookups) {
      const i = t.find((s) => s.key.equals(r.accountKey));
      if (!i)
        throw new Error(
          `Failed to find address lookup table account for table key ${r.accountKey.toBase58()}`
        );
      for (const s of r.writableIndexes)
        if (s < i.state.addresses.length) n.writable.push(i.state.addresses[s]);
        else
          throw new Error(
            `Failed to find address for index ${s} in address lookup table ${r.accountKey.toBase58()}`
          );
      for (const s of r.readonlyIndexes)
        if (s < i.state.addresses.length) n.readonly.push(i.state.addresses[s]);
        else
          throw new Error(
            `Failed to find address for index ${s} in address lookup table ${r.accountKey.toBase58()}`
          );
    }
    return n;
  }
  static compile(t) {
    const n = m8.compile(t.instructions, t.payerKey),
      r = new Array(),
      i = { writable: new Array(), readonly: new Array() },
      s = t.addressLookupTableAccounts || [];
    for (const u of s) {
      const d = n.extractTableLookup(u);
      if (d !== void 0) {
        const [f, { writable: h, readonly: p }] = d;
        r.push(f), i.writable.push(...h), i.readonly.push(...p);
      }
    }
    const [o, a] = n.getMessageComponents(),
      c = new ob(a, i).compileInstructions(t.instructions);
    return new Vm({
      header: o,
      staticAccountKeys: a,
      recentBlockhash: t.recentBlockhash,
      compiledInstructions: c,
      addressTableLookups: r,
    });
  }
  serialize() {
    const t = Array();
    Ml(t, this.staticAccountKeys.length);
    const n = this.serializeInstructions(),
      r = Array();
    Ml(r, this.compiledInstructions.length);
    const i = this.serializeAddressTableLookups(),
      s = Array();
    Ml(s, this.addressTableLookups.length);
    const o = Qt([
        Ur("prefix"),
        Qt(
          [
            Ur("numRequiredSignatures"),
            Ur("numReadonlySignedAccounts"),
            Ur("numReadonlyUnsignedAccounts"),
          ],
          "header"
        ),
        $i(t.length, "staticAccountKeysLength"),
        Fo(gr(), this.staticAccountKeys.length, "staticAccountKeys"),
        gr("recentBlockhash"),
        $i(r.length, "instructionsLength"),
        $i(n.length, "serializedInstructions"),
        $i(s.length, "addressTableLookupsLength"),
        $i(i.length, "serializedAddressTableLookups"),
      ]),
      a = new Uint8Array(Bp),
      c = o.encode(
        {
          prefix: 128,
          header: this.header,
          staticAccountKeysLength: new Uint8Array(t),
          staticAccountKeys: this.staticAccountKeys.map((u) => u.toBytes()),
          recentBlockhash: fs.decode(this.recentBlockhash),
          instructionsLength: new Uint8Array(r),
          serializedInstructions: n,
          addressTableLookupsLength: new Uint8Array(s),
          serializedAddressTableLookups: i,
        },
        a
      );
    return a.slice(0, c);
  }
  serializeInstructions() {
    let t = 0;
    const n = new Uint8Array(Bp);
    for (const r of this.compiledInstructions) {
      const i = Array();
      Ml(i, r.accountKeyIndexes.length);
      const s = Array();
      Ml(s, r.data.length);
      const o = Qt([
        Ur("programIdIndex"),
        $i(i.length, "encodedAccountKeyIndexesLength"),
        Fo(Ur(), r.accountKeyIndexes.length, "accountKeyIndexes"),
        $i(s.length, "encodedDataLength"),
        $i(r.data.length, "data"),
      ]);
      t += o.encode(
        {
          programIdIndex: r.programIdIndex,
          encodedAccountKeyIndexesLength: new Uint8Array(i),
          accountKeyIndexes: r.accountKeyIndexes,
          encodedDataLength: new Uint8Array(s),
          data: r.data,
        },
        n,
        t
      );
    }
    return n.slice(0, t);
  }
  serializeAddressTableLookups() {
    let t = 0;
    const n = new Uint8Array(Bp);
    for (const r of this.addressTableLookups) {
      const i = Array();
      Ml(i, r.writableIndexes.length);
      const s = Array();
      Ml(s, r.readonlyIndexes.length);
      const o = Qt([
        gr("accountKey"),
        $i(i.length, "encodedWritableIndexesLength"),
        Fo(Ur(), r.writableIndexes.length, "writableIndexes"),
        $i(s.length, "encodedReadonlyIndexesLength"),
        Fo(Ur(), r.readonlyIndexes.length, "readonlyIndexes"),
      ]);
      t += o.encode(
        {
          accountKey: r.accountKey.toBytes(),
          encodedWritableIndexesLength: new Uint8Array(i),
          writableIndexes: r.writableIndexes,
          encodedReadonlyIndexesLength: new Uint8Array(s),
          readonlyIndexes: r.readonlyIndexes,
        },
        n,
        t
      );
    }
    return n.slice(0, t);
  }
  static deserialize(t) {
    let n = [...t];
    const r = nd(n),
      i = r & p8;
    Vr(r !== i, "Expected versioned message but received legacy message");
    const s = i;
    Vr(
      s === 0,
      `Expected versioned message with version 0 but found version ${s}`
    );
    const o = {
        numRequiredSignatures: nd(n),
        numReadonlySignedAccounts: nd(n),
        numReadonlyUnsignedAccounts: nd(n),
      },
      a = [],
      l = Ka(n);
    for (let p = 0; p < l; p++) a.push(new Pe(Ya(n, 0, vd)));
    const c = fs.encode(Ya(n, 0, vd)),
      u = Ka(n),
      d = [];
    for (let p = 0; p < u; p++) {
      const g = nd(n),
        b = Ka(n),
        v = Ya(n, 0, b),
        w = Ka(n),
        x = new Uint8Array(Ya(n, 0, w));
      d.push({ programIdIndex: g, accountKeyIndexes: v, data: x });
    }
    const f = Ka(n),
      h = [];
    for (let p = 0; p < f; p++) {
      const g = new Pe(Ya(n, 0, vd)),
        b = Ka(n),
        v = Ya(n, 0, b),
        w = Ka(n),
        x = Ya(n, 0, w);
      h.push({ accountKey: g, writableIndexes: v, readonlyIndexes: x });
    }
    return new Vm({
      header: o,
      staticAccountKeys: a,
      recentBlockhash: c,
      compiledInstructions: d,
      addressTableLookups: h,
    });
  }
}
const g8 = {
  deserializeMessageVersion(e) {
    const t = e[0],
      n = t & p8;
    return n === t ? "legacy" : n;
  },
  deserialize: (e) => {
    const t = g8.deserializeMessageVersion(e);
    if (t === "legacy") return Au.from(e);
    if (t === 0) return Vm.deserialize(e);
    throw new Error(
      `Transaction message version ${t} deserialization is not supported`
    );
  },
};
let bf = (function (e) {
  return (
    (e[(e.BLOCKHEIGHT_EXCEEDED = 0)] = "BLOCKHEIGHT_EXCEEDED"),
    (e[(e.PROCESSED = 1)] = "PROCESSED"),
    (e[(e.TIMED_OUT = 2)] = "TIMED_OUT"),
    (e[(e.NONCE_INVALID = 3)] = "NONCE_INVALID"),
    e
  );
})({});
const ebe = Xt.alloc(Ay).fill(0);
class yi {
  constructor(t) {
    (this.keys = void 0),
      (this.programId = void 0),
      (this.data = Xt.alloc(0)),
      (this.programId = t.programId),
      (this.keys = t.keys),
      t.data && (this.data = t.data);
  }
  toJSON() {
    return {
      keys: this.keys.map(({ pubkey: t, isSigner: n, isWritable: r }) => ({
        pubkey: t.toJSON(),
        isSigner: n,
        isWritable: r,
      })),
      programId: this.programId.toJSON(),
      data: [...this.data],
    };
  }
}
class fr {
  get signature() {
    return this.signatures.length > 0 ? this.signatures[0].signature : null;
  }
  constructor(t) {
    if (
      ((this.signatures = []),
      (this.feePayer = void 0),
      (this.instructions = []),
      (this.recentBlockhash = void 0),
      (this.lastValidBlockHeight = void 0),
      (this.nonceInfo = void 0),
      (this.minNonceContextSlot = void 0),
      (this._message = void 0),
      (this._json = void 0),
      !!t)
    )
      if (
        (t.feePayer && (this.feePayer = t.feePayer),
        t.signatures && (this.signatures = t.signatures),
        Object.prototype.hasOwnProperty.call(t, "nonceInfo"))
      ) {
        const { minContextSlot: n, nonceInfo: r } = t;
        (this.minNonceContextSlot = n), (this.nonceInfo = r);
      } else if (
        Object.prototype.hasOwnProperty.call(t, "lastValidBlockHeight")
      ) {
        const { blockhash: n, lastValidBlockHeight: r } = t;
        (this.recentBlockhash = n), (this.lastValidBlockHeight = r);
      } else {
        const { recentBlockhash: n, nonceInfo: r } = t;
        r && (this.nonceInfo = r), (this.recentBlockhash = n);
      }
  }
  toJSON() {
    return {
      recentBlockhash: this.recentBlockhash || null,
      feePayer: this.feePayer ? this.feePayer.toJSON() : null,
      nonceInfo: this.nonceInfo
        ? {
            nonce: this.nonceInfo.nonce,
            nonceInstruction: this.nonceInfo.nonceInstruction.toJSON(),
          }
        : null,
      instructions: this.instructions.map((t) => t.toJSON()),
      signers: this.signatures.map(({ publicKey: t }) => t.toJSON()),
    };
  }
  add(...t) {
    if (t.length === 0) throw new Error("No instructions");
    return (
      t.forEach((n) => {
        "instructions" in n
          ? (this.instructions = this.instructions.concat(n.instructions))
          : "data" in n && "programId" in n && "keys" in n
          ? this.instructions.push(n)
          : this.instructions.push(new yi(n));
      }),
      this
    );
  }
  compileMessage() {
    if (
      this._message &&
      JSON.stringify(this.toJSON()) === JSON.stringify(this._json)
    )
      return this._message;
    let t, n;
    if (
      (this.nonceInfo
        ? ((t = this.nonceInfo.nonce),
          this.instructions[0] != this.nonceInfo.nonceInstruction
            ? (n = [this.nonceInfo.nonceInstruction, ...this.instructions])
            : (n = this.instructions))
        : ((t = this.recentBlockhash), (n = this.instructions)),
      !t)
    )
      throw new Error("Transaction recentBlockhash required");
    n.length < 1 && console.warn("No instructions provided");
    let r;
    if (this.feePayer) r = this.feePayer;
    else if (this.signatures.length > 0 && this.signatures[0].publicKey)
      r = this.signatures[0].publicKey;
    else throw new Error("Transaction fee payer required");
    for (let g = 0; g < n.length; g++)
      if (n[g].programId === void 0)
        throw new Error(
          `Transaction instruction index ${g} has undefined program id`
        );
    const i = [],
      s = [];
    n.forEach((g) => {
      g.keys.forEach((v) => {
        s.push({ ...v });
      });
      const b = g.programId.toString();
      i.includes(b) || i.push(b);
    }),
      i.forEach((g) => {
        s.push({ pubkey: new Pe(g), isSigner: !1, isWritable: !1 });
      });
    const o = [];
    s.forEach((g) => {
      const b = g.pubkey.toString(),
        v = o.findIndex((w) => w.pubkey.toString() === b);
      v > -1
        ? ((o[v].isWritable = o[v].isWritable || g.isWritable),
          (o[v].isSigner = o[v].isSigner || g.isSigner))
        : o.push(g);
    }),
      o.sort(function (g, b) {
        if (g.isSigner !== b.isSigner) return g.isSigner ? -1 : 1;
        if (g.isWritable !== b.isWritable) return g.isWritable ? -1 : 1;
        const v = {
          localeMatcher: "best fit",
          usage: "sort",
          sensitivity: "variant",
          ignorePunctuation: !1,
          numeric: !1,
          caseFirst: "lower",
        };
        return g.pubkey.toBase58().localeCompare(b.pubkey.toBase58(), "en", v);
      });
    const a = o.findIndex((g) => g.pubkey.equals(r));
    if (a > -1) {
      const [g] = o.splice(a, 1);
      (g.isSigner = !0), (g.isWritable = !0), o.unshift(g);
    } else o.unshift({ pubkey: r, isSigner: !0, isWritable: !0 });
    for (const g of this.signatures) {
      const b = o.findIndex((v) => v.pubkey.equals(g.publicKey));
      if (b > -1)
        o[b].isSigner ||
          ((o[b].isSigner = !0),
          console.warn(
            "Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."
          ));
      else throw new Error(`unknown signer: ${g.publicKey.toString()}`);
    }
    let l = 0,
      c = 0,
      u = 0;
    const d = [],
      f = [];
    o.forEach(({ pubkey: g, isSigner: b, isWritable: v }) => {
      b
        ? (d.push(g.toString()), (l += 1), v || (c += 1))
        : (f.push(g.toString()), v || (u += 1));
    });
    const h = d.concat(f),
      p = n.map((g) => {
        const { data: b, programId: v } = g;
        return {
          programIdIndex: h.indexOf(v.toString()),
          accounts: g.keys.map((w) => h.indexOf(w.pubkey.toString())),
          data: fs.encode(b),
        };
      });
    return (
      p.forEach((g) => {
        Vr(g.programIdIndex >= 0), g.accounts.forEach((b) => Vr(b >= 0));
      }),
      new Au({
        header: {
          numRequiredSignatures: l,
          numReadonlySignedAccounts: c,
          numReadonlyUnsignedAccounts: u,
        },
        accountKeys: h,
        recentBlockhash: t,
        instructions: p,
      })
    );
  }
  _compile() {
    const t = this.compileMessage(),
      n = t.accountKeys.slice(0, t.header.numRequiredSignatures);
    return (
      (this.signatures.length === n.length &&
        this.signatures.every((i, s) => n[s].equals(i.publicKey))) ||
        (this.signatures = n.map((r) => ({ signature: null, publicKey: r }))),
      t
    );
  }
  serializeMessage() {
    return this._compile().serialize();
  }
  async getEstimatedFee(t) {
    return (await t.getFeeForMessage(this.compileMessage())).value;
  }
  setSigners(...t) {
    if (t.length === 0) throw new Error("No signers");
    const n = new Set();
    this.signatures = t
      .filter((r) => {
        const i = r.toString();
        return n.has(i) ? !1 : (n.add(i), !0);
      })
      .map((r) => ({ signature: null, publicKey: r }));
  }
  sign(...t) {
    if (t.length === 0) throw new Error("No signers");
    const n = new Set(),
      r = [];
    for (const s of t) {
      const o = s.publicKey.toString();
      n.has(o) || (n.add(o), r.push(s));
    }
    this.signatures = r.map((s) => ({
      signature: null,
      publicKey: s.publicKey,
    }));
    const i = this._compile();
    this._partialSign(i, ...r);
  }
  partialSign(...t) {
    if (t.length === 0) throw new Error("No signers");
    const n = new Set(),
      r = [];
    for (const s of t) {
      const o = s.publicKey.toString();
      n.has(o) || (n.add(o), r.push(s));
    }
    const i = this._compile();
    this._partialSign(i, ...r);
  }
  _partialSign(t, ...n) {
    const r = t.serialize();
    n.forEach((i) => {
      const s = lR(r, i.secretKey);
      this._addSignature(i.publicKey, er(s));
    });
  }
  addSignature(t, n) {
    this._compile(), this._addSignature(t, n);
  }
  _addSignature(t, n) {
    Vr(n.length === 64);
    const r = this.signatures.findIndex((i) => t.equals(i.publicKey));
    if (r < 0) throw new Error(`unknown signer: ${t.toString()}`);
    this.signatures[r].signature = Xt.from(n);
  }
  verifySignatures(t = !0) {
    return !this._getMessageSignednessErrors(this.serializeMessage(), t);
  }
  _getMessageSignednessErrors(t, n) {
    const r = {};
    for (const { signature: i, publicKey: s } of this.signatures)
      i === null
        ? n && (r.missing || (r.missing = [])).push(s)
        : Hwe(i, t, s.toBytes()) || (r.invalid || (r.invalid = [])).push(s);
    return r.invalid || r.missing ? r : void 0;
  }
  serialize(t) {
    const { requireAllSignatures: n, verifySignatures: r } = Object.assign(
        { requireAllSignatures: !0, verifySignatures: !0 },
        t
      ),
      i = this.serializeMessage();
    if (r) {
      const s = this._getMessageSignednessErrors(i, n);
      if (s) {
        let o = "Signature verification failed.";
        throw (
          (s.invalid &&
            (o += `
Invalid signature for public key${
              s.invalid.length === 1 ? "" : "(s)"
            } [\`${s.invalid.map((a) => a.toBase58()).join("`, `")}\`].`),
          s.missing &&
            (o += `
Missing signature for public key${
              s.missing.length === 1 ? "" : "(s)"
            } [\`${s.missing.map((a) => a.toBase58()).join("`, `")}\`].`),
          new Error(o))
        );
      }
    }
    return this._serialize(i);
  }
  _serialize(t) {
    const { signatures: n } = this,
      r = [];
    Ml(r, n.length);
    const i = r.length + n.length * 64 + t.length,
      s = Xt.alloc(i);
    return (
      Vr(n.length < 256),
      Xt.from(r).copy(s, 0),
      n.forEach(({ signature: o }, a) => {
        o !== null &&
          (Vr(o.length === 64, "signature has invalid length"),
          Xt.from(o).copy(s, r.length + a * 64));
      }),
      t.copy(s, r.length + n.length * 64),
      Vr(s.length <= Bp, `Transaction too large: ${s.length} > ${Bp}`),
      s
    );
  }
  get keys() {
    return (
      Vr(this.instructions.length === 1),
      this.instructions[0].keys.map((t) => t.pubkey)
    );
  }
  get programId() {
    return Vr(this.instructions.length === 1), this.instructions[0].programId;
  }
  get data() {
    return Vr(this.instructions.length === 1), this.instructions[0].data;
  }
  static from(t) {
    let n = [...t];
    const r = Ka(n);
    let i = [];
    for (let s = 0; s < r; s++) {
      const o = Ya(n, 0, Ay);
      i.push(fs.encode(Xt.from(o)));
    }
    return fr.populate(Au.from(n), i);
  }
  static populate(t, n = []) {
    const r = new fr();
    return (
      (r.recentBlockhash = t.recentBlockhash),
      t.header.numRequiredSignatures > 0 && (r.feePayer = t.accountKeys[0]),
      n.forEach((i, s) => {
        const o = {
          signature: i == fs.encode(ebe) ? null : fs.decode(i),
          publicKey: t.accountKeys[s],
        };
        r.signatures.push(o);
      }),
      t.instructions.forEach((i) => {
        const s = i.accounts.map((o) => {
          const a = t.accountKeys[o];
          return {
            pubkey: a,
            isSigner:
              r.signatures.some(
                (l) => l.publicKey.toString() === a.toString()
              ) || t.isAccountSigner(o),
            isWritable: t.isAccountWritable(o),
          };
        });
        r.instructions.push(
          new yi({
            keys: s,
            programId: t.accountKeys[i.programIdIndex],
            data: fs.decode(i.data),
          })
        );
      }),
      (r._message = t),
      (r._json = r.toJSON()),
      r
    );
  }
}
class fR {
  constructor(t) {
    (this.payerKey = void 0),
      (this.instructions = void 0),
      (this.recentBlockhash = void 0),
      (this.payerKey = t.payerKey),
      (this.instructions = t.instructions),
      (this.recentBlockhash = t.recentBlockhash);
  }
  static decompile(t, n) {
    const { header: r, compiledInstructions: i, recentBlockhash: s } = t,
      {
        numRequiredSignatures: o,
        numReadonlySignedAccounts: a,
        numReadonlyUnsignedAccounts: l,
      } = r,
      c = o - a;
    Vr(c > 0, "Message header is invalid");
    const u = t.staticAccountKeys.length - o - l;
    Vr(u >= 0, "Message header is invalid");
    const d = t.getAccountKeys(n),
      f = d.get(0);
    if (f === void 0)
      throw new Error(
        "Failed to decompile message because no account keys were found"
      );
    const h = [];
    for (const p of i) {
      const g = [];
      for (const v of p.accountKeyIndexes) {
        const w = d.get(v);
        if (w === void 0)
          throw new Error(`Failed to find key for account key index ${v}`);
        const x = v < o;
        let S;
        x
          ? (S = v < c)
          : v < d.staticAccountKeys.length
          ? (S = v - o < u)
          : (S =
              v - d.staticAccountKeys.length <
              d.accountKeysFromLookups.writable.length),
          g.push({
            pubkey: w,
            isSigner: v < r.numRequiredSignatures,
            isWritable: S,
          });
      }
      const b = d.get(p.programIdIndex);
      if (b === void 0)
        throw new Error(
          `Failed to find program id for program id index ${p.programIdIndex}`
        );
      h.push(new yi({ programId: b, data: er(p.data), keys: g }));
    }
    return new fR({ payerKey: f, instructions: h, recentBlockhash: s });
  }
  compileToLegacyMessage() {
    return Au.compile({
      payerKey: this.payerKey,
      recentBlockhash: this.recentBlockhash,
      instructions: this.instructions,
    });
  }
  compileToV0Message(t) {
    return Vm.compile({
      payerKey: this.payerKey,
      recentBlockhash: this.recentBlockhash,
      instructions: this.instructions,
      addressLookupTableAccounts: t,
    });
  }
}
class Cy {
  get version() {
    return this.message.version;
  }
  constructor(t, n) {
    if (((this.signatures = void 0), (this.message = void 0), n !== void 0))
      Vr(
        n.length === t.header.numRequiredSignatures,
        "Expected signatures length to be equal to the number of required signatures"
      ),
        (this.signatures = n);
    else {
      const r = [];
      for (let i = 0; i < t.header.numRequiredSignatures; i++)
        r.push(new Uint8Array(Ay));
      this.signatures = r;
    }
    this.message = t;
  }
  serialize() {
    const t = this.message.serialize(),
      n = Array();
    Ml(n, this.signatures.length);
    const r = Qt([
        $i(n.length, "encodedSignaturesLength"),
        Fo(Ywe(), this.signatures.length, "signatures"),
        $i(t.length, "serializedMessage"),
      ]),
      i = new Uint8Array(2048),
      s = r.encode(
        {
          encodedSignaturesLength: new Uint8Array(n),
          signatures: this.signatures,
          serializedMessage: t,
        },
        i
      );
    return i.slice(0, s);
  }
  static deserialize(t) {
    let n = [...t];
    const r = [],
      i = Ka(n);
    for (let o = 0; o < i; o++) r.push(new Uint8Array(Ya(n, 0, Ay)));
    const s = g8.deserialize(new Uint8Array(n));
    return new Cy(s, r);
  }
  sign(t) {
    const n = this.message.serialize(),
      r = this.message.staticAccountKeys.slice(
        0,
        this.message.header.numRequiredSignatures
      );
    for (const i of t) {
      const s = r.findIndex((o) => o.equals(i.publicKey));
      Vr(s >= 0, `Cannot sign with non signer key ${i.publicKey.toBase58()}`),
        (this.signatures[s] = lR(n, i.secretKey));
    }
  }
  addSignature(t, n) {
    Vr(n.byteLength === 64, "Signature must be 64 bytes long");
    const i = this.message.staticAccountKeys
      .slice(0, this.message.header.numRequiredSignatures)
      .findIndex((s) => s.equals(t));
    Vr(
      i >= 0,
      `Can not add signature; \`${t.toBase58()}\` is not required to sign this transaction`
    ),
      (this.signatures[i] = n);
  }
}
const tbe = 160,
  nbe = 64,
  rbe = tbe / nbe,
  yQ = 1e3 / rbe,
  Ju = new Pe("SysvarC1ock11111111111111111111111111111111"),
  ibe = new Pe("SysvarEpochSchedu1e111111111111111111111111"),
  sbe = new Pe("Sysvar1nstructions1111111111111111111111111"),
  k4 = new Pe("SysvarRecentB1ockHashes11111111111111111111"),
  ky = new Pe("SysvarRent111111111111111111111111111111111"),
  obe = new Pe("SysvarRewards111111111111111111111111111111"),
  abe = new Pe("SysvarS1otHashes111111111111111111111111111"),
  lbe = new Pe("SysvarS1otHistory11111111111111111111111111"),
  T4 = new Pe("SysvarStakeHistory1111111111111111111111111");
class Zp extends Error {
  constructor({ action: t, signature: n, transactionMessage: r, logs: i }) {
    const s = i
        ? `Logs: 
${JSON.stringify(i.slice(-10), null, 2)}. `
        : "",
      o =
        "\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.";
    let a;
    switch (t) {
      case "send":
        a =
          `Transaction ${n} resulted in an error. 
${r}. ` +
          s +
          o;
        break;
      case "simulate":
        a =
          `Simulation failed. 
Message: ${r}. 
` +
          s +
          o;
        break;
      default:
        a = `Unknown action '${((l) => l)(t)}'`;
    }
    super(a),
      (this.signature = void 0),
      (this.transactionMessage = void 0),
      (this.transactionLogs = void 0),
      (this.signature = n),
      (this.transactionMessage = r),
      (this.transactionLogs = i || void 0);
  }
  get transactionError() {
    return {
      message: this.transactionMessage,
      logs: Array.isArray(this.transactionLogs) ? this.transactionLogs : void 0,
    };
  }
  get logs() {
    const t = this.transactionLogs;
    if (!(t != null && typeof t == "object" && "then" in t)) return t;
  }
  async getLogs(t) {
    return (
      Array.isArray(this.transactionLogs) ||
        (this.transactionLogs = new Promise((n, r) => {
          t.getTransaction(this.signature)
            .then((i) => {
              if (i && i.meta && i.meta.logMessages) {
                const s = i.meta.logMessages;
                (this.transactionLogs = s), n(s);
              } else r(new Error("Log messages not found"));
            })
            .catch(r);
        })),
      await this.transactionLogs
    );
  }
}
const cbe = {
  JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,
  JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,
  JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: -32003,
  JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,
  JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,
  JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: -32006,
  JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,
  JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,
  JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,
  JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,
  JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,
  JSON_RPC_SCAN_ERROR: -32012,
  JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,
  JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,
  JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,
  JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016,
};
class tn extends Error {
  constructor({ code: t, message: n, data: r }, i) {
    super(i != null ? `${i}: ${n}` : n),
      (this.code = void 0),
      (this.data = void 0),
      (this.code = t),
      (this.data = r),
      (this.name = "SolanaJSONRPCError");
  }
}
async function dT(e, t, n, r) {
  const i = r && {
      skipPreflight: r.skipPreflight,
      preflightCommitment: r.preflightCommitment || r.commitment,
      maxRetries: r.maxRetries,
      minContextSlot: r.minContextSlot,
    },
    s = await e.sendTransaction(t, n, i);
  let o;
  if (t.recentBlockhash != null && t.lastValidBlockHeight != null)
    o = (
      await e.confirmTransaction(
        {
          abortSignal: r == null ? void 0 : r.abortSignal,
          signature: s,
          blockhash: t.recentBlockhash,
          lastValidBlockHeight: t.lastValidBlockHeight,
        },
        r && r.commitment
      )
    ).value;
  else if (t.minNonceContextSlot != null && t.nonceInfo != null) {
    const { nonceInstruction: a } = t.nonceInfo,
      l = a.keys[0].pubkey;
    o = (
      await e.confirmTransaction(
        {
          abortSignal: r == null ? void 0 : r.abortSignal,
          minContextSlot: t.minNonceContextSlot,
          nonceAccountPubkey: l,
          nonceValue: t.nonceInfo.nonce,
          signature: s,
        },
        r && r.commitment
      )
    ).value;
  } else
    (r == null ? void 0 : r.abortSignal) != null &&
      console.warn(
        "sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable."
      ),
      (o = (await e.confirmTransaction(s, r && r.commitment)).value);
  if (o.err)
    throw s != null
      ? new Zp({
          action: "send",
          signature: s,
          transactionMessage: `Status: (${JSON.stringify(o)})`,
        })
      : new Error(`Transaction ${s} failed (${JSON.stringify(o)})`);
  return s;
}
function X0(e) {
  return new Promise((t) => setTimeout(t, e));
}
function Lr(e, t) {
  const n = e.layout.span >= 0 ? e.layout.span : mQ(e, t),
    r = Xt.alloc(n),
    i = Object.assign({ instruction: e.index }, t);
  return e.layout.encode(i, r), r;
}
function ni(e, t) {
  let n;
  try {
    n = e.layout.decode(t);
  } catch (r) {
    throw new Error("invalid instruction; " + r);
  }
  if (n.instruction !== e.index)
    throw new Error(
      `invalid instruction; instruction index mismatch ${n.instruction} != ${e.index}`
    );
  return n;
}
const vQ = Io("lamportsPerSignature"),
  wQ = Qt([
    Zt("version"),
    Zt("state"),
    gr("authorizedPubkey"),
    gr("nonce"),
    Qt([vQ], "feeCalculator"),
  ]),
  fT = wQ.span;
class y8 {
  constructor(t) {
    (this.authorizedPubkey = void 0),
      (this.nonce = void 0),
      (this.feeCalculator = void 0),
      (this.authorizedPubkey = t.authorizedPubkey),
      (this.nonce = t.nonce),
      (this.feeCalculator = t.feeCalculator);
  }
  static fromAccountData(t) {
    const n = wQ.decode(er(t), 0);
    return new y8({
      authorizedPubkey: new Pe(n.authorizedPubkey),
      nonce: new Pe(n.nonce).toString(),
      feeCalculator: n.feeCalculator,
    });
  }
}
const ube = (e) => {
    const t = e.decode.bind(e),
      n = e.encode.bind(e);
    return { decode: t, encode: n };
  },
  dbe = (e) => (t) => {
    const n = $i(e, t),
      { encode: r, decode: i } = ube(n),
      s = n;
    return (
      (s.decode = (o, a) => {
        const l = i(o, a);
        return j2e(Xt.from(l));
      }),
      (s.encode = (o, a, l) => {
        const c = ZZ(o, e);
        return r(c, a, l);
      }),
      s
    );
  },
  Ty = dbe(8);
class fbe {
  constructor() {}
  static decodeInstructionType(t) {
    this.checkProgramId(t.programId);
    const r = Zt("instruction").decode(t.data);
    let i;
    for (const [s, o] of Object.entries(Pi))
      if (o.index == r) {
        i = s;
        break;
      }
    if (!i)
      throw new Error("Instruction type incorrect; not a SystemInstruction");
    return i;
  }
  static decodeCreateAccount(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 2);
    const { lamports: n, space: r, programId: i } = ni(Pi.Create, t.data);
    return {
      fromPubkey: t.keys[0].pubkey,
      newAccountPubkey: t.keys[1].pubkey,
      lamports: n,
      space: r,
      programId: new Pe(i),
    };
  }
  static decodeTransfer(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 2);
    const { lamports: n } = ni(Pi.Transfer, t.data);
    return {
      fromPubkey: t.keys[0].pubkey,
      toPubkey: t.keys[1].pubkey,
      lamports: n,
    };
  }
  static decodeTransferWithSeed(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
    const {
      lamports: n,
      seed: r,
      programId: i,
    } = ni(Pi.TransferWithSeed, t.data);
    return {
      fromPubkey: t.keys[0].pubkey,
      basePubkey: t.keys[1].pubkey,
      toPubkey: t.keys[2].pubkey,
      lamports: n,
      seed: r,
      programId: new Pe(i),
    };
  }
  static decodeAllocate(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 1);
    const { space: n } = ni(Pi.Allocate, t.data);
    return { accountPubkey: t.keys[0].pubkey, space: n };
  }
  static decodeAllocateWithSeed(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 1);
    const {
      base: n,
      seed: r,
      space: i,
      programId: s,
    } = ni(Pi.AllocateWithSeed, t.data);
    return {
      accountPubkey: t.keys[0].pubkey,
      basePubkey: new Pe(n),
      seed: r,
      space: i,
      programId: new Pe(s),
    };
  }
  static decodeAssign(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 1);
    const { programId: n } = ni(Pi.Assign, t.data);
    return { accountPubkey: t.keys[0].pubkey, programId: new Pe(n) };
  }
  static decodeAssignWithSeed(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 1);
    const { base: n, seed: r, programId: i } = ni(Pi.AssignWithSeed, t.data);
    return {
      accountPubkey: t.keys[0].pubkey,
      basePubkey: new Pe(n),
      seed: r,
      programId: new Pe(i),
    };
  }
  static decodeCreateWithSeed(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 2);
    const {
      base: n,
      seed: r,
      lamports: i,
      space: s,
      programId: o,
    } = ni(Pi.CreateWithSeed, t.data);
    return {
      fromPubkey: t.keys[0].pubkey,
      newAccountPubkey: t.keys[1].pubkey,
      basePubkey: new Pe(n),
      seed: r,
      lamports: i,
      space: s,
      programId: new Pe(o),
    };
  }
  static decodeNonceInitialize(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
    const { authorized: n } = ni(Pi.InitializeNonceAccount, t.data);
    return { noncePubkey: t.keys[0].pubkey, authorizedPubkey: new Pe(n) };
  }
  static decodeNonceAdvance(t) {
    return (
      this.checkProgramId(t.programId),
      this.checkKeyLength(t.keys, 3),
      ni(Pi.AdvanceNonceAccount, t.data),
      { noncePubkey: t.keys[0].pubkey, authorizedPubkey: t.keys[2].pubkey }
    );
  }
  static decodeNonceWithdraw(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 5);
    const { lamports: n } = ni(Pi.WithdrawNonceAccount, t.data);
    return {
      noncePubkey: t.keys[0].pubkey,
      toPubkey: t.keys[1].pubkey,
      authorizedPubkey: t.keys[4].pubkey,
      lamports: n,
    };
  }
  static decodeNonceAuthorize(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 2);
    const { authorized: n } = ni(Pi.AuthorizeNonceAccount, t.data);
    return {
      noncePubkey: t.keys[0].pubkey,
      authorizedPubkey: t.keys[1].pubkey,
      newAuthorizedPubkey: new Pe(n),
    };
  }
  static checkProgramId(t) {
    if (!t.equals(Js.programId))
      throw new Error("invalid instruction; programId is not SystemProgram");
  }
  static checkKeyLength(t, n) {
    if (t.length < n)
      throw new Error(
        `invalid instruction; found ${t.length} keys, expected at least ${n}`
      );
  }
}
const Pi = Object.freeze({
  Create: {
    index: 0,
    layout: Qt([
      Zt("instruction"),
      Tl("lamports"),
      Tl("space"),
      gr("programId"),
    ]),
  },
  Assign: { index: 1, layout: Qt([Zt("instruction"), gr("programId")]) },
  Transfer: { index: 2, layout: Qt([Zt("instruction"), Ty("lamports")]) },
  CreateWithSeed: {
    index: 3,
    layout: Qt([
      Zt("instruction"),
      gr("base"),
      im("seed"),
      Tl("lamports"),
      Tl("space"),
      gr("programId"),
    ]),
  },
  AdvanceNonceAccount: { index: 4, layout: Qt([Zt("instruction")]) },
  WithdrawNonceAccount: {
    index: 5,
    layout: Qt([Zt("instruction"), Tl("lamports")]),
  },
  InitializeNonceAccount: {
    index: 6,
    layout: Qt([Zt("instruction"), gr("authorized")]),
  },
  AuthorizeNonceAccount: {
    index: 7,
    layout: Qt([Zt("instruction"), gr("authorized")]),
  },
  Allocate: { index: 8, layout: Qt([Zt("instruction"), Tl("space")]) },
  AllocateWithSeed: {
    index: 9,
    layout: Qt([
      Zt("instruction"),
      gr("base"),
      im("seed"),
      Tl("space"),
      gr("programId"),
    ]),
  },
  AssignWithSeed: {
    index: 10,
    layout: Qt([Zt("instruction"), gr("base"), im("seed"), gr("programId")]),
  },
  TransferWithSeed: {
    index: 11,
    layout: Qt([
      Zt("instruction"),
      Ty("lamports"),
      im("seed"),
      gr("programId"),
    ]),
  },
  UpgradeNonceAccount: { index: 12, layout: Qt([Zt("instruction")]) },
});
class Js {
  constructor() {}
  static createAccount(t) {
    const n = Pi.Create,
      r = Lr(n, {
        lamports: t.lamports,
        space: t.space,
        programId: er(t.programId.toBuffer()),
      });
    return new yi({
      keys: [
        { pubkey: t.fromPubkey, isSigner: !0, isWritable: !0 },
        { pubkey: t.newAccountPubkey, isSigner: !0, isWritable: !0 },
      ],
      programId: this.programId,
      data: r,
    });
  }
  static transfer(t) {
    let n, r;
    if ("basePubkey" in t) {
      const i = Pi.TransferWithSeed;
      (n = Lr(i, {
        lamports: BigInt(t.lamports),
        seed: t.seed,
        programId: er(t.programId.toBuffer()),
      })),
        (r = [
          { pubkey: t.fromPubkey, isSigner: !1, isWritable: !0 },
          { pubkey: t.basePubkey, isSigner: !0, isWritable: !1 },
          { pubkey: t.toPubkey, isSigner: !1, isWritable: !0 },
        ]);
    } else {
      const i = Pi.Transfer;
      (n = Lr(i, { lamports: BigInt(t.lamports) })),
        (r = [
          { pubkey: t.fromPubkey, isSigner: !0, isWritable: !0 },
          { pubkey: t.toPubkey, isSigner: !1, isWritable: !0 },
        ]);
    }
    return new yi({ keys: r, programId: this.programId, data: n });
  }
  static assign(t) {
    let n, r;
    if ("basePubkey" in t) {
      const i = Pi.AssignWithSeed;
      (n = Lr(i, {
        base: er(t.basePubkey.toBuffer()),
        seed: t.seed,
        programId: er(t.programId.toBuffer()),
      })),
        (r = [
          { pubkey: t.accountPubkey, isSigner: !1, isWritable: !0 },
          { pubkey: t.basePubkey, isSigner: !0, isWritable: !1 },
        ]);
    } else {
      const i = Pi.Assign;
      (n = Lr(i, { programId: er(t.programId.toBuffer()) })),
        (r = [{ pubkey: t.accountPubkey, isSigner: !0, isWritable: !0 }]);
    }
    return new yi({ keys: r, programId: this.programId, data: n });
  }
  static createAccountWithSeed(t) {
    const n = Pi.CreateWithSeed,
      r = Lr(n, {
        base: er(t.basePubkey.toBuffer()),
        seed: t.seed,
        lamports: t.lamports,
        space: t.space,
        programId: er(t.programId.toBuffer()),
      });
    let i = [
      { pubkey: t.fromPubkey, isSigner: !0, isWritable: !0 },
      { pubkey: t.newAccountPubkey, isSigner: !1, isWritable: !0 },
    ];
    return (
      t.basePubkey.equals(t.fromPubkey) ||
        i.push({ pubkey: t.basePubkey, isSigner: !0, isWritable: !1 }),
      new yi({ keys: i, programId: this.programId, data: r })
    );
  }
  static createNonceAccount(t) {
    const n = new fr();
    "basePubkey" in t && "seed" in t
      ? n.add(
          Js.createAccountWithSeed({
            fromPubkey: t.fromPubkey,
            newAccountPubkey: t.noncePubkey,
            basePubkey: t.basePubkey,
            seed: t.seed,
            lamports: t.lamports,
            space: fT,
            programId: this.programId,
          })
        )
      : n.add(
          Js.createAccount({
            fromPubkey: t.fromPubkey,
            newAccountPubkey: t.noncePubkey,
            lamports: t.lamports,
            space: fT,
            programId: this.programId,
          })
        );
    const r = {
      noncePubkey: t.noncePubkey,
      authorizedPubkey: t.authorizedPubkey,
    };
    return n.add(this.nonceInitialize(r)), n;
  }
  static nonceInitialize(t) {
    const n = Pi.InitializeNonceAccount,
      r = Lr(n, { authorized: er(t.authorizedPubkey.toBuffer()) }),
      i = {
        keys: [
          { pubkey: t.noncePubkey, isSigner: !1, isWritable: !0 },
          { pubkey: k4, isSigner: !1, isWritable: !1 },
          { pubkey: ky, isSigner: !1, isWritable: !1 },
        ],
        programId: this.programId,
        data: r,
      };
    return new yi(i);
  }
  static nonceAdvance(t) {
    const n = Pi.AdvanceNonceAccount,
      r = Lr(n),
      i = {
        keys: [
          { pubkey: t.noncePubkey, isSigner: !1, isWritable: !0 },
          { pubkey: k4, isSigner: !1, isWritable: !1 },
          { pubkey: t.authorizedPubkey, isSigner: !0, isWritable: !1 },
        ],
        programId: this.programId,
        data: r,
      };
    return new yi(i);
  }
  static nonceWithdraw(t) {
    const n = Pi.WithdrawNonceAccount,
      r = Lr(n, { lamports: t.lamports });
    return new yi({
      keys: [
        { pubkey: t.noncePubkey, isSigner: !1, isWritable: !0 },
        { pubkey: t.toPubkey, isSigner: !1, isWritable: !0 },
        { pubkey: k4, isSigner: !1, isWritable: !1 },
        { pubkey: ky, isSigner: !1, isWritable: !1 },
        { pubkey: t.authorizedPubkey, isSigner: !0, isWritable: !1 },
      ],
      programId: this.programId,
      data: r,
    });
  }
  static nonceAuthorize(t) {
    const n = Pi.AuthorizeNonceAccount,
      r = Lr(n, { authorized: er(t.newAuthorizedPubkey.toBuffer()) });
    return new yi({
      keys: [
        { pubkey: t.noncePubkey, isSigner: !1, isWritable: !0 },
        { pubkey: t.authorizedPubkey, isSigner: !0, isWritable: !1 },
      ],
      programId: this.programId,
      data: r,
    });
  }
  static allocate(t) {
    let n, r;
    if ("basePubkey" in t) {
      const i = Pi.AllocateWithSeed;
      (n = Lr(i, {
        base: er(t.basePubkey.toBuffer()),
        seed: t.seed,
        space: t.space,
        programId: er(t.programId.toBuffer()),
      })),
        (r = [
          { pubkey: t.accountPubkey, isSigner: !1, isWritable: !0 },
          { pubkey: t.basePubkey, isSigner: !0, isWritable: !1 },
        ]);
    } else {
      const i = Pi.Allocate;
      (n = Lr(i, { space: t.space })),
        (r = [{ pubkey: t.accountPubkey, isSigner: !0, isWritable: !0 }]);
    }
    return new yi({ keys: r, programId: this.programId, data: n });
  }
}
Js.programId = new Pe("11111111111111111111111111111111");
const hbe = Bp - 300;
class Gm {
  constructor() {}
  static getMinNumSignatures(t) {
    return 2 * (Math.ceil(t / Gm.chunkSize) + 1 + 1);
  }
  static async load(t, n, r, i, s) {
    {
      const d = await t.getMinimumBalanceForRentExemption(s.length),
        f = await t.getAccountInfo(r.publicKey, "confirmed");
      let h = null;
      if (f !== null) {
        if (f.executable)
          return (
            console.error("Program load failed, account is already executable"),
            !1
          );
        f.data.length !== s.length &&
          ((h = h || new fr()),
          h.add(Js.allocate({ accountPubkey: r.publicKey, space: s.length }))),
          f.owner.equals(i) ||
            ((h = h || new fr()),
            h.add(Js.assign({ accountPubkey: r.publicKey, programId: i }))),
          f.lamports < d &&
            ((h = h || new fr()),
            h.add(
              Js.transfer({
                fromPubkey: n.publicKey,
                toPubkey: r.publicKey,
                lamports: d - f.lamports,
              })
            ));
      } else
        h = new fr().add(
          Js.createAccount({
            fromPubkey: n.publicKey,
            newAccountPubkey: r.publicKey,
            lamports: d > 0 ? d : 1,
            space: s.length,
            programId: i,
          })
        );
      h !== null && (await dT(t, h, [n, r], { commitment: "confirmed" }));
    }
    const o = Qt([
        Zt("instruction"),
        Zt("offset"),
        Zt("bytesLength"),
        Zt("bytesLengthPadding"),
        Fo(Ur("byte"), Dp(Zt(), -8), "bytes"),
      ]),
      a = Gm.chunkSize;
    let l = 0,
      c = s,
      u = [];
    for (; c.length > 0; ) {
      const d = c.slice(0, a),
        f = Xt.alloc(a + 16);
      o.encode(
        {
          instruction: 0,
          offset: l,
          bytes: d,
          bytesLength: 0,
          bytesLengthPadding: 0,
        },
        f
      );
      const h = new fr().add({
        keys: [{ pubkey: r.publicKey, isSigner: !0, isWritable: !0 }],
        programId: i,
        data: f,
      });
      u.push(dT(t, h, [n, r], { commitment: "confirmed" })),
        t._rpcEndpoint.includes("solana.com") && (await X0(1e3 / 4)),
        (l += a),
        (c = c.slice(a));
    }
    await Promise.all(u);
    {
      const d = Qt([Zt("instruction")]),
        f = Xt.alloc(d.span);
      d.encode({ instruction: 1 }, f);
      const h = new fr().add({
          keys: [
            { pubkey: r.publicKey, isSigner: !0, isWritable: !0 },
            { pubkey: ky, isSigner: !1, isWritable: !1 },
          ],
          programId: i,
          data: f,
        }),
        p = "processed",
        g = await t.sendTransaction(h, [n, r], { preflightCommitment: p }),
        { context: b, value: v } = await t.confirmTransaction(
          {
            signature: g,
            lastValidBlockHeight: h.lastValidBlockHeight,
            blockhash: h.recentBlockhash,
          },
          p
        );
      if (v.err)
        throw new Error(`Transaction ${g} failed (${JSON.stringify(v)})`);
      for (;;) {
        try {
          if ((await t.getSlot({ commitment: p })) > b.slot) break;
        } catch {}
        await new Promise((w) => setTimeout(w, Math.round(yQ / 2)));
      }
    }
    return !0;
  }
}
Gm.chunkSize = hbe;
const pbe = new Pe("BPFLoader2111111111111111111111111111111111");
class mbe {
  static getMinNumSignatures(t) {
    return Gm.getMinNumSignatures(t);
  }
  static load(t, n, r, i, s) {
    return Gm.load(t, n, r, s, i);
  }
}
function gbe(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default")
    ? e.default
    : e;
}
var VA, ZF;
function ybe() {
  if (ZF) return VA;
  ZF = 1;
  var e = Object.prototype.toString,
    t =
      Object.keys ||
      function (r) {
        var i = [];
        for (var s in r) i.push(s);
        return i;
      };
  function n(r, i) {
    var s, o, a, l, c, u, d;
    if (r === !0) return "true";
    if (r === !1) return "false";
    switch (typeof r) {
      case "object":
        if (r === null) return null;
        if (r.toJSON && typeof r.toJSON == "function") return n(r.toJSON(), i);
        if (((d = e.call(r)), d === "[object Array]")) {
          for (a = "[", o = r.length - 1, s = 0; s < o; s++)
            a += n(r[s], !0) + ",";
          return o > -1 && (a += n(r[s], !0)), a + "]";
        } else if (d === "[object Object]") {
          for (l = t(r).sort(), o = l.length, a = "", s = 0; s < o; )
            (c = l[s]),
              (u = n(r[c], !1)),
              u !== void 0 &&
                (a && (a += ","), (a += JSON.stringify(c) + ":" + u)),
              s++;
          return "{" + a + "}";
        } else return JSON.stringify(r);
      case "function":
      case "undefined":
        return i ? null : void 0;
      case "string":
        return JSON.stringify(r);
      default:
        return isFinite(r) ? r : null;
    }
  }
  return (
    (VA = function (r) {
      var i = n(r, !1);
      if (i !== void 0) return "" + i;
    }),
    VA
  );
}
var vbe = ybe(),
  QF = gbe(vbe);
const x2 = 32;
function GA(e) {
  let t = 0;
  for (; e > 1; ) (e /= 2), t++;
  return t;
}
function wbe(e) {
  return e === 0
    ? 1
    : (e--,
      (e |= e >> 1),
      (e |= e >> 2),
      (e |= e >> 4),
      (e |= e >> 8),
      (e |= e >> 16),
      (e |= e >> 32),
      e + 1);
}
class bQ {
  constructor(t, n, r, i, s) {
    (this.slotsPerEpoch = void 0),
      (this.leaderScheduleSlotOffset = void 0),
      (this.warmup = void 0),
      (this.firstNormalEpoch = void 0),
      (this.firstNormalSlot = void 0),
      (this.slotsPerEpoch = t),
      (this.leaderScheduleSlotOffset = n),
      (this.warmup = r),
      (this.firstNormalEpoch = i),
      (this.firstNormalSlot = s);
  }
  getEpoch(t) {
    return this.getEpochAndSlotIndex(t)[0];
  }
  getEpochAndSlotIndex(t) {
    if (t < this.firstNormalSlot) {
      const n = GA(wbe(t + x2 + 1)) - GA(x2) - 1,
        r = this.getSlotsInEpoch(n),
        i = t - (r - x2);
      return [n, i];
    } else {
      const n = t - this.firstNormalSlot,
        r = Math.floor(n / this.slotsPerEpoch),
        i = this.firstNormalEpoch + r,
        s = n % this.slotsPerEpoch;
      return [i, s];
    }
  }
  getFirstSlotInEpoch(t) {
    return t <= this.firstNormalEpoch
      ? (Math.pow(2, t) - 1) * x2
      : (t - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;
  }
  getLastSlotInEpoch(t) {
    return this.getFirstSlotInEpoch(t) + this.getSlotsInEpoch(t) - 1;
  }
  getSlotsInEpoch(t) {
    return t < this.firstNormalEpoch
      ? Math.pow(2, t + GA(x2))
      : this.slotsPerEpoch;
  }
}
var bbe = globalThis.fetch;
class xbe extends Swe {
  constructor(t, n, r) {
    const i = (s) => {
      const o = xwe(s, {
        autoconnect: !0,
        max_reconnects: 5,
        reconnect: !0,
        reconnect_interval: 1e3,
        ...n,
      });
      return (
        "socket" in o
          ? (this.underlyingSocket = o.socket)
          : (this.underlyingSocket = o),
        o
      );
    };
    super(i, t, n, r), (this.underlyingSocket = void 0);
  }
  call(...t) {
    var r;
    const n = (r = this.underlyingSocket) == null ? void 0 : r.readyState;
    return n === 1
      ? super.call(...t)
      : Promise.reject(
          new Error(
            "Tried to call a JSON-RPC method `" +
              t[0] +
              "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " +
              n +
              ")"
          )
        );
  }
  notify(...t) {
    var r;
    const n = (r = this.underlyingSocket) == null ? void 0 : r.readyState;
    return n === 1
      ? super.notify(...t)
      : Promise.reject(
          new Error(
            "Tried to send a JSON-RPC notification `" +
              t[0] +
              "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " +
              n +
              ")"
          )
        );
  }
}
function _be(e, t) {
  let n;
  try {
    n = e.layout.decode(t);
  } catch (r) {
    throw new Error("invalid instruction; " + r);
  }
  if (n.typeIndex !== e.index)
    throw new Error(
      `invalid account data; account type mismatch ${n.typeIndex} != ${e.index}`
    );
  return n;
}
const XF = 56;
class hT {
  constructor(t) {
    (this.key = void 0),
      (this.state = void 0),
      (this.key = t.key),
      (this.state = t.state);
  }
  isActive() {
    const t = BigInt("0xffffffffffffffff");
    return this.state.deactivationSlot === t;
  }
  static deserialize(t) {
    const n = _be(Sbe, t),
      r = t.length - XF;
    Vr(r >= 0, "lookup table is invalid"),
      Vr(r % 32 === 0, "lookup table is invalid");
    const i = r / 32,
      { addresses: s } = Qt([Fo(gr(), i, "addresses")]).decode(t.slice(XF));
    return {
      deactivationSlot: n.deactivationSlot,
      lastExtendedSlot: n.lastExtendedSlot,
      lastExtendedSlotStartIndex: n.lastExtendedStartIndex,
      authority: n.authority.length !== 0 ? new Pe(n.authority[0]) : void 0,
      addresses: s.map((o) => new Pe(o)),
    };
  }
}
const Sbe = {
    index: 1,
    layout: Qt([
      Zt("typeIndex"),
      Ty("deactivationSlot"),
      Io("lastExtendedSlot"),
      Ur("lastExtendedStartIndex"),
      Ur(),
      Fo(gr(), Dp(Ur(), -1), "authority"),
    ]),
  },
  Ebe = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;
function Abe(e) {
  const t = e.match(Ebe);
  if (t == null) throw TypeError(`Failed to validate endpoint URL \`${e}\``);
  const [n, r, i, s] = t,
    o = e.startsWith("https:") ? "wss:" : "ws:",
    a = i == null ? null : parseInt(i.slice(1), 10),
    l = a == null ? "" : `:${a + 1}`;
  return `${o}//${r}${l}${s}`;
}
const gs = vx(sR(Pe), pt(), (e) => new Pe(e)),
  xQ = oR([pt(), us("base64")]),
  hR = vx(sR(Xt), xQ, (e) => Xt.from(e[0], "base64")),
  _Q = 30 * 1e3;
function Cbe(e) {
  if (/^https?:/.test(e) === !1)
    throw new TypeError("Endpoint URL must start with `http:` or `https:`.");
  return e;
}
function Ri(e) {
  let t, n;
  if (typeof e == "string") t = e;
  else if (e) {
    const { commitment: r, ...i } = e;
    (t = r), (n = i);
  }
  return { commitment: t, config: n };
}
function JF(e) {
  return e.map((t) =>
    "memcmp" in t
      ? {
          ...t,
          memcmp: { ...t.memcmp, encoding: t.memcmp.encoding ?? "base58" },
        }
      : t
  );
}
function SQ(e) {
  return Ma([
    tt({ jsonrpc: us("2.0"), id: pt(), result: e }),
    tt({
      jsonrpc: us("2.0"),
      id: pt(),
      error: tt({ code: uv(), message: pt(), data: An(V2e()) }),
    }),
  ]);
}
const kbe = SQ(uv());
function Jn(e) {
  return vx(SQ(e), kbe, (t) =>
    "error" in t ? t : { ...t, result: yt(t.result, e) }
  );
}
function _s(e) {
  return Jn(tt({ context: tt({ slot: Ae() }), value: e }));
}
function v8(e) {
  return tt({ context: tt({ slot: Ae() }), value: e });
}
function qA(e, t) {
  return e === 0
    ? new Vm({
        header: t.header,
        staticAccountKeys: t.accountKeys.map((n) => new Pe(n)),
        recentBlockhash: t.recentBlockhash,
        compiledInstructions: t.instructions.map((n) => ({
          programIdIndex: n.programIdIndex,
          accountKeyIndexes: n.accounts,
          data: fs.decode(n.data),
        })),
        addressTableLookups: t.addressTableLookups,
      })
    : new Au(t);
}
const Tbe = tt({
    foundation: Ae(),
    foundationTerm: Ae(),
    initial: Ae(),
    taper: Ae(),
    terminal: Ae(),
  }),
  Mbe = Jn(
    Et(
      Ct(
        tt({
          epoch: Ae(),
          effectiveSlot: Ae(),
          amount: Ae(),
          postBalance: Ae(),
          commission: An(Ct(Ae())),
        })
      )
    )
  ),
  Ibe = Et(tt({ slot: Ae(), prioritizationFee: Ae() })),
  Nbe = tt({ total: Ae(), validator: Ae(), foundation: Ae(), epoch: Ae() }),
  Rbe = tt({
    epoch: Ae(),
    slotIndex: Ae(),
    slotsInEpoch: Ae(),
    absoluteSlot: Ae(),
    blockHeight: An(Ae()),
    transactionCount: An(Ae()),
  }),
  Obe = tt({
    slotsPerEpoch: Ae(),
    leaderScheduleSlotOffset: Ae(),
    warmup: Id(),
    firstNormalEpoch: Ae(),
    firstNormalSlot: Ae(),
  }),
  Pbe = JZ(pt(), Et(Ae())),
  p1 = Ct(Ma([tt({}), pt()])),
  Lbe = tt({ err: p1 }),
  jbe = us("receivedSignature"),
  Dbe = tt({ "solana-core": pt(), "feature-set": An(Ae()) }),
  Bbe = tt({ program: pt(), programId: gs, parsed: uv() }),
  Fbe = tt({ programId: gs, accounts: Et(gs), data: pt() }),
  eU = _s(
    tt({
      err: Ct(Ma([tt({}), pt()])),
      logs: Ct(Et(pt())),
      accounts: An(
        Ct(
          Et(
            Ct(
              tt({
                executable: Id(),
                owner: pt(),
                lamports: Ae(),
                data: Et(pt()),
                rentEpoch: An(Ae()),
              })
            )
          )
        )
      ),
      unitsConsumed: An(Ae()),
      returnData: An(
        Ct(tt({ programId: pt(), data: oR([pt(), us("base64")]) }))
      ),
      innerInstructions: An(
        Ct(Et(tt({ index: Ae(), instructions: Et(Ma([Bbe, Fbe])) })))
      ),
    })
  ),
  Ube = _s(
    tt({
      byIdentity: JZ(pt(), Et(Ae())),
      range: tt({ firstSlot: Ae(), lastSlot: Ae() }),
    })
  );
function $be(e, t, n, r, i, s) {
  const o = n || bbe;
  let a;
  s != null &&
    console.warn(
      "You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments."
    );
  let l;
  return (
    r &&
      (l = async (u, d) => {
        const f = await new Promise((h, p) => {
          try {
            r(u, d, (g, b) => h([g, b]));
          } catch (g) {
            p(g);
          }
        });
        return await o(...f);
      }),
    new vwe(async (u, d) => {
      const f = {
        method: "POST",
        body: u,
        agent: a,
        headers: Object.assign(
          { "Content-Type": "application/json" },
          t || {},
          zxe
        ),
      };
      try {
        let h = 5,
          p,
          g = 500;
        for (
          ;
          l ? (p = await l(e, f)) : (p = await o(e, f)),
            !(p.status !== 429 || i === !0 || ((h -= 1), h === 0));

        )
          console.error(
            `Server responded with ${p.status} ${p.statusText}.  Retrying after ${g}ms delay...`
          ),
            await X0(g),
            (g *= 2);
        const b = await p.text();
        p.ok ? d(null, b) : d(new Error(`${p.status} ${p.statusText}: ${b}`));
      } catch (h) {
        h instanceof Error && d(h);
      }
    }, {})
  );
}
function zbe(e) {
  return (t, n) =>
    new Promise((r, i) => {
      e.request(t, n, (s, o) => {
        if (s) {
          i(s);
          return;
        }
        r(o);
      });
    });
}
function Wbe(e) {
  return (t) =>
    new Promise((n, r) => {
      t.length === 0 && n([]);
      const i = t.map((s) => e.request(s.methodName, s.args));
      e.request(i, (s, o) => {
        if (s) {
          r(s);
          return;
        }
        n(o);
      });
    });
}
const Hbe = Jn(Tbe),
  Vbe = Jn(Nbe),
  Gbe = Jn(Ibe),
  qbe = Jn(Rbe),
  Kbe = Jn(Obe),
  Ybe = Jn(Pbe),
  Zbe = Jn(Ae()),
  Qbe = _s(
    tt({
      total: Ae(),
      circulating: Ae(),
      nonCirculating: Ae(),
      nonCirculatingAccounts: Et(gs),
    })
  ),
  pT = tt({
    amount: pt(),
    uiAmount: Ct(Ae()),
    decimals: Ae(),
    uiAmountString: An(pt()),
  }),
  Xbe = _s(
    Et(
      tt({
        address: gs,
        amount: pt(),
        uiAmount: Ct(Ae()),
        decimals: Ae(),
        uiAmountString: An(pt()),
      })
    )
  ),
  Jbe = _s(
    Et(
      tt({
        pubkey: gs,
        account: tt({
          executable: Id(),
          owner: gs,
          lamports: Ae(),
          data: hR,
          rentEpoch: Ae(),
        }),
      })
    )
  ),
  mT = tt({ program: pt(), parsed: uv(), space: Ae() }),
  exe = _s(
    Et(
      tt({
        pubkey: gs,
        account: tt({
          executable: Id(),
          owner: gs,
          lamports: Ae(),
          data: mT,
          rentEpoch: Ae(),
        }),
      })
    )
  ),
  txe = _s(Et(tt({ lamports: Ae(), address: gs }))),
  ab = tt({
    executable: Id(),
    owner: gs,
    lamports: Ae(),
    data: hR,
    rentEpoch: Ae(),
  }),
  nxe = tt({ pubkey: gs, account: ab }),
  rxe = vx(Ma([sR(Xt), mT]), Ma([xQ, mT]), (e) =>
    Array.isArray(e) ? yt(e, hR) : e
  ),
  gT = tt({
    executable: Id(),
    owner: gs,
    lamports: Ae(),
    data: rxe,
    rentEpoch: Ae(),
  }),
  ixe = tt({ pubkey: gs, account: gT }),
  sxe = tt({
    state: Ma([
      us("active"),
      us("inactive"),
      us("activating"),
      us("deactivating"),
    ]),
    active: Ae(),
    inactive: Ae(),
  }),
  oxe = Jn(
    Et(
      tt({
        signature: pt(),
        slot: Ae(),
        err: p1,
        memo: Ct(pt()),
        blockTime: An(Ct(Ae())),
      })
    )
  ),
  axe = Jn(
    Et(
      tt({
        signature: pt(),
        slot: Ae(),
        err: p1,
        memo: Ct(pt()),
        blockTime: An(Ct(Ae())),
      })
    )
  ),
  lxe = tt({ subscription: Ae(), result: v8(ab) }),
  cxe = tt({ pubkey: gs, account: ab }),
  uxe = tt({ subscription: Ae(), result: v8(cxe) }),
  dxe = tt({ parent: Ae(), slot: Ae(), root: Ae() }),
  fxe = tt({ subscription: Ae(), result: dxe }),
  hxe = Ma([
    tt({
      type: Ma([
        us("firstShredReceived"),
        us("completed"),
        us("optimisticConfirmation"),
        us("root"),
      ]),
      slot: Ae(),
      timestamp: Ae(),
    }),
    tt({ type: us("createdBank"), parent: Ae(), slot: Ae(), timestamp: Ae() }),
    tt({
      type: us("frozen"),
      slot: Ae(),
      timestamp: Ae(),
      stats: tt({
        numTransactionEntries: Ae(),
        numSuccessfulTransactions: Ae(),
        numFailedTransactions: Ae(),
        maxTransactionsPerEntry: Ae(),
      }),
    }),
    tt({ type: us("dead"), slot: Ae(), timestamp: Ae(), err: pt() }),
  ]),
  pxe = tt({ subscription: Ae(), result: hxe }),
  mxe = tt({ subscription: Ae(), result: v8(Ma([Lbe, jbe])) }),
  gxe = tt({ subscription: Ae(), result: Ae() }),
  yxe = tt({
    pubkey: pt(),
    gossip: Ct(pt()),
    tpu: Ct(pt()),
    rpc: Ct(pt()),
    version: Ct(pt()),
  }),
  tU = tt({
    votePubkey: pt(),
    nodePubkey: pt(),
    activatedStake: Ae(),
    epochVoteAccount: Id(),
    epochCredits: Et(oR([Ae(), Ae(), Ae()])),
    commission: Ae(),
    lastVote: Ae(),
    rootSlot: Ct(Ae()),
  }),
  vxe = Jn(tt({ current: Et(tU), delinquent: Et(tU) })),
  wxe = Ma([us("processed"), us("confirmed"), us("finalized")]),
  bxe = tt({
    slot: Ae(),
    confirmations: Ct(Ae()),
    err: p1,
    confirmationStatus: An(wxe),
  }),
  xxe = _s(Et(Ct(bxe))),
  _xe = Jn(Ae()),
  EQ = tt({
    accountKey: gs,
    writableIndexes: Et(Ae()),
    readonlyIndexes: Et(Ae()),
  }),
  pR = tt({
    signatures: Et(pt()),
    message: tt({
      accountKeys: Et(pt()),
      header: tt({
        numRequiredSignatures: Ae(),
        numReadonlySignedAccounts: Ae(),
        numReadonlyUnsignedAccounts: Ae(),
      }),
      instructions: Et(
        tt({ accounts: Et(Ae()), data: pt(), programIdIndex: Ae() })
      ),
      recentBlockhash: pt(),
      addressTableLookups: An(Et(EQ)),
    }),
  }),
  AQ = tt({
    pubkey: gs,
    signer: Id(),
    writable: Id(),
    source: An(Ma([us("transaction"), us("lookupTable")])),
  }),
  CQ = tt({ accountKeys: Et(AQ), signatures: Et(pt()) }),
  kQ = tt({ parsed: uv(), program: pt(), programId: gs }),
  TQ = tt({ accounts: Et(gs), data: pt(), programId: gs }),
  Sxe = Ma([TQ, kQ]),
  Exe = Ma([
    tt({ parsed: uv(), program: pt(), programId: pt() }),
    tt({ accounts: Et(pt()), data: pt(), programId: pt() }),
  ]),
  MQ = vx(Sxe, Exe, (e) => ("accounts" in e ? yt(e, TQ) : yt(e, kQ))),
  IQ = tt({
    signatures: Et(pt()),
    message: tt({
      accountKeys: Et(AQ),
      instructions: Et(MQ),
      recentBlockhash: pt(),
      addressTableLookups: An(Ct(Et(EQ))),
    }),
  }),
  c5 = tt({
    accountIndex: Ae(),
    mint: pt(),
    owner: An(pt()),
    uiTokenAmount: pT,
  }),
  NQ = tt({ writable: Et(gs), readonly: Et(gs) }),
  w8 = tt({
    err: p1,
    fee: Ae(),
    innerInstructions: An(
      Ct(
        Et(
          tt({
            index: Ae(),
            instructions: Et(
              tt({ accounts: Et(Ae()), data: pt(), programIdIndex: Ae() })
            ),
          })
        )
      )
    ),
    preBalances: Et(Ae()),
    postBalances: Et(Ae()),
    logMessages: An(Ct(Et(pt()))),
    preTokenBalances: An(Ct(Et(c5))),
    postTokenBalances: An(Ct(Et(c5))),
    loadedAddresses: An(NQ),
    computeUnitsConsumed: An(Ae()),
  }),
  mR = tt({
    err: p1,
    fee: Ae(),
    innerInstructions: An(Ct(Et(tt({ index: Ae(), instructions: Et(MQ) })))),
    preBalances: Et(Ae()),
    postBalances: Et(Ae()),
    logMessages: An(Ct(Et(pt()))),
    preTokenBalances: An(Ct(Et(c5))),
    postTokenBalances: An(Ct(Et(c5))),
    loadedAddresses: An(NQ),
    computeUnitsConsumed: An(Ae()),
  }),
  dv = Ma([us(0), us("legacy")]),
  m1 = tt({
    pubkey: pt(),
    lamports: Ae(),
    postBalance: Ct(Ae()),
    rewardType: Ct(pt()),
    commission: An(Ct(Ae())),
  }),
  Axe = Jn(
    Ct(
      tt({
        blockhash: pt(),
        previousBlockhash: pt(),
        parentSlot: Ae(),
        transactions: Et(
          tt({ transaction: pR, meta: Ct(w8), version: An(dv) })
        ),
        rewards: An(Et(m1)),
        blockTime: Ct(Ae()),
        blockHeight: Ct(Ae()),
      })
    )
  ),
  Cxe = Jn(
    Ct(
      tt({
        blockhash: pt(),
        previousBlockhash: pt(),
        parentSlot: Ae(),
        rewards: An(Et(m1)),
        blockTime: Ct(Ae()),
        blockHeight: Ct(Ae()),
      })
    )
  ),
  kxe = Jn(
    Ct(
      tt({
        blockhash: pt(),
        previousBlockhash: pt(),
        parentSlot: Ae(),
        transactions: Et(
          tt({ transaction: CQ, meta: Ct(w8), version: An(dv) })
        ),
        rewards: An(Et(m1)),
        blockTime: Ct(Ae()),
        blockHeight: Ct(Ae()),
      })
    )
  ),
  Txe = Jn(
    Ct(
      tt({
        blockhash: pt(),
        previousBlockhash: pt(),
        parentSlot: Ae(),
        transactions: Et(
          tt({ transaction: IQ, meta: Ct(mR), version: An(dv) })
        ),
        rewards: An(Et(m1)),
        blockTime: Ct(Ae()),
        blockHeight: Ct(Ae()),
      })
    )
  ),
  Mxe = Jn(
    Ct(
      tt({
        blockhash: pt(),
        previousBlockhash: pt(),
        parentSlot: Ae(),
        transactions: Et(
          tt({ transaction: CQ, meta: Ct(mR), version: An(dv) })
        ),
        rewards: An(Et(m1)),
        blockTime: Ct(Ae()),
        blockHeight: Ct(Ae()),
      })
    )
  ),
  Ixe = Jn(
    Ct(
      tt({
        blockhash: pt(),
        previousBlockhash: pt(),
        parentSlot: Ae(),
        rewards: An(Et(m1)),
        blockTime: Ct(Ae()),
        blockHeight: Ct(Ae()),
      })
    )
  ),
  Nxe = Jn(
    Ct(
      tt({
        blockhash: pt(),
        previousBlockhash: pt(),
        parentSlot: Ae(),
        transactions: Et(tt({ transaction: pR, meta: Ct(w8) })),
        rewards: An(Et(m1)),
        blockTime: Ct(Ae()),
      })
    )
  ),
  nU = Jn(
    Ct(
      tt({
        blockhash: pt(),
        previousBlockhash: pt(),
        parentSlot: Ae(),
        signatures: Et(pt()),
        blockTime: Ct(Ae()),
      })
    )
  ),
  KA = Jn(
    Ct(
      tt({
        slot: Ae(),
        meta: Ct(w8),
        blockTime: An(Ct(Ae())),
        transaction: pR,
        version: An(dv),
      })
    )
  ),
  C_ = Jn(
    Ct(
      tt({
        slot: Ae(),
        transaction: IQ,
        meta: Ct(mR),
        blockTime: An(Ct(Ae())),
        version: An(dv),
      })
    )
  ),
  Rxe = _s(
    tt({ blockhash: pt(), feeCalculator: tt({ lamportsPerSignature: Ae() }) })
  ),
  Oxe = _s(tt({ blockhash: pt(), lastValidBlockHeight: Ae() })),
  Pxe = _s(Id()),
  Lxe = tt({
    slot: Ae(),
    numTransactions: Ae(),
    numSlots: Ae(),
    samplePeriodSecs: Ae(),
  }),
  jxe = Jn(Et(Lxe)),
  Dxe = _s(Ct(tt({ feeCalculator: tt({ lamportsPerSignature: Ae() }) }))),
  Bxe = Jn(pt()),
  Fxe = Jn(pt()),
  Uxe = tt({ err: p1, logs: Et(pt()), signature: pt() }),
  $xe = tt({ result: v8(Uxe), subscription: Ae() }),
  zxe = { "solana-client": "js/1.0.0-maintenance" };
class gR {
  constructor(t, n) {
    (this._commitment = void 0),
      (this._confirmTransactionInitialTimeout = void 0),
      (this._rpcEndpoint = void 0),
      (this._rpcWsEndpoint = void 0),
      (this._rpcClient = void 0),
      (this._rpcRequest = void 0),
      (this._rpcBatchRequest = void 0),
      (this._rpcWebSocket = void 0),
      (this._rpcWebSocketConnected = !1),
      (this._rpcWebSocketHeartbeat = null),
      (this._rpcWebSocketIdleTimeout = null),
      (this._rpcWebSocketGeneration = 0),
      (this._disableBlockhashCaching = !1),
      (this._pollingBlockhash = !1),
      (this._blockhashInfo = {
        latestBlockhash: null,
        lastFetch: 0,
        transactionSignatures: [],
        simulatedSignatures: [],
      }),
      (this._nextClientSubscriptionId = 0),
      (this._subscriptionDisposeFunctionsByClientSubscriptionId = {}),
      (this._subscriptionHashByClientSubscriptionId = {}),
      (this._subscriptionStateChangeCallbacksByHash = {}),
      (this._subscriptionCallbacksByServerSubscriptionId = {}),
      (this._subscriptionsByHash = {}),
      (this._subscriptionsAutoDisposedByRpc = new Set()),
      (this.getBlockHeight = (() => {
        const c = {};
        return async (u) => {
          const { commitment: d, config: f } = Ri(u),
            h = this._buildArgs([], d, void 0, f),
            p = QF(h);
          return (
            (c[p] =
              c[p] ??
              (async () => {
                try {
                  const g = await this._rpcRequest("getBlockHeight", h),
                    b = yt(g, Jn(Ae()));
                  if ("error" in b)
                    throw new tn(
                      b.error,
                      "failed to get block height information"
                    );
                  return b.result;
                } finally {
                  delete c[p];
                }
              })()),
            await c[p]
          );
        };
      })());
    let r, i, s, o, a, l;
    n && typeof n == "string"
      ? (this._commitment = n)
      : n &&
        ((this._commitment = n.commitment),
        (this._confirmTransactionInitialTimeout =
          n.confirmTransactionInitialTimeout),
        (r = n.wsEndpoint),
        (i = n.httpHeaders),
        (s = n.fetch),
        (o = n.fetchMiddleware),
        (a = n.disableRetryOnRateLimit),
        (l = n.httpAgent)),
      (this._rpcEndpoint = Cbe(t)),
      (this._rpcWsEndpoint = r || Abe(t)),
      (this._rpcClient = $be(t, i, s, o, a, l)),
      (this._rpcRequest = zbe(this._rpcClient)),
      (this._rpcBatchRequest = Wbe(this._rpcClient)),
      (this._rpcWebSocket = new xbe(this._rpcWsEndpoint, {
        autoconnect: !1,
        max_reconnects: 1 / 0,
      })),
      this._rpcWebSocket.on("open", this._wsOnOpen.bind(this)),
      this._rpcWebSocket.on("error", this._wsOnError.bind(this)),
      this._rpcWebSocket.on("close", this._wsOnClose.bind(this)),
      this._rpcWebSocket.on(
        "accountNotification",
        this._wsOnAccountNotification.bind(this)
      ),
      this._rpcWebSocket.on(
        "programNotification",
        this._wsOnProgramAccountNotification.bind(this)
      ),
      this._rpcWebSocket.on(
        "slotNotification",
        this._wsOnSlotNotification.bind(this)
      ),
      this._rpcWebSocket.on(
        "slotsUpdatesNotification",
        this._wsOnSlotUpdatesNotification.bind(this)
      ),
      this._rpcWebSocket.on(
        "signatureNotification",
        this._wsOnSignatureNotification.bind(this)
      ),
      this._rpcWebSocket.on(
        "rootNotification",
        this._wsOnRootNotification.bind(this)
      ),
      this._rpcWebSocket.on(
        "logsNotification",
        this._wsOnLogsNotification.bind(this)
      );
  }
  get commitment() {
    return this._commitment;
  }
  get rpcEndpoint() {
    return this._rpcEndpoint;
  }
  async getBalanceAndContext(t, n) {
    const { commitment: r, config: i } = Ri(n),
      s = this._buildArgs([t.toBase58()], r, void 0, i),
      o = await this._rpcRequest("getBalance", s),
      a = yt(o, _s(Ae()));
    if ("error" in a)
      throw new tn(a.error, `failed to get balance for ${t.toBase58()}`);
    return a.result;
  }
  async getBalance(t, n) {
    return await this.getBalanceAndContext(t, n)
      .then((r) => r.value)
      .catch((r) => {
        throw new Error(
          "failed to get balance of account " + t.toBase58() + ": " + r
        );
      });
  }
  async getBlockTime(t) {
    const n = await this._rpcRequest("getBlockTime", [t]),
      r = yt(n, Jn(Ct(Ae())));
    if ("error" in r)
      throw new tn(r.error, `failed to get block time for slot ${t}`);
    return r.result;
  }
  async getMinimumLedgerSlot() {
    const t = await this._rpcRequest("minimumLedgerSlot", []),
      n = yt(t, Jn(Ae()));
    if ("error" in n)
      throw new tn(n.error, "failed to get minimum ledger slot");
    return n.result;
  }
  async getFirstAvailableBlock() {
    const t = await this._rpcRequest("getFirstAvailableBlock", []),
      n = yt(t, Zbe);
    if ("error" in n)
      throw new tn(n.error, "failed to get first available block");
    return n.result;
  }
  async getSupply(t) {
    let n = {};
    typeof t == "string"
      ? (n = { commitment: t })
      : t
      ? (n = { ...t, commitment: (t && t.commitment) || this.commitment })
      : (n = { commitment: this.commitment });
    const r = await this._rpcRequest("getSupply", [n]),
      i = yt(r, Qbe);
    if ("error" in i) throw new tn(i.error, "failed to get supply");
    return i.result;
  }
  async getTokenSupply(t, n) {
    const r = this._buildArgs([t.toBase58()], n),
      i = await this._rpcRequest("getTokenSupply", r),
      s = yt(i, _s(pT));
    if ("error" in s) throw new tn(s.error, "failed to get token supply");
    return s.result;
  }
  async getTokenAccountBalance(t, n) {
    const r = this._buildArgs([t.toBase58()], n),
      i = await this._rpcRequest("getTokenAccountBalance", r),
      s = yt(i, _s(pT));
    if ("error" in s)
      throw new tn(s.error, "failed to get token account balance");
    return s.result;
  }
  async getTokenAccountsByOwner(t, n, r) {
    const { commitment: i, config: s } = Ri(r);
    let o = [t.toBase58()];
    "mint" in n
      ? o.push({ mint: n.mint.toBase58() })
      : o.push({ programId: n.programId.toBase58() });
    const a = this._buildArgs(o, i, "base64", s),
      l = await this._rpcRequest("getTokenAccountsByOwner", a),
      c = yt(l, Jbe);
    if ("error" in c)
      throw new tn(
        c.error,
        `failed to get token accounts owned by account ${t.toBase58()}`
      );
    return c.result;
  }
  async getParsedTokenAccountsByOwner(t, n, r) {
    let i = [t.toBase58()];
    "mint" in n
      ? i.push({ mint: n.mint.toBase58() })
      : i.push({ programId: n.programId.toBase58() });
    const s = this._buildArgs(i, r, "jsonParsed"),
      o = await this._rpcRequest("getTokenAccountsByOwner", s),
      a = yt(o, exe);
    if ("error" in a)
      throw new tn(
        a.error,
        `failed to get token accounts owned by account ${t.toBase58()}`
      );
    return a.result;
  }
  async getLargestAccounts(t) {
    const n = { ...t, commitment: (t && t.commitment) || this.commitment },
      r = n.filter || n.commitment ? [n] : [],
      i = await this._rpcRequest("getLargestAccounts", r),
      s = yt(i, txe);
    if ("error" in s) throw new tn(s.error, "failed to get largest accounts");
    return s.result;
  }
  async getTokenLargestAccounts(t, n) {
    const r = this._buildArgs([t.toBase58()], n),
      i = await this._rpcRequest("getTokenLargestAccounts", r),
      s = yt(i, Xbe);
    if ("error" in s)
      throw new tn(s.error, "failed to get token largest accounts");
    return s.result;
  }
  async getAccountInfoAndContext(t, n) {
    const { commitment: r, config: i } = Ri(n),
      s = this._buildArgs([t.toBase58()], r, "base64", i),
      o = await this._rpcRequest("getAccountInfo", s),
      a = yt(o, _s(Ct(ab)));
    if ("error" in a)
      throw new tn(a.error, `failed to get info about account ${t.toBase58()}`);
    return a.result;
  }
  async getParsedAccountInfo(t, n) {
    const { commitment: r, config: i } = Ri(n),
      s = this._buildArgs([t.toBase58()], r, "jsonParsed", i),
      o = await this._rpcRequest("getAccountInfo", s),
      a = yt(o, _s(Ct(gT)));
    if ("error" in a)
      throw new tn(a.error, `failed to get info about account ${t.toBase58()}`);
    return a.result;
  }
  async getAccountInfo(t, n) {
    try {
      return (await this.getAccountInfoAndContext(t, n)).value;
    } catch (r) {
      throw new Error(
        "failed to get info about account " + t.toBase58() + ": " + r
      );
    }
  }
  async getMultipleParsedAccounts(t, n) {
    const { commitment: r, config: i } = Ri(n),
      s = t.map((c) => c.toBase58()),
      o = this._buildArgs([s], r, "jsonParsed", i),
      a = await this._rpcRequest("getMultipleAccounts", o),
      l = yt(a, _s(Et(Ct(gT))));
    if ("error" in l)
      throw new tn(l.error, `failed to get info for accounts ${s}`);
    return l.result;
  }
  async getMultipleAccountsInfoAndContext(t, n) {
    const { commitment: r, config: i } = Ri(n),
      s = t.map((c) => c.toBase58()),
      o = this._buildArgs([s], r, "base64", i),
      a = await this._rpcRequest("getMultipleAccounts", o),
      l = yt(a, _s(Et(Ct(ab))));
    if ("error" in l)
      throw new tn(l.error, `failed to get info for accounts ${s}`);
    return l.result;
  }
  async getMultipleAccountsInfo(t, n) {
    return (await this.getMultipleAccountsInfoAndContext(t, n)).value;
  }
  async getStakeActivation(t, n, r) {
    const { commitment: i, config: s } = Ri(n),
      o = this._buildArgs([t.toBase58()], i, void 0, {
        ...s,
        epoch: r ?? (s == null ? void 0 : s.epoch),
      }),
      a = await this._rpcRequest("getStakeActivation", o),
      l = yt(a, Jn(sxe));
    if ("error" in l)
      throw new tn(l.error, `failed to get Stake Activation ${t.toBase58()}`);
    return l.result;
  }
  async getProgramAccounts(t, n) {
    const { commitment: r, config: i } = Ri(n),
      { encoding: s, ...o } = i || {},
      a = this._buildArgs([t.toBase58()], r, s || "base64", {
        ...o,
        ...(o.filters ? { filters: JF(o.filters) } : null),
      }),
      l = await this._rpcRequest("getProgramAccounts", a),
      c = Et(nxe),
      u = o.withContext === !0 ? yt(l, _s(c)) : yt(l, Jn(c));
    if ("error" in u)
      throw new tn(
        u.error,
        `failed to get accounts owned by program ${t.toBase58()}`
      );
    return u.result;
  }
  async getParsedProgramAccounts(t, n) {
    const { commitment: r, config: i } = Ri(n),
      s = this._buildArgs([t.toBase58()], r, "jsonParsed", i),
      o = await this._rpcRequest("getProgramAccounts", s),
      a = yt(o, Jn(Et(ixe)));
    if ("error" in a)
      throw new tn(
        a.error,
        `failed to get accounts owned by program ${t.toBase58()}`
      );
    return a.result;
  }
  async confirmTransaction(t, n) {
    var s;
    let r;
    if (typeof t == "string") r = t;
    else {
      const o = t;
      if ((s = o.abortSignal) != null && s.aborted)
        return Promise.reject(o.abortSignal.reason);
      r = o.signature;
    }
    let i;
    try {
      i = fs.decode(r);
    } catch {
      throw new Error("signature must be base58 encoded: " + r);
    }
    return (
      Vr(i.length === 64, "signature has invalid length"),
      typeof t == "string"
        ? await this.confirmTransactionUsingLegacyTimeoutStrategy({
            commitment: n || this.commitment,
            signature: r,
          })
        : "lastValidBlockHeight" in t
        ? await this.confirmTransactionUsingBlockHeightExceedanceStrategy({
            commitment: n || this.commitment,
            strategy: t,
          })
        : await this.confirmTransactionUsingDurableNonceStrategy({
            commitment: n || this.commitment,
            strategy: t,
          })
    );
  }
  getCancellationPromise(t) {
    return new Promise((n, r) => {
      t != null &&
        (t.aborted
          ? r(t.reason)
          : t.addEventListener("abort", () => {
              r(t.reason);
            }));
    });
  }
  getTransactionConfirmationPromise({ commitment: t, signature: n }) {
    let r,
      i,
      s = !1;
    const o = new Promise((l, c) => {
      try {
        r = this.onSignature(
          n,
          (d, f) => {
            r = void 0;
            const h = { context: f, value: d };
            l({ __type: bf.PROCESSED, response: h });
          },
          t
        );
        const u = new Promise((d) => {
          r == null
            ? d()
            : (i = this._onSubscriptionStateChange(r, (f) => {
                f === "subscribed" && d();
              }));
        });
        (async () => {
          if ((await u, s)) return;
          const d = await this.getSignatureStatus(n);
          if (s || d == null) return;
          const { context: f, value: h } = d;
          if (h != null)
            if (h != null && h.err) c(h.err);
            else {
              switch (t) {
                case "confirmed":
                case "single":
                case "singleGossip": {
                  if (h.confirmationStatus === "processed") return;
                  break;
                }
                case "finalized":
                case "max":
                case "root": {
                  if (
                    h.confirmationStatus === "processed" ||
                    h.confirmationStatus === "confirmed"
                  )
                    return;
                  break;
                }
                case "processed":
                case "recent":
              }
              (s = !0),
                l({ __type: bf.PROCESSED, response: { context: f, value: h } });
            }
        })();
      } catch (u) {
        c(u);
      }
    });
    return {
      abortConfirmation: () => {
        i && (i(), (i = void 0)),
          r != null && (this.removeSignatureListener(r), (r = void 0));
      },
      confirmationPromise: o,
    };
  }
  async confirmTransactionUsingBlockHeightExceedanceStrategy({
    commitment: t,
    strategy: { abortSignal: n, lastValidBlockHeight: r, signature: i },
  }) {
    let s = !1;
    const o = new Promise((d) => {
        const f = async () => {
          try {
            return await this.getBlockHeight(t);
          } catch {
            return -1;
          }
        };
        (async () => {
          let h = await f();
          if (!s) {
            for (; h <= r; )
              if ((await X0(1e3), s || ((h = await f()), s))) return;
            d({ __type: bf.BLOCKHEIGHT_EXCEEDED });
          }
        })();
      }),
      { abortConfirmation: a, confirmationPromise: l } =
        this.getTransactionConfirmationPromise({ commitment: t, signature: i }),
      c = this.getCancellationPromise(n);
    let u;
    try {
      const d = await Promise.race([c, l, o]);
      if (d.__type === bf.PROCESSED) u = d.response;
      else throw new uR(i);
    } finally {
      (s = !0), a();
    }
    return u;
  }
  async confirmTransactionUsingDurableNonceStrategy({
    commitment: t,
    strategy: {
      abortSignal: n,
      minContextSlot: r,
      nonceAccountPubkey: i,
      nonceValue: s,
      signature: o,
    },
  }) {
    let a = !1;
    const l = new Promise((h) => {
        let p = s,
          g = null;
        const b = async () => {
          try {
            const { context: v, value: w } = await this.getNonceAndContext(i, {
              commitment: t,
              minContextSlot: r,
            });
            return (g = v.slot), w == null ? void 0 : w.nonce;
          } catch {
            return p;
          }
        };
        (async () => {
          if (((p = await b()), !a))
            for (;;) {
              if (s !== p) {
                h({ __type: bf.NONCE_INVALID, slotInWhichNonceDidAdvance: g });
                return;
              }
              if ((await X0(2e3), a || ((p = await b()), a))) return;
            }
        })();
      }),
      { abortConfirmation: c, confirmationPromise: u } =
        this.getTransactionConfirmationPromise({ commitment: t, signature: o }),
      d = this.getCancellationPromise(n);
    let f;
    try {
      const h = await Promise.race([d, u, l]);
      if (h.__type === bf.PROCESSED) f = h.response;
      else {
        let p;
        for (;;) {
          const g = await this.getSignatureStatus(o);
          if (g == null) break;
          if (g.context.slot < (h.slotInWhichNonceDidAdvance ?? r)) {
            await X0(400);
            continue;
          }
          p = g;
          break;
        }
        if (p != null && p.value) {
          const g = t || "finalized",
            { confirmationStatus: b } = p.value;
          switch (g) {
            case "processed":
            case "recent":
              if (b !== "processed" && b !== "confirmed" && b !== "finalized")
                throw new _g(o);
              break;
            case "confirmed":
            case "single":
            case "singleGossip":
              if (b !== "confirmed" && b !== "finalized") throw new _g(o);
              break;
            case "finalized":
            case "max":
            case "root":
              if (b !== "finalized") throw new _g(o);
              break;
            default:
          }
          f = { context: p.context, value: { err: p.value.err } };
        } else throw new _g(o);
      }
    } finally {
      (a = !0), c();
    }
    return f;
  }
  async confirmTransactionUsingLegacyTimeoutStrategy({
    commitment: t,
    signature: n,
  }) {
    let r;
    const i = new Promise((l) => {
        let c = this._confirmTransactionInitialTimeout || 6e4;
        switch (t) {
          case "processed":
          case "recent":
          case "single":
          case "confirmed":
          case "singleGossip": {
            c = this._confirmTransactionInitialTimeout || 3e4;
            break;
          }
        }
        r = setTimeout(() => l({ __type: bf.TIMED_OUT, timeoutMs: c }), c);
      }),
      { abortConfirmation: s, confirmationPromise: o } =
        this.getTransactionConfirmationPromise({ commitment: t, signature: n });
    let a;
    try {
      const l = await Promise.race([o, i]);
      if (l.__type === bf.PROCESSED) a = l.response;
      else throw new dR(n, l.timeoutMs / 1e3);
    } finally {
      clearTimeout(r), s();
    }
    return a;
  }
  async getClusterNodes() {
    const t = await this._rpcRequest("getClusterNodes", []),
      n = yt(t, Jn(Et(yxe)));
    if ("error" in n) throw new tn(n.error, "failed to get cluster nodes");
    return n.result;
  }
  async getVoteAccounts(t) {
    const n = this._buildArgs([], t),
      r = await this._rpcRequest("getVoteAccounts", n),
      i = yt(r, vxe);
    if ("error" in i) throw new tn(i.error, "failed to get vote accounts");
    return i.result;
  }
  async getSlot(t) {
    const { commitment: n, config: r } = Ri(t),
      i = this._buildArgs([], n, void 0, r),
      s = await this._rpcRequest("getSlot", i),
      o = yt(s, Jn(Ae()));
    if ("error" in o) throw new tn(o.error, "failed to get slot");
    return o.result;
  }
  async getSlotLeader(t) {
    const { commitment: n, config: r } = Ri(t),
      i = this._buildArgs([], n, void 0, r),
      s = await this._rpcRequest("getSlotLeader", i),
      o = yt(s, Jn(pt()));
    if ("error" in o) throw new tn(o.error, "failed to get slot leader");
    return o.result;
  }
  async getSlotLeaders(t, n) {
    const r = [t, n],
      i = await this._rpcRequest("getSlotLeaders", r),
      s = yt(i, Jn(Et(gs)));
    if ("error" in s) throw new tn(s.error, "failed to get slot leaders");
    return s.result;
  }
  async getSignatureStatus(t, n) {
    const { context: r, value: i } = await this.getSignatureStatuses([t], n);
    Vr(i.length === 1);
    const s = i[0];
    return { context: r, value: s };
  }
  async getSignatureStatuses(t, n) {
    const r = [t];
    n && r.push(n);
    const i = await this._rpcRequest("getSignatureStatuses", r),
      s = yt(i, xxe);
    if ("error" in s) throw new tn(s.error, "failed to get signature status");
    return s.result;
  }
  async getTransactionCount(t) {
    const { commitment: n, config: r } = Ri(t),
      i = this._buildArgs([], n, void 0, r),
      s = await this._rpcRequest("getTransactionCount", i),
      o = yt(s, Jn(Ae()));
    if ("error" in o) throw new tn(o.error, "failed to get transaction count");
    return o.result;
  }
  async getTotalSupply(t) {
    return (
      await this.getSupply({
        commitment: t,
        excludeNonCirculatingAccountsList: !0,
      })
    ).value.total;
  }
  async getInflationGovernor(t) {
    const n = this._buildArgs([], t),
      r = await this._rpcRequest("getInflationGovernor", n),
      i = yt(r, Hbe);
    if ("error" in i) throw new tn(i.error, "failed to get inflation");
    return i.result;
  }
  async getInflationReward(t, n, r) {
    const { commitment: i, config: s } = Ri(r),
      o = this._buildArgs([t.map((c) => c.toBase58())], i, void 0, {
        ...s,
        epoch: n ?? (s == null ? void 0 : s.epoch),
      }),
      a = await this._rpcRequest("getInflationReward", o),
      l = yt(a, Mbe);
    if ("error" in l) throw new tn(l.error, "failed to get inflation reward");
    return l.result;
  }
  async getInflationRate() {
    const t = await this._rpcRequest("getInflationRate", []),
      n = yt(t, Vbe);
    if ("error" in n) throw new tn(n.error, "failed to get inflation rate");
    return n.result;
  }
  async getEpochInfo(t) {
    const { commitment: n, config: r } = Ri(t),
      i = this._buildArgs([], n, void 0, r),
      s = await this._rpcRequest("getEpochInfo", i),
      o = yt(s, qbe);
    if ("error" in o) throw new tn(o.error, "failed to get epoch info");
    return o.result;
  }
  async getEpochSchedule() {
    const t = await this._rpcRequest("getEpochSchedule", []),
      n = yt(t, Kbe);
    if ("error" in n) throw new tn(n.error, "failed to get epoch schedule");
    const r = n.result;
    return new bQ(
      r.slotsPerEpoch,
      r.leaderScheduleSlotOffset,
      r.warmup,
      r.firstNormalEpoch,
      r.firstNormalSlot
    );
  }
  async getLeaderSchedule() {
    const t = await this._rpcRequest("getLeaderSchedule", []),
      n = yt(t, Ybe);
    if ("error" in n) throw new tn(n.error, "failed to get leader schedule");
    return n.result;
  }
  async getMinimumBalanceForRentExemption(t, n) {
    const r = this._buildArgs([t], n),
      i = await this._rpcRequest("getMinimumBalanceForRentExemption", r),
      s = yt(i, _xe);
    return "error" in s
      ? (console.warn("Unable to fetch minimum balance for rent exemption"), 0)
      : s.result;
  }
  async getRecentBlockhashAndContext(t) {
    const n = this._buildArgs([], t),
      r = await this._rpcRequest("getRecentBlockhash", n),
      i = yt(r, Rxe);
    if ("error" in i) throw new tn(i.error, "failed to get recent blockhash");
    return i.result;
  }
  async getRecentPerformanceSamples(t) {
    const n = await this._rpcRequest(
        "getRecentPerformanceSamples",
        t ? [t] : []
      ),
      r = yt(n, jxe);
    if ("error" in r)
      throw new tn(r.error, "failed to get recent performance samples");
    return r.result;
  }
  async getFeeCalculatorForBlockhash(t, n) {
    const r = this._buildArgs([t], n),
      i = await this._rpcRequest("getFeeCalculatorForBlockhash", r),
      s = yt(i, Dxe);
    if ("error" in s) throw new tn(s.error, "failed to get fee calculator");
    const { context: o, value: a } = s.result;
    return { context: o, value: a !== null ? a.feeCalculator : null };
  }
  async getFeeForMessage(t, n) {
    const r = er(t.serialize()).toString("base64"),
      i = this._buildArgs([r], n),
      s = await this._rpcRequest("getFeeForMessage", i),
      o = yt(s, _s(Ct(Ae())));
    if ("error" in o) throw new tn(o.error, "failed to get fee for message");
    if (o.result === null) throw new Error("invalid blockhash");
    return o.result;
  }
  async getRecentPrioritizationFees(t) {
    var o;
    const n =
        (o = t == null ? void 0 : t.lockedWritableAccounts) == null
          ? void 0
          : o.map((a) => a.toBase58()),
      r = n != null && n.length ? [n] : [],
      i = await this._rpcRequest("getRecentPrioritizationFees", r),
      s = yt(i, Gbe);
    if ("error" in s)
      throw new tn(s.error, "failed to get recent prioritization fees");
    return s.result;
  }
  async getRecentBlockhash(t) {
    try {
      return (await this.getRecentBlockhashAndContext(t)).value;
    } catch (n) {
      throw new Error("failed to get recent blockhash: " + n);
    }
  }
  async getLatestBlockhash(t) {
    try {
      return (await this.getLatestBlockhashAndContext(t)).value;
    } catch (n) {
      throw new Error("failed to get recent blockhash: " + n);
    }
  }
  async getLatestBlockhashAndContext(t) {
    const { commitment: n, config: r } = Ri(t),
      i = this._buildArgs([], n, void 0, r),
      s = await this._rpcRequest("getLatestBlockhash", i),
      o = yt(s, Oxe);
    if ("error" in o) throw new tn(o.error, "failed to get latest blockhash");
    return o.result;
  }
  async isBlockhashValid(t, n) {
    const { commitment: r, config: i } = Ri(n),
      s = this._buildArgs([t], r, void 0, i),
      o = await this._rpcRequest("isBlockhashValid", s),
      a = yt(o, Pxe);
    if ("error" in a)
      throw new tn(
        a.error,
        "failed to determine if the blockhash `" + t + "`is valid"
      );
    return a.result;
  }
  async getVersion() {
    const t = await this._rpcRequest("getVersion", []),
      n = yt(t, Jn(Dbe));
    if ("error" in n) throw new tn(n.error, "failed to get version");
    return n.result;
  }
  async getGenesisHash() {
    const t = await this._rpcRequest("getGenesisHash", []),
      n = yt(t, Jn(pt()));
    if ("error" in n) throw new tn(n.error, "failed to get genesis hash");
    return n.result;
  }
  async getBlock(t, n) {
    const { commitment: r, config: i } = Ri(n),
      s = this._buildArgsAtLeastConfirmed([t], r, void 0, i),
      o = await this._rpcRequest("getBlock", s);
    try {
      switch (i == null ? void 0 : i.transactionDetails) {
        case "accounts": {
          const a = yt(o, kxe);
          if ("error" in a) throw a.error;
          return a.result;
        }
        case "none": {
          const a = yt(o, Cxe);
          if ("error" in a) throw a.error;
          return a.result;
        }
        default: {
          const a = yt(o, Axe);
          if ("error" in a) throw a.error;
          const { result: l } = a;
          return l
            ? {
                ...l,
                transactions: l.transactions.map(
                  ({ transaction: c, meta: u, version: d }) => ({
                    meta: u,
                    transaction: { ...c, message: qA(d, c.message) },
                    version: d,
                  })
                ),
              }
            : null;
        }
      }
    } catch (a) {
      throw new tn(a, "failed to get confirmed block");
    }
  }
  async getParsedBlock(t, n) {
    const { commitment: r, config: i } = Ri(n),
      s = this._buildArgsAtLeastConfirmed([t], r, "jsonParsed", i),
      o = await this._rpcRequest("getBlock", s);
    try {
      switch (i == null ? void 0 : i.transactionDetails) {
        case "accounts": {
          const a = yt(o, Mxe);
          if ("error" in a) throw a.error;
          return a.result;
        }
        case "none": {
          const a = yt(o, Ixe);
          if ("error" in a) throw a.error;
          return a.result;
        }
        default: {
          const a = yt(o, Txe);
          if ("error" in a) throw a.error;
          return a.result;
        }
      }
    } catch (a) {
      throw new tn(a, "failed to get block");
    }
  }
  async getBlockProduction(t) {
    let n, r;
    if (typeof t == "string") r = t;
    else if (t) {
      const { commitment: a, ...l } = t;
      (r = a), (n = l);
    }
    const i = this._buildArgs([], r, "base64", n),
      s = await this._rpcRequest("getBlockProduction", i),
      o = yt(s, Ube);
    if ("error" in o)
      throw new tn(o.error, "failed to get block production information");
    return o.result;
  }
  async getTransaction(t, n) {
    const { commitment: r, config: i } = Ri(n),
      s = this._buildArgsAtLeastConfirmed([t], r, void 0, i),
      o = await this._rpcRequest("getTransaction", s),
      a = yt(o, KA);
    if ("error" in a) throw new tn(a.error, "failed to get transaction");
    const l = a.result;
    return (
      l && {
        ...l,
        transaction: {
          ...l.transaction,
          message: qA(l.version, l.transaction.message),
        },
      }
    );
  }
  async getParsedTransaction(t, n) {
    const { commitment: r, config: i } = Ri(n),
      s = this._buildArgsAtLeastConfirmed([t], r, "jsonParsed", i),
      o = await this._rpcRequest("getTransaction", s),
      a = yt(o, C_);
    if ("error" in a) throw new tn(a.error, "failed to get transaction");
    return a.result;
  }
  async getParsedTransactions(t, n) {
    const { commitment: r, config: i } = Ri(n),
      s = t.map((l) => ({
        methodName: "getTransaction",
        args: this._buildArgsAtLeastConfirmed([l], r, "jsonParsed", i),
      }));
    return (await this._rpcBatchRequest(s)).map((l) => {
      const c = yt(l, C_);
      if ("error" in c) throw new tn(c.error, "failed to get transactions");
      return c.result;
    });
  }
  async getTransactions(t, n) {
    const { commitment: r, config: i } = Ri(n),
      s = t.map((l) => ({
        methodName: "getTransaction",
        args: this._buildArgsAtLeastConfirmed([l], r, void 0, i),
      }));
    return (await this._rpcBatchRequest(s)).map((l) => {
      const c = yt(l, KA);
      if ("error" in c) throw new tn(c.error, "failed to get transactions");
      const u = c.result;
      return (
        u && {
          ...u,
          transaction: {
            ...u.transaction,
            message: qA(u.version, u.transaction.message),
          },
        }
      );
    });
  }
  async getConfirmedBlock(t, n) {
    const r = this._buildArgsAtLeastConfirmed([t], n),
      i = await this._rpcRequest("getConfirmedBlock", r),
      s = yt(i, Nxe);
    if ("error" in s) throw new tn(s.error, "failed to get confirmed block");
    const o = s.result;
    if (!o) throw new Error("Confirmed block " + t + " not found");
    const a = {
      ...o,
      transactions: o.transactions.map(({ transaction: l, meta: c }) => {
        const u = new Au(l.message);
        return { meta: c, transaction: { ...l, message: u } };
      }),
    };
    return {
      ...a,
      transactions: a.transactions.map(({ transaction: l, meta: c }) => ({
        meta: c,
        transaction: fr.populate(l.message, l.signatures),
      })),
    };
  }
  async getBlocks(t, n, r) {
    const i = this._buildArgsAtLeastConfirmed(n !== void 0 ? [t, n] : [t], r),
      s = await this._rpcRequest("getBlocks", i),
      o = yt(s, Jn(Et(Ae())));
    if ("error" in o) throw new tn(o.error, "failed to get blocks");
    return o.result;
  }
  async getBlockSignatures(t, n) {
    const r = this._buildArgsAtLeastConfirmed([t], n, void 0, {
        transactionDetails: "signatures",
        rewards: !1,
      }),
      i = await this._rpcRequest("getBlock", r),
      s = yt(i, nU);
    if ("error" in s) throw new tn(s.error, "failed to get block");
    const o = s.result;
    if (!o) throw new Error("Block " + t + " not found");
    return o;
  }
  async getConfirmedBlockSignatures(t, n) {
    const r = this._buildArgsAtLeastConfirmed([t], n, void 0, {
        transactionDetails: "signatures",
        rewards: !1,
      }),
      i = await this._rpcRequest("getConfirmedBlock", r),
      s = yt(i, nU);
    if ("error" in s) throw new tn(s.error, "failed to get confirmed block");
    const o = s.result;
    if (!o) throw new Error("Confirmed block " + t + " not found");
    return o;
  }
  async getConfirmedTransaction(t, n) {
    const r = this._buildArgsAtLeastConfirmed([t], n),
      i = await this._rpcRequest("getConfirmedTransaction", r),
      s = yt(i, KA);
    if ("error" in s) throw new tn(s.error, "failed to get transaction");
    const o = s.result;
    if (!o) return o;
    const a = new Au(o.transaction.message),
      l = o.transaction.signatures;
    return { ...o, transaction: fr.populate(a, l) };
  }
  async getParsedConfirmedTransaction(t, n) {
    const r = this._buildArgsAtLeastConfirmed([t], n, "jsonParsed"),
      i = await this._rpcRequest("getConfirmedTransaction", r),
      s = yt(i, C_);
    if ("error" in s)
      throw new tn(s.error, "failed to get confirmed transaction");
    return s.result;
  }
  async getParsedConfirmedTransactions(t, n) {
    const r = t.map((o) => ({
      methodName: "getConfirmedTransaction",
      args: this._buildArgsAtLeastConfirmed([o], n, "jsonParsed"),
    }));
    return (await this._rpcBatchRequest(r)).map((o) => {
      const a = yt(o, C_);
      if ("error" in a)
        throw new tn(a.error, "failed to get confirmed transactions");
      return a.result;
    });
  }
  async getConfirmedSignaturesForAddress(t, n, r) {
    let i = {},
      s = await this.getFirstAvailableBlock();
    for (; !("until" in i) && (n--, !(n <= 0 || n < s)); )
      try {
        const l = await this.getConfirmedBlockSignatures(n, "finalized");
        l.signatures.length > 0 &&
          (i.until = l.signatures[l.signatures.length - 1].toString());
      } catch (l) {
        if (l instanceof Error && l.message.includes("skipped")) continue;
        throw l;
      }
    let o = await this.getSlot("finalized");
    for (; !("before" in i) && (r++, !(r > o)); )
      try {
        const l = await this.getConfirmedBlockSignatures(r);
        l.signatures.length > 0 &&
          (i.before = l.signatures[l.signatures.length - 1].toString());
      } catch (l) {
        if (l instanceof Error && l.message.includes("skipped")) continue;
        throw l;
      }
    return (await this.getConfirmedSignaturesForAddress2(t, i)).map(
      (l) => l.signature
    );
  }
  async getConfirmedSignaturesForAddress2(t, n, r) {
    const i = this._buildArgsAtLeastConfirmed([t.toBase58()], r, void 0, n),
      s = await this._rpcRequest("getConfirmedSignaturesForAddress2", i),
      o = yt(s, oxe);
    if ("error" in o)
      throw new tn(o.error, "failed to get confirmed signatures for address");
    return o.result;
  }
  async getSignaturesForAddress(t, n, r) {
    const i = this._buildArgsAtLeastConfirmed([t.toBase58()], r, void 0, n),
      s = await this._rpcRequest("getSignaturesForAddress", i),
      o = yt(s, axe);
    if ("error" in o)
      throw new tn(o.error, "failed to get signatures for address");
    return o.result;
  }
  async getAddressLookupTable(t, n) {
    const { context: r, value: i } = await this.getAccountInfoAndContext(t, n);
    let s = null;
    return (
      i !== null && (s = new hT({ key: t, state: hT.deserialize(i.data) })),
      { context: r, value: s }
    );
  }
  async getNonceAndContext(t, n) {
    const { context: r, value: i } = await this.getAccountInfoAndContext(t, n);
    let s = null;
    return (
      i !== null && (s = y8.fromAccountData(i.data)), { context: r, value: s }
    );
  }
  async getNonce(t, n) {
    return await this.getNonceAndContext(t, n)
      .then((r) => r.value)
      .catch((r) => {
        throw new Error(
          "failed to get nonce for account " + t.toBase58() + ": " + r
        );
      });
  }
  async requestAirdrop(t, n) {
    const r = await this._rpcRequest("requestAirdrop", [t.toBase58(), n]),
      i = yt(r, Bxe);
    if ("error" in i)
      throw new tn(i.error, `airdrop to ${t.toBase58()} failed`);
    return i.result;
  }
  async _blockhashWithExpiryBlockHeight(t) {
    if (!t) {
      for (; this._pollingBlockhash; ) await X0(100);
      const r = Date.now() - this._blockhashInfo.lastFetch >= _Q;
      if (this._blockhashInfo.latestBlockhash !== null && !r)
        return this._blockhashInfo.latestBlockhash;
    }
    return await this._pollNewBlockhash();
  }
  async _pollNewBlockhash() {
    this._pollingBlockhash = !0;
    try {
      const t = Date.now(),
        n = this._blockhashInfo.latestBlockhash,
        r = n ? n.blockhash : null;
      for (let i = 0; i < 50; i++) {
        const s = await this.getLatestBlockhash("finalized");
        if (r !== s.blockhash)
          return (
            (this._blockhashInfo = {
              latestBlockhash: s,
              lastFetch: Date.now(),
              transactionSignatures: [],
              simulatedSignatures: [],
            }),
            s
          );
        await X0(yQ / 2);
      }
      throw new Error(
        `Unable to obtain a new blockhash after ${Date.now() - t}ms`
      );
    } finally {
      this._pollingBlockhash = !1;
    }
  }
  async getStakeMinimumDelegation(t) {
    const { commitment: n, config: r } = Ri(t),
      i = this._buildArgs([], n, "base64", r),
      s = await this._rpcRequest("getStakeMinimumDelegation", i),
      o = yt(s, _s(Ae()));
    if ("error" in o)
      throw new tn(o.error, "failed to get stake minimum delegation");
    return o.result;
  }
  async simulateTransaction(t, n, r) {
    if ("message" in t) {
      const g = t.serialize(),
        b = Xt.from(g).toString("base64");
      if (Array.isArray(n) || r !== void 0)
        throw new Error("Invalid arguments");
      const v = n || {};
      (v.encoding = "base64"),
        "commitment" in v || (v.commitment = this.commitment),
        n &&
          typeof n == "object" &&
          "innerInstructions" in n &&
          (v.innerInstructions = n.innerInstructions);
      const w = [b, v],
        x = await this._rpcRequest("simulateTransaction", w),
        S = yt(x, eU);
      if ("error" in S)
        throw new Error("failed to simulate transaction: " + S.error.message);
      return S.result;
    }
    let i;
    if (t instanceof fr) {
      let p = t;
      (i = new fr()),
        (i.feePayer = p.feePayer),
        (i.instructions = t.instructions),
        (i.nonceInfo = p.nonceInfo),
        (i.signatures = p.signatures);
    } else (i = fr.populate(t)), (i._message = i._json = void 0);
    if (n !== void 0 && !Array.isArray(n)) throw new Error("Invalid arguments");
    const s = n;
    if (i.nonceInfo && s) i.sign(...s);
    else {
      let p = this._disableBlockhashCaching;
      for (;;) {
        const g = await this._blockhashWithExpiryBlockHeight(p);
        if (
          ((i.lastValidBlockHeight = g.lastValidBlockHeight),
          (i.recentBlockhash = g.blockhash),
          !s)
        )
          break;
        if ((i.sign(...s), !i.signature)) throw new Error("!signature");
        const b = i.signature.toString("base64");
        if (
          !this._blockhashInfo.simulatedSignatures.includes(b) &&
          !this._blockhashInfo.transactionSignatures.includes(b)
        ) {
          this._blockhashInfo.simulatedSignatures.push(b);
          break;
        } else p = !0;
      }
    }
    const o = i._compile(),
      a = o.serialize(),
      c = i._serialize(a).toString("base64"),
      u = { encoding: "base64", commitment: this.commitment };
    if (r) {
      const p = (Array.isArray(r) ? r : o.nonProgramIds()).map((g) =>
        g.toBase58()
      );
      u.accounts = { encoding: "base64", addresses: p };
    }
    s && (u.sigVerify = !0),
      n &&
        typeof n == "object" &&
        "innerInstructions" in n &&
        (u.innerInstructions = n.innerInstructions);
    const d = [c, u],
      f = await this._rpcRequest("simulateTransaction", d),
      h = yt(f, eU);
    if ("error" in h) {
      let p;
      if (
        "data" in h.error &&
        ((p = h.error.data.logs), p && Array.isArray(p))
      ) {
        const g = `
    `,
          b = g + p.join(g);
        console.error(h.error.message, b);
      }
      throw new Zp({
        action: "simulate",
        signature: "",
        transactionMessage: h.error.message,
        logs: p,
      });
    }
    return h.result;
  }
  async sendTransaction(t, n, r) {
    if ("version" in t) {
      if (n && Array.isArray(n)) throw new Error("Invalid arguments");
      const o = t.serialize();
      return await this.sendRawTransaction(o, n);
    }
    if (n === void 0 || !Array.isArray(n)) throw new Error("Invalid arguments");
    const i = n;
    if (t.nonceInfo) t.sign(...i);
    else {
      let o = this._disableBlockhashCaching;
      for (;;) {
        const a = await this._blockhashWithExpiryBlockHeight(o);
        if (
          ((t.lastValidBlockHeight = a.lastValidBlockHeight),
          (t.recentBlockhash = a.blockhash),
          t.sign(...i),
          !t.signature)
        )
          throw new Error("!signature");
        const l = t.signature.toString("base64");
        if (this._blockhashInfo.transactionSignatures.includes(l)) o = !0;
        else {
          this._blockhashInfo.transactionSignatures.push(l);
          break;
        }
      }
    }
    const s = t.serialize();
    return await this.sendRawTransaction(s, r);
  }
  async sendRawTransaction(t, n) {
    const r = er(t).toString("base64");
    return await this.sendEncodedTransaction(r, n);
  }
  async sendEncodedTransaction(t, n) {
    const r = { encoding: "base64" },
      i = n && n.skipPreflight,
      s =
        i === !0
          ? "processed"
          : (n && n.preflightCommitment) || this.commitment;
    n && n.maxRetries != null && (r.maxRetries = n.maxRetries),
      n && n.minContextSlot != null && (r.minContextSlot = n.minContextSlot),
      i && (r.skipPreflight = i),
      s && (r.preflightCommitment = s);
    const o = [t, r],
      a = await this._rpcRequest("sendTransaction", o),
      l = yt(a, Fxe);
    if ("error" in l) {
      let c;
      throw (
        ("data" in l.error && (c = l.error.data.logs),
        new Zp({
          action: i ? "send" : "simulate",
          signature: "",
          transactionMessage: l.error.message,
          logs: c,
        }))
      );
    }
    return l.result;
  }
  _wsOnOpen() {
    (this._rpcWebSocketConnected = !0),
      (this._rpcWebSocketHeartbeat = setInterval(() => {
        (async () => {
          try {
            await this._rpcWebSocket.notify("ping");
          } catch {}
        })();
      }, 5e3)),
      this._updateSubscriptions();
  }
  _wsOnError(t) {
    (this._rpcWebSocketConnected = !1), console.error("ws error:", t.message);
  }
  _wsOnClose(t) {
    if (
      ((this._rpcWebSocketConnected = !1),
      (this._rpcWebSocketGeneration =
        (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER),
      this._rpcWebSocketIdleTimeout &&
        (clearTimeout(this._rpcWebSocketIdleTimeout),
        (this._rpcWebSocketIdleTimeout = null)),
      this._rpcWebSocketHeartbeat &&
        (clearInterval(this._rpcWebSocketHeartbeat),
        (this._rpcWebSocketHeartbeat = null)),
      t === 1e3)
    ) {
      this._updateSubscriptions();
      return;
    }
    (this._subscriptionCallbacksByServerSubscriptionId = {}),
      Object.entries(this._subscriptionsByHash).forEach(([n, r]) => {
        this._setSubscription(n, { ...r, state: "pending" });
      });
  }
  _setSubscription(t, n) {
    var i;
    const r = (i = this._subscriptionsByHash[t]) == null ? void 0 : i.state;
    if (((this._subscriptionsByHash[t] = n), r !== n.state)) {
      const s = this._subscriptionStateChangeCallbacksByHash[t];
      s &&
        s.forEach((o) => {
          try {
            o(n.state);
          } catch {}
        });
    }
  }
  _onSubscriptionStateChange(t, n) {
    var s;
    const r = this._subscriptionHashByClientSubscriptionId[t];
    if (r == null) return () => {};
    const i =
      (s = this._subscriptionStateChangeCallbacksByHash)[r] ||
      (s[r] = new Set());
    return (
      i.add(n),
      () => {
        i.delete(n),
          i.size === 0 &&
            delete this._subscriptionStateChangeCallbacksByHash[r];
      }
    );
  }
  async _updateSubscriptions() {
    if (Object.keys(this._subscriptionsByHash).length === 0) {
      this._rpcWebSocketConnected &&
        ((this._rpcWebSocketConnected = !1),
        (this._rpcWebSocketIdleTimeout = setTimeout(() => {
          this._rpcWebSocketIdleTimeout = null;
          try {
            this._rpcWebSocket.close();
          } catch (r) {
            r instanceof Error &&
              console.log(`Error when closing socket connection: ${r.message}`);
          }
        }, 500)));
      return;
    }
    if (
      (this._rpcWebSocketIdleTimeout !== null &&
        (clearTimeout(this._rpcWebSocketIdleTimeout),
        (this._rpcWebSocketIdleTimeout = null),
        (this._rpcWebSocketConnected = !0)),
      !this._rpcWebSocketConnected)
    ) {
      this._rpcWebSocket.connect();
      return;
    }
    const t = this._rpcWebSocketGeneration,
      n = () => t === this._rpcWebSocketGeneration;
    await Promise.all(
      Object.keys(this._subscriptionsByHash).map(async (r) => {
        const i = this._subscriptionsByHash[r];
        if (i !== void 0)
          switch (i.state) {
            case "pending":
            case "unsubscribed":
              if (i.callbacks.size === 0) {
                delete this._subscriptionsByHash[r],
                  i.state === "unsubscribed" &&
                    delete this._subscriptionCallbacksByServerSubscriptionId[
                      i.serverSubscriptionId
                    ],
                  await this._updateSubscriptions();
                return;
              }
              await (async () => {
                const { args: s, method: o } = i;
                try {
                  this._setSubscription(r, { ...i, state: "subscribing" });
                  const a = await this._rpcWebSocket.call(o, s);
                  this._setSubscription(r, {
                    ...i,
                    serverSubscriptionId: a,
                    state: "subscribed",
                  }),
                    (this._subscriptionCallbacksByServerSubscriptionId[a] =
                      i.callbacks),
                    await this._updateSubscriptions();
                } catch (a) {
                  if (
                    (console.error(
                      `Received ${
                        a instanceof Error ? "" : "JSON-RPC "
                      }error calling \`${o}\``,
                      { args: s, error: a }
                    ),
                    !n())
                  )
                    return;
                  this._setSubscription(r, { ...i, state: "pending" }),
                    await this._updateSubscriptions();
                }
              })();
              break;
            case "subscribed":
              i.callbacks.size === 0 &&
                (await (async () => {
                  const { serverSubscriptionId: s, unsubscribeMethod: o } = i;
                  if (this._subscriptionsAutoDisposedByRpc.has(s))
                    this._subscriptionsAutoDisposedByRpc.delete(s);
                  else {
                    this._setSubscription(r, { ...i, state: "unsubscribing" }),
                      this._setSubscription(r, {
                        ...i,
                        state: "unsubscribing",
                      });
                    try {
                      await this._rpcWebSocket.call(o, [s]);
                    } catch (a) {
                      if (
                        (a instanceof Error &&
                          console.error(`${o} error:`, a.message),
                        !n())
                      )
                        return;
                      this._setSubscription(r, { ...i, state: "subscribed" }),
                        await this._updateSubscriptions();
                      return;
                    }
                  }
                  this._setSubscription(r, { ...i, state: "unsubscribed" }),
                    await this._updateSubscriptions();
                })());
              break;
          }
      })
    );
  }
  _handleServerNotification(t, n) {
    const r = this._subscriptionCallbacksByServerSubscriptionId[t];
    r !== void 0 &&
      r.forEach((i) => {
        try {
          i(...n);
        } catch (s) {
          console.error(s);
        }
      });
  }
  _wsOnAccountNotification(t) {
    const { result: n, subscription: r } = yt(t, lxe);
    this._handleServerNotification(r, [n.value, n.context]);
  }
  _makeSubscription(t, n) {
    const r = this._nextClientSubscriptionId++,
      i = QF([t.method, n]),
      s = this._subscriptionsByHash[i];
    return (
      s === void 0
        ? (this._subscriptionsByHash[i] = {
            ...t,
            args: n,
            callbacks: new Set([t.callback]),
            state: "pending",
          })
        : s.callbacks.add(t.callback),
      (this._subscriptionHashByClientSubscriptionId[r] = i),
      (this._subscriptionDisposeFunctionsByClientSubscriptionId[r] =
        async () => {
          delete this._subscriptionDisposeFunctionsByClientSubscriptionId[r],
            delete this._subscriptionHashByClientSubscriptionId[r];
          const o = this._subscriptionsByHash[i];
          Vr(
            o !== void 0,
            `Could not find a \`Subscription\` when tearing down client subscription #${r}`
          ),
            o.callbacks.delete(t.callback),
            await this._updateSubscriptions();
        }),
      this._updateSubscriptions(),
      r
    );
  }
  onAccountChange(t, n, r) {
    const { commitment: i, config: s } = Ri(r),
      o = this._buildArgs(
        [t.toBase58()],
        i || this._commitment || "finalized",
        "base64",
        s
      );
    return this._makeSubscription(
      {
        callback: n,
        method: "accountSubscribe",
        unsubscribeMethod: "accountUnsubscribe",
      },
      o
    );
  }
  async removeAccountChangeListener(t) {
    await this._unsubscribeClientSubscription(t, "account change");
  }
  _wsOnProgramAccountNotification(t) {
    const { result: n, subscription: r } = yt(t, uxe);
    this._handleServerNotification(r, [
      { accountId: n.value.pubkey, accountInfo: n.value.account },
      n.context,
    ]);
  }
  onProgramAccountChange(t, n, r, i) {
    const { commitment: s, config: o } = Ri(r),
      a = this._buildArgs(
        [t.toBase58()],
        s || this._commitment || "finalized",
        "base64",
        o || (i ? { filters: JF(i) } : void 0)
      );
    return this._makeSubscription(
      {
        callback: n,
        method: "programSubscribe",
        unsubscribeMethod: "programUnsubscribe",
      },
      a
    );
  }
  async removeProgramAccountChangeListener(t) {
    await this._unsubscribeClientSubscription(t, "program account change");
  }
  onLogs(t, n, r) {
    const i = this._buildArgs(
      [typeof t == "object" ? { mentions: [t.toString()] } : t],
      r || this._commitment || "finalized"
    );
    return this._makeSubscription(
      {
        callback: n,
        method: "logsSubscribe",
        unsubscribeMethod: "logsUnsubscribe",
      },
      i
    );
  }
  async removeOnLogsListener(t) {
    await this._unsubscribeClientSubscription(t, "logs");
  }
  _wsOnLogsNotification(t) {
    const { result: n, subscription: r } = yt(t, $xe);
    this._handleServerNotification(r, [n.value, n.context]);
  }
  _wsOnSlotNotification(t) {
    const { result: n, subscription: r } = yt(t, fxe);
    this._handleServerNotification(r, [n]);
  }
  onSlotChange(t) {
    return this._makeSubscription(
      {
        callback: t,
        method: "slotSubscribe",
        unsubscribeMethod: "slotUnsubscribe",
      },
      []
    );
  }
  async removeSlotChangeListener(t) {
    await this._unsubscribeClientSubscription(t, "slot change");
  }
  _wsOnSlotUpdatesNotification(t) {
    const { result: n, subscription: r } = yt(t, pxe);
    this._handleServerNotification(r, [n]);
  }
  onSlotUpdate(t) {
    return this._makeSubscription(
      {
        callback: t,
        method: "slotsUpdatesSubscribe",
        unsubscribeMethod: "slotsUpdatesUnsubscribe",
      },
      []
    );
  }
  async removeSlotUpdateListener(t) {
    await this._unsubscribeClientSubscription(t, "slot update");
  }
  async _unsubscribeClientSubscription(t, n) {
    const r = this._subscriptionDisposeFunctionsByClientSubscriptionId[t];
    r
      ? await r()
      : console.warn(
          `Ignored unsubscribe request because an active subscription with id \`${t}\` for '${n}' events could not be found.`
        );
  }
  _buildArgs(t, n, r, i) {
    const s = n || this._commitment;
    if (s || r || i) {
      let o = {};
      r && (o.encoding = r),
        s && (o.commitment = s),
        i && (o = Object.assign(o, i)),
        t.push(o);
    }
    return t;
  }
  _buildArgsAtLeastConfirmed(t, n, r, i) {
    const s = n || this._commitment;
    if (s && !["confirmed", "finalized"].includes(s))
      throw new Error(
        "Using Connection with default commitment: `" +
          this._commitment +
          "`, but method requires at least `confirmed`"
      );
    return this._buildArgs(t, n, r, i);
  }
  _wsOnSignatureNotification(t) {
    const { result: n, subscription: r } = yt(t, mxe);
    n.value !== "receivedSignature" &&
      this._subscriptionsAutoDisposedByRpc.add(r),
      this._handleServerNotification(
        r,
        n.value === "receivedSignature"
          ? [{ type: "received" }, n.context]
          : [{ type: "status", result: n.value }, n.context]
      );
  }
  onSignature(t, n, r) {
    const i = this._buildArgs([t], r || this._commitment || "finalized"),
      s = this._makeSubscription(
        {
          callback: (o, a) => {
            if (o.type === "status") {
              n(o.result, a);
              try {
                this.removeSignatureListener(s);
              } catch {}
            }
          },
          method: "signatureSubscribe",
          unsubscribeMethod: "signatureUnsubscribe",
        },
        i
      );
    return s;
  }
  onSignatureWithOptions(t, n, r) {
    const { commitment: i, ...s } = {
        ...r,
        commitment: (r && r.commitment) || this._commitment || "finalized",
      },
      o = this._buildArgs([t], i, void 0, s),
      a = this._makeSubscription(
        {
          callback: (l, c) => {
            n(l, c);
            try {
              this.removeSignatureListener(a);
            } catch {}
          },
          method: "signatureSubscribe",
          unsubscribeMethod: "signatureUnsubscribe",
        },
        o
      );
    return a;
  }
  async removeSignatureListener(t) {
    await this._unsubscribeClientSubscription(t, "signature result");
  }
  _wsOnRootNotification(t) {
    const { result: n, subscription: r } = yt(t, gxe);
    this._handleServerNotification(r, [n]);
  }
  onRootChange(t) {
    return this._makeSubscription(
      {
        callback: t,
        method: "rootSubscribe",
        unsubscribeMethod: "rootUnsubscribe",
      },
      []
    );
  }
  async removeRootChangeListener(t) {
    await this._unsubscribeClientSubscription(t, "root change");
  }
}
class Cm {
  constructor(t) {
    (this._keypair = void 0), (this._keypair = t ?? qF());
  }
  static generate() {
    return new Cm(qF());
  }
  static fromSecretKey(t, n) {
    if (t.byteLength !== 64) throw new Error("bad secret key size");
    const r = t.slice(32, 64);
    if (!n || !n.skipValidation) {
      const i = t.slice(0, 32),
        s = l5(i);
      for (let o = 0; o < 32; o++)
        if (r[o] !== s[o]) throw new Error("provided secretKey is invalid");
    }
    return new Cm({ publicKey: r, secretKey: t });
  }
  static fromSeed(t) {
    const n = l5(t),
      r = new Uint8Array(64);
    return r.set(t), r.set(n, 32), new Cm({ publicKey: n, secretKey: r });
  }
  get publicKey() {
    return new Pe(this._keypair.publicKey);
  }
  get secretKey() {
    return new Uint8Array(this._keypair.secretKey);
  }
}
const Rf = Object.freeze({
  CreateLookupTable: {
    index: 0,
    layout: Qt([Zt("instruction"), Ty("recentSlot"), Ur("bumpSeed")]),
  },
  FreezeLookupTable: { index: 1, layout: Qt([Zt("instruction")]) },
  ExtendLookupTable: {
    index: 2,
    layout: Qt([Zt("instruction"), Ty(), Fo(gr(), Dp(Zt(), -8), "addresses")]),
  },
  DeactivateLookupTable: { index: 3, layout: Qt([Zt("instruction")]) },
  CloseLookupTable: { index: 4, layout: Qt([Zt("instruction")]) },
});
class Wxe {
  constructor() {}
  static decodeInstructionType(t) {
    this.checkProgramId(t.programId);
    const r = Zt("instruction").decode(t.data);
    let i;
    for (const [s, o] of Object.entries(Rf))
      if (o.index == r) {
        i = s;
        break;
      }
    if (!i)
      throw new Error(
        "Invalid Instruction. Should be a LookupTable Instruction"
      );
    return i;
  }
  static decodeCreateLookupTable(t) {
    this.checkProgramId(t.programId), this.checkKeysLength(t.keys, 4);
    const { recentSlot: n } = ni(Rf.CreateLookupTable, t.data);
    return {
      authority: t.keys[1].pubkey,
      payer: t.keys[2].pubkey,
      recentSlot: Number(n),
    };
  }
  static decodeExtendLookupTable(t) {
    if ((this.checkProgramId(t.programId), t.keys.length < 2))
      throw new Error(
        `invalid instruction; found ${t.keys.length} keys, expected at least 2`
      );
    const { addresses: n } = ni(Rf.ExtendLookupTable, t.data);
    return {
      lookupTable: t.keys[0].pubkey,
      authority: t.keys[1].pubkey,
      payer: t.keys.length > 2 ? t.keys[2].pubkey : void 0,
      addresses: n.map((r) => new Pe(r)),
    };
  }
  static decodeCloseLookupTable(t) {
    return (
      this.checkProgramId(t.programId),
      this.checkKeysLength(t.keys, 3),
      {
        lookupTable: t.keys[0].pubkey,
        authority: t.keys[1].pubkey,
        recipient: t.keys[2].pubkey,
      }
    );
  }
  static decodeFreezeLookupTable(t) {
    return (
      this.checkProgramId(t.programId),
      this.checkKeysLength(t.keys, 2),
      { lookupTable: t.keys[0].pubkey, authority: t.keys[1].pubkey }
    );
  }
  static decodeDeactivateLookupTable(t) {
    return (
      this.checkProgramId(t.programId),
      this.checkKeysLength(t.keys, 2),
      { lookupTable: t.keys[0].pubkey, authority: t.keys[1].pubkey }
    );
  }
  static checkProgramId(t) {
    if (!t.equals(yR.programId))
      throw new Error(
        "invalid instruction; programId is not AddressLookupTable Program"
      );
  }
  static checkKeysLength(t, n) {
    if (t.length < n)
      throw new Error(
        `invalid instruction; found ${t.length} keys, expected at least ${n}`
      );
  }
}
class yR {
  constructor() {}
  static createLookupTable(t) {
    const [n, r] = Pe.findProgramAddressSync(
        [t.authority.toBuffer(), ZZ(BigInt(t.recentSlot), 8)],
        this.programId
      ),
      i = Rf.CreateLookupTable,
      s = Lr(i, { recentSlot: BigInt(t.recentSlot), bumpSeed: r }),
      o = [
        { pubkey: n, isSigner: !1, isWritable: !0 },
        { pubkey: t.authority, isSigner: !0, isWritable: !1 },
        { pubkey: t.payer, isSigner: !0, isWritable: !0 },
        { pubkey: Js.programId, isSigner: !1, isWritable: !1 },
      ];
    return [new yi({ programId: this.programId, keys: o, data: s }), n];
  }
  static freezeLookupTable(t) {
    const n = Rf.FreezeLookupTable,
      r = Lr(n),
      i = [
        { pubkey: t.lookupTable, isSigner: !1, isWritable: !0 },
        { pubkey: t.authority, isSigner: !0, isWritable: !1 },
      ];
    return new yi({ programId: this.programId, keys: i, data: r });
  }
  static extendLookupTable(t) {
    const n = Rf.ExtendLookupTable,
      r = Lr(n, { addresses: t.addresses.map((s) => s.toBytes()) }),
      i = [
        { pubkey: t.lookupTable, isSigner: !1, isWritable: !0 },
        { pubkey: t.authority, isSigner: !0, isWritable: !1 },
      ];
    return (
      t.payer &&
        i.push(
          { pubkey: t.payer, isSigner: !0, isWritable: !0 },
          { pubkey: Js.programId, isSigner: !1, isWritable: !1 }
        ),
      new yi({ programId: this.programId, keys: i, data: r })
    );
  }
  static deactivateLookupTable(t) {
    const n = Rf.DeactivateLookupTable,
      r = Lr(n),
      i = [
        { pubkey: t.lookupTable, isSigner: !1, isWritable: !0 },
        { pubkey: t.authority, isSigner: !0, isWritable: !1 },
      ];
    return new yi({ programId: this.programId, keys: i, data: r });
  }
  static closeLookupTable(t) {
    const n = Rf.CloseLookupTable,
      r = Lr(n),
      i = [
        { pubkey: t.lookupTable, isSigner: !1, isWritable: !0 },
        { pubkey: t.authority, isSigner: !0, isWritable: !1 },
        { pubkey: t.recipient, isSigner: !1, isWritable: !0 },
      ];
    return new yi({ programId: this.programId, keys: i, data: r });
  }
}
yR.programId = new Pe("AddressLookupTab1e1111111111111111111111111");
class Hxe {
  constructor() {}
  static decodeInstructionType(t) {
    this.checkProgramId(t.programId);
    const r = Ur("instruction").decode(t.data);
    let i;
    for (const [s, o] of Object.entries(rd))
      if (o.index == r) {
        i = s;
        break;
      }
    if (!i)
      throw new Error(
        "Instruction type incorrect; not a ComputeBudgetInstruction"
      );
    return i;
  }
  static decodeRequestUnits(t) {
    this.checkProgramId(t.programId);
    const { units: n, additionalFee: r } = ni(rd.RequestUnits, t.data);
    return { units: n, additionalFee: r };
  }
  static decodeRequestHeapFrame(t) {
    this.checkProgramId(t.programId);
    const { bytes: n } = ni(rd.RequestHeapFrame, t.data);
    return { bytes: n };
  }
  static decodeSetComputeUnitLimit(t) {
    this.checkProgramId(t.programId);
    const { units: n } = ni(rd.SetComputeUnitLimit, t.data);
    return { units: n };
  }
  static decodeSetComputeUnitPrice(t) {
    this.checkProgramId(t.programId);
    const { microLamports: n } = ni(rd.SetComputeUnitPrice, t.data);
    return { microLamports: n };
  }
  static checkProgramId(t) {
    if (!t.equals(vR.programId))
      throw new Error(
        "invalid instruction; programId is not ComputeBudgetProgram"
      );
  }
}
const rd = Object.freeze({
  RequestUnits: {
    index: 0,
    layout: Qt([Ur("instruction"), Zt("units"), Zt("additionalFee")]),
  },
  RequestHeapFrame: { index: 1, layout: Qt([Ur("instruction"), Zt("bytes")]) },
  SetComputeUnitLimit: {
    index: 2,
    layout: Qt([Ur("instruction"), Zt("units")]),
  },
  SetComputeUnitPrice: {
    index: 3,
    layout: Qt([Ur("instruction"), Ty("microLamports")]),
  },
});
class vR {
  constructor() {}
  static requestUnits(t) {
    const n = rd.RequestUnits,
      r = Lr(n, t);
    return new yi({ keys: [], programId: this.programId, data: r });
  }
  static requestHeapFrame(t) {
    const n = rd.RequestHeapFrame,
      r = Lr(n, t);
    return new yi({ keys: [], programId: this.programId, data: r });
  }
  static setComputeUnitLimit(t) {
    const n = rd.SetComputeUnitLimit,
      r = Lr(n, t);
    return new yi({ keys: [], programId: this.programId, data: r });
  }
  static setComputeUnitPrice(t) {
    const n = rd.SetComputeUnitPrice,
      r = Lr(n, { microLamports: BigInt(t.microLamports) });
    return new yi({ keys: [], programId: this.programId, data: r });
  }
}
vR.programId = new Pe("ComputeBudget111111111111111111111111111111");
const rU = 64,
  iU = 32,
  sU = 64,
  oU = Qt([
    Ur("numSignatures"),
    Ur("padding"),
    gc("signatureOffset"),
    gc("signatureInstructionIndex"),
    gc("publicKeyOffset"),
    gc("publicKeyInstructionIndex"),
    gc("messageDataOffset"),
    gc("messageDataSize"),
    gc("messageInstructionIndex"),
  ]);
class wx {
  constructor() {}
  static createInstructionWithPublicKey(t) {
    const { publicKey: n, message: r, signature: i, instructionIndex: s } = t;
    Vr(
      n.length === iU,
      `Public Key must be ${iU} bytes but received ${n.length} bytes`
    ),
      Vr(
        i.length === sU,
        `Signature must be ${sU} bytes but received ${i.length} bytes`
      );
    const o = oU.span,
      a = o + n.length,
      l = a + i.length,
      c = 1,
      u = Xt.alloc(l + r.length),
      d = s ?? 65535;
    return (
      oU.encode(
        {
          numSignatures: c,
          padding: 0,
          signatureOffset: a,
          signatureInstructionIndex: d,
          publicKeyOffset: o,
          publicKeyInstructionIndex: d,
          messageDataOffset: l,
          messageDataSize: r.length,
          messageInstructionIndex: d,
        },
        u
      ),
      u.fill(n, o),
      u.fill(i, a),
      u.fill(r, l),
      new yi({ keys: [], programId: wx.programId, data: u })
    );
  }
  static createInstructionWithPrivateKey(t) {
    const { privateKey: n, message: r, instructionIndex: i } = t;
    Vr(
      n.length === rU,
      `Private key must be ${rU} bytes but received ${n.length} bytes`
    );
    try {
      const s = Cm.fromSecretKey(n),
        o = s.publicKey.toBytes(),
        a = lR(r, s.secretKey);
      return this.createInstructionWithPublicKey({
        publicKey: o,
        message: r,
        signature: a,
        instructionIndex: i,
      });
    } catch (s) {
      throw new Error(`Error creating instruction; ${s}`);
    }
  }
}
wx.programId = new Pe("Ed25519SigVerify111111111111111111111111111");
const Vxe = (e, t) => {
  const n = h8.sign(e, t);
  return [n.toCompactRawBytes(), n.recovery];
};
h8.utils.isValidPrivateKey;
const Gxe = h8.getPublicKey,
  aU = 32,
  YA = 20,
  lU = 64,
  qxe = 11,
  ZA = Qt([
    Ur("numSignatures"),
    gc("signatureOffset"),
    Ur("signatureInstructionIndex"),
    gc("ethAddressOffset"),
    Ur("ethAddressInstructionIndex"),
    gc("messageDataOffset"),
    gc("messageDataSize"),
    Ur("messageInstructionIndex"),
    $i(20, "ethAddress"),
    $i(64, "signature"),
    Ur("recoveryId"),
  ]);
class qg {
  constructor() {}
  static publicKeyToEthAddress(t) {
    Vr(
      t.length === lU,
      `Public key must be ${lU} bytes but received ${t.length} bytes`
    );
    try {
      return Xt.from(zF(er(t))).slice(-YA);
    } catch (n) {
      throw new Error(`Error constructing Ethereum address: ${n}`);
    }
  }
  static createInstructionWithPublicKey(t) {
    const {
      publicKey: n,
      message: r,
      signature: i,
      recoveryId: s,
      instructionIndex: o,
    } = t;
    return qg.createInstructionWithEthAddress({
      ethAddress: qg.publicKeyToEthAddress(n),
      message: r,
      signature: i,
      recoveryId: s,
      instructionIndex: o,
    });
  }
  static createInstructionWithEthAddress(t) {
    const {
      ethAddress: n,
      message: r,
      signature: i,
      recoveryId: s,
      instructionIndex: o = 0,
    } = t;
    let a;
    typeof n == "string"
      ? n.startsWith("0x")
        ? (a = Xt.from(n.substr(2), "hex"))
        : (a = Xt.from(n, "hex"))
      : (a = n),
      Vr(
        a.length === YA,
        `Address must be ${YA} bytes but received ${a.length} bytes`
      );
    const l = 1 + qxe,
      c = l,
      u = l + a.length,
      d = u + i.length + 1,
      f = 1,
      h = Xt.alloc(ZA.span + r.length);
    return (
      ZA.encode(
        {
          numSignatures: f,
          signatureOffset: u,
          signatureInstructionIndex: o,
          ethAddressOffset: c,
          ethAddressInstructionIndex: o,
          messageDataOffset: d,
          messageDataSize: r.length,
          messageInstructionIndex: o,
          signature: er(i),
          ethAddress: er(a),
          recoveryId: s,
        },
        h
      ),
      h.fill(er(r), ZA.span),
      new yi({ keys: [], programId: qg.programId, data: h })
    );
  }
  static createInstructionWithPrivateKey(t) {
    const { privateKey: n, message: r, instructionIndex: i } = t;
    Vr(
      n.length === aU,
      `Private key must be ${aU} bytes but received ${n.length} bytes`
    );
    try {
      const s = er(n),
        o = Gxe(s, !1).slice(1),
        a = Xt.from(zF(er(r))),
        [l, c] = Vxe(a, s);
      return this.createInstructionWithPublicKey({
        publicKey: o,
        message: r,
        signature: l,
        recoveryId: c,
        instructionIndex: i,
      });
    } catch (s) {
      throw new Error(`Error creating instruction; ${s}`);
    }
  }
}
qg.programId = new Pe("KeccakSecp256k11111111111111111111111111111");
var RQ;
const OQ = new Pe("StakeConfig11111111111111111111111111111111");
class PQ {
  constructor(t, n) {
    (this.staker = void 0),
      (this.withdrawer = void 0),
      (this.staker = t),
      (this.withdrawer = n);
  }
}
class bx {
  constructor(t, n, r) {
    (this.unixTimestamp = void 0),
      (this.epoch = void 0),
      (this.custodian = void 0),
      (this.unixTimestamp = t),
      (this.epoch = n),
      (this.custodian = r);
  }
}
RQ = bx;
bx.default = new RQ(0, 0, Pe.default);
class Kxe {
  constructor() {}
  static decodeInstructionType(t) {
    this.checkProgramId(t.programId);
    const r = Zt("instruction").decode(t.data);
    let i;
    for (const [s, o] of Object.entries(mo))
      if (o.index == r) {
        i = s;
        break;
      }
    if (!i)
      throw new Error("Instruction type incorrect; not a StakeInstruction");
    return i;
  }
  static decodeInitialize(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 2);
    const { authorized: n, lockup: r } = ni(mo.Initialize, t.data);
    return {
      stakePubkey: t.keys[0].pubkey,
      authorized: new PQ(new Pe(n.staker), new Pe(n.withdrawer)),
      lockup: new bx(r.unixTimestamp, r.epoch, new Pe(r.custodian)),
    };
  }
  static decodeDelegate(t) {
    return (
      this.checkProgramId(t.programId),
      this.checkKeyLength(t.keys, 6),
      ni(mo.Delegate, t.data),
      {
        stakePubkey: t.keys[0].pubkey,
        votePubkey: t.keys[1].pubkey,
        authorizedPubkey: t.keys[5].pubkey,
      }
    );
  }
  static decodeAuthorize(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
    const { newAuthorized: n, stakeAuthorizationType: r } = ni(
        mo.Authorize,
        t.data
      ),
      i = {
        stakePubkey: t.keys[0].pubkey,
        authorizedPubkey: t.keys[2].pubkey,
        newAuthorizedPubkey: new Pe(n),
        stakeAuthorizationType: { index: r },
      };
    return t.keys.length > 3 && (i.custodianPubkey = t.keys[3].pubkey), i;
  }
  static decodeAuthorizeWithSeed(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 2);
    const {
        newAuthorized: n,
        stakeAuthorizationType: r,
        authoritySeed: i,
        authorityOwner: s,
      } = ni(mo.AuthorizeWithSeed, t.data),
      o = {
        stakePubkey: t.keys[0].pubkey,
        authorityBase: t.keys[1].pubkey,
        authoritySeed: i,
        authorityOwner: new Pe(s),
        newAuthorizedPubkey: new Pe(n),
        stakeAuthorizationType: { index: r },
      };
    return t.keys.length > 3 && (o.custodianPubkey = t.keys[3].pubkey), o;
  }
  static decodeSplit(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
    const { lamports: n } = ni(mo.Split, t.data);
    return {
      stakePubkey: t.keys[0].pubkey,
      splitStakePubkey: t.keys[1].pubkey,
      authorizedPubkey: t.keys[2].pubkey,
      lamports: n,
    };
  }
  static decodeMerge(t) {
    return (
      this.checkProgramId(t.programId),
      this.checkKeyLength(t.keys, 3),
      ni(mo.Merge, t.data),
      {
        stakePubkey: t.keys[0].pubkey,
        sourceStakePubKey: t.keys[1].pubkey,
        authorizedPubkey: t.keys[4].pubkey,
      }
    );
  }
  static decodeWithdraw(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 5);
    const { lamports: n } = ni(mo.Withdraw, t.data),
      r = {
        stakePubkey: t.keys[0].pubkey,
        toPubkey: t.keys[1].pubkey,
        authorizedPubkey: t.keys[4].pubkey,
        lamports: n,
      };
    return t.keys.length > 5 && (r.custodianPubkey = t.keys[5].pubkey), r;
  }
  static decodeDeactivate(t) {
    return (
      this.checkProgramId(t.programId),
      this.checkKeyLength(t.keys, 3),
      ni(mo.Deactivate, t.data),
      { stakePubkey: t.keys[0].pubkey, authorizedPubkey: t.keys[2].pubkey }
    );
  }
  static checkProgramId(t) {
    if (!t.equals(b8.programId))
      throw new Error("invalid instruction; programId is not StakeProgram");
  }
  static checkKeyLength(t, n) {
    if (t.length < n)
      throw new Error(
        `invalid instruction; found ${t.length} keys, expected at least ${n}`
      );
  }
}
const mo = Object.freeze({
    Initialize: { index: 0, layout: Qt([Zt("instruction"), Zwe(), Qwe()]) },
    Authorize: {
      index: 1,
      layout: Qt([
        Zt("instruction"),
        gr("newAuthorized"),
        Zt("stakeAuthorizationType"),
      ]),
    },
    Delegate: { index: 2, layout: Qt([Zt("instruction")]) },
    Split: { index: 3, layout: Qt([Zt("instruction"), Tl("lamports")]) },
    Withdraw: { index: 4, layout: Qt([Zt("instruction"), Tl("lamports")]) },
    Deactivate: { index: 5, layout: Qt([Zt("instruction")]) },
    Merge: { index: 7, layout: Qt([Zt("instruction")]) },
    AuthorizeWithSeed: {
      index: 8,
      layout: Qt([
        Zt("instruction"),
        gr("newAuthorized"),
        Zt("stakeAuthorizationType"),
        im("authoritySeed"),
        gr("authorityOwner"),
      ]),
    },
  }),
  Yxe = Object.freeze({ Staker: { index: 0 }, Withdrawer: { index: 1 } });
class b8 {
  constructor() {}
  static initialize(t) {
    const { stakePubkey: n, authorized: r, lockup: i } = t,
      s = i || bx.default,
      o = mo.Initialize,
      a = Lr(o, {
        authorized: {
          staker: er(r.staker.toBuffer()),
          withdrawer: er(r.withdrawer.toBuffer()),
        },
        lockup: {
          unixTimestamp: s.unixTimestamp,
          epoch: s.epoch,
          custodian: er(s.custodian.toBuffer()),
        },
      }),
      l = {
        keys: [
          { pubkey: n, isSigner: !1, isWritable: !0 },
          { pubkey: ky, isSigner: !1, isWritable: !1 },
        ],
        programId: this.programId,
        data: a,
      };
    return new yi(l);
  }
  static createAccountWithSeed(t) {
    const n = new fr();
    n.add(
      Js.createAccountWithSeed({
        fromPubkey: t.fromPubkey,
        newAccountPubkey: t.stakePubkey,
        basePubkey: t.basePubkey,
        seed: t.seed,
        lamports: t.lamports,
        space: this.space,
        programId: this.programId,
      })
    );
    const { stakePubkey: r, authorized: i, lockup: s } = t;
    return n.add(this.initialize({ stakePubkey: r, authorized: i, lockup: s }));
  }
  static createAccount(t) {
    const n = new fr();
    n.add(
      Js.createAccount({
        fromPubkey: t.fromPubkey,
        newAccountPubkey: t.stakePubkey,
        lamports: t.lamports,
        space: this.space,
        programId: this.programId,
      })
    );
    const { stakePubkey: r, authorized: i, lockup: s } = t;
    return n.add(this.initialize({ stakePubkey: r, authorized: i, lockup: s }));
  }
  static delegate(t) {
    const { stakePubkey: n, authorizedPubkey: r, votePubkey: i } = t,
      s = mo.Delegate,
      o = Lr(s);
    return new fr().add({
      keys: [
        { pubkey: n, isSigner: !1, isWritable: !0 },
        { pubkey: i, isSigner: !1, isWritable: !1 },
        { pubkey: Ju, isSigner: !1, isWritable: !1 },
        { pubkey: T4, isSigner: !1, isWritable: !1 },
        { pubkey: OQ, isSigner: !1, isWritable: !1 },
        { pubkey: r, isSigner: !0, isWritable: !1 },
      ],
      programId: this.programId,
      data: o,
    });
  }
  static authorize(t) {
    const {
        stakePubkey: n,
        authorizedPubkey: r,
        newAuthorizedPubkey: i,
        stakeAuthorizationType: s,
        custodianPubkey: o,
      } = t,
      a = mo.Authorize,
      l = Lr(a, {
        newAuthorized: er(i.toBuffer()),
        stakeAuthorizationType: s.index,
      }),
      c = [
        { pubkey: n, isSigner: !1, isWritable: !0 },
        { pubkey: Ju, isSigner: !1, isWritable: !0 },
        { pubkey: r, isSigner: !0, isWritable: !1 },
      ];
    return (
      o && c.push({ pubkey: o, isSigner: !0, isWritable: !1 }),
      new fr().add({ keys: c, programId: this.programId, data: l })
    );
  }
  static authorizeWithSeed(t) {
    const {
        stakePubkey: n,
        authorityBase: r,
        authoritySeed: i,
        authorityOwner: s,
        newAuthorizedPubkey: o,
        stakeAuthorizationType: a,
        custodianPubkey: l,
      } = t,
      c = mo.AuthorizeWithSeed,
      u = Lr(c, {
        newAuthorized: er(o.toBuffer()),
        stakeAuthorizationType: a.index,
        authoritySeed: i,
        authorityOwner: er(s.toBuffer()),
      }),
      d = [
        { pubkey: n, isSigner: !1, isWritable: !0 },
        { pubkey: r, isSigner: !0, isWritable: !1 },
        { pubkey: Ju, isSigner: !1, isWritable: !1 },
      ];
    return (
      l && d.push({ pubkey: l, isSigner: !0, isWritable: !1 }),
      new fr().add({ keys: d, programId: this.programId, data: u })
    );
  }
  static splitInstruction(t) {
    const {
        stakePubkey: n,
        authorizedPubkey: r,
        splitStakePubkey: i,
        lamports: s,
      } = t,
      o = mo.Split,
      a = Lr(o, { lamports: s });
    return new yi({
      keys: [
        { pubkey: n, isSigner: !1, isWritable: !0 },
        { pubkey: i, isSigner: !1, isWritable: !0 },
        { pubkey: r, isSigner: !0, isWritable: !1 },
      ],
      programId: this.programId,
      data: a,
    });
  }
  static split(t, n) {
    const r = new fr();
    return (
      r.add(
        Js.createAccount({
          fromPubkey: t.authorizedPubkey,
          newAccountPubkey: t.splitStakePubkey,
          lamports: n,
          space: this.space,
          programId: this.programId,
        })
      ),
      r.add(this.splitInstruction(t))
    );
  }
  static splitWithSeed(t, n) {
    const {
        stakePubkey: r,
        authorizedPubkey: i,
        splitStakePubkey: s,
        basePubkey: o,
        seed: a,
        lamports: l,
      } = t,
      c = new fr();
    return (
      c.add(
        Js.allocate({
          accountPubkey: s,
          basePubkey: o,
          seed: a,
          space: this.space,
          programId: this.programId,
        })
      ),
      n &&
        n > 0 &&
        c.add(
          Js.transfer({
            fromPubkey: t.authorizedPubkey,
            toPubkey: s,
            lamports: n,
          })
        ),
      c.add(
        this.splitInstruction({
          stakePubkey: r,
          authorizedPubkey: i,
          splitStakePubkey: s,
          lamports: l,
        })
      )
    );
  }
  static merge(t) {
    const { stakePubkey: n, sourceStakePubKey: r, authorizedPubkey: i } = t,
      s = mo.Merge,
      o = Lr(s);
    return new fr().add({
      keys: [
        { pubkey: n, isSigner: !1, isWritable: !0 },
        { pubkey: r, isSigner: !1, isWritable: !0 },
        { pubkey: Ju, isSigner: !1, isWritable: !1 },
        { pubkey: T4, isSigner: !1, isWritable: !1 },
        { pubkey: i, isSigner: !0, isWritable: !1 },
      ],
      programId: this.programId,
      data: o,
    });
  }
  static withdraw(t) {
    const {
        stakePubkey: n,
        authorizedPubkey: r,
        toPubkey: i,
        lamports: s,
        custodianPubkey: o,
      } = t,
      a = mo.Withdraw,
      l = Lr(a, { lamports: s }),
      c = [
        { pubkey: n, isSigner: !1, isWritable: !0 },
        { pubkey: i, isSigner: !1, isWritable: !0 },
        { pubkey: Ju, isSigner: !1, isWritable: !1 },
        { pubkey: T4, isSigner: !1, isWritable: !1 },
        { pubkey: r, isSigner: !0, isWritable: !1 },
      ];
    return (
      o && c.push({ pubkey: o, isSigner: !0, isWritable: !1 }),
      new fr().add({ keys: c, programId: this.programId, data: l })
    );
  }
  static deactivate(t) {
    const { stakePubkey: n, authorizedPubkey: r } = t,
      i = mo.Deactivate,
      s = Lr(i);
    return new fr().add({
      keys: [
        { pubkey: n, isSigner: !1, isWritable: !0 },
        { pubkey: Ju, isSigner: !1, isWritable: !1 },
        { pubkey: r, isSigner: !0, isWritable: !1 },
      ],
      programId: this.programId,
      data: s,
    });
  }
}
b8.programId = new Pe("Stake11111111111111111111111111111111111111");
b8.space = 200;
class LQ {
  constructor(t, n, r, i) {
    (this.nodePubkey = void 0),
      (this.authorizedVoter = void 0),
      (this.authorizedWithdrawer = void 0),
      (this.commission = void 0),
      (this.nodePubkey = t),
      (this.authorizedVoter = n),
      (this.authorizedWithdrawer = r),
      (this.commission = i);
  }
}
class Zxe {
  constructor() {}
  static decodeInstructionType(t) {
    this.checkProgramId(t.programId);
    const r = Zt("instruction").decode(t.data);
    let i;
    for (const [s, o] of Object.entries(id))
      if (o.index == r) {
        i = s;
        break;
      }
    if (!i)
      throw new Error("Instruction type incorrect; not a VoteInstruction");
    return i;
  }
  static decodeInitializeAccount(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 4);
    const { voteInit: n } = ni(id.InitializeAccount, t.data);
    return {
      votePubkey: t.keys[0].pubkey,
      nodePubkey: t.keys[3].pubkey,
      voteInit: new LQ(
        new Pe(n.nodePubkey),
        new Pe(n.authorizedVoter),
        new Pe(n.authorizedWithdrawer),
        n.commission
      ),
    };
  }
  static decodeAuthorize(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
    const { newAuthorized: n, voteAuthorizationType: r } = ni(
      id.Authorize,
      t.data
    );
    return {
      votePubkey: t.keys[0].pubkey,
      authorizedPubkey: t.keys[2].pubkey,
      newAuthorizedPubkey: new Pe(n),
      voteAuthorizationType: { index: r },
    };
  }
  static decodeAuthorizeWithSeed(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
    const {
      voteAuthorizeWithSeedArgs: {
        currentAuthorityDerivedKeyOwnerPubkey: n,
        currentAuthorityDerivedKeySeed: r,
        newAuthorized: i,
        voteAuthorizationType: s,
      },
    } = ni(id.AuthorizeWithSeed, t.data);
    return {
      currentAuthorityDerivedKeyBasePubkey: t.keys[2].pubkey,
      currentAuthorityDerivedKeyOwnerPubkey: new Pe(n),
      currentAuthorityDerivedKeySeed: r,
      newAuthorizedPubkey: new Pe(i),
      voteAuthorizationType: { index: s },
      votePubkey: t.keys[0].pubkey,
    };
  }
  static decodeWithdraw(t) {
    this.checkProgramId(t.programId), this.checkKeyLength(t.keys, 3);
    const { lamports: n } = ni(id.Withdraw, t.data);
    return {
      votePubkey: t.keys[0].pubkey,
      authorizedWithdrawerPubkey: t.keys[2].pubkey,
      lamports: n,
      toPubkey: t.keys[1].pubkey,
    };
  }
  static checkProgramId(t) {
    if (!t.equals(fv.programId))
      throw new Error("invalid instruction; programId is not VoteProgram");
  }
  static checkKeyLength(t, n) {
    if (t.length < n)
      throw new Error(
        `invalid instruction; found ${t.length} keys, expected at least ${n}`
      );
  }
}
const id = Object.freeze({
    InitializeAccount: { index: 0, layout: Qt([Zt("instruction"), Xwe()]) },
    Authorize: {
      index: 1,
      layout: Qt([
        Zt("instruction"),
        gr("newAuthorized"),
        Zt("voteAuthorizationType"),
      ]),
    },
    Withdraw: { index: 3, layout: Qt([Zt("instruction"), Tl("lamports")]) },
    UpdateValidatorIdentity: { index: 4, layout: Qt([Zt("instruction")]) },
    AuthorizeWithSeed: { index: 10, layout: Qt([Zt("instruction"), Jwe()]) },
  }),
  Qxe = Object.freeze({ Voter: { index: 0 }, Withdrawer: { index: 1 } });
class fv {
  constructor() {}
  static initializeAccount(t) {
    const { votePubkey: n, nodePubkey: r, voteInit: i } = t,
      s = id.InitializeAccount,
      o = Lr(s, {
        voteInit: {
          nodePubkey: er(i.nodePubkey.toBuffer()),
          authorizedVoter: er(i.authorizedVoter.toBuffer()),
          authorizedWithdrawer: er(i.authorizedWithdrawer.toBuffer()),
          commission: i.commission,
        },
      }),
      a = {
        keys: [
          { pubkey: n, isSigner: !1, isWritable: !0 },
          { pubkey: ky, isSigner: !1, isWritable: !1 },
          { pubkey: Ju, isSigner: !1, isWritable: !1 },
          { pubkey: r, isSigner: !0, isWritable: !1 },
        ],
        programId: this.programId,
        data: o,
      };
    return new yi(a);
  }
  static createAccount(t) {
    const n = new fr();
    return (
      n.add(
        Js.createAccount({
          fromPubkey: t.fromPubkey,
          newAccountPubkey: t.votePubkey,
          lamports: t.lamports,
          space: this.space,
          programId: this.programId,
        })
      ),
      n.add(
        this.initializeAccount({
          votePubkey: t.votePubkey,
          nodePubkey: t.voteInit.nodePubkey,
          voteInit: t.voteInit,
        })
      )
    );
  }
  static authorize(t) {
    const {
        votePubkey: n,
        authorizedPubkey: r,
        newAuthorizedPubkey: i,
        voteAuthorizationType: s,
      } = t,
      o = id.Authorize,
      a = Lr(o, {
        newAuthorized: er(i.toBuffer()),
        voteAuthorizationType: s.index,
      }),
      l = [
        { pubkey: n, isSigner: !1, isWritable: !0 },
        { pubkey: Ju, isSigner: !1, isWritable: !1 },
        { pubkey: r, isSigner: !0, isWritable: !1 },
      ];
    return new fr().add({ keys: l, programId: this.programId, data: a });
  }
  static authorizeWithSeed(t) {
    const {
        currentAuthorityDerivedKeyBasePubkey: n,
        currentAuthorityDerivedKeyOwnerPubkey: r,
        currentAuthorityDerivedKeySeed: i,
        newAuthorizedPubkey: s,
        voteAuthorizationType: o,
        votePubkey: a,
      } = t,
      l = id.AuthorizeWithSeed,
      c = Lr(l, {
        voteAuthorizeWithSeedArgs: {
          currentAuthorityDerivedKeyOwnerPubkey: er(r.toBuffer()),
          currentAuthorityDerivedKeySeed: i,
          newAuthorized: er(s.toBuffer()),
          voteAuthorizationType: o.index,
        },
      }),
      u = [
        { pubkey: a, isSigner: !1, isWritable: !0 },
        { pubkey: Ju, isSigner: !1, isWritable: !1 },
        { pubkey: n, isSigner: !0, isWritable: !1 },
      ];
    return new fr().add({ keys: u, programId: this.programId, data: c });
  }
  static withdraw(t) {
    const {
        votePubkey: n,
        authorizedWithdrawerPubkey: r,
        lamports: i,
        toPubkey: s,
      } = t,
      o = id.Withdraw,
      a = Lr(o, { lamports: i }),
      l = [
        { pubkey: n, isSigner: !1, isWritable: !0 },
        { pubkey: s, isSigner: !1, isWritable: !0 },
        { pubkey: r, isSigner: !0, isWritable: !1 },
      ];
    return new fr().add({ keys: l, programId: this.programId, data: a });
  }
  static safeWithdraw(t, n, r) {
    if (t.lamports > n - r)
      throw new Error(
        "Withdraw will leave vote account with insufficient funds."
      );
    return fv.withdraw(t);
  }
  static updateValidatorIdentity(t) {
    const { votePubkey: n, authorizedWithdrawerPubkey: r, nodePubkey: i } = t,
      s = id.UpdateValidatorIdentity,
      o = Lr(s),
      a = [
        { pubkey: n, isSigner: !1, isWritable: !0 },
        { pubkey: i, isSigner: !0, isWritable: !1 },
        { pubkey: r, isSigner: !0, isWritable: !1 },
      ];
    return new fr().add({ keys: a, programId: this.programId, data: o });
  }
}
fv.programId = new Pe("Vote111111111111111111111111111111111111111");
fv.space = 3762;
const jQ = new Pe("Va1idator1nfo111111111111111111111111111111"),
  Xxe = tt({
    name: pt(),
    website: An(pt()),
    details: An(pt()),
    iconUrl: An(pt()),
    keybaseUsername: An(pt()),
  });
class wR {
  constructor(t, n) {
    (this.key = void 0), (this.info = void 0), (this.key = t), (this.info = n);
  }
  static fromConfigData(t) {
    let n = [...t];
    if (Ka(n) !== 2) return null;
    const i = [];
    for (let s = 0; s < 2; s++) {
      const o = new Pe(Ya(n, 0, vd)),
        a = nd(n) === 1;
      i.push({ publicKey: o, isSigner: a });
    }
    if (i[0].publicKey.equals(jQ) && i[1].isSigner) {
      const s = im().decode(Xt.from(n)),
        o = JSON.parse(s);
      return QZ(o, Xxe), new wR(i[1].publicKey, o);
    }
    return null;
  }
}
const Jxe = new Pe("Vote111111111111111111111111111111111111111"),
  e3e = Qt([
    gr("nodePubkey"),
    gr("authorizedWithdrawer"),
    Ur("commission"),
    Io(),
    Fo(Qt([Io("slot"), Zt("confirmationCount")]), Dp(Zt(), -8), "votes"),
    Ur("rootSlotValid"),
    Io("rootSlot"),
    Io(),
    Fo(
      Qt([Io("epoch"), gr("authorizedVoter")]),
      Dp(Zt(), -8),
      "authorizedVoters"
    ),
    Qt(
      [
        Fo(
          Qt([
            gr("authorizedPubkey"),
            Io("epochOfLastAuthorizedSwitch"),
            Io("targetEpoch"),
          ]),
          32,
          "buf"
        ),
        Io("idx"),
        Ur("isEmpty"),
      ],
      "priorVoters"
    ),
    Io(),
    Fo(
      Qt([Io("epoch"), Io("credits"), Io("prevCredits")]),
      Dp(Zt(), -8),
      "epochCredits"
    ),
    Qt([Io("slot"), Io("timestamp")], "lastTimestamp"),
  ]);
class bR {
  constructor(t) {
    (this.nodePubkey = void 0),
      (this.authorizedWithdrawer = void 0),
      (this.commission = void 0),
      (this.rootSlot = void 0),
      (this.votes = void 0),
      (this.authorizedVoters = void 0),
      (this.priorVoters = void 0),
      (this.epochCredits = void 0),
      (this.lastTimestamp = void 0),
      (this.nodePubkey = t.nodePubkey),
      (this.authorizedWithdrawer = t.authorizedWithdrawer),
      (this.commission = t.commission),
      (this.rootSlot = t.rootSlot),
      (this.votes = t.votes),
      (this.authorizedVoters = t.authorizedVoters),
      (this.priorVoters = t.priorVoters),
      (this.epochCredits = t.epochCredits),
      (this.lastTimestamp = t.lastTimestamp);
  }
  static fromAccountData(t) {
    const r = e3e.decode(er(t), 4);
    let i = r.rootSlot;
    return (
      r.rootSlotValid || (i = null),
      new bR({
        nodePubkey: new Pe(r.nodePubkey),
        authorizedWithdrawer: new Pe(r.authorizedWithdrawer),
        commission: r.commission,
        votes: r.votes,
        rootSlot: i,
        authorizedVoters: r.authorizedVoters.map(t3e),
        priorVoters: n3e(r.priorVoters),
        epochCredits: r.epochCredits,
        lastTimestamp: r.lastTimestamp,
      })
    );
  }
}
function t3e({ authorizedVoter: e, epoch: t }) {
  return { epoch: t, authorizedVoter: new Pe(e) };
}
function cU({
  authorizedPubkey: e,
  epochOfLastAuthorizedSwitch: t,
  targetEpoch: n,
}) {
  return {
    authorizedPubkey: new Pe(e),
    epochOfLastAuthorizedSwitch: t,
    targetEpoch: n,
  };
}
function n3e({ buf: e, idx: t, isEmpty: n }) {
  return n ? [] : [...e.slice(t + 1).map(cU), ...e.slice(0, t).map(cU)];
}
const uU = {
  http: {
    devnet: "http://api.devnet.solana.com",
    testnet: "http://api.testnet.solana.com",
    "mainnet-beta": "http://api.mainnet-beta.solana.com/",
  },
  https: {
    devnet: "https://api.devnet.solana.com",
    testnet: "https://api.testnet.solana.com",
    "mainnet-beta": "https://api.mainnet-beta.solana.com/",
  },
};
function r3e(e, t) {
  const n = t === !1 ? "http" : "https";
  if (!e) return uU[n].devnet;
  const r = uU[n][e];
  if (!r) throw new Error(`Unknown ${n} cluster: ${e}`);
  return r;
}
async function i3e(e, t, n, r) {
  let i, s;
  (n && Object.prototype.hasOwnProperty.call(n, "lastValidBlockHeight")) ||
  (n && Object.prototype.hasOwnProperty.call(n, "nonceValue"))
    ? ((i = n), (s = r))
    : (s = n);
  const o = s && {
      skipPreflight: s.skipPreflight,
      preflightCommitment: s.preflightCommitment || s.commitment,
      minContextSlot: s.minContextSlot,
    },
    a = await e.sendRawTransaction(t, o),
    l = s && s.commitment,
    u = (await (i ? e.confirmTransaction(i, l) : e.confirmTransaction(a, l)))
      .value;
  if (u.err)
    throw a != null
      ? new Zp({
          action: o != null && o.skipPreflight ? "send" : "simulate",
          signature: a,
          transactionMessage: `Status: (${JSON.stringify(u)})`,
        })
      : new Error(`Raw transaction ${a} failed (${JSON.stringify(u)})`);
  return a;
}
const s3e = 1e9,
  o3e = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        Account: qwe,
        AddressLookupTableAccount: hT,
        AddressLookupTableInstruction: Wxe,
        AddressLookupTableProgram: yR,
        Authorized: PQ,
        BLOCKHASH_CACHE_TIMEOUT_MS: _Q,
        BPF_LOADER_DEPRECATED_PROGRAM_ID: Kwe,
        BPF_LOADER_PROGRAM_ID: pbe,
        BpfLoader: mbe,
        COMPUTE_BUDGET_INSTRUCTION_LAYOUTS: rd,
        ComputeBudgetInstruction: Hxe,
        ComputeBudgetProgram: vR,
        Connection: gR,
        Ed25519Program: wx,
        Enum: Vwe,
        EpochSchedule: bQ,
        FeeCalculatorLayout: vQ,
        Keypair: Cm,
        LAMPORTS_PER_SOL: s3e,
        LOOKUP_TABLE_INSTRUCTION_LAYOUTS: Rf,
        Loader: Gm,
        Lockup: bx,
        MAX_SEED_LENGTH: pQ,
        Message: Au,
        MessageAccountKeys: ob,
        MessageV0: Vm,
        NONCE_ACCOUNT_LENGTH: fT,
        NonceAccount: y8,
        PACKET_DATA_SIZE: Bp,
        PUBLIC_KEY_LENGTH: vd,
        PublicKey: Pe,
        SIGNATURE_LENGTH_IN_BYTES: Ay,
        SOLANA_SCHEMA: yw,
        STAKE_CONFIG_ID: OQ,
        STAKE_INSTRUCTION_LAYOUTS: mo,
        SYSTEM_INSTRUCTION_LAYOUTS: Pi,
        SYSVAR_CLOCK_PUBKEY: Ju,
        SYSVAR_EPOCH_SCHEDULE_PUBKEY: ibe,
        SYSVAR_INSTRUCTIONS_PUBKEY: sbe,
        SYSVAR_RECENT_BLOCKHASHES_PUBKEY: k4,
        SYSVAR_RENT_PUBKEY: ky,
        SYSVAR_REWARDS_PUBKEY: obe,
        SYSVAR_SLOT_HASHES_PUBKEY: abe,
        SYSVAR_SLOT_HISTORY_PUBKEY: lbe,
        SYSVAR_STAKE_HISTORY_PUBKEY: T4,
        Secp256k1Program: qg,
        SendTransactionError: Zp,
        SolanaJSONRPCError: tn,
        SolanaJSONRPCErrorCode: cbe,
        StakeAuthorizationLayout: Yxe,
        StakeInstruction: Kxe,
        StakeProgram: b8,
        Struct: cR,
        SystemInstruction: fbe,
        SystemProgram: Js,
        Transaction: fr,
        TransactionExpiredBlockheightExceededError: uR,
        TransactionExpiredNonceInvalidError: _g,
        TransactionExpiredTimeoutError: dR,
        TransactionInstruction: yi,
        TransactionMessage: fR,
        TransactionStatus: bf,
        VALIDATOR_INFO_KEY: jQ,
        VERSION_PREFIX_MASK: p8,
        VOTE_PROGRAM_ID: Jxe,
        ValidatorInfo: wR,
        VersionedMessage: g8,
        VersionedTransaction: Cy,
        VoteAccount: bR,
        VoteAuthorizationLayout: Qxe,
        VoteInit: LQ,
        VoteInstruction: Zxe,
        VoteProgram: fv,
        clusterApiUrl: r3e,
        sendAndConfirmRawTransaction: i3e,
        sendAndConfirmTransaction: dT,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  DQ = Y.createContext({});
function a3e() {
  return Y.useContext(DQ);
}
const l3e = ({
  children: e,
  endpoint: t,
  config: n = { commitment: "confirmed" },
}) => {
  const r = Y.useMemo(() => new gR(t, n), [t, n]);
  return Ce.createElement(DQ.Provider, { value: { connection: r } }, e);
};
var BQ = { exports: {} };
(function (e) {
  var t = Object.prototype.hasOwnProperty,
    n = "~";
  function r() {}
  Object.create &&
    ((r.prototype = Object.create(null)), new r().__proto__ || (n = !1));
  function i(l, c, u) {
    (this.fn = l), (this.context = c), (this.once = u || !1);
  }
  function s(l, c, u, d, f) {
    if (typeof u != "function")
      throw new TypeError("The listener must be a function");
    var h = new i(u, d || l, f),
      p = n ? n + c : c;
    return (
      l._events[p]
        ? l._events[p].fn
          ? (l._events[p] = [l._events[p], h])
          : l._events[p].push(h)
        : ((l._events[p] = h), l._eventsCount++),
      l
    );
  }
  function o(l, c) {
    --l._eventsCount === 0 ? (l._events = new r()) : delete l._events[c];
  }
  function a() {
    (this._events = new r()), (this._eventsCount = 0);
  }
  (a.prototype.eventNames = function () {
    var c = [],
      u,
      d;
    if (this._eventsCount === 0) return c;
    for (d in (u = this._events)) t.call(u, d) && c.push(n ? d.slice(1) : d);
    return Object.getOwnPropertySymbols
      ? c.concat(Object.getOwnPropertySymbols(u))
      : c;
  }),
    (a.prototype.listeners = function (c) {
      var u = n ? n + c : c,
        d = this._events[u];
      if (!d) return [];
      if (d.fn) return [d.fn];
      for (var f = 0, h = d.length, p = new Array(h); f < h; f++)
        p[f] = d[f].fn;
      return p;
    }),
    (a.prototype.listenerCount = function (c) {
      var u = n ? n + c : c,
        d = this._events[u];
      return d ? (d.fn ? 1 : d.length) : 0;
    }),
    (a.prototype.emit = function (c, u, d, f, h, p) {
      var g = n ? n + c : c;
      if (!this._events[g]) return !1;
      var b = this._events[g],
        v = arguments.length,
        w,
        x;
      if (b.fn) {
        switch ((b.once && this.removeListener(c, b.fn, void 0, !0), v)) {
          case 1:
            return b.fn.call(b.context), !0;
          case 2:
            return b.fn.call(b.context, u), !0;
          case 3:
            return b.fn.call(b.context, u, d), !0;
          case 4:
            return b.fn.call(b.context, u, d, f), !0;
          case 5:
            return b.fn.call(b.context, u, d, f, h), !0;
          case 6:
            return b.fn.call(b.context, u, d, f, h, p), !0;
        }
        for (x = 1, w = new Array(v - 1); x < v; x++) w[x - 1] = arguments[x];
        b.fn.apply(b.context, w);
      } else {
        var S = b.length,
          R;
        for (x = 0; x < S; x++)
          switch (
            (b[x].once && this.removeListener(c, b[x].fn, void 0, !0), v)
          ) {
            case 1:
              b[x].fn.call(b[x].context);
              break;
            case 2:
              b[x].fn.call(b[x].context, u);
              break;
            case 3:
              b[x].fn.call(b[x].context, u, d);
              break;
            case 4:
              b[x].fn.call(b[x].context, u, d, f);
              break;
            default:
              if (!w)
                for (R = 1, w = new Array(v - 1); R < v; R++)
                  w[R - 1] = arguments[R];
              b[x].fn.apply(b[x].context, w);
          }
      }
      return !0;
    }),
    (a.prototype.on = function (c, u, d) {
      return s(this, c, u, d, !1);
    }),
    (a.prototype.once = function (c, u, d) {
      return s(this, c, u, d, !0);
    }),
    (a.prototype.removeListener = function (c, u, d, f) {
      var h = n ? n + c : c;
      if (!this._events[h]) return this;
      if (!u) return o(this, h), this;
      var p = this._events[h];
      if (p.fn)
        p.fn === u && (!f || p.once) && (!d || p.context === d) && o(this, h);
      else {
        for (var g = 0, b = [], v = p.length; g < v; g++)
          (p[g].fn !== u || (f && !p[g].once) || (d && p[g].context !== d)) &&
            b.push(p[g]);
        b.length ? (this._events[h] = b.length === 1 ? b[0] : b) : o(this, h);
      }
      return this;
    }),
    (a.prototype.removeAllListeners = function (c) {
      var u;
      return (
        c
          ? ((u = n ? n + c : c), this._events[u] && o(this, u))
          : ((this._events = new r()), (this._eventsCount = 0)),
        this
      );
    }),
    (a.prototype.off = a.prototype.removeListener),
    (a.prototype.addListener = a.prototype.on),
    (a.prefixed = n),
    (a.EventEmitter = a),
    (e.exports = a);
})(BQ);
var c3e = BQ.exports;
const xR = Gi(c3e);
class Vs extends Error {
  constructor(t, n) {
    super(t), (this.error = n);
  }
}
class _u extends Vs {
  constructor() {
    super(...arguments), (this.name = "WalletNotReadyError");
  }
}
class FQ extends Vs {
  constructor() {
    super(...arguments), (this.name = "WalletLoadError");
  }
}
class sm extends Vs {
  constructor() {
    super(...arguments), (this.name = "WalletConfigError");
  }
}
class ud extends Vs {
  constructor() {
    super(...arguments), (this.name = "WalletConnectionError");
  }
}
class xx extends Vs {
  constructor() {
    super(...arguments), (this.name = "WalletDisconnectedError");
  }
}
class _x extends Vs {
  constructor() {
    super(...arguments), (this.name = "WalletDisconnectionError");
  }
}
class dd extends Vs {
  constructor() {
    super(...arguments), (this.name = "WalletAccountError");
  }
}
class lh extends Vs {
  constructor() {
    super(...arguments), (this.name = "WalletPublicKeyError");
  }
}
class qr extends Vs {
  constructor() {
    super(...arguments), (this.name = "WalletNotConnectedError");
  }
}
class hu extends Vs {
  constructor() {
    super(...arguments), (this.name = "WalletSendTransactionError");
  }
}
class xo extends Vs {
  constructor() {
    super(...arguments), (this.name = "WalletSignTransactionError");
  }
}
class hv extends Vs {
  constructor() {
    super(...arguments), (this.name = "WalletSignMessageError");
  }
}
class dU extends Vs {
  constructor() {
    super(...arguments), (this.name = "WalletSignInError");
  }
}
var hn;
(function (e) {
  (e.Installed = "Installed"),
    (e.NotDetected = "NotDetected"),
    (e.Loadable = "Loadable"),
    (e.Unsupported = "Unsupported");
})(hn || (hn = {}));
class UQ extends xR {
  get connected() {
    return !!this.publicKey;
  }
  async autoConnect() {
    await this.connect();
  }
  async prepareTransaction(t, n, r = {}) {
    const i = this.publicKey;
    if (!i) throw new qr();
    return (
      (t.feePayer = t.feePayer || i),
      (t.recentBlockhash =
        t.recentBlockhash ||
        (
          await n.getLatestBlockhash({
            commitment: r.preflightCommitment,
            minContextSlot: r.minContextSlot,
          })
        ).blockhash),
      t
    );
  }
}
function x8(e) {
  if (typeof window > "u" || typeof document > "u") return;
  const t = [];
  function n() {
    if (e()) for (const s of t) s();
  }
  const r = setInterval(n, 1e3);
  t.push(() => clearInterval(r)),
    document.readyState === "loading" &&
      (document.addEventListener("DOMContentLoaded", n, { once: !0 }),
      t.push(() => document.removeEventListener("DOMContentLoaded", n))),
    document.readyState !== "complete" &&
      (window.addEventListener("load", n, { once: !0 }),
      t.push(() => window.removeEventListener("load", n))),
    n();
}
function yT() {
  if (!navigator) return !1;
  const e = navigator.userAgent.toLowerCase(),
    t = e.includes("iphone") || e.includes("ipad"),
    n = e.includes("safari");
  return t && n;
}
function fd(e) {
  return "version" in e;
}
class u3e extends UQ {
  async sendTransaction(t, n, r = {}) {
    let i = !0;
    try {
      if (fd(t)) {
        if (!this.supportedTransactionVersions)
          throw new hu(
            "Sending versioned transactions isn't supported by this wallet"
          );
        if (!this.supportedTransactionVersions.has(t.version))
          throw new hu(
            `Sending transaction version ${t.version} isn't supported by this wallet`
          );
        try {
          t = await this.signTransaction(t);
          const s = t.serialize();
          return await n.sendRawTransaction(s, r);
        } catch (s) {
          throw s instanceof xo
            ? ((i = !1), s)
            : new hu(s == null ? void 0 : s.message, s);
        }
      } else
        try {
          const { signers: s, ...o } = r;
          (t = await this.prepareTransaction(t, n, o)),
            s != null && s.length && t.partialSign(...s),
            (t = await this.signTransaction(t));
          const a = t.serialize();
          return await n.sendRawTransaction(a, o);
        } catch (s) {
          throw s instanceof xo
            ? ((i = !1), s)
            : new hu(s == null ? void 0 : s.message, s);
        }
    } catch (s) {
      throw (i && this.emit("error", s), s);
    }
  }
  async signAllTransactions(t) {
    for (const r of t)
      if (fd(r)) {
        if (!this.supportedTransactionVersions)
          throw new xo(
            "Signing versioned transactions isn't supported by this wallet"
          );
        if (!this.supportedTransactionVersions.has(r.version))
          throw new xo(
            `Signing transaction version ${r.version} isn't supported by this wallet`
          );
      }
    const n = [];
    for (const r of t) n.push(await this.signTransaction(r));
    return n;
  }
}
class pv extends u3e {}
class d3e extends pv {}
const Of = "solana:signAndSendTransaction",
  QA = "solana:signIn",
  ng = "solana:signMessage",
  go = "solana:signTransaction",
  _R = "standard:connect",
  vT = "standard:disconnect",
  SR = "standard:events";
function f3e(e) {
  return (
    _R in e.features &&
    SR in e.features &&
    (Of in e.features || go in e.features)
  );
}
class fU extends Vs {
  constructor() {
    super(...arguments), (this.name = "WalletNotSelectedError");
  }
}
const h3e = [],
  _8 = {
    autoConnect: !1,
    connecting: !1,
    connected: !1,
    disconnecting: !1,
    select() {
      au("call", "select");
    },
    connect() {
      return Promise.reject(au("call", "connect"));
    },
    disconnect() {
      return Promise.reject(au("call", "disconnect"));
    },
    sendTransaction() {
      return Promise.reject(au("call", "sendTransaction"));
    },
    signTransaction() {
      return Promise.reject(au("call", "signTransaction"));
    },
    signAllTransactions() {
      return Promise.reject(au("call", "signAllTransactions"));
    },
    signMessage() {
      return Promise.reject(au("call", "signMessage"));
    },
    signIn() {
      return Promise.reject(au("call", "signIn"));
    },
  };
Object.defineProperty(_8, "wallets", {
  get() {
    return au("read", "wallets"), h3e;
  },
});
Object.defineProperty(_8, "wallet", {
  get() {
    return au("read", "wallet"), null;
  },
});
Object.defineProperty(_8, "publicKey", {
  get() {
    return au("read", "publicKey"), null;
  },
});
function au(e, t) {
  const n = new Error(
    `You have tried to ${e} "${t}" on a WalletContext without providing one. Make sure to render a WalletProvider as an ancestor of the component that uses WalletContext.`
  );
  return console.error(n), n;
}
const $Q = Y.createContext(_8);
function g1() {
  return Y.useContext($Q);
}
function S8() {
  const { publicKey: e, signTransaction: t, signAllTransactions: n } = g1();
  return Y.useMemo(
    () =>
      e && t && n
        ? { publicKey: e, signTransaction: t, signAllTransactions: n }
        : void 0,
    [e, t, n]
  );
}
function p3e(e, t) {
  const n = Y.useState(() => {
      try {
        const s = localStorage.getItem(e);
        if (s) return JSON.parse(s);
      } catch (s) {
        typeof window < "u" && console.error(s);
      }
      return t;
    }),
    r = n[0],
    i = Y.useRef(!0);
  return (
    Y.useEffect(() => {
      if (i.current) {
        i.current = !1;
        return;
      }
      try {
        r === null
          ? localStorage.removeItem(e)
          : localStorage.setItem(e, JSON.stringify(r));
      } catch (s) {
        typeof window < "u" && console.error(s);
      }
    }, [r, e]),
    n
  );
}
function XA(e) {
  switch (e) {
    case "processed":
    case "confirmed":
    case "finalized":
    case void 0:
      return e;
    case "recent":
      return "processed";
    case "single":
    case "singleGossip":
      return "confirmed";
    case "max":
    case "root":
      return "finalized";
    default:
      return;
  }
}
const wT = "solana:mainnet",
  zQ = "solana:devnet",
  WQ = "solana:testnet",
  m3e = "solana:localnet",
  g3e = "https://api.mainnet-beta.solana.com";
function y3e(e) {
  return e.includes(g3e)
    ? wT
    : /\bdevnet\b/i.test(e)
    ? zQ
    : /\btestnet\b/i.test(e)
    ? WQ
    : /\blocalhost\b/i.test(e) || /\b127\.0\.0\.1\b/.test(e)
    ? m3e
    : wT;
}
function v3e(e) {
  let t = `${e.domain} wants you to sign in with your Solana account:
`;
  (t += `${e.address}`),
    e.statement &&
      (t += `

${e.statement}`);
  const n = [];
  if (
    (e.uri && n.push(`URI: ${e.uri}`),
    e.version && n.push(`Version: ${e.version}`),
    e.chainId && n.push(`Chain ID: ${e.chainId}`),
    e.nonce && n.push(`Nonce: ${e.nonce}`),
    e.issuedAt && n.push(`Issued At: ${e.issuedAt}`),
    e.expirationTime && n.push(`Expiration Time: ${e.expirationTime}`),
    e.notBefore && n.push(`Not Before: ${e.notBefore}`),
    e.requestId && n.push(`Request ID: ${e.requestId}`),
    e.resources)
  ) {
    n.push("Resources:");
    for (const r of e.resources) n.push(`- ${r}`);
  }
  return (
    n.length &&
      (t += `

${n.join(`
`)}`),
    t
  );
}
const ch = {
  ERROR_ASSOCIATION_PORT_OUT_OF_RANGE: "ERROR_ASSOCIATION_PORT_OUT_OF_RANGE",
  ERROR_FORBIDDEN_WALLET_BASE_URL: "ERROR_FORBIDDEN_WALLET_BASE_URL",
  ERROR_SECURE_CONTEXT_REQUIRED: "ERROR_SECURE_CONTEXT_REQUIRED",
  ERROR_SESSION_CLOSED: "ERROR_SESSION_CLOSED",
  ERROR_SESSION_TIMEOUT: "ERROR_SESSION_TIMEOUT",
  ERROR_WALLET_NOT_FOUND: "ERROR_WALLET_NOT_FOUND",
  ERROR_INVALID_PROTOCOL_VERSION: "ERROR_INVALID_PROTOCOL_VERSION",
};
class uh extends Error {
  constructor(...t) {
    const [n, r, i] = t;
    super(r),
      (this.code = n),
      (this.data = i),
      (this.name = "SolanaMobileWalletAdapterError");
  }
}
class HQ extends Error {
  constructor(...t) {
    const [n, r, i, s] = t;
    super(i),
      (this.code = r),
      (this.data = s),
      (this.jsonRpcMessageId = n),
      (this.name = "SolanaMobileWalletAdapterProtocolError");
  }
}
function Xs(e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(u) {
      try {
        c(r.next(u));
      } catch (d) {
        o(d);
      }
    }
    function l(u) {
      try {
        c(r.throw(u));
      } catch (d) {
        o(d);
      }
    }
    function c(u) {
      u.done ? s(u.value) : i(u.value).then(a, l);
    }
    c((r = r.apply(e, [])).next());
  });
}
function w3e(e, t) {
  return Xs(this, void 0, void 0, function* () {
    const n = yield crypto.subtle.exportKey("raw", e),
      r = yield crypto.subtle.sign({ hash: "SHA-256", name: "ECDSA" }, t, n),
      i = new Uint8Array(n.byteLength + r.byteLength);
    return (
      i.set(new Uint8Array(n), 0), i.set(new Uint8Array(r), n.byteLength), i
    );
  });
}
function b3e(e) {
  return window.btoa(e);
}
function x3e(e) {
  return v3e(e);
}
function _3e(e) {
  return b3e(x3e(e));
}
const S3e = "solana:signTransactions",
  hU = "solana:cloneAuthorization";
function E3e(e, t) {
  return new Proxy(
    {},
    {
      get(n, r) {
        return (
          n[r] == null &&
            (n[r] = function (i) {
              return Xs(this, void 0, void 0, function* () {
                const { method: s, params: o } = A3e(r, i, e),
                  a = yield t(s, o);
                return (
                  s === "authorize" &&
                    o.sign_in_payload &&
                    !a.sign_in_result &&
                    (a.sign_in_result = yield k3e(o.sign_in_payload, a, t)),
                  C3e(r, a, e)
                );
              });
            }),
          n[r]
        );
      },
      defineProperty() {
        return !1;
      },
      deleteProperty() {
        return !1;
      },
    }
  );
}
function A3e(e, t, n) {
  let r = t,
    i = e
      .toString()
      .replace(/[A-Z]/g, (s) => `_${s.toLowerCase()}`)
      .toLowerCase();
  switch (e) {
    case "authorize": {
      let { chain: s } = r;
      if (n === "legacy") {
        switch (s) {
          case "solana:testnet": {
            s = "testnet";
            break;
          }
          case "solana:devnet": {
            s = "devnet";
            break;
          }
          case "solana:mainnet": {
            s = "mainnet-beta";
            break;
          }
          default:
            s = r.cluster;
        }
        r.cluster = s;
      } else {
        switch (s) {
          case "testnet":
          case "devnet": {
            s = `solana:${s}`;
            break;
          }
          case "mainnet-beta": {
            s = "solana:mainnet";
            break;
          }
        }
        r.chain = s;
      }
    }
    case "reauthorize": {
      const { auth_token: s, identity: o } = r;
      if (s)
        switch (n) {
          case "legacy": {
            (i = "reauthorize"), (r = { auth_token: s, identity: o });
            break;
          }
          default: {
            i = "authorize";
            break;
          }
        }
      break;
    }
  }
  return { method: i, params: r };
}
function C3e(e, t, n) {
  switch (e) {
    case "getCapabilities": {
      const r = t;
      switch (n) {
        case "legacy": {
          const i = [S3e];
          return (
            r.supports_clone_authorization === !0 && i.push(hU),
            Object.assign(Object.assign({}, r), { features: i })
          );
        }
        case "v1":
          return Object.assign(Object.assign({}, r), {
            supports_sign_and_send_transactions: !0,
            supports_clone_authorization: r.features.includes(hU),
          });
      }
    }
  }
  return t;
}
function k3e(e, t, n) {
  var r;
  return Xs(this, void 0, void 0, function* () {
    const i =
        (r = e.domain) !== null && r !== void 0 ? r : window.location.host,
      s = t.accounts[0].address,
      o = _3e(Object.assign(Object.assign({}, e), { domain: i, address: s })),
      a = yield n("sign_messages", { addresses: [s], payloads: [o] });
    return {
      address: s,
      signed_message: o,
      signature: a.signed_payloads[0].slice(o.length),
    };
  });
}
const om = 4;
function T3e(e) {
  if (e >= 4294967296)
    throw new Error(
      "Outbound sequence number overflow. The maximum sequence number is 32-bytes."
    );
  const t = new ArrayBuffer(om);
  return new DataView(t).setUint32(0, e, !1), new Uint8Array(t);
}
const bT = 12,
  VQ = 65;
function M3e(e, t, n) {
  return Xs(this, void 0, void 0, function* () {
    const r = T3e(t),
      i = new Uint8Array(bT);
    crypto.getRandomValues(i);
    const s = yield crypto.subtle.encrypt(
        qQ(r, i),
        n,
        new TextEncoder().encode(e)
      ),
      o = new Uint8Array(r.byteLength + i.byteLength + s.byteLength);
    return (
      o.set(new Uint8Array(r), 0),
      o.set(new Uint8Array(i), r.byteLength),
      o.set(new Uint8Array(s), r.byteLength + i.byteLength),
      o
    );
  });
}
function GQ(e, t) {
  return Xs(this, void 0, void 0, function* () {
    const n = e.slice(0, om),
      r = e.slice(om, om + bT),
      i = e.slice(om + bT),
      s = yield crypto.subtle.decrypt(qQ(n, r), t, i);
    return I3e().decode(s);
  });
}
function qQ(e, t) {
  return { additionalData: e, iv: t, name: "AES-GCM", tagLength: 128 };
}
let JA;
function I3e() {
  return JA === void 0 && (JA = new TextDecoder("utf-8")), JA;
}
function N3e() {
  return Xs(this, void 0, void 0, function* () {
    return yield crypto.subtle.generateKey(
      { name: "ECDSA", namedCurve: "P-256" },
      !1,
      ["sign"]
    );
  });
}
function R3e() {
  return Xs(this, void 0, void 0, function* () {
    return yield crypto.subtle.generateKey(
      { name: "ECDH", namedCurve: "P-256" },
      !1,
      ["deriveKey", "deriveBits"]
    );
  });
}
function O3e(e, t) {
  return Xs(this, void 0, void 0, function* () {
    const n = JSON.stringify(e),
      r = e.id;
    return M3e(n, r, t);
  });
}
function P3e(e, t) {
  return Xs(this, void 0, void 0, function* () {
    const n = yield GQ(e, t),
      r = JSON.parse(n);
    if (Object.hasOwnProperty.call(r, "error"))
      throw new HQ(r.id, r.error.code, r.error.message);
    return r;
  });
}
function L3e(e, t, n) {
  return Xs(this, void 0, void 0, function* () {
    const [r, i] = yield Promise.all([
        crypto.subtle.exportKey("raw", t),
        crypto.subtle.importKey(
          "raw",
          e.slice(0, VQ),
          { name: "ECDH", namedCurve: "P-256" },
          !1,
          []
        ),
      ]),
      s = yield crypto.subtle.deriveBits({ name: "ECDH", public: i }, n, 256),
      o = yield crypto.subtle.importKey("raw", s, "HKDF", !1, ["deriveKey"]);
    return yield crypto.subtle.deriveKey(
      {
        name: "HKDF",
        hash: "SHA-256",
        salt: new Uint8Array(r),
        info: new Uint8Array(),
      },
      o,
      { name: "AES-GCM", length: 128 },
      !1,
      ["encrypt", "decrypt"]
    );
  });
}
function j3e(e, t) {
  return Xs(this, void 0, void 0, function* () {
    const n = yield GQ(e, t),
      r = JSON.parse(n);
    let i = "legacy";
    if (Object.hasOwnProperty.call(r, "v"))
      switch (r.v) {
        case 1:
        case "1":
        case "v1":
          i = "v1";
          break;
        case "legacy":
          i = "legacy";
          break;
        default:
          throw new uh(
            ch.ERROR_INVALID_PROTOCOL_VERSION,
            `Unknown/unsupported protocol version: ${r.v}`
          );
      }
    return { protocol_version: i };
  });
}
function D3e() {
  return KQ(49152 + Math.floor(Math.random() * 16384));
}
function KQ(e) {
  if (e < 49152 || e > 65535)
    throw new uh(
      ch.ERROR_ASSOCIATION_PORT_OUT_OF_RANGE,
      `Association port number must be between 49152 and 65535. ${e} given.`,
      { port: e }
    );
  return e;
}
function B3e(e) {
  let t = "";
  const n = new Uint8Array(e),
    r = n.byteLength;
  for (let i = 0; i < r; i++) t += String.fromCharCode(n[i]);
  return window.btoa(t);
}
function F3e(e) {
  return e.replace(/[/+=]/g, (t) => ({ "/": "_", "+": "-", "=": "." }[t]));
}
const U3e = "solana-wallet";
function pU(e) {
  return e.replace(/(^\/+|\/+$)/g, "").split("/");
}
function $3e(e, t) {
  let n = null;
  if (t) {
    try {
      n = new URL(t);
    } catch {}
    if ((n == null ? void 0 : n.protocol) !== "https:")
      throw new uh(
        ch.ERROR_FORBIDDEN_WALLET_BASE_URL,
        "Base URLs supplied by wallets must be valid `https` URLs"
      );
  }
  n || (n = new URL(`${U3e}:/`));
  const r = e.startsWith("/") ? e : [...pU(n.pathname), ...pU(e)].join("/");
  return new URL(r, n);
}
function z3e(e, t, n, r = ["v1"]) {
  return Xs(this, void 0, void 0, function* () {
    const i = KQ(t),
      s = yield crypto.subtle.exportKey("raw", e),
      o = B3e(s),
      a = $3e("v1/associate/local", n);
    return (
      a.searchParams.set("association", F3e(o)),
      a.searchParams.set("port", `${i}`),
      r.forEach((l) => {
        a.searchParams.set("v", l);
      }),
      a
    );
  });
}
const u5 = { Firefox: 0, Other: 1 };
function W3e() {
  return navigator.userAgent.indexOf("Firefox/") !== -1 ? u5.Firefox : u5.Other;
}
function H3e() {
  return new Promise((e, t) => {
    function n() {
      clearTimeout(i), window.removeEventListener("blur", r);
    }
    function r() {
      n(), e();
    }
    window.addEventListener("blur", r);
    const i = setTimeout(() => {
      n(), t();
    }, 2e3);
  });
}
let _2 = null;
function V3e(e) {
  _2 == null &&
    ((_2 = document.createElement("iframe")),
    (_2.style.display = "none"),
    document.body.appendChild(_2)),
    (_2.contentWindow.location.href = e.toString());
}
function G3e(e, t) {
  return Xs(this, void 0, void 0, function* () {
    const n = D3e(),
      r = yield z3e(e, n, t);
    if (r.protocol === "https:") window.location.assign(r);
    else
      try {
        const i = W3e();
        switch (i) {
          case u5.Firefox:
            V3e(r);
            break;
          case u5.Other: {
            const s = H3e();
            window.location.assign(r), yield s;
            break;
          }
          default:
        }
      } catch {
        throw new uh(
          ch.ERROR_WALLET_NOT_FOUND,
          "Found no installed wallet that supports the mobile wallet protocol."
        );
      }
    return n;
  });
}
const mU = {
    retryDelayScheduleMs: [150, 150, 200, 500, 500, 750, 750, 1e3],
    timeoutMs: 3e4,
  },
  q3e = "com.solana.mobilewalletadapter.v1";
function K3e() {
  if (typeof window > "u" || window.isSecureContext !== !0)
    throw new uh(
      ch.ERROR_SECURE_CONTEXT_REQUIRED,
      "The mobile wallet adapter protocol must be used in a secure context (`https`)."
    );
}
function Y3e(e) {
  let t;
  try {
    t = new URL(e);
  } catch {
    throw new uh(
      ch.ERROR_FORBIDDEN_WALLET_BASE_URL,
      "Invalid base URL supplied by wallet"
    );
  }
  if (t.protocol !== "https:")
    throw new uh(
      ch.ERROR_FORBIDDEN_WALLET_BASE_URL,
      "Base URLs supplied by wallets must be valid `https` URLs"
    );
}
function gU(e) {
  return new DataView(e).getUint32(0, !1);
}
function Z3e(e, t) {
  return Xs(this, void 0, void 0, function* () {
    K3e();
    const n = yield N3e(),
      r = yield G3e(n.publicKey, t == null ? void 0 : t.baseUri),
      i = `ws://localhost:${r}/solana-wallet`;
    let s;
    const o = (() => {
      const u = [...mU.retryDelayScheduleMs];
      return () => (u.length > 1 ? u.shift() : u[0]);
    })();
    let a = 1,
      l = 0,
      c = { __type: "disconnected" };
    return new Promise((u, d) => {
      let f;
      const h = {},
        p = () =>
          Xs(this, void 0, void 0, function* () {
            if (c.__type !== "connecting") {
              console.warn(
                `Expected adapter state to be \`connecting\` at the moment the websocket opens. Got \`${c.__type}\`.`
              );
              return;
            }
            const { associationKeypair: R } = c;
            f.removeEventListener("open", p);
            const O = yield R3e();
            f.send(yield w3e(O.publicKey, R.privateKey)),
              (c = {
                __type: "hello_req_sent",
                associationPublicKey: R.publicKey,
                ecdhPrivateKey: O.privateKey,
              });
          }),
        g = (R) => {
          R.wasClean
            ? (c = { __type: "disconnected" })
            : d(
                new uh(
                  ch.ERROR_SESSION_CLOSED,
                  `The wallet session dropped unexpectedly (${R.code}: ${R.reason}).`,
                  { closeEvent: R }
                )
              ),
            w();
        },
        b = (R) =>
          Xs(this, void 0, void 0, function* () {
            w(),
              Date.now() - s >= mU.timeoutMs
                ? d(
                    new uh(
                      ch.ERROR_SESSION_TIMEOUT,
                      `Failed to connect to the wallet websocket on port ${r}.`
                    )
                  )
                : (yield new Promise((O) => {
                    const B = o();
                    x = window.setTimeout(O, B);
                  }),
                  S());
          }),
        v = (R) =>
          Xs(this, void 0, void 0, function* () {
            const O = yield R.data.arrayBuffer();
            switch (c.__type) {
              case "connected":
                try {
                  const B = O.slice(0, om),
                    C = gU(B);
                  if (C !== l + 1)
                    throw new Error(
                      "Encrypted message has invalid sequence number"
                    );
                  l = C;
                  const I = yield P3e(O, c.sharedSecret),
                    P = h[I.id];
                  delete h[I.id], P.resolve(I.result);
                } catch (B) {
                  if (B instanceof HQ) {
                    const C = h[B.jsonRpcMessageId];
                    delete h[B.jsonRpcMessageId], C.reject(B);
                  } else throw B;
                }
                break;
              case "hello_req_sent": {
                const B = yield L3e(
                    O,
                    c.associationPublicKey,
                    c.ecdhPrivateKey
                  ),
                  C = O.slice(VQ),
                  I =
                    C.byteLength !== 0
                      ? yield Xs(this, void 0, void 0, function* () {
                          const M = C.slice(0, om),
                            k = gU(M);
                          if (k !== l + 1)
                            throw new Error(
                              "Encrypted message has invalid sequence number"
                            );
                          return (l = k), j3e(C, B);
                        })
                      : { protocol_version: "legacy" };
                c = {
                  __type: "connected",
                  sharedSecret: B,
                  sessionProperties: I,
                };
                const P = E3e(I.protocol_version, (M, k) =>
                  Xs(this, void 0, void 0, function* () {
                    const T = a++;
                    return (
                      f.send(
                        yield O3e(
                          { id: T, jsonrpc: "2.0", method: M, params: k ?? {} },
                          B
                        )
                      ),
                      new Promise((_, A) => {
                        h[T] = {
                          resolve(N) {
                            switch (M) {
                              case "authorize":
                              case "reauthorize": {
                                const { wallet_uri_base: L } = N;
                                if (L != null)
                                  try {
                                    Y3e(L);
                                  } catch (F) {
                                    A(F);
                                    return;
                                  }
                                break;
                              }
                            }
                            _(N);
                          },
                          reject: A,
                        };
                      })
                    );
                  })
                );
                try {
                  u(yield e(P));
                } catch (M) {
                  d(M);
                } finally {
                  w(), f.close();
                }
                break;
              }
            }
          });
      let w, x;
      const S = () => {
        w && w(),
          (c = { __type: "connecting", associationKeypair: n }),
          s === void 0 && (s = Date.now()),
          (f = new WebSocket(i, [q3e])),
          f.addEventListener("open", p),
          f.addEventListener("close", g),
          f.addEventListener("error", b),
          f.addEventListener("message", v),
          (w = () => {
            window.clearTimeout(x),
              f.removeEventListener("open", p),
              f.removeEventListener("close", g),
              f.removeEventListener("error", b),
              f.removeEventListener("message", v);
          });
      };
      S();
    });
  });
}
function Q3e(e) {
  if (e.length >= 255) throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), n = 0; n < t.length; n++) t[n] = 255;
  for (var r = 0; r < e.length; r++) {
    var i = e.charAt(r),
      s = i.charCodeAt(0);
    if (t[s] !== 255) throw new TypeError(i + " is ambiguous");
    t[s] = r;
  }
  var o = e.length,
    a = e.charAt(0),
    l = Math.log(o) / Math.log(256),
    c = Math.log(256) / Math.log(o);
  function u(h) {
    if (
      (h instanceof Uint8Array ||
        (ArrayBuffer.isView(h)
          ? (h = new Uint8Array(h.buffer, h.byteOffset, h.byteLength))
          : Array.isArray(h) && (h = Uint8Array.from(h))),
      !(h instanceof Uint8Array))
    )
      throw new TypeError("Expected Uint8Array");
    if (h.length === 0) return "";
    for (var p = 0, g = 0, b = 0, v = h.length; b !== v && h[b] === 0; )
      b++, p++;
    for (var w = ((v - b) * c + 1) >>> 0, x = new Uint8Array(w); b !== v; ) {
      for (
        var S = h[b], R = 0, O = w - 1;
        (S !== 0 || R < g) && O !== -1;
        O--, R++
      )
        (S += (256 * x[O]) >>> 0), (x[O] = S % o >>> 0), (S = (S / o) >>> 0);
      if (S !== 0) throw new Error("Non-zero carry");
      (g = R), b++;
    }
    for (var B = w - g; B !== w && x[B] === 0; ) B++;
    for (var C = a.repeat(p); B < w; ++B) C += e.charAt(x[B]);
    return C;
  }
  function d(h) {
    if (typeof h != "string") throw new TypeError("Expected String");
    if (h.length === 0) return new Uint8Array();
    for (var p = 0, g = 0, b = 0; h[p] === a; ) g++, p++;
    for (
      var v = ((h.length - p) * l + 1) >>> 0, w = new Uint8Array(v);
      h[p];

    ) {
      var x = t[h.charCodeAt(p)];
      if (x === 255) return;
      for (var S = 0, R = v - 1; (x !== 0 || S < b) && R !== -1; R--, S++)
        (x += (o * w[R]) >>> 0), (w[R] = x % 256 >>> 0), (x = (x / 256) >>> 0);
      if (x !== 0) throw new Error("Non-zero carry");
      (b = S), p++;
    }
    for (var O = v - b; O !== v && w[O] === 0; ) O++;
    for (var B = new Uint8Array(g + (v - O)), C = g; O !== v; ) B[C++] = w[O++];
    return B;
  }
  function f(h) {
    var p = d(h);
    if (p) return p;
    throw new Error("Non-base" + o + " character");
  }
  return { encode: u, decodeUnsafe: d, decode: f };
}
var X3e = Q3e;
const J3e = X3e,
  e_e = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var t_e = J3e(e_e);
const n_e = Gi(t_e);
function eC(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) &&
      t.indexOf(r) < 0 &&
      (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(e, r[i]) &&
        (n[r[i]] = e[r[i]]);
  return n;
}
function k_(e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(u) {
      try {
        c(r.next(u));
      } catch (d) {
        o(d);
      }
    }
    function l(u) {
      try {
        c(r.throw(u));
      } catch (d) {
        o(d);
      }
    }
    function c(u) {
      u.done ? s(u.value) : i(u.value).then(a, l);
    }
    c((r = r.apply(e, [])).next());
  });
}
function YQ(e) {
  return window.btoa(String.fromCharCode.call(null, ...e));
}
function tC(e) {
  return new Uint8Array(
    window
      .atob(e)
      .split("")
      .map((t) => t.charCodeAt(0))
  );
}
function yU(e) {
  const t =
    "version" in e
      ? e.serialize()
      : e.serialize({ requireAllSignatures: !1, verifySignatures: !1 });
  return YQ(t);
}
function r_e(e) {
  const n = e[0] * Ay + 1;
  return g8.deserializeMessageVersion(e.slice(n, e.length)) === "legacy"
    ? fr.from(e)
    : Cy.deserialize(e);
}
function i_e(e, t) {
  return k_(this, void 0, void 0, function* () {
    return yield Z3e((r) => {
      const i = new Proxy(
        {},
        {
          get(s, o) {
            if (s[o] == null)
              switch (o) {
                case "signAndSendTransactions":
                  s[o] = function (a) {
                    var {
                        minContextSlot: l,
                        commitment: c,
                        skipPreflight: u,
                        maxRetries: d,
                        waitForCommitmentToSendNextTransaction: f,
                        transactions: h,
                      } = a,
                      p = eC(a, [
                        "minContextSlot",
                        "commitment",
                        "skipPreflight",
                        "maxRetries",
                        "waitForCommitmentToSendNextTransaction",
                        "transactions",
                      ]);
                    return k_(this, void 0, void 0, function* () {
                      const g = h.map(yU),
                        b = {
                          min_context_slot: l,
                          commitment: c,
                          skip_preflight: u,
                          max_retries: d,
                          wait_for_commitment_to_send_next_transaction: f,
                        },
                        { signatures: v } = yield r.signAndSendTransactions(
                          Object.assign(
                            Object.assign(
                              Object.assign({}, p),
                              Object.values(b).some((x) => x != null)
                                ? { options: b }
                                : null
                            ),
                            { payloads: g }
                          )
                        );
                      return v.map(tC).map(n_e.encode);
                    });
                  };
                  break;
                case "signMessages":
                  s[o] = function (a) {
                    var { payloads: l } = a,
                      c = eC(a, ["payloads"]);
                    return k_(this, void 0, void 0, function* () {
                      const u = l.map(YQ),
                        { signed_payloads: d } = yield r.signMessages(
                          Object.assign(Object.assign({}, c), { payloads: u })
                        );
                      return d.map(tC);
                    });
                  };
                  break;
                case "signTransactions":
                  s[o] = function (a) {
                    var { transactions: l } = a,
                      c = eC(a, ["transactions"]);
                    return k_(this, void 0, void 0, function* () {
                      const u = l.map(yU),
                        { signed_payloads: d } = yield r.signTransactions(
                          Object.assign(Object.assign({}, c), { payloads: u })
                        );
                      return d.map(tC).map(r_e);
                    });
                  };
                  break;
                default: {
                  s[o] = r[o];
                  break;
                }
              }
            return s[o];
          },
          defineProperty() {
            return !1;
          },
          deleteProperty() {
            return !1;
          },
        }
      );
      return e(i);
    }, t);
  });
}
function Wr(e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(u) {
      try {
        c(r.next(u));
      } catch (d) {
        o(d);
      }
    }
    function l(u) {
      try {
        c(r.throw(u));
      } catch (d) {
        o(d);
      }
    }
    function c(u) {
      u.done ? s(u.value) : i(u.value).then(a, l);
    }
    c((r = r.apply(e, [])).next());
  });
}
function M4(e) {
  return new Uint8Array(
    window
      .atob(e)
      .split("")
      .map((t) => t.charCodeAt(0))
  );
}
function s_e() {
  return (
    typeof window < "u" &&
    window.isSecureContext &&
    typeof document < "u" &&
    /android/i.test(navigator.userAgent)
  );
}
const up = "Mobile Wallet Adapter",
  o_e = 64;
function a_e(e) {
  const t = M4(e);
  return new Pe(t);
}
function vU(e) {
  return "version" in e;
}
class l_e extends d3e {
  constructor(t) {
    var n;
    super(),
      (this.supportedTransactionVersions = new Set(["legacy", 0])),
      (this.name = up),
      (this.url = "https://solanamobile.com/wallets"),
      (this.icon =
        "data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjI4IiB3aWR0aD0iMjgiIHZpZXdCb3g9Ii0zIDAgMjggMjgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iI0RDQjhGRiI+PHBhdGggZD0iTTE3LjQgMTcuNEgxNXYyLjRoMi40di0yLjRabTEuMi05LjZoLTIuNHYyLjRoMi40VjcuOFoiLz48cGF0aCBkPSJNMjEuNiAzVjBoLTIuNHYzaC0zLjZWMGgtMi40djNoLTIuNHY2LjZINC41YTIuMSAyLjEgMCAxIDEgMC00LjJoMi43VjNINC41QTQuNSA0LjUgMCAwIDAgMCA3LjVWMjRoMjEuNnYtNi42aC0yLjR2NC4ySDIuNFYxMS41Yy41LjMgMS4yLjQgMS44LjVoNy41QTYuNiA2LjYgMCAwIDAgMjQgOVYzaC0yLjRabTAgNS43YTQuMiA0LjIgMCAxIDEtOC40IDBWNS40aDguNHYzLjNaIi8+PC9nPjwvc3ZnPg=="),
      (this._connecting = !1),
      (this._connectionGeneration = 0),
      (this._readyState = s_e() ? hn.Loadable : hn.Unsupported),
      (this._authorizationResultCache = t.authorizationResultCache),
      (this._addressSelector = t.addressSelector),
      (this._appIdentity = t.appIdentity),
      (this._chain = (n = t.chain) !== null && n !== void 0 ? n : t.cluster),
      (this._onWalletNotFound = t.onWalletNotFound),
      this._readyState !== hn.Unsupported &&
        this._authorizationResultCache.get().then((r) => {
          r && this.declareWalletAsInstalled();
        });
  }
  get publicKey() {
    if (this._publicKey == null && this._selectedAddress != null)
      try {
        this._publicKey = a_e(this._selectedAddress);
      } catch (t) {
        throw new lh(
          (t instanceof Error && (t == null ? void 0 : t.message)) ||
            "Unknown error",
          t
        );
      }
    return this._publicKey ? this._publicKey : null;
  }
  get connected() {
    return !!this._authorizationResult;
  }
  get connecting() {
    return this._connecting;
  }
  get readyState() {
    return this._readyState;
  }
  declareWalletAsInstalled() {
    this._readyState !== hn.Installed &&
      this.emit("readyStateChange", (this._readyState = hn.Installed));
  }
  runWithGuard(t) {
    return Wr(this, void 0, void 0, function* () {
      try {
        return yield t();
      } catch (n) {
        throw (this.emit("error", n), n);
      }
    });
  }
  autoConnect_DO_NOT_USE_OR_YOU_WILL_BE_FIRED() {
    return Wr(this, void 0, void 0, function* () {
      return yield this.autoConnect();
    });
  }
  autoConnect() {
    return Wr(this, void 0, void 0, function* () {
      if (!(this.connecting || this.connected))
        return yield this.runWithGuard(() =>
          Wr(this, void 0, void 0, function* () {
            if (
              this._readyState !== hn.Installed &&
              this._readyState !== hn.Loadable
            )
              throw new _u();
            this._connecting = !0;
            try {
              const t = yield this._authorizationResultCache.get();
              t && this.handleAuthorizationResult(t);
            } catch (t) {
              throw new ud(
                (t instanceof Error && t.message) || "Unknown error",
                t
              );
            } finally {
              this._connecting = !1;
            }
          })
        );
    });
  }
  connect() {
    return Wr(this, void 0, void 0, function* () {
      if (!(this.connecting || this.connected))
        return yield this.runWithGuard(() =>
          Wr(this, void 0, void 0, function* () {
            if (
              this._readyState !== hn.Installed &&
              this._readyState !== hn.Loadable
            )
              throw new _u();
            this._connecting = !0;
            try {
              yield this.performAuthorization();
            } catch (t) {
              throw new ud(
                (t instanceof Error && t.message) || "Unknown error",
                t
              );
            } finally {
              this._connecting = !1;
            }
          })
        );
    });
  }
  performAuthorization(t) {
    return Wr(this, void 0, void 0, function* () {
      try {
        const n = yield this._authorizationResultCache.get();
        return n
          ? (this.handleAuthorizationResult(n), n)
          : yield this.transact((r) =>
              Wr(this, void 0, void 0, function* () {
                const i = yield r.authorize({
                  chain: this._chain,
                  identity: this._appIdentity,
                  sign_in_payload: t,
                });
                return (
                  Promise.all([
                    this._authorizationResultCache.set(i),
                    this.handleAuthorizationResult(i),
                  ]),
                  i
                );
              })
            );
      } catch (n) {
        throw new ud((n instanceof Error && n.message) || "Unknown error", n);
      }
    });
  }
  handleAuthorizationResult(t) {
    var n;
    return Wr(this, void 0, void 0, function* () {
      const r =
        this._authorizationResult == null ||
        ((n = this._authorizationResult) === null || n === void 0
          ? void 0
          : n.accounts.length) !== t.accounts.length ||
        this._authorizationResult.accounts.some(
          (i, s) => i.address !== t.accounts[s].address
        );
      if (
        ((this._authorizationResult = t), this.declareWalletAsInstalled(), r)
      ) {
        const i = yield this._addressSelector.select(
          t.accounts.map(({ address: s }) => s)
        );
        i !== this._selectedAddress &&
          ((this._selectedAddress = i),
          delete this._publicKey,
          this.emit("connect", this.publicKey));
      }
    });
  }
  performReauthorization(t, n) {
    return Wr(this, void 0, void 0, function* () {
      try {
        const r = yield t.authorize({
          auth_token: n,
          identity: this._appIdentity,
        });
        Promise.all([
          this._authorizationResultCache.set(r),
          this.handleAuthorizationResult(r),
        ]);
      } catch (r) {
        throw (
          (this.disconnect(),
          new xx(
            (r instanceof Error && (r == null ? void 0 : r.message)) ||
              "Unknown error",
            r
          ))
        );
      }
    });
  }
  disconnect() {
    return Wr(this, void 0, void 0, function* () {
      this._authorizationResultCache.clear(),
        (this._connecting = !1),
        this._connectionGeneration++,
        delete this._authorizationResult,
        delete this._publicKey,
        delete this._selectedAddress,
        this.emit("disconnect");
    });
  }
  transact(t) {
    var n;
    return Wr(this, void 0, void 0, function* () {
      const r =
          (n = this._authorizationResult) === null || n === void 0
            ? void 0
            : n.wallet_uri_base,
        i = r ? { baseUri: r } : void 0,
        s = this._connectionGeneration;
      try {
        return yield i_e(t, i);
      } catch (o) {
        throw (
          (this._connectionGeneration !== s && (yield new Promise(() => {})),
          o instanceof Error &&
            o.name === "SolanaMobileWalletAdapterError" &&
            o.code === "ERROR_WALLET_NOT_FOUND" &&
            (yield this._onWalletNotFound(this)),
          o)
        );
      }
    });
  }
  assertIsAuthorized() {
    if (!this._authorizationResult || !this._selectedAddress) throw new qr();
    return {
      authToken: this._authorizationResult.auth_token,
      selectedAddress: this._selectedAddress,
    };
  }
  performSignTransactions(t) {
    return Wr(this, void 0, void 0, function* () {
      const { authToken: n } = this.assertIsAuthorized();
      try {
        return yield this.transact((r) =>
          Wr(this, void 0, void 0, function* () {
            return (
              yield this.performReauthorization(r, n),
              yield r.signTransactions({ transactions: t })
            );
          })
        );
      } catch (r) {
        throw new xo(r == null ? void 0 : r.message, r);
      }
    });
  }
  sendTransaction(t, n, r) {
    return Wr(this, void 0, void 0, function* () {
      return yield this.runWithGuard(() =>
        Wr(this, void 0, void 0, function* () {
          const { authToken: i } = this.assertIsAuthorized(),
            s = r == null ? void 0 : r.minContextSlot;
          try {
            return yield this.transact((o) =>
              Wr(this, void 0, void 0, function* () {
                function a() {
                  let d;
                  switch (n.commitment) {
                    case "confirmed":
                    case "finalized":
                    case "processed":
                      d = n.commitment;
                      break;
                    default:
                      d = "finalized";
                  }
                  let f;
                  switch (r == null ? void 0 : r.preflightCommitment) {
                    case "confirmed":
                    case "finalized":
                    case "processed":
                      f = r.preflightCommitment;
                      break;
                    case void 0:
                      f = d;
                      break;
                    default:
                      f = "finalized";
                  }
                  return (f === "finalized" ? 2 : f === "confirmed" ? 1 : 0) <
                    (d === "finalized" ? 2 : d === "confirmed" ? 1 : 0)
                    ? f
                    : d;
                }
                const [l, c, u] = yield Promise.all([
                  o.getCapabilities(),
                  this.performReauthorization(o, i),
                  vU(t)
                    ? null
                    : Wr(this, void 0, void 0, function* () {
                        var d;
                        if (
                          (t.feePayer ||
                            (t.feePayer =
                              (d = this.publicKey) !== null && d !== void 0
                                ? d
                                : void 0),
                          t.recentBlockhash == null)
                        ) {
                          const { blockhash: f } = yield n.getLatestBlockhash({
                            commitment: a(),
                          });
                          t.recentBlockhash = f;
                        }
                      }),
                ]);
                if (l.supports_sign_and_send_transactions)
                  return (yield o.signAndSendTransactions({
                    minContextSlot: s,
                    transactions: [t],
                  }))[0];
                {
                  const [d] = yield o.signTransactions({ transactions: [t] });
                  if (vU(d)) return yield n.sendTransaction(d);
                  {
                    const f = d.serialize();
                    return yield n.sendRawTransaction(
                      f,
                      Object.assign(Object.assign({}, r), {
                        preflightCommitment: a(),
                      })
                    );
                  }
                }
              })
            );
          } catch (o) {
            throw new hu(o == null ? void 0 : o.message, o);
          }
        })
      );
    });
  }
  signTransaction(t) {
    return Wr(this, void 0, void 0, function* () {
      return yield this.runWithGuard(() =>
        Wr(this, void 0, void 0, function* () {
          const [n] = yield this.performSignTransactions([t]);
          return n;
        })
      );
    });
  }
  signAllTransactions(t) {
    return Wr(this, void 0, void 0, function* () {
      return yield this.runWithGuard(() =>
        Wr(this, void 0, void 0, function* () {
          return yield this.performSignTransactions(t);
        })
      );
    });
  }
  signMessage(t) {
    return Wr(this, void 0, void 0, function* () {
      return yield this.runWithGuard(() =>
        Wr(this, void 0, void 0, function* () {
          const { authToken: n, selectedAddress: r } =
            this.assertIsAuthorized();
          try {
            return yield this.transact((i) =>
              Wr(this, void 0, void 0, function* () {
                yield this.performReauthorization(i, n);
                const [s] = yield i.signMessages({
                  addresses: [r],
                  payloads: [t],
                });
                return s.slice(-o_e);
              })
            );
          } catch (i) {
            throw new hv(i == null ? void 0 : i.message, i);
          }
        })
      );
    });
  }
  signIn(t) {
    return Wr(this, void 0, void 0, function* () {
      return yield this.runWithGuard(() =>
        Wr(this, void 0, void 0, function* () {
          var n, r;
          if (
            this._readyState !== hn.Installed &&
            this._readyState !== hn.Loadable
          )
            throw new _u();
          this._connecting = !0;
          try {
            const i = yield this.performAuthorization(
              Object.assign(Object.assign({}, t), {
                domain:
                  (n = t == null ? void 0 : t.domain) !== null && n !== void 0
                    ? n
                    : window.location.host,
              })
            );
            if (!i.sign_in_result)
              throw new Error(
                "Sign in failed, no sign in result returned by wallet"
              );
            const s = i.sign_in_result.address;
            return {
              account: Object.assign(
                Object.assign(
                  {},
                  (r = i.accounts.find((a) => a.address == s)) !== null &&
                    r !== void 0
                    ? r
                    : { address: s }
                ),
                { publicKey: M4(s) }
              ),
              signedMessage: M4(i.sign_in_result.signed_message),
              signature: M4(i.sign_in_result.signature),
            };
          } catch (i) {
            throw new ud(
              (i instanceof Error && i.message) || "Unknown error",
              i
            );
          } finally {
            this._connecting = !1;
          }
        })
      );
    });
  }
}
function c_e() {
  return {
    select(e) {
      return Wr(this, void 0, void 0, function* () {
        return e[0];
      });
    },
  };
}
const nC = "SolanaMobileWalletAdapterDefaultAuthorizationCache";
function u_e() {
  let e;
  try {
    e = window.localStorage;
  } catch {}
  return {
    clear() {
      return Wr(this, void 0, void 0, function* () {
        if (e)
          try {
            e.removeItem(nC);
          } catch {}
      });
    },
    get() {
      return Wr(this, void 0, void 0, function* () {
        if (e)
          try {
            return JSON.parse(e.getItem(nC)) || void 0;
          } catch {}
      });
    },
    set(t) {
      return Wr(this, void 0, void 0, function* () {
        if (e)
          try {
            e.setItem(nC, JSON.stringify(t));
          } catch {}
      });
    },
  };
}
function d_e(e) {
  return Wr(this, void 0, void 0, function* () {
    typeof window < "u" && window.location.assign(e.url);
  });
}
function f_e() {
  return d_e;
}
var h_e = function (e, t, n, r, i) {
    if (r === "m") throw new TypeError("Private method is not writable");
    if (r === "a" && !i)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof t == "function" ? e !== t || !i : !t.has(e))
      throw new TypeError(
        "Cannot write private member to an object whose class did not declare it"
      );
    return r === "a" ? i.call(e, n) : i ? (i.value = n) : t.set(e, n), n;
  },
  p_e = function (e, t, n, r) {
    if (n === "a" && !r)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof t == "function" ? e !== t || !r : !t.has(e))
      throw new TypeError(
        "Cannot read private member from an object whose class did not declare it"
      );
    return n === "m" ? r : n === "a" ? r.call(e) : r ? r.value : t.get(e);
  },
  I4;
function m_e(e) {
  const t = ({ register: n }) => n(e);
  try {
    window.dispatchEvent(new g_e(t));
  } catch (n) {
    console.error(
      `wallet-standard:register-wallet event could not be dispatched
`,
      n
    );
  }
  try {
    window.addEventListener("wallet-standard:app-ready", ({ detail: n }) =>
      t(n)
    );
  } catch (n) {
    console.error(
      `wallet-standard:app-ready event listener could not be added
`,
      n
    );
  }
}
class g_e extends Event {
  constructor(t) {
    super("wallet-standard:register-wallet", {
      bubbles: !1,
      cancelable: !1,
      composed: !1,
    }),
      I4.set(this, void 0),
      h_e(this, I4, t, "f");
  }
  get detail() {
    return p_e(this, I4, "f");
  }
  get type() {
    return "wallet-standard:register-wallet";
  }
  preventDefault() {
    throw new Error("preventDefault cannot be called");
  }
  stopImmediatePropagation() {
    throw new Error("stopImmediatePropagation cannot be called");
  }
  stopPropagation() {
    throw new Error("stopPropagation cannot be called");
  }
}
I4 = new WeakMap();
function y_e(e, t) {
  if (e === t) return !0;
  const n = e.length;
  if (n !== t.length) return !1;
  for (let r = 0; r < n; r++) if (e[r] !== t[r]) return !1;
  return !0;
}
var Ds = function (e, t, n, r, i) {
    if (r === "m") throw new TypeError("Private method is not writable");
    if (r === "a" && !i)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof t == "function" ? e !== t || !i : !t.has(e))
      throw new TypeError(
        "Cannot write private member to an object whose class did not declare it"
      );
    return r === "a" ? i.call(e, n) : i ? (i.value = n) : t.set(e, n), n;
  },
  nn = function (e, t, n, r) {
    if (n === "a" && !r)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof t == "function" ? e !== t || !r : !t.has(e))
      throw new TypeError(
        "Cannot read private member from an object whose class did not declare it"
      );
    return n === "m" ? r : n === "a" ? r.call(e) : r ? r.value : t.get(e);
  },
  Lo,
  qa,
  am,
  lm,
  $0,
  K2,
  d5,
  Hr,
  f5,
  xT,
  N4,
  _T,
  vw,
  ST,
  wU,
  bU,
  xU,
  _U;
class v_e extends UQ {
  constructor({ wallet: t }) {
    super(),
      Lo.add(this),
      qa.set(this, void 0),
      am.set(this, void 0),
      lm.set(this, void 0),
      $0.set(this, void 0),
      K2.set(this, void 0),
      d5.set(this, void 0),
      Hr.set(this, void 0),
      f5.set(
        this,
        typeof window > "u" || typeof document > "u"
          ? hn.Unsupported
          : hn.Installed
      ),
      ST.set(this, (n) => {
        if ("accounts" in n) {
          const r = nn(this, Hr, "f").accounts[0];
          nn(this, qa, "f") &&
            !nn(this, $0, "f") &&
            r !== nn(this, qa, "f") &&
            (r
              ? nn(this, Lo, "m", N4).call(this, r)
              : (this.emit("error", new xx()),
                nn(this, Lo, "m", _T).call(this)));
        }
        "features" in n && nn(this, Lo, "m", vw).call(this);
      }),
      Ds(this, Hr, t, "f"),
      Ds(this, qa, null, "f"),
      Ds(this, am, null, "f"),
      Ds(this, lm, !1, "f"),
      Ds(this, $0, !1, "f"),
      Ds(
        this,
        K2,
        nn(this, Hr, "f").features[SR].on("change", nn(this, ST, "f")),
        "f"
      ),
      nn(this, Lo, "m", vw).call(this);
  }
  get name() {
    return nn(this, Hr, "f").name;
  }
  get url() {
    return "https://github.com/solana-labs/wallet-standard";
  }
  get icon() {
    return nn(this, Hr, "f").icon;
  }
  get readyState() {
    return nn(this, f5, "f");
  }
  get publicKey() {
    return nn(this, am, "f");
  }
  get connecting() {
    return nn(this, lm, "f");
  }
  get supportedTransactionVersions() {
    return nn(this, d5, "f");
  }
  get wallet() {
    return nn(this, Hr, "f");
  }
  get standard() {
    return !0;
  }
  destroy() {
    Ds(this, qa, null, "f"),
      Ds(this, am, null, "f"),
      Ds(this, lm, !1, "f"),
      Ds(this, $0, !1, "f");
    const t = nn(this, K2, "f");
    t && (Ds(this, K2, null, "f"), t());
  }
  async autoConnect() {
    return nn(this, Lo, "m", xT).call(this, { silent: !0 });
  }
  async connect() {
    return nn(this, Lo, "m", xT).call(this);
  }
  async disconnect() {
    if (vT in nn(this, Hr, "f").features)
      try {
        Ds(this, $0, !0, "f"),
          await nn(this, Hr, "f").features[vT].disconnect();
      } catch (t) {
        this.emit("error", new _x(t == null ? void 0 : t.message, t));
      } finally {
        Ds(this, $0, !1, "f");
      }
    nn(this, Lo, "m", _T).call(this);
  }
  async sendTransaction(t, n, r = {}) {
    try {
      const i = nn(this, qa, "f");
      if (!i) throw new qr();
      let s;
      if (Of in nn(this, Hr, "f").features)
        if (i.features.includes(Of)) s = Of;
        else if (go in nn(this, Hr, "f").features && i.features.includes(go))
          s = go;
        else throw new dd();
      else if (go in nn(this, Hr, "f").features) {
        if (!i.features.includes(go)) throw new dd();
        s = go;
      } else throw new sm();
      const o = y3e(n.rpcEndpoint);
      if (!i.chains.includes(o)) throw new hu();
      try {
        const { signers: a, ...l } = r;
        let c;
        if (
          (fd(t)
            ? (a != null && a.length && t.sign(a), (c = t.serialize()))
            : ((t = await this.prepareTransaction(t, n, l)),
              a != null && a.length && t.partialSign(...a),
              (c = new Uint8Array(
                t.serialize({ requireAllSignatures: !1, verifySignatures: !1 })
              ))),
          s === Of)
        ) {
          const [u] = await nn(this, Hr, "f").features[
            Of
          ].signAndSendTransaction({
            account: i,
            chain: o,
            transaction: c,
            options: {
              preflightCommitment: XA(l.preflightCommitment || n.commitment),
              skipPreflight: l.skipPreflight,
              maxRetries: l.maxRetries,
              minContextSlot: l.minContextSlot,
            },
          });
          return fs.encode(u.signature);
        } else {
          const [u] = await nn(this, Hr, "f").features[go].signTransaction({
            account: i,
            chain: o,
            transaction: c,
            options: {
              preflightCommitment: XA(l.preflightCommitment || n.commitment),
              minContextSlot: l.minContextSlot,
            },
          });
          return await n.sendRawTransaction(u.signedTransaction, {
            ...l,
            preflightCommitment: XA(l.preflightCommitment || n.commitment),
          });
        }
      } catch (a) {
        throw a instanceof Vs ? a : new hu(a == null ? void 0 : a.message, a);
      }
    } catch (i) {
      throw (this.emit("error", i), i);
    }
  }
}
(qa = new WeakMap()),
  (am = new WeakMap()),
  (lm = new WeakMap()),
  ($0 = new WeakMap()),
  (K2 = new WeakMap()),
  (d5 = new WeakMap()),
  (Hr = new WeakMap()),
  (f5 = new WeakMap()),
  (ST = new WeakMap()),
  (Lo = new WeakSet()),
  (xT = async function (t) {
    try {
      if (this.connected || this.connecting) return;
      if (nn(this, f5, "f") !== hn.Installed) throw new _u();
      if ((Ds(this, lm, !0, "f"), !nn(this, Hr, "f").accounts.length))
        try {
          await nn(this, Hr, "f").features[_R].connect(t);
        } catch (r) {
          throw new ud(r == null ? void 0 : r.message, r);
        }
      const n = nn(this, Hr, "f").accounts[0];
      if (!n) throw new dd();
      nn(this, Lo, "m", N4).call(this, n);
    } catch (n) {
      throw (this.emit("error", n), n);
    } finally {
      Ds(this, lm, !1, "f");
    }
  }),
  (N4 = function (t) {
    let n;
    try {
      n = new Pe(t.address);
    } catch (r) {
      throw new lh(r == null ? void 0 : r.message, r);
    }
    Ds(this, qa, t, "f"),
      Ds(this, am, n, "f"),
      nn(this, Lo, "m", vw).call(this),
      this.emit("connect", n);
  }),
  (_T = function () {
    Ds(this, qa, null, "f"),
      Ds(this, am, null, "f"),
      nn(this, Lo, "m", vw).call(this),
      this.emit("disconnect");
  }),
  (vw = function () {
    var n, r;
    const t =
      Of in nn(this, Hr, "f").features
        ? nn(this, Hr, "f").features[Of].supportedTransactionVersions
        : nn(this, Hr, "f").features[go].supportedTransactionVersions;
    Ds(this, d5, y_e(t, ["legacy"]) ? null : new Set(t), "f"),
      go in nn(this, Hr, "f").features &&
      (n = nn(this, qa, "f")) != null &&
      n.features.includes(go)
        ? ((this.signTransaction = nn(this, Lo, "m", wU)),
          (this.signAllTransactions = nn(this, Lo, "m", bU)))
        : (delete this.signTransaction, delete this.signAllTransactions),
      ng in nn(this, Hr, "f").features &&
      (r = nn(this, qa, "f")) != null &&
      r.features.includes(ng)
        ? (this.signMessage = nn(this, Lo, "m", xU))
        : delete this.signMessage,
      QA in nn(this, Hr, "f").features
        ? (this.signIn = nn(this, Lo, "m", _U))
        : delete this.signIn;
  }),
  (wU = async function (t) {
    try {
      const n = nn(this, qa, "f");
      if (!n) throw new qr();
      if (!(go in nn(this, Hr, "f").features)) throw new sm();
      if (!n.features.includes(go)) throw new dd();
      try {
        const i = (
          await nn(this, Hr, "f").features[go].signTransaction({
            account: n,
            transaction: fd(t)
              ? t.serialize()
              : new Uint8Array(
                  t.serialize({
                    requireAllSignatures: !1,
                    verifySignatures: !1,
                  })
                ),
          })
        )[0].signedTransaction;
        return fd(t) ? Cy.deserialize(i) : fr.from(i);
      } catch (r) {
        throw r instanceof Vs ? r : new xo(r == null ? void 0 : r.message, r);
      }
    } catch (n) {
      throw (this.emit("error", n), n);
    }
  }),
  (bU = async function (t) {
    try {
      const n = nn(this, qa, "f");
      if (!n) throw new qr();
      if (!(go in nn(this, Hr, "f").features)) throw new sm();
      if (!n.features.includes(go)) throw new dd();
      try {
        const r = await nn(this, Hr, "f").features[go].signTransaction(
          ...t.map((i) => ({
            account: n,
            transaction: fd(i)
              ? i.serialize()
              : new Uint8Array(
                  i.serialize({
                    requireAllSignatures: !1,
                    verifySignatures: !1,
                  })
                ),
          }))
        );
        return t.map((i, s) => {
          const o = r[s].signedTransaction;
          return fd(i) ? Cy.deserialize(o) : fr.from(o);
        });
      } catch (r) {
        throw new xo(r == null ? void 0 : r.message, r);
      }
    } catch (n) {
      throw (this.emit("error", n), n);
    }
  }),
  (xU = async function (t) {
    try {
      const n = nn(this, qa, "f");
      if (!n) throw new qr();
      if (!(ng in nn(this, Hr, "f").features)) throw new sm();
      if (!n.features.includes(ng)) throw new dd();
      try {
        return (
          await nn(this, Hr, "f").features[ng].signMessage({
            account: n,
            message: t,
          })
        )[0].signature;
      } catch (r) {
        throw new hv(r == null ? void 0 : r.message, r);
      }
    } catch (n) {
      throw (this.emit("error", n), n);
    }
  }),
  (_U = async function (t = {}) {
    try {
      if (!(QA in nn(this, Hr, "f").features)) throw new sm();
      let n;
      try {
        [n] = await nn(this, Hr, "f").features[QA].signIn(t);
      } catch (r) {
        throw new dU(r == null ? void 0 : r.message, r);
      }
      if (!n) throw new dU();
      return nn(this, Lo, "m", N4).call(this, n.account), n;
    } catch (n) {
      throw (this.emit("error", n), n);
    }
  });
const w_e = f3e;
var b_e = function (e, t, n, r, i) {
    if (r === "m") throw new TypeError("Private method is not writable");
    if (r === "a" && !i)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof t == "function" ? e !== t || !i : !t.has(e))
      throw new TypeError(
        "Cannot write private member to an object whose class did not declare it"
      );
    return r === "a" ? i.call(e, n) : i ? (i.value = n) : t.set(e, n), n;
  },
  x_e = function (e, t, n, r) {
    if (n === "a" && !r)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof t == "function" ? e !== t || !r : !t.has(e))
      throw new TypeError(
        "Cannot read private member from an object whose class did not declare it"
      );
    return n === "m" ? r : n === "a" ? r.call(e) : r ? r.value : t.get(e);
  },
  R4;
let Cl;
const O4 = new Set(),
  Sg = {};
function __e() {
  if (
    Cl ||
    ((Cl = Object.freeze({ register: SU, get: S_e, on: E_e })),
    typeof window > "u")
  )
    return Cl;
  const e = Object.freeze({ register: SU });
  try {
    window.addEventListener(
      "wallet-standard:register-wallet",
      ({ detail: t }) => t(e)
    );
  } catch (t) {
    console.error(
      `wallet-standard:register-wallet event listener could not be added
`,
      t
    );
  }
  try {
    window.dispatchEvent(new A_e(e));
  } catch (t) {
    console.error(
      `wallet-standard:app-ready event could not be dispatched
`,
      t
    );
  }
  return Cl;
}
function SU(...e) {
  var t;
  return (
    (e = e.filter((n) => !O4.has(n))),
    e.length
      ? (e.forEach((n) => O4.add(n)),
        (t = Sg.register) == null || t.forEach((n) => ET(() => n(...e))),
        function () {
          var r;
          e.forEach((i) => O4.delete(i)),
            (r = Sg.unregister) == null || r.forEach((i) => ET(() => i(...e)));
        })
      : () => {}
  );
}
function S_e() {
  return [...O4];
}
function E_e(e, t) {
  var n;
  return (
    ((n = Sg[e]) != null && n.push(t)) || (Sg[e] = [t]),
    function () {
      var i;
      Sg[e] = (i = Sg[e]) == null ? void 0 : i.filter((s) => t !== s);
    }
  );
}
function ET(e) {
  try {
    e();
  } catch (t) {
    console.error(t);
  }
}
class A_e extends Event {
  constructor(t) {
    super("wallet-standard:app-ready", {
      bubbles: !1,
      cancelable: !1,
      composed: !1,
    }),
      R4.set(this, void 0),
      b_e(this, R4, t, "f");
  }
  get detail() {
    return x_e(this, R4, "f");
  }
  get type() {
    return "wallet-standard:app-ready";
  }
  preventDefault() {
    throw new Error("preventDefault cannot be called");
  }
  stopImmediatePropagation() {
    throw new Error("stopImmediatePropagation cannot be called");
  }
  stopPropagation() {
    throw new Error("stopPropagation cannot be called");
  }
}
R4 = new WeakMap();
function C_e() {
  if (Cl || ((Cl = __e()), typeof window > "u")) return Cl;
  const e = window.navigator.wallets || [];
  if (!Array.isArray(e))
    return console.error("window.navigator.wallets is not an array"), Cl;
  const { register: t } = Cl,
    n = (...r) => r.forEach((i) => ET(() => i({ register: t })));
  try {
    Object.defineProperty(window.navigator, "wallets", {
      value: Object.freeze({ push: n }),
    });
  } catch {
    return console.error("window.navigator.wallets could not be set"), Cl;
  }
  return n(...e), Cl;
}
function k_e(e) {
  const t = EU(() => new Set()),
    { get: n, on: r } = EU(() => C_e()),
    [i, s] = Y.useState(() => AU(n()));
  Y.useEffect(() => {
    const a = [
      r("register", (...l) => s((c) => [...c, ...AU(l)])),
      r("unregister", (...l) =>
        s((c) => c.filter((u) => l.some((d) => d === u.wallet)))
      ),
    ];
    return () => a.forEach((l) => l());
  }, [r]);
  const o = T_e(i);
  return (
    Y.useEffect(() => {
      if (!o) return;
      const a = new Set(i);
      new Set(o.filter((c) => !a.has(c))).forEach((c) => c.destroy());
    }, [o, i]),
    Y.useEffect(() => () => i.forEach((a) => a.destroy()), []),
    Y.useMemo(
      () => [
        ...i,
        ...e.filter(({ name: a }) =>
          i.some((l) => l.name === a)
            ? (t.has(a) ||
                (t.add(a),
                console.warn(
                  `${a} was registered as a Standard Wallet. The Wallet Adapter for ${a} can be removed from your app.`
                )),
              !1)
            : !0
        ),
      ],
      [i, e, t]
    )
  );
}
function EU(e) {
  const t = Y.useRef();
  return t.current || (t.current = { value: e() }), t.current.value;
}
function T_e(e) {
  const t = Y.useRef();
  return (
    Y.useEffect(() => {
      t.current = e;
    }),
    t.current
  );
}
function AU(e) {
  return e.filter(w_e).map((t) => new v_e({ wallet: t }));
}
var Kg;
(function (e) {
  (e[(e.DESKTOP_WEB = 0)] = "DESKTOP_WEB"),
    (e[(e.MOBILE_WEB = 1)] = "MOBILE_WEB");
})(Kg || (Kg = {}));
function M_e(e) {
  return /(WebView|Version\/.+(Chrome)\/(\d+)\.(\d+)\.(\d+)\.(\d+)|; wv\).+(Chrome)\/(\d+)\.(\d+)\.(\d+)\.(\d+))/i.test(
    e
  );
}
function I_e({ adapters: e, userAgentString: t }) {
  return e.some((n) => n.name !== up && n.readyState === hn.Installed)
    ? Kg.DESKTOP_WEB
    : t && /android/i.test(t) && !M_e(t)
    ? Kg.MOBILE_WEB
    : Kg.DESKTOP_WEB;
}
function N_e(e) {
  return e
    ? /devnet/i.test(e)
      ? "devnet"
      : /testnet/i.test(e)
      ? "testnet"
      : "mainnet-beta"
    : "mainnet-beta";
}
function R_e({
  children: e,
  wallets: t,
  adapter: n,
  isUnloadingRef: r,
  onAutoConnectRequest: i,
  onConnectError: s,
  onError: o,
  onSelectWallet: a,
}) {
  const l = Y.useRef(!1),
    [c, u] = Y.useState(!1),
    d = Y.useRef(!1),
    [f, h] = Y.useState(!1),
    [p, g] = Y.useState(() => (n == null ? void 0 : n.publicKey) ?? null),
    [b, v] = Y.useState(() => (n == null ? void 0 : n.connected) ?? !1),
    w = Y.useRef(o);
  Y.useEffect(
    () => (
      (w.current = o),
      () => {
        w.current = void 0;
      }
    ),
    [o]
  );
  const x = Y.useRef(
      (A, N) => (
        r.current ||
          (w.current
            ? w.current(A, N)
            : (console.error(A, N),
              A instanceof _u &&
                typeof window < "u" &&
                N &&
                window.open(N.url, "_blank"))),
        A
      )
    ),
    [S, R] = Y.useState(() =>
      t
        .map((A) => ({ adapter: A, readyState: A.readyState }))
        .filter(({ readyState: A }) => A !== hn.Unsupported)
    );
  Y.useEffect(() => {
    R((N) =>
      t
        .map((L, F) => {
          const D = N[F];
          return D && D.adapter === L && D.readyState === L.readyState
            ? D
            : { adapter: L, readyState: L.readyState };
        })
        .filter(({ readyState: L }) => L !== hn.Unsupported)
    );
    function A(N) {
      R((L) => {
        const F = L.findIndex(({ adapter: j }) => j === this);
        if (F === -1) return L;
        const { adapter: D } = L[F];
        return [
          ...L.slice(0, F),
          { adapter: D, readyState: N },
          ...L.slice(F + 1),
        ].filter(({ readyState: j }) => j !== hn.Unsupported);
      });
    }
    return (
      t.forEach((N) => N.on("readyStateChange", A, N)),
      () => {
        t.forEach((N) => N.off("readyStateChange", A, N));
      }
    );
  }, [n, t]);
  const O = Y.useMemo(() => S.find((A) => A.adapter === n) ?? null, [n, S]);
  Y.useEffect(() => {
    if (!n) return;
    const A = (F) => {
        g(F), (l.current = !1), u(!1), v(!0), (d.current = !1), h(!1);
      },
      N = () => {
        r.current ||
          (g(null), (l.current = !1), u(!1), v(!1), (d.current = !1), h(!1));
      },
      L = (F) => {
        x.current(F, n);
      };
    return (
      n.on("connect", A),
      n.on("disconnect", N),
      n.on("error", L),
      () => {
        n.off("connect", A), n.off("disconnect", N), n.off("error", L), N();
      }
    );
  }, [n, r]);
  const B = Y.useRef(!1);
  Y.useEffect(
    () => () => {
      B.current = !1;
    },
    [n]
  ),
    Y.useEffect(() => {
      B.current ||
        l.current ||
        b ||
        !i ||
        !(
          (O == null ? void 0 : O.readyState) === hn.Installed ||
          (O == null ? void 0 : O.readyState) === hn.Loadable
        ) ||
        ((l.current = !0),
        u(!0),
        (B.current = !0),
        (async function () {
          try {
            await i();
          } catch {
            s();
          } finally {
            u(!1), (l.current = !1);
          }
        })());
    }, [b, i, s, O]);
  const C = Y.useCallback(
      async (A, N, L) => {
        if (!n) throw x.current(new fU());
        if (!b) throw x.current(new qr(), n);
        return await n.sendTransaction(A, N, L);
      },
      [n, b]
    ),
    I = Y.useMemo(
      () =>
        n && "signTransaction" in n
          ? async (A) => {
              if (!b) throw x.current(new qr(), n);
              return await n.signTransaction(A);
            }
          : void 0,
      [n, b]
    ),
    P = Y.useMemo(
      () =>
        n && "signAllTransactions" in n
          ? async (A) => {
              if (!b) throw x.current(new qr(), n);
              return await n.signAllTransactions(A);
            }
          : void 0,
      [n, b]
    ),
    M = Y.useMemo(
      () =>
        n && "signMessage" in n
          ? async (A) => {
              if (!b) throw x.current(new qr(), n);
              return await n.signMessage(A);
            }
          : void 0,
      [n, b]
    ),
    k = Y.useMemo(
      () => (n && "signIn" in n ? async (A) => await n.signIn(A) : void 0),
      [n]
    ),
    T = Y.useCallback(async () => {
      if (l.current || d.current || (O != null && O.adapter.connected)) return;
      if (!O) throw x.current(new fU());
      const { adapter: A, readyState: N } = O;
      if (!(N === hn.Installed || N === hn.Loadable))
        throw x.current(new _u(), A);
      (l.current = !0), u(!0);
      try {
        await A.connect();
      } catch (L) {
        throw (s(), L);
      } finally {
        u(!1), (l.current = !1);
      }
    }, [s, O]),
    _ = Y.useCallback(async () => {
      if (!d.current && n) {
        (d.current = !0), h(!0);
        try {
          await n.disconnect();
        } finally {
          h(!1), (d.current = !1);
        }
      }
    }, [n]);
  return Ce.createElement(
    $Q.Provider,
    {
      value: {
        autoConnect: !!i,
        wallets: S,
        wallet: O,
        publicKey: p,
        connected: b,
        connecting: c,
        disconnecting: f,
        select: a,
        connect: T,
        disconnect: _,
        sendTransaction: C,
        signTransaction: I,
        signAllTransactions: P,
        signMessage: M,
        signIn: k,
      },
    },
    e
  );
}
let rC;
function O_e() {
  var e;
  return (
    rC === void 0 &&
      (rC =
        ((e = globalThis.navigator) == null ? void 0 : e.userAgent) ?? null),
    rC
  );
}
function T_(e) {
  const t = O_e();
  return I_e({ adapters: e, userAgentString: t }) === Kg.MOBILE_WEB;
}
function P_e() {
  const e = globalThis.location;
  if (e) return `${e.protocol}//${e.host}`;
}
function L_e({
  children: e,
  wallets: t,
  autoConnect: n,
  localStorageKey: r = "walletName",
  onError: i,
}) {
  const { connection: s } = a3e(),
    o = k_e(t),
    a = Y.useMemo(() => {
      if (!T_(o)) return null;
      const w = o.find((x) => x.name === up);
      return (
        w ||
        new l_e({
          addressSelector: c_e(),
          appIdentity: { uri: P_e() },
          authorizationResultCache: u_e(),
          cluster: N_e(s == null ? void 0 : s.rpcEndpoint),
          onWalletNotFound: f_e(),
        })
      );
    }, [o, s == null ? void 0 : s.rpcEndpoint]),
    l = Y.useMemo(
      () => (a == null || o.indexOf(a) !== -1 ? o : [a, ...o]),
      [o, a]
    ),
    [c, u] = p3e(r, T_(o) ? up : null),
    d = Y.useMemo(() => l.find((w) => w.name === c) ?? null, [l, c]),
    f = Y.useCallback(
      (w) => {
        c !== w && (d && d.name !== up && d.disconnect(), u(w));
      },
      [d, u, c]
    );
  Y.useEffect(() => {
    if (!d) return;
    function w() {
      g.current || (c === up && T_(o)) || u(null);
    }
    return (
      d.on("disconnect", w),
      () => {
        d.off("disconnect", w);
      }
    );
  }, [d, o, u, c]);
  const h = Y.useRef(!1),
    p = Y.useMemo(() => {
      if (!(!n || !d))
        return async () => {
          (n === !0 || (await n(d))) &&
            (h.current ? await d.connect() : await d.autoConnect());
        };
    }, [n, d]),
    g = Y.useRef(!1);
  Y.useEffect(() => {
    if (c === up && T_(o)) {
      g.current = !1;
      return;
    }
    function w() {
      g.current = !0;
    }
    return (
      window.addEventListener("beforeunload", w),
      () => {
        window.removeEventListener("beforeunload", w);
      }
    );
  }, [o, c]);
  const b = Y.useCallback(() => {
      d && d.name !== up && f(null);
    }, [d, f]),
    v = Y.useCallback(
      (w) => {
        (h.current = !0), f(w);
      },
      [f]
    );
  return Ce.createElement(
    R_e,
    {
      wallets: l,
      adapter: d,
      isUnloadingRef: g,
      onAutoConnectRequest: p,
      onConnectError: b,
      onError: i,
      onSelectWallet: v,
    },
    e
  );
}
function j_e({ onSelectWallet: e }) {
  const {
    connect: t,
    connected: n,
    connecting: r,
    disconnect: i,
    disconnecting: s,
    publicKey: o,
    select: a,
    wallet: l,
    wallets: c,
  } = g1();
  let u;
  r
    ? (u = "connecting")
    : n
    ? (u = "connected")
    : s
    ? (u = "disconnecting")
    : l
    ? (u = "has-wallet")
    : (u = "no-wallet");
  const d = Y.useCallback(() => {
      t().catch(() => {});
    }, [t]),
    f = Y.useCallback(() => {
      i().catch(() => {});
    }, [i]),
    h = Y.useCallback(() => {
      e({ onSelectWallet: a, wallets: c });
    }, [e, a, c]);
  return {
    buttonState: u,
    onConnect: u === "has-wallet" ? d : void 0,
    onDisconnect: u !== "disconnecting" && u !== "no-wallet" ? f : void 0,
    onSelectWallet: h,
    publicKey: o ?? void 0,
    walletIcon: l == null ? void 0 : l.adapter.icon,
    walletName: l == null ? void 0 : l.adapter.name,
  };
}
var ZQ = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/ (function (e) {
  (function () {
    var t = {}.hasOwnProperty;
    function n() {
      for (var s = "", o = 0; o < arguments.length; o++) {
        var a = arguments[o];
        a && (s = i(s, r(a)));
      }
      return s;
    }
    function r(s) {
      if (typeof s == "string" || typeof s == "number") return s;
      if (typeof s != "object") return "";
      if (Array.isArray(s)) return n.apply(null, s);
      if (
        s.toString !== Object.prototype.toString &&
        !s.toString.toString().includes("[native code]")
      )
        return s.toString();
      var o = "";
      for (var a in s) t.call(s, a) && s[a] && (o = i(o, a));
      return o;
    }
    function i(s, o) {
      return o ? (s ? s + " " + o : s + o) : s;
    }
    e.exports ? ((n.default = n), (e.exports = n)) : (window.classNames = n);
  })();
})(ZQ);
var D_e = ZQ.exports;
const xn = Gi(D_e);
function B_e(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default")
    ? e.default
    : e;
}
var QQ = { exports: {} },
  Rs = (QQ.exports = {}),
  Zu,
  Qu;
function AT() {
  throw new Error("setTimeout has not been defined");
}
function CT() {
  throw new Error("clearTimeout has not been defined");
}
(function () {
  try {
    typeof setTimeout == "function" ? (Zu = setTimeout) : (Zu = AT);
  } catch {
    Zu = AT;
  }
  try {
    typeof clearTimeout == "function" ? (Qu = clearTimeout) : (Qu = CT);
  } catch {
    Qu = CT;
  }
})();
function XQ(e) {
  if (Zu === setTimeout) return setTimeout(e, 0);
  if ((Zu === AT || !Zu) && setTimeout)
    return (Zu = setTimeout), setTimeout(e, 0);
  try {
    return Zu(e, 0);
  } catch {
    try {
      return Zu.call(null, e, 0);
    } catch {
      return Zu.call(this, e, 0);
    }
  }
}
function F_e(e) {
  if (Qu === clearTimeout) return clearTimeout(e);
  if ((Qu === CT || !Qu) && clearTimeout)
    return (Qu = clearTimeout), clearTimeout(e);
  try {
    return Qu(e);
  } catch {
    try {
      return Qu.call(null, e);
    } catch {
      return Qu.call(this, e);
    }
  }
}
var Ff = [],
  Yg = !1,
  cm,
  P4 = -1;
function U_e() {
  !Yg ||
    !cm ||
    ((Yg = !1),
    cm.length ? (Ff = cm.concat(Ff)) : (P4 = -1),
    Ff.length && JQ());
}
function JQ() {
  if (!Yg) {
    var e = XQ(U_e);
    Yg = !0;
    for (var t = Ff.length; t; ) {
      for (cm = Ff, Ff = []; ++P4 < t; ) cm && cm[P4].run();
      (P4 = -1), (t = Ff.length);
    }
    (cm = null), (Yg = !1), F_e(e);
  }
}
Rs.nextTick = function (e) {
  var t = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];
  Ff.push(new eX(e, t)), Ff.length === 1 && !Yg && XQ(JQ);
};
function eX(e, t) {
  (this.fun = e), (this.array = t);
}
eX.prototype.run = function () {
  this.fun.apply(null, this.array);
};
Rs.title = "browser";
Rs.browser = !0;
Rs.env = {};
Rs.argv = [];
Rs.version = "";
Rs.versions = {};
function wh() {}
Rs.on = wh;
Rs.addListener = wh;
Rs.once = wh;
Rs.off = wh;
Rs.removeListener = wh;
Rs.removeAllListeners = wh;
Rs.emit = wh;
Rs.prependListener = wh;
Rs.prependOnceListener = wh;
Rs.listeners = function (e) {
  return [];
};
Rs.binding = function (e) {
  throw new Error("process.binding is not supported");
};
Rs.cwd = function () {
  return "/";
};
Rs.chdir = function (e) {
  throw new Error("process.chdir is not supported");
};
Rs.umask = function () {
  return 0;
};
var $_e = QQ.exports;
const Hs = B_e($_e);
function No(e) {
  return `Minified Redux error #${e}; visit https://redux.js.org/Errors?code=${e} for the full message or use the non-minified dev environment for full errors. `;
}
var z_e = (typeof Symbol == "function" && Symbol.observable) || "@@observable",
  CU = z_e,
  iC = () => Math.random().toString(36).substring(7).split("").join("."),
  W_e = {
    INIT: `@@redux/INIT${iC()}`,
    REPLACE: `@@redux/REPLACE${iC()}`,
    PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${iC()}`,
  },
  h5 = W_e;
function Nd(e) {
  if (typeof e != "object" || e === null) return !1;
  let t = e;
  for (; Object.getPrototypeOf(t) !== null; ) t = Object.getPrototypeOf(t);
  return Object.getPrototypeOf(e) === t || Object.getPrototypeOf(e) === null;
}
function ER(e, t, n) {
  if (typeof e != "function") throw new Error(No(2));
  if (
    (typeof t == "function" && typeof n == "function") ||
    (typeof n == "function" && typeof arguments[3] == "function")
  )
    throw new Error(No(0));
  if (
    (typeof t == "function" && typeof n > "u" && ((n = t), (t = void 0)),
    typeof n < "u")
  ) {
    if (typeof n != "function") throw new Error(No(1));
    return n(ER)(e, t);
  }
  let r = e,
    i = t,
    s = new Map(),
    o = s,
    a = 0,
    l = !1;
  function c() {
    o === s &&
      ((o = new Map()),
      s.forEach((b, v) => {
        o.set(v, b);
      }));
  }
  function u() {
    if (l) throw new Error(No(3));
    return i;
  }
  function d(b) {
    if (typeof b != "function") throw new Error(No(4));
    if (l) throw new Error(No(5));
    let v = !0;
    c();
    const w = a++;
    return (
      o.set(w, b),
      function () {
        if (v) {
          if (l) throw new Error(No(6));
          (v = !1), c(), o.delete(w), (s = null);
        }
      }
    );
  }
  function f(b) {
    if (!Nd(b)) throw new Error(No(7));
    if (typeof b.type > "u") throw new Error(No(8));
    if (typeof b.type != "string") throw new Error(No(17));
    if (l) throw new Error(No(9));
    try {
      (l = !0), (i = r(i, b));
    } finally {
      l = !1;
    }
    return (
      (s = o).forEach((w) => {
        w();
      }),
      b
    );
  }
  function h(b) {
    if (typeof b != "function") throw new Error(No(10));
    (r = b), f({ type: h5.REPLACE });
  }
  function p() {
    const b = d;
    return {
      subscribe(v) {
        if (typeof v != "object" || v === null) throw new Error(No(11));
        function w() {
          const S = v;
          S.next && S.next(u());
        }
        return w(), { unsubscribe: b(w) };
      },
      [CU]() {
        return this;
      },
    };
  }
  return (
    f({ type: h5.INIT }),
    { dispatch: f, subscribe: d, getState: u, replaceReducer: h, [CU]: p }
  );
}
function H_e(e) {
  Object.keys(e).forEach((t) => {
    const n = e[t];
    if (typeof n(void 0, { type: h5.INIT }) > "u") throw new Error(No(12));
    if (typeof n(void 0, { type: h5.PROBE_UNKNOWN_ACTION() }) > "u")
      throw new Error(No(13));
  });
}
function AR(e) {
  const t = Object.keys(e),
    n = {};
  for (let s = 0; s < t.length; s++) {
    const o = t[s];
    typeof e[o] == "function" && (n[o] = e[o]);
  }
  const r = Object.keys(n);
  let i;
  try {
    H_e(n);
  } catch (s) {
    i = s;
  }
  return function (o = {}, a) {
    if (i) throw i;
    let l = !1;
    const c = {};
    for (let u = 0; u < r.length; u++) {
      const d = r[u],
        f = n[d],
        h = o[d],
        p = f(h, a);
      if (typeof p > "u") throw (a && a.type, new Error(No(14)));
      (c[d] = p), (l = l || p !== h);
    }
    return (l = l || r.length !== Object.keys(o).length), l ? c : o;
  };
}
function p5(...e) {
  return e.length === 0
    ? (t) => t
    : e.length === 1
    ? e[0]
    : e.reduce(
        (t, n) =>
          (...r) =>
            t(n(...r))
      );
}
function V_e(...e) {
  return (t) => (n, r) => {
    const i = t(n, r);
    let s = () => {
      throw new Error(No(15));
    };
    const o = { getState: i.getState, dispatch: (l, ...c) => s(l, ...c) },
      a = e.map((l) => l(o));
    return (s = p5(...a)(i.dispatch)), { ...i, dispatch: s };
  };
}
function tX(e) {
  return Nd(e) && "type" in e && typeof e.type == "string";
}
var CR = Symbol.for("immer-nothing"),
  ww = Symbol.for("immer-draftable"),
  al = Symbol.for("immer-state");
function Bo(e, ...t) {
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var qm = Object.getPrototypeOf;
function Cu(e) {
  return !!e && !!e[al];
}
function ku(e) {
  var t;
  return e
    ? nX(e) ||
        Array.isArray(e) ||
        !!e[ww] ||
        !!((t = e.constructor) != null && t[ww]) ||
        Sx(e) ||
        Ex(e)
    : !1;
}
var G_e = Object.prototype.constructor.toString();
function nX(e) {
  if (!e || typeof e != "object") return !1;
  const t = qm(e);
  if (t === null) return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object
    ? !0
    : typeof n == "function" && Function.toString.call(n) === G_e;
}
function q_e(e) {
  return Cu(e) || Bo(15, e), e[al].base_;
}
function lb(e, t) {
  Km(e) === 0
    ? Reflect.ownKeys(e).forEach((n) => {
        t(n, e[n], e);
      })
    : e.forEach((n, r) => t(r, n, e));
}
function Km(e) {
  const t = e[al];
  return t ? t.type_ : Array.isArray(e) ? 1 : Sx(e) ? 2 : Ex(e) ? 3 : 0;
}
function cb(e, t) {
  return Km(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function sC(e, t) {
  return Km(e) === 2 ? e.get(t) : e[t];
}
function rX(e, t, n) {
  const r = Km(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : (e[t] = n);
}
function K_e(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function Sx(e) {
  return e instanceof Map;
}
function Ex(e) {
  return e instanceof Set;
}
function z0(e) {
  return e.copy_ || e.base_;
}
function kT(e, t) {
  if (Sx(e)) return new Map(e);
  if (Ex(e)) return new Set(e);
  if (Array.isArray(e)) return Array.prototype.slice.call(e);
  const n = nX(e);
  if (t === !0 || (t === "class_only" && !n)) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[al];
    let i = Reflect.ownKeys(r);
    for (let s = 0; s < i.length; s++) {
      const o = i[s],
        a = r[o];
      a.writable === !1 && ((a.writable = !0), (a.configurable = !0)),
        (a.get || a.set) &&
          (r[o] = {
            configurable: !0,
            writable: !0,
            enumerable: a.enumerable,
            value: e[o],
          });
    }
    return Object.create(qm(e), r);
  } else {
    const r = qm(e);
    if (r !== null && n) return { ...e };
    const i = Object.create(r);
    return Object.assign(i, e);
  }
}
function kR(e, t = !1) {
  return (
    E8(e) ||
      Cu(e) ||
      !ku(e) ||
      (Km(e) > 1 && (e.set = e.add = e.clear = e.delete = Y_e),
      Object.freeze(e),
      t && Object.entries(e).forEach(([n, r]) => kR(r, !0))),
    e
  );
}
function Y_e() {
  Bo(2);
}
function E8(e) {
  return Object.isFrozen(e);
}
var TT = {};
function Ym(e) {
  const t = TT[e];
  return t || Bo(0, e), t;
}
function Z_e(e, t) {
  TT[e] || (TT[e] = t);
}
var ub;
function iX() {
  return ub;
}
function Q_e(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0,
  };
}
function kU(e, t) {
  t &&
    (Ym("Patches"),
    (e.patches_ = []),
    (e.inversePatches_ = []),
    (e.patchListener_ = t));
}
function MT(e) {
  IT(e), e.drafts_.forEach(X_e), (e.drafts_ = null);
}
function IT(e) {
  e === ub && (ub = e.parent_);
}
function TU(e) {
  return (ub = Q_e(ub, e));
}
function X_e(e) {
  const t = e[al];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : (t.revoked_ = !0);
}
function MU(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return (
    e !== void 0 && e !== n
      ? (n[al].modified_ && (MT(t), Bo(4)),
        ku(e) && ((e = m5(t, e)), t.parent_ || g5(t, e)),
        t.patches_ &&
          Ym("Patches").generateReplacementPatches_(
            n[al].base_,
            e,
            t.patches_,
            t.inversePatches_
          ))
      : (e = m5(t, n, [])),
    MT(t),
    t.patches_ && t.patchListener_(t.patches_, t.inversePatches_),
    e !== CR ? e : void 0
  );
}
function m5(e, t, n) {
  if (E8(t)) return t;
  const r = t[al];
  if (!r) return lb(t, (i, s) => IU(e, r, t, i, s, n)), t;
  if (r.scope_ !== e) return t;
  if (!r.modified_) return g5(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    (r.finalized_ = !0), r.scope_.unfinalizedDrafts_--;
    const i = r.copy_;
    let s = i,
      o = !1;
    r.type_ === 3 && ((s = new Set(i)), i.clear(), (o = !0)),
      lb(s, (a, l) => IU(e, r, i, a, l, n, o)),
      g5(e, i, !1),
      n &&
        e.patches_ &&
        Ym("Patches").generatePatches_(r, n, e.patches_, e.inversePatches_);
  }
  return r.copy_;
}
function IU(e, t, n, r, i, s, o) {
  if (Cu(i)) {
    const a =
        s && t && t.type_ !== 3 && !cb(t.assigned_, r) ? s.concat(r) : void 0,
      l = m5(e, i, a);
    if ((rX(n, r, l), Cu(l))) e.canAutoFreeze_ = !1;
    else return;
  } else o && n.add(i);
  if (ku(i) && !E8(i)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1) return;
    m5(e, i),
      (!t || !t.scope_.parent_) &&
        typeof r != "symbol" &&
        Object.prototype.propertyIsEnumerable.call(n, r) &&
        g5(e, i);
  }
}
function g5(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && kR(t, n);
}
function J_e(e, t) {
  const n = Array.isArray(e),
    r = {
      type_: n ? 1 : 0,
      scope_: t ? t.scope_ : iX(),
      modified_: !1,
      finalized_: !1,
      assigned_: {},
      parent_: t,
      base_: e,
      draft_: null,
      copy_: null,
      revoke_: null,
      isManual_: !1,
    };
  let i = r,
    s = TR;
  n && ((i = [r]), (s = db));
  const { revoke: o, proxy: a } = Proxy.revocable(i, s);
  return (r.draft_ = a), (r.revoke_ = o), a;
}
var TR = {
    get(e, t) {
      if (t === al) return e;
      const n = z0(e);
      if (!cb(n, t)) return e4e(e, n, t);
      const r = n[t];
      return e.finalized_ || !ku(r)
        ? r
        : r === oC(e.base_, t)
        ? (aC(e), (e.copy_[t] = RT(r, e)))
        : r;
    },
    has(e, t) {
      return t in z0(e);
    },
    ownKeys(e) {
      return Reflect.ownKeys(z0(e));
    },
    set(e, t, n) {
      const r = sX(z0(e), t);
      if (r != null && r.set) return r.set.call(e.draft_, n), !0;
      if (!e.modified_) {
        const i = oC(z0(e), t),
          s = i == null ? void 0 : i[al];
        if (s && s.base_ === n)
          return (e.copy_[t] = n), (e.assigned_[t] = !1), !0;
        if (K_e(n, i) && (n !== void 0 || cb(e.base_, t))) return !0;
        aC(e), NT(e);
      }
      return (
        (e.copy_[t] === n && (n !== void 0 || t in e.copy_)) ||
          (Number.isNaN(n) && Number.isNaN(e.copy_[t])) ||
          ((e.copy_[t] = n), (e.assigned_[t] = !0)),
        !0
      );
    },
    deleteProperty(e, t) {
      return (
        oC(e.base_, t) !== void 0 || t in e.base_
          ? ((e.assigned_[t] = !1), aC(e), NT(e))
          : delete e.assigned_[t],
        e.copy_ && delete e.copy_[t],
        !0
      );
    },
    getOwnPropertyDescriptor(e, t) {
      const n = z0(e),
        r = Reflect.getOwnPropertyDescriptor(n, t);
      return (
        r && {
          writable: !0,
          configurable: e.type_ !== 1 || t !== "length",
          enumerable: r.enumerable,
          value: n[t],
        }
      );
    },
    defineProperty() {
      Bo(11);
    },
    getPrototypeOf(e) {
      return qm(e.base_);
    },
    setPrototypeOf() {
      Bo(12);
    },
  },
  db = {};
lb(TR, (e, t) => {
  db[e] = function () {
    return (arguments[0] = arguments[0][0]), t.apply(this, arguments);
  };
});
db.deleteProperty = function (e, t) {
  return db.set.call(this, e, t, void 0);
};
db.set = function (e, t, n) {
  return TR.set.call(this, e[0], t, n, e[0]);
};
function oC(e, t) {
  const n = e[al];
  return (n ? z0(n) : e)[t];
}
function e4e(e, t, n) {
  var i;
  const r = sX(t, n);
  return r
    ? "value" in r
      ? r.value
      : (i = r.get) == null
      ? void 0
      : i.call(e.draft_)
    : void 0;
}
function sX(e, t) {
  if (!(t in e)) return;
  let n = qm(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r) return r;
    n = qm(n);
  }
}
function NT(e) {
  e.modified_ || ((e.modified_ = !0), e.parent_ && NT(e.parent_));
}
function aC(e) {
  e.copy_ || (e.copy_ = kT(e.base_, e.scope_.immer_.useStrictShallowCopy_));
}
var t4e = class {
  constructor(e) {
    (this.autoFreeze_ = !0),
      (this.useStrictShallowCopy_ = !1),
      (this.produce = (t, n, r) => {
        if (typeof t == "function" && typeof n != "function") {
          const s = n;
          n = t;
          const o = this;
          return function (l = s, ...c) {
            return o.produce(l, (u) => n.call(this, u, ...c));
          };
        }
        typeof n != "function" && Bo(6),
          r !== void 0 && typeof r != "function" && Bo(7);
        let i;
        if (ku(t)) {
          const s = TU(this),
            o = RT(t, void 0);
          let a = !0;
          try {
            (i = n(o)), (a = !1);
          } finally {
            a ? MT(s) : IT(s);
          }
          return kU(s, r), MU(i, s);
        } else if (!t || typeof t != "object") {
          if (
            ((i = n(t)),
            i === void 0 && (i = t),
            i === CR && (i = void 0),
            this.autoFreeze_ && kR(i, !0),
            r)
          ) {
            const s = [],
              o = [];
            Ym("Patches").generateReplacementPatches_(t, i, s, o), r(s, o);
          }
          return i;
        } else Bo(1, t);
      }),
      (this.produceWithPatches = (t, n) => {
        if (typeof t == "function")
          return (o, ...a) => this.produceWithPatches(o, (l) => t(l, ...a));
        let r, i;
        return [
          this.produce(t, n, (o, a) => {
            (r = o), (i = a);
          }),
          r,
          i,
        ];
      }),
      typeof (e == null ? void 0 : e.autoFreeze) == "boolean" &&
        this.setAutoFreeze(e.autoFreeze),
      typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" &&
        this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    ku(e) || Bo(8), Cu(e) && (e = oX(e));
    const t = TU(this),
      n = RT(e, void 0);
    return (n[al].isManual_ = !0), IT(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[al];
    (!n || !n.isManual_) && Bo(9);
    const { scope_: r } = n;
    return kU(r, t), MU(void 0, r);
  }
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const i = t[n];
      if (i.path.length === 0 && i.op === "replace") {
        e = i.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Ym("Patches").applyPatches_;
    return Cu(e) ? r(e, t) : this.produce(e, (i) => r(i, t));
  }
};
function RT(e, t) {
  const n = Sx(e)
    ? Ym("MapSet").proxyMap_(e, t)
    : Ex(e)
    ? Ym("MapSet").proxySet_(e, t)
    : J_e(e, t);
  return (t ? t.scope_ : iX()).drafts_.push(n), n;
}
function oX(e) {
  return Cu(e) || Bo(10, e), aX(e);
}
function aX(e) {
  if (!ku(e) || E8(e)) return e;
  const t = e[al];
  let n;
  if (t) {
    if (!t.modified_) return t.base_;
    (t.finalized_ = !0), (n = kT(e, t.scope_.immer_.useStrictShallowCopy_));
  } else n = kT(e, !0);
  return (
    lb(n, (r, i) => {
      rX(n, r, aX(i));
    }),
    t && (t.finalized_ = !1),
    n
  );
}
function n4e() {
  const t = "replace",
    n = "add",
    r = "remove";
  function i(f, h, p, g) {
    switch (f.type_) {
      case 0:
      case 2:
        return o(f, h, p, g);
      case 1:
        return s(f, h, p, g);
      case 3:
        return a(f, h, p, g);
    }
  }
  function s(f, h, p, g) {
    let { base_: b, assigned_: v } = f,
      w = f.copy_;
    w.length < b.length && (([b, w] = [w, b]), ([p, g] = [g, p]));
    for (let x = 0; x < b.length; x++)
      if (v[x] && w[x] !== b[x]) {
        const S = h.concat([x]);
        p.push({ op: t, path: S, value: d(w[x]) }),
          g.push({ op: t, path: S, value: d(b[x]) });
      }
    for (let x = b.length; x < w.length; x++) {
      const S = h.concat([x]);
      p.push({ op: n, path: S, value: d(w[x]) });
    }
    for (let x = w.length - 1; b.length <= x; --x) {
      const S = h.concat([x]);
      g.push({ op: r, path: S });
    }
  }
  function o(f, h, p, g) {
    const { base_: b, copy_: v } = f;
    lb(f.assigned_, (w, x) => {
      const S = sC(b, w),
        R = sC(v, w),
        O = x ? (cb(b, w) ? t : n) : r;
      if (S === R && O === t) return;
      const B = h.concat(w);
      p.push(O === r ? { op: O, path: B } : { op: O, path: B, value: R }),
        g.push(
          O === n
            ? { op: r, path: B }
            : O === r
            ? { op: n, path: B, value: d(S) }
            : { op: t, path: B, value: d(S) }
        );
    });
  }
  function a(f, h, p, g) {
    let { base_: b, copy_: v } = f,
      w = 0;
    b.forEach((x) => {
      if (!v.has(x)) {
        const S = h.concat([w]);
        p.push({ op: r, path: S, value: x }),
          g.unshift({ op: n, path: S, value: x });
      }
      w++;
    }),
      (w = 0),
      v.forEach((x) => {
        if (!b.has(x)) {
          const S = h.concat([w]);
          p.push({ op: n, path: S, value: x }),
            g.unshift({ op: r, path: S, value: x });
        }
        w++;
      });
  }
  function l(f, h, p, g) {
    p.push({ op: t, path: [], value: h === CR ? void 0 : h }),
      g.push({ op: t, path: [], value: f });
  }
  function c(f, h) {
    return (
      h.forEach((p) => {
        const { path: g, op: b } = p;
        let v = f;
        for (let R = 0; R < g.length - 1; R++) {
          const O = Km(v);
          let B = g[R];
          typeof B != "string" && typeof B != "number" && (B = "" + B),
            (O === 0 || O === 1) &&
              (B === "__proto__" || B === "constructor") &&
              Bo(19),
            typeof v == "function" && B === "prototype" && Bo(19),
            (v = sC(v, B)),
            typeof v != "object" && Bo(18, g.join("/"));
        }
        const w = Km(v),
          x = u(p.value),
          S = g[g.length - 1];
        switch (b) {
          case t:
            switch (w) {
              case 2:
                return v.set(S, x);
              case 3:
                Bo(16);
              default:
                return (v[S] = x);
            }
          case n:
            switch (w) {
              case 1:
                return S === "-" ? v.push(x) : v.splice(S, 0, x);
              case 2:
                return v.set(S, x);
              case 3:
                return v.add(x);
              default:
                return (v[S] = x);
            }
          case r:
            switch (w) {
              case 1:
                return v.splice(S, 1);
              case 2:
                return v.delete(S);
              case 3:
                return v.delete(p.value);
              default:
                return delete v[S];
            }
          default:
            Bo(17, b);
        }
      }),
      f
    );
  }
  function u(f) {
    if (!ku(f)) return f;
    if (Array.isArray(f)) return f.map(u);
    if (Sx(f))
      return new Map(Array.from(f.entries()).map(([p, g]) => [p, u(g)]));
    if (Ex(f)) return new Set(Array.from(f).map(u));
    const h = Object.create(qm(f));
    for (const p in f) h[p] = u(f[p]);
    return cb(f, ww) && (h[ww] = f[ww]), h;
  }
  function d(f) {
    return Cu(f) ? u(f) : f;
  }
  Z_e("Patches", {
    applyPatches_: c,
    generatePatches_: i,
    generateReplacementPatches_: l,
  });
}
var Ul = new t4e(),
  Ax = Ul.produce,
  lX = Ul.produceWithPatches.bind(Ul);
Ul.setAutoFreeze.bind(Ul);
Ul.setUseStrictShallowCopy.bind(Ul);
var NU = Ul.applyPatches.bind(Ul);
Ul.createDraft.bind(Ul);
Ul.finishDraft.bind(Ul);
function r4e(e, t = `expected a function, instead received ${typeof e}`) {
  if (typeof e != "function") throw new TypeError(t);
}
function i4e(e, t = `expected an object, instead received ${typeof e}`) {
  if (typeof e != "object") throw new TypeError(t);
}
function s4e(
  e,
  t = "expected all items to be functions, instead received the following types: "
) {
  if (!e.every((n) => typeof n == "function")) {
    const n = e
      .map((r) =>
        typeof r == "function" ? `function ${r.name || "unnamed"}()` : typeof r
      )
      .join(", ");
    throw new TypeError(`${t}[${n}]`);
  }
}
var RU = (e) => (Array.isArray(e) ? e : [e]);
function o4e(e) {
  const t = Array.isArray(e[0]) ? e[0] : e;
  return (
    s4e(
      t,
      "createSelector expects all input-selectors to be functions, but received the following types: "
    ),
    t
  );
}
function a4e(e, t) {
  const n = [],
    { length: r } = e;
  for (let i = 0; i < r; i++) n.push(e[i].apply(null, t));
  return n;
}
var l4e = class {
    constructor(e) {
      this.value = e;
    }
    deref() {
      return this.value;
    }
  },
  c4e = typeof WeakRef < "u" ? WeakRef : l4e,
  u4e = 0,
  OU = 1;
function M_() {
  return { s: u4e, v: void 0, o: null, p: null };
}
function fb(e, t = {}) {
  let n = M_();
  const { resultEqualityCheck: r } = t;
  let i,
    s = 0;
  function o() {
    var d;
    let a = n;
    const { length: l } = arguments;
    for (let f = 0, h = l; f < h; f++) {
      const p = arguments[f];
      if (typeof p == "function" || (typeof p == "object" && p !== null)) {
        let g = a.o;
        g === null && (a.o = g = new WeakMap());
        const b = g.get(p);
        b === void 0 ? ((a = M_()), g.set(p, a)) : (a = b);
      } else {
        let g = a.p;
        g === null && (a.p = g = new Map());
        const b = g.get(p);
        b === void 0 ? ((a = M_()), g.set(p, a)) : (a = b);
      }
    }
    const c = a;
    let u;
    if (a.s === OU) u = a.v;
    else if (((u = e.apply(null, arguments)), s++, r)) {
      const f =
        ((d = i == null ? void 0 : i.deref) == null ? void 0 : d.call(i)) ?? i;
      f != null && r(f, u) && ((u = f), s !== 0 && s--),
        (i =
          (typeof u == "object" && u !== null) || typeof u == "function"
            ? new c4e(u)
            : u);
    }
    return (c.s = OU), (c.v = u), u;
  }
  return (
    (o.clearCache = () => {
      (n = M_()), o.resetResultsCount();
    }),
    (o.resultsCount = () => s),
    (o.resetResultsCount = () => {
      s = 0;
    }),
    o
  );
}
function cX(e, ...t) {
  const n = typeof e == "function" ? { memoize: e, memoizeOptions: t } : e,
    r = (...i) => {
      let s = 0,
        o = 0,
        a,
        l = {},
        c = i.pop();
      typeof c == "object" && ((l = c), (c = i.pop())),
        r4e(
          c,
          `createSelector expects an output function after the inputs, but received: [${typeof c}]`
        );
      const u = { ...n, ...l },
        {
          memoize: d,
          memoizeOptions: f = [],
          argsMemoize: h = fb,
          argsMemoizeOptions: p = [],
          devModeChecks: g = {},
        } = u,
        b = RU(f),
        v = RU(p),
        w = o4e(i),
        x = d(function () {
          return s++, c.apply(null, arguments);
        }, ...b),
        S = h(function () {
          o++;
          const O = a4e(w, arguments);
          return (a = x.apply(null, O)), a;
        }, ...v);
      return Object.assign(S, {
        resultFunc: c,
        memoizedResultFunc: x,
        dependencies: w,
        dependencyRecomputations: () => o,
        resetDependencyRecomputations: () => {
          o = 0;
        },
        lastResult: () => a,
        recomputations: () => s,
        resetRecomputations: () => {
          s = 0;
        },
        memoize: d,
        argsMemoize: h,
      });
    };
  return Object.assign(r, { withTypes: () => r }), r;
}
var bh = cX(fb),
  d4e = Object.assign(
    (e, t = bh) => {
      i4e(
        e,
        `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof e}`
      );
      const n = Object.keys(e),
        r = n.map((s) => e[s]);
      return t(r, (...s) => s.reduce((o, a, l) => ((o[n[l]] = a), o), {}));
    },
    { withTypes: () => d4e }
  );
function uX(e) {
  return ({ dispatch: n, getState: r }) =>
    (i) =>
    (s) =>
      typeof s == "function" ? s(n, r, e) : i(s);
}
var f4e = uX(),
  h4e = uX,
  p4e = (...e) => {
    const t = cX(...e),
      n = Object.assign(
        (...r) => {
          const i = t(...r),
            s = (o, ...a) => i(Cu(o) ? oX(o) : o, ...a);
          return Object.assign(s, i), s;
        },
        { withTypes: () => n }
      );
    return n;
  };
p4e(fb);
var m4e =
    typeof window < "u" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__
      ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__
      : function () {
          if (arguments.length !== 0)
            return typeof arguments[0] == "object"
              ? p5
              : p5.apply(null, arguments);
        },
  g4e = (e) => e && typeof e.match == "function";
function ka(e, t) {
  function n(...r) {
    if (t) {
      let i = t(...r);
      if (!i) throw new Error(aa(0));
      return {
        type: e,
        payload: i.payload,
        ...("meta" in i && { meta: i.meta }),
        ...("error" in i && { error: i.error }),
      };
    }
    return { type: e, payload: r[0] };
  }
  return (
    (n.toString = () => `${e}`),
    (n.type = e),
    (n.match = (r) => tX(r) && r.type === e),
    n
  );
}
var dX = class Y2 extends Array {
  constructor(...t) {
    super(...t), Object.setPrototypeOf(this, Y2.prototype);
  }
  static get [Symbol.species]() {
    return Y2;
  }
  concat(...t) {
    return super.concat.apply(this, t);
  }
  prepend(...t) {
    return t.length === 1 && Array.isArray(t[0])
      ? new Y2(...t[0].concat(this))
      : new Y2(...t.concat(this));
  }
};
function PU(e) {
  return ku(e) ? Ax(e, () => {}) : e;
}
function LU(e, t, n) {
  if (e.has(t)) {
    let i = e.get(t);
    return n.update && ((i = n.update(i, t, e)), e.set(t, i)), i;
  }
  if (!n.insert) throw new Error(aa(10));
  const r = n.insert(t, e);
  return e.set(t, r), r;
}
function y4e(e) {
  return typeof e == "boolean";
}
var v4e = () =>
    function (t) {
      const {
        thunk: n = !0,
        immutableCheck: r = !0,
        serializableCheck: i = !0,
        actionCreatorCheck: s = !0,
      } = t ?? {};
      let o = new dX();
      return n && (y4e(n) ? o.push(f4e) : o.push(h4e(n.extraArgument))), o;
    },
  Eg = "RTK_autoBatch",
  S2 = () => (e) => ({ payload: e, meta: { [Eg]: !0 } }),
  fX = (e) => (t) => {
    setTimeout(t, e);
  },
  w4e =
    typeof window < "u" && window.requestAnimationFrame
      ? window.requestAnimationFrame
      : fX(10),
  b4e =
    (e = { type: "raf" }) =>
    (t) =>
    (...n) => {
      const r = t(...n);
      let i = !0,
        s = !1,
        o = !1;
      const a = new Set(),
        l =
          e.type === "tick"
            ? queueMicrotask
            : e.type === "raf"
            ? w4e
            : e.type === "callback"
            ? e.queueNotification
            : fX(e.timeout),
        c = () => {
          (o = !1), s && ((s = !1), a.forEach((u) => u()));
        };
      return Object.assign({}, r, {
        subscribe(u) {
          const d = () => i && u(),
            f = r.subscribe(d);
          return (
            a.add(u),
            () => {
              f(), a.delete(u);
            }
          );
        },
        dispatch(u) {
          var d;
          try {
            return (
              (i = !((d = u == null ? void 0 : u.meta) != null && d[Eg])),
              (s = !i),
              s && (o || ((o = !0), l(c))),
              r.dispatch(u)
            );
          } finally {
            i = !0;
          }
        },
      });
    },
  x4e = (e) =>
    function (n) {
      const { autoBatch: r = !0 } = n ?? {};
      let i = new dX(e);
      return r && i.push(b4e(typeof r == "object" ? r : void 0)), i;
    },
  _4e = !0;
function S4e(e) {
  const t = v4e(),
    {
      reducer: n = void 0,
      middleware: r,
      devTools: i = !0,
      preloadedState: s = void 0,
      enhancers: o = void 0,
    } = e || {};
  let a;
  if (typeof n == "function") a = n;
  else if (Nd(n)) a = AR(n);
  else throw new Error(aa(1));
  let l;
  typeof r == "function" ? (l = r(t)) : (l = t());
  let c = p5;
  i && (c = m4e({ trace: !_4e, ...(typeof i == "object" && i) }));
  const u = V_e(...l),
    d = x4e(u);
  let f = typeof o == "function" ? o(d) : d();
  const h = c(...f);
  return ER(a, s, h);
}
function hX(e) {
  const t = {},
    n = [];
  let r;
  const i = {
    addCase(s, o) {
      const a = typeof s == "string" ? s : s.type;
      if (!a) throw new Error(aa(28));
      if (a in t) throw new Error(aa(29));
      return (t[a] = o), i;
    },
    addMatcher(s, o) {
      return n.push({ matcher: s, reducer: o }), i;
    },
    addDefaultCase(s) {
      return (r = s), i;
    },
  };
  return e(i), [t, n, r];
}
function E4e(e) {
  return typeof e == "function";
}
function A4e(e, t) {
  let [n, r, i] = hX(t),
    s;
  if (E4e(e)) s = () => PU(e());
  else {
    const a = PU(e);
    s = () => a;
  }
  function o(a = s(), l) {
    let c = [
      n[l.type],
      ...r.filter(({ matcher: u }) => u(l)).map(({ reducer: u }) => u),
    ];
    return (
      c.filter((u) => !!u).length === 0 && (c = [i]),
      c.reduce((u, d) => {
        if (d)
          if (Cu(u)) {
            const h = d(u, l);
            return h === void 0 ? u : h;
          } else {
            if (ku(u)) return Ax(u, (f) => d(f, l));
            {
              const f = d(u, l);
              if (f === void 0) {
                if (u === null) return u;
                throw new Error(aa(9));
              }
              return f;
            }
          }
        return u;
      }, a)
    );
  }
  return (o.getInitialState = s), o;
}
var C4e = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW",
  MR = (e = 21) => {
    let t = "",
      n = e;
    for (; n--; ) t += C4e[(Math.random() * 64) | 0];
    return t;
  },
  pX = (e, t) => (g4e(e) ? e.match(t) : e(t));
function Qp(...e) {
  return (t) => e.some((n) => pX(n, t));
}
function bw(...e) {
  return (t) => e.every((n) => pX(n, t));
}
function A8(e, t) {
  if (!e || !e.meta) return !1;
  const n = typeof e.meta.requestId == "string",
    r = t.indexOf(e.meta.requestStatus) > -1;
  return n && r;
}
function Cx(e) {
  return (
    typeof e[0] == "function" &&
    "pending" in e[0] &&
    "fulfilled" in e[0] &&
    "rejected" in e[0]
  );
}
function IR(...e) {
  return e.length === 0
    ? (t) => A8(t, ["pending"])
    : Cx(e)
    ? (t) => {
        const n = e.map((i) => i.pending);
        return Qp(...n)(t);
      }
    : IR()(e[0]);
}
function My(...e) {
  return e.length === 0
    ? (t) => A8(t, ["rejected"])
    : Cx(e)
    ? (t) => {
        const n = e.map((i) => i.rejected);
        return Qp(...n)(t);
      }
    : My()(e[0]);
}
function C8(...e) {
  const t = (n) => n && n.meta && n.meta.rejectedWithValue;
  return e.length === 0
    ? (n) => bw(My(...e), t)(n)
    : Cx(e)
    ? (n) => bw(My(...e), t)(n)
    : C8()(e[0]);
}
function Xp(...e) {
  return e.length === 0
    ? (t) => A8(t, ["fulfilled"])
    : Cx(e)
    ? (t) => {
        const n = e.map((i) => i.fulfilled);
        return Qp(...n)(t);
      }
    : Xp()(e[0]);
}
function OT(...e) {
  return e.length === 0
    ? (t) => A8(t, ["pending", "fulfilled", "rejected"])
    : Cx(e)
    ? (t) => {
        const n = [];
        for (const i of e) n.push(i.pending, i.rejected, i.fulfilled);
        return Qp(...n)(t);
      }
    : OT()(e[0]);
}
var k4e = ["name", "message", "stack", "code"],
  lC = class {
    constructor(e, t) {
      Ls(this, "_type");
      (this.payload = e), (this.meta = t);
    }
  },
  jU = class {
    constructor(e, t) {
      Ls(this, "_type");
      (this.payload = e), (this.meta = t);
    }
  },
  T4e = (e) => {
    if (typeof e == "object" && e !== null) {
      const t = {};
      for (const n of k4e) typeof e[n] == "string" && (t[n] = e[n]);
      return t;
    }
    return { message: String(e) };
  },
  Zr = (() => {
    function e(t, n, r) {
      const i = ka(t + "/fulfilled", (l, c, u, d) => ({
          payload: l,
          meta: {
            ...(d || {}),
            arg: u,
            requestId: c,
            requestStatus: "fulfilled",
          },
        })),
        s = ka(t + "/pending", (l, c, u) => ({
          payload: void 0,
          meta: {
            ...(u || {}),
            arg: c,
            requestId: l,
            requestStatus: "pending",
          },
        })),
        o = ka(t + "/rejected", (l, c, u, d, f) => ({
          payload: d,
          error: ((r && r.serializeError) || T4e)(l || "Rejected"),
          meta: {
            ...(f || {}),
            arg: u,
            requestId: c,
            rejectedWithValue: !!d,
            requestStatus: "rejected",
            aborted: (l == null ? void 0 : l.name) === "AbortError",
            condition: (l == null ? void 0 : l.name) === "ConditionError",
          },
        }));
      function a(l) {
        return (c, u, d) => {
          const f = r != null && r.idGenerator ? r.idGenerator(l) : MR(),
            h = new AbortController();
          let p, g;
          function b(w) {
            (g = w), h.abort();
          }
          const v = (async function () {
            var S, R;
            let w;
            try {
              let O =
                (S = r == null ? void 0 : r.condition) == null
                  ? void 0
                  : S.call(r, l, { getState: u, extra: d });
              if ((I4e(O) && (O = await O), O === !1 || h.signal.aborted))
                throw {
                  name: "ConditionError",
                  message: "Aborted due to condition callback returning false.",
                };
              const B = new Promise((C, I) => {
                (p = () => {
                  I({ name: "AbortError", message: g || "Aborted" });
                }),
                  h.signal.addEventListener("abort", p);
              });
              c(
                s(
                  f,
                  l,
                  (R = r == null ? void 0 : r.getPendingMeta) == null
                    ? void 0
                    : R.call(
                        r,
                        { requestId: f, arg: l },
                        { getState: u, extra: d }
                      )
                )
              ),
                (w = await Promise.race([
                  B,
                  Promise.resolve(
                    n(l, {
                      dispatch: c,
                      getState: u,
                      extra: d,
                      requestId: f,
                      signal: h.signal,
                      abort: b,
                      rejectWithValue: (C, I) => new lC(C, I),
                      fulfillWithValue: (C, I) => new jU(C, I),
                    })
                  ).then((C) => {
                    if (C instanceof lC) throw C;
                    return C instanceof jU
                      ? i(C.payload, f, l, C.meta)
                      : i(C, f, l);
                  }),
                ]));
            } catch (O) {
              w =
                O instanceof lC ? o(null, f, l, O.payload, O.meta) : o(O, f, l);
            } finally {
              p && h.signal.removeEventListener("abort", p);
            }
            return (
              (r &&
                !r.dispatchConditionRejection &&
                o.match(w) &&
                w.meta.condition) ||
                c(w),
              w
            );
          })();
          return Object.assign(v, {
            abort: b,
            requestId: f,
            arg: l,
            unwrap() {
              return v.then(M4e);
            },
          });
        };
      }
      return Object.assign(a, {
        pending: s,
        rejected: o,
        fulfilled: i,
        settled: Qp(o, i),
        typePrefix: t,
      });
    }
    return (e.withTypes = () => e), e;
  })();
function M4e(e) {
  if (e.meta && e.meta.rejectedWithValue) throw e.payload;
  if (e.error) throw e.error;
  return e.payload;
}
function I4e(e) {
  return e !== null && typeof e == "object" && typeof e.then == "function";
}
var N4e = Symbol.for("rtk-slice-createasyncthunk");
function R4e(e, t) {
  return `${e}/${t}`;
}
function O4e({ creators: e } = {}) {
  var n;
  const t = (n = e == null ? void 0 : e.asyncThunk) == null ? void 0 : n[N4e];
  return function (i) {
    const { name: s, reducerPath: o = s } = i;
    if (!s) throw new Error(aa(11));
    typeof Hs < "u";
    const a =
        (typeof i.reducers == "function" ? i.reducers(L4e()) : i.reducers) ||
        {},
      l = Object.keys(a),
      c = {
        sliceCaseReducersByName: {},
        sliceCaseReducersByType: {},
        actionCreators: {},
        sliceMatchers: [],
      },
      u = {
        addCase(x, S) {
          const R = typeof x == "string" ? x : x.type;
          if (!R) throw new Error(aa(12));
          if (R in c.sliceCaseReducersByType) throw new Error(aa(13));
          return (c.sliceCaseReducersByType[R] = S), u;
        },
        addMatcher(x, S) {
          return c.sliceMatchers.push({ matcher: x, reducer: S }), u;
        },
        exposeAction(x, S) {
          return (c.actionCreators[x] = S), u;
        },
        exposeCaseReducer(x, S) {
          return (c.sliceCaseReducersByName[x] = S), u;
        },
      };
    l.forEach((x) => {
      const S = a[x],
        R = {
          reducerName: x,
          type: R4e(s, x),
          createNotation: typeof i.reducers == "function",
        };
      D4e(S) ? F4e(R, S, u, t) : j4e(R, S, u);
    });
    function d() {
      const [x = {}, S = [], R = void 0] =
          typeof i.extraReducers == "function"
            ? hX(i.extraReducers)
            : [i.extraReducers],
        O = { ...x, ...c.sliceCaseReducersByType };
      return A4e(i.initialState, (B) => {
        for (let C in O) B.addCase(C, O[C]);
        for (let C of c.sliceMatchers) B.addMatcher(C.matcher, C.reducer);
        for (let C of S) B.addMatcher(C.matcher, C.reducer);
        R && B.addDefaultCase(R);
      });
    }
    const f = (x) => x,
      h = new Map();
    let p;
    function g(x, S) {
      return p || (p = d()), p(x, S);
    }
    function b() {
      return p || (p = d()), p.getInitialState();
    }
    function v(x, S = !1) {
      function R(B) {
        let C = B[x];
        return typeof C > "u" && S && (C = b()), C;
      }
      function O(B = f) {
        const C = LU(h, S, { insert: () => new WeakMap() });
        return LU(C, B, {
          insert: () => {
            const I = {};
            for (const [P, M] of Object.entries(i.selectors ?? {}))
              I[P] = P4e(M, B, b, S);
            return I;
          },
        });
      }
      return {
        reducerPath: x,
        getSelectors: O,
        get selectors() {
          return O(R);
        },
        selectSlice: R,
      };
    }
    const w = {
      name: s,
      reducer: g,
      actions: c.actionCreators,
      caseReducers: c.sliceCaseReducersByName,
      getInitialState: b,
      ...v(o),
      injectInto(x, { reducerPath: S, ...R } = {}) {
        const O = S ?? o;
        return (
          x.inject({ reducerPath: O, reducer: g }, R), { ...w, ...v(O, !0) }
        );
      },
    };
    return w;
  };
}
function P4e(e, t, n, r) {
  function i(s, ...o) {
    let a = t(s);
    return typeof a > "u" && r && (a = n()), e(a, ...o);
  }
  return (i.unwrapped = e), i;
}
var W0 = O4e();
function L4e() {
  function e(t, n) {
    return { _reducerDefinitionType: "asyncThunk", payloadCreator: t, ...n };
  }
  return (
    (e.withTypes = () => e),
    {
      reducer(t) {
        return Object.assign(
          {
            [t.name](...n) {
              return t(...n);
            },
          }[t.name],
          { _reducerDefinitionType: "reducer" }
        );
      },
      preparedReducer(t, n) {
        return {
          _reducerDefinitionType: "reducerWithPrepare",
          prepare: t,
          reducer: n,
        };
      },
      asyncThunk: e,
    }
  );
}
function j4e({ type: e, reducerName: t, createNotation: n }, r, i) {
  let s, o;
  if ("reducer" in r) {
    if (n && !B4e(r)) throw new Error(aa(17));
    (s = r.reducer), (o = r.prepare);
  } else s = r;
  i.addCase(e, s)
    .exposeCaseReducer(t, s)
    .exposeAction(t, o ? ka(e, o) : ka(e));
}
function D4e(e) {
  return e._reducerDefinitionType === "asyncThunk";
}
function B4e(e) {
  return e._reducerDefinitionType === "reducerWithPrepare";
}
function F4e({ type: e, reducerName: t }, n, r, i) {
  if (!i) throw new Error(aa(18));
  const {
      payloadCreator: s,
      fulfilled: o,
      pending: a,
      rejected: l,
      settled: c,
      options: u,
    } = n,
    d = i(e, s, u);
  r.exposeAction(t, d),
    o && r.addCase(d.fulfilled, o),
    a && r.addCase(d.pending, a),
    l && r.addCase(d.rejected, l),
    c && r.addMatcher(d.settled, c),
    r.exposeCaseReducer(t, {
      fulfilled: o || I_,
      pending: a || I_,
      rejected: l || I_,
      settled: c || I_,
    });
}
function I_() {}
var U4e = (e, t) => {
    if (typeof e != "function") throw new Error(aa(32));
  },
  NR = "listenerMiddleware",
  $4e = (e) => {
    let { type: t, actionCreator: n, matcher: r, predicate: i, effect: s } = e;
    if (t) i = ka(t).match;
    else if (n) (t = n.type), (i = n.match);
    else if (r) i = r;
    else if (!i) throw new Error(aa(21));
    return U4e(s), { predicate: i, type: t, effect: s };
  },
  z4e = Object.assign(
    (e) => {
      const { type: t, predicate: n, effect: r } = $4e(e);
      return {
        id: MR(),
        effect: r,
        type: t,
        predicate: n,
        pending: new Set(),
        unsubscribe: () => {
          throw new Error(aa(22));
        },
      };
    },
    { withTypes: () => z4e }
  ),
  W4e = Object.assign(ka(`${NR}/add`), { withTypes: () => W4e });
ka(`${NR}/removeAll`);
var H4e = Object.assign(ka(`${NR}/remove`), { withTypes: () => H4e });
function aa(e) {
  return `Minified Redux Toolkit error #${e}; visit https://redux-toolkit.js.org/Errors?code=${e} for the full message or use the non-minified dev environment for full errors. `;
}
var RR = "persist:",
  mX = "persist/FLUSH",
  OR = "persist/REHYDRATE",
  gX = "persist/PAUSE",
  yX = "persist/PERSIST",
  vX = "persist/PURGE",
  wX = "persist/REGISTER",
  V4e = -1;
function L4(e) {
  return (
    typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
      ? (L4 = function (n) {
          return typeof n;
        })
      : (L4 = function (n) {
          return n &&
            typeof Symbol == "function" &&
            n.constructor === Symbol &&
            n !== Symbol.prototype
            ? "symbol"
            : typeof n;
        }),
    L4(e)
  );
}
function DU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable;
      })),
      n.push.apply(n, r);
  }
  return n;
}
function G4e(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2
      ? DU(n, !0).forEach(function (r) {
          q4e(e, r, n[r]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
      : DU(n).forEach(function (r) {
          Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
        });
  }
  return e;
}
function q4e(e, t, n) {
  return (
    t in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (e[t] = n),
    e
  );
}
function K4e(e, t, n, r) {
  r.debug;
  var i = G4e({}, n);
  return (
    e &&
      L4(e) === "object" &&
      Object.keys(e).forEach(function (s) {
        s !== "_persist" && t[s] === n[s] && (i[s] = e[s]);
      }),
    i
  );
}
function Y4e(e) {
  var t = e.blacklist || null,
    n = e.whitelist || null,
    r = e.transforms || [],
    i = e.throttle || 0,
    s = "".concat(e.keyPrefix !== void 0 ? e.keyPrefix : RR).concat(e.key),
    o = e.storage,
    a;
  e.serialize === !1
    ? (a = function (R) {
        return R;
      })
    : typeof e.serialize == "function"
    ? (a = e.serialize)
    : (a = Z4e);
  var l = e.writeFailHandler || null,
    c = {},
    u = {},
    d = [],
    f = null,
    h = null,
    p = function (R) {
      Object.keys(R).forEach(function (O) {
        v(O) && c[O] !== R[O] && d.indexOf(O) === -1 && d.push(O);
      }),
        Object.keys(c).forEach(function (O) {
          R[O] === void 0 &&
            v(O) &&
            d.indexOf(O) === -1 &&
            c[O] !== void 0 &&
            d.push(O);
        }),
        f === null && (f = setInterval(g, i)),
        (c = R);
    };
  function g() {
    if (d.length === 0) {
      f && clearInterval(f), (f = null);
      return;
    }
    var S = d.shift(),
      R = r.reduce(function (O, B) {
        return B.in(O, S, c);
      }, c[S]);
    if (R !== void 0)
      try {
        u[S] = a(R);
      } catch (O) {
        console.error(
          "redux-persist/createPersistoid: error serializing state",
          O
        );
      }
    else delete u[S];
    d.length === 0 && b();
  }
  function b() {
    Object.keys(u).forEach(function (S) {
      c[S] === void 0 && delete u[S];
    }),
      (h = o.setItem(s, a(u)).catch(w));
  }
  function v(S) {
    return !(
      (n && n.indexOf(S) === -1 && S !== "_persist") ||
      (t && t.indexOf(S) !== -1)
    );
  }
  function w(S) {
    l && l(S);
  }
  var x = function () {
    for (; d.length !== 0; ) g();
    return h || Promise.resolve();
  };
  return { update: p, flush: x };
}
function Z4e(e) {
  return JSON.stringify(e);
}
function Q4e(e) {
  var t = e.transforms || [],
    n = "".concat(e.keyPrefix !== void 0 ? e.keyPrefix : RR).concat(e.key),
    r = e.storage;
  e.debug;
  var i;
  return (
    e.deserialize === !1
      ? (i = function (o) {
          return o;
        })
      : typeof e.deserialize == "function"
      ? (i = e.deserialize)
      : (i = X4e),
    r.getItem(n).then(function (s) {
      if (s)
        try {
          var o = {},
            a = i(s);
          return (
            Object.keys(a).forEach(function (l) {
              o[l] = t.reduceRight(function (c, u) {
                return u.out(c, l, a);
              }, i(a[l]));
            }),
            o
          );
        } catch (l) {
          throw l;
        }
      else return;
    })
  );
}
function X4e(e) {
  return JSON.parse(e);
}
function J4e(e) {
  var t = e.storage,
    n = "".concat(e.keyPrefix !== void 0 ? e.keyPrefix : RR).concat(e.key);
  return t.removeItem(n, e6e);
}
function e6e(e) {}
function BU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable;
      })),
      n.push.apply(n, r);
  }
  return n;
}
function mf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2
      ? BU(n, !0).forEach(function (r) {
          t6e(e, r, n[r]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
      : BU(n).forEach(function (r) {
          Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
        });
  }
  return e;
}
function t6e(e, t, n) {
  return (
    t in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (e[t] = n),
    e
  );
}
function n6e(e, t) {
  if (e == null) return {};
  var n = r6e(e, t),
    r,
    i;
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(e);
    for (i = 0; i < s.length; i++)
      (r = s[i]),
        !(t.indexOf(r) >= 0) &&
          Object.prototype.propertyIsEnumerable.call(e, r) &&
          (n[r] = e[r]);
  }
  return n;
}
function r6e(e, t) {
  if (e == null) return {};
  var n = {},
    r = Object.keys(e),
    i,
    s;
  for (s = 0; s < r.length; s++)
    (i = r[s]), !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
var i6e = 5e3;
function s6e(e, t) {
  var n = e.version !== void 0 ? e.version : V4e;
  e.debug;
  var r = e.stateReconciler === void 0 ? K4e : e.stateReconciler,
    i = e.getStoredState || Q4e,
    s = e.timeout !== void 0 ? e.timeout : i6e,
    o = null,
    a = !1,
    l = !0,
    c = function (d) {
      return d._persist.rehydrated && o && !l && o.update(d), d;
    };
  return function (u, d) {
    var f = u || {},
      h = f._persist,
      p = n6e(f, ["_persist"]),
      g = p;
    if (d.type === yX) {
      var b = !1,
        v = function (C, I) {
          b || (d.rehydrate(e.key, C, I), (b = !0));
        };
      if (
        (s &&
          setTimeout(function () {
            !b &&
              v(
                void 0,
                new Error(
                  'redux-persist: persist timed out for persist key "'.concat(
                    e.key,
                    '"'
                  )
                )
              );
          }, s),
        (l = !1),
        o || (o = Y4e(e)),
        h)
      )
        return mf({}, t(g, d), { _persist: h });
      if (typeof d.rehydrate != "function" || typeof d.register != "function")
        throw new Error(
          "redux-persist: either rehydrate or register is not a function on the PERSIST action. This can happen if the action is being replayed. This is an unexplored use case, please open an issue and we will figure out a resolution."
        );
      return (
        d.register(e.key),
        i(e).then(
          function (B) {
            var C =
              e.migrate ||
              function (I, P) {
                return Promise.resolve(I);
              };
            C(B, n).then(
              function (I) {
                v(I);
              },
              function (I) {
                v(void 0, I);
              }
            );
          },
          function (B) {
            v(void 0, B);
          }
        ),
        mf({}, t(g, d), { _persist: { version: n, rehydrated: !1 } })
      );
    } else {
      if (d.type === vX)
        return (a = !0), d.result(J4e(e)), mf({}, t(g, d), { _persist: h });
      if (d.type === mX)
        return d.result(o && o.flush()), mf({}, t(g, d), { _persist: h });
      if (d.type === gX) l = !0;
      else if (d.type === OR) {
        if (a) return mf({}, g, { _persist: mf({}, h, { rehydrated: !0 }) });
        if (d.key === e.key) {
          var w = t(g, d),
            x = d.payload,
            S = r !== !1 && x !== void 0 ? r(x, u, w, e) : w,
            R = mf({}, S, { _persist: mf({}, h, { rehydrated: !0 }) });
          return c(R);
        }
      }
    }
    if (!h) return t(u, d);
    var O = t(g, d);
    return O === g ? u : c(mf({}, O, { _persist: h }));
  };
}
function FU(e) {
  return l6e(e) || a6e(e) || o6e();
}
function o6e() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}
function a6e(e) {
  if (
    Symbol.iterator in Object(e) ||
    Object.prototype.toString.call(e) === "[object Arguments]"
  )
    return Array.from(e);
}
function l6e(e) {
  if (Array.isArray(e)) {
    for (var t = 0, n = new Array(e.length); t < e.length; t++) n[t] = e[t];
    return n;
  }
}
function UU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable;
      })),
      n.push.apply(n, r);
  }
  return n;
}
function PT(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2
      ? UU(n, !0).forEach(function (r) {
          c6e(e, r, n[r]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
      : UU(n).forEach(function (r) {
          Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
        });
  }
  return e;
}
function c6e(e, t, n) {
  return (
    t in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (e[t] = n),
    e
  );
}
var bX = { registry: [], bootstrapped: !1 },
  u6e = function () {
    var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : bX,
      n = arguments.length > 1 ? arguments[1] : void 0;
    switch (n.type) {
      case wX:
        return PT({}, t, { registry: [].concat(FU(t.registry), [n.key]) });
      case OR:
        var r = t.registry.indexOf(n.key),
          i = FU(t.registry);
        return (
          i.splice(r, 1),
          PT({}, t, { registry: i, bootstrapped: i.length === 0 })
        );
      default:
        return t;
    }
  };
function d6e(e, t, n) {
  var r = ER(u6e, bX, void 0),
    i = function (l) {
      r.dispatch({ type: wX, key: l });
    },
    s = function (l, c, u) {
      var d = { type: OR, payload: c, err: u, key: l };
      e.dispatch(d), r.dispatch(d);
    },
    o = PT({}, r, {
      purge: function () {
        var l = [];
        return (
          e.dispatch({
            type: vX,
            result: function (u) {
              l.push(u);
            },
          }),
          Promise.all(l)
        );
      },
      flush: function () {
        var l = [];
        return (
          e.dispatch({
            type: mX,
            result: function (u) {
              l.push(u);
            },
          }),
          Promise.all(l)
        );
      },
      pause: function () {
        e.dispatch({ type: gX });
      },
      persist: function () {
        e.dispatch({ type: yX, register: i, rehydrate: s });
      },
    });
  return o.persist(), o;
}
var PR = {},
  LR = {};
LR.__esModule = !0;
LR.default = p6e;
function j4(e) {
  return (
    typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
      ? (j4 = function (n) {
          return typeof n;
        })
      : (j4 = function (n) {
          return n &&
            typeof Symbol == "function" &&
            n.constructor === Symbol &&
            n !== Symbol.prototype
            ? "symbol"
            : typeof n;
        }),
    j4(e)
  );
}
function cC() {}
var f6e = { getItem: cC, setItem: cC, removeItem: cC };
function h6e(e) {
  if ((typeof self > "u" ? "undefined" : j4(self)) !== "object" || !(e in self))
    return !1;
  try {
    var t = self[e],
      n = "redux-persist ".concat(e, " test");
    t.setItem(n, "test"), t.getItem(n), t.removeItem(n);
  } catch {
    return !1;
  }
  return !0;
}
function p6e(e) {
  var t = "".concat(e, "Storage");
  return h6e(t) ? self[t] : f6e;
}
PR.__esModule = !0;
PR.default = y6e;
var m6e = g6e(LR);
function g6e(e) {
  return e && e.__esModule ? e : { default: e };
}
function y6e(e) {
  var t = (0, m6e.default)(e);
  return {
    getItem: function (r) {
      return new Promise(function (i, s) {
        i(t.getItem(r));
      });
    },
    setItem: function (r, i) {
      return new Promise(function (s, o) {
        s(t.setItem(r, i));
      });
    },
    removeItem: function (r) {
      return new Promise(function (i, s) {
        i(t.removeItem(r));
      });
    },
  };
}
var xX = void 0,
  v6e = w6e(PR);
function w6e(e) {
  return e && e.__esModule ? e : { default: e };
}
var b6e = (0, v6e.default)("local");
xX = b6e;
var x6e = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
  uC = Math.ceil,
  uc = Math.floor,
  Ha = "[BigNumber Error] ",
  $U = Ha + "Number primitive has more than 15 significant digits: ",
  nu = 1e14,
  Un = 14,
  dC = 9007199254740991,
  fC = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
  Xh = 1e7,
  fo = 1e9;
function _X(e) {
  var t,
    n,
    r,
    i = (w.prototype = { constructor: w, toString: null, valueOf: null }),
    s = new w(1),
    o = 20,
    a = 4,
    l = -7,
    c = 21,
    u = -1e7,
    d = 1e7,
    f = !1,
    h = 1,
    p = 0,
    g = {
      prefix: "",
      groupSize: 3,
      secondaryGroupSize: 0,
      groupSeparator: ",",
      decimalSeparator: ".",
      fractionGroupSize: 0,
      fractionGroupSeparator: " ",
      suffix: "",
    },
    b = "0123456789abcdefghijklmnopqrstuvwxyz",
    v = !0;
  function w(C, I) {
    var P,
      M,
      k,
      T,
      _,
      A,
      N,
      L,
      F = this;
    if (!(F instanceof w)) return new w(C, I);
    if (I == null) {
      if (C && C._isBigNumber === !0) {
        (F.s = C.s),
          !C.c || C.e > d
            ? (F.c = F.e = null)
            : C.e < u
            ? (F.c = [(F.e = 0)])
            : ((F.e = C.e), (F.c = C.c.slice()));
        return;
      }
      if ((A = typeof C == "number") && C * 0 == 0) {
        if (((F.s = 1 / C < 0 ? ((C = -C), -1) : 1), C === ~~C)) {
          for (T = 0, _ = C; _ >= 10; _ /= 10, T++);
          T > d ? (F.c = F.e = null) : ((F.e = T), (F.c = [C]));
          return;
        }
        L = String(C);
      } else {
        if (!x6e.test((L = String(C)))) return r(F, L, A);
        F.s = L.charCodeAt(0) == 45 ? ((L = L.slice(1)), -1) : 1;
      }
      (T = L.indexOf(".")) > -1 && (L = L.replace(".", "")),
        (_ = L.search(/e/i)) > 0
          ? (T < 0 && (T = _), (T += +L.slice(_ + 1)), (L = L.substring(0, _)))
          : T < 0 && (T = L.length);
    } else {
      if ((os(I, 2, b.length, "Base"), I == 10 && v))
        return (F = new w(C)), O(F, o + F.e + 1, a);
      if (((L = String(C)), (A = typeof C == "number"))) {
        if (C * 0 != 0) return r(F, L, A, I);
        if (
          ((F.s = 1 / C < 0 ? ((L = L.slice(1)), -1) : 1),
          w.DEBUG && L.replace(/^0\.0*|\./, "").length > 15)
        )
          throw Error($U + C);
      } else F.s = L.charCodeAt(0) === 45 ? ((L = L.slice(1)), -1) : 1;
      for (P = b.slice(0, I), T = _ = 0, N = L.length; _ < N; _++)
        if (P.indexOf((M = L.charAt(_))) < 0) {
          if (M == ".") {
            if (_ > T) {
              T = N;
              continue;
            }
          } else if (
            !k &&
            ((L == L.toUpperCase() && (L = L.toLowerCase())) ||
              (L == L.toLowerCase() && (L = L.toUpperCase())))
          ) {
            (k = !0), (_ = -1), (T = 0);
            continue;
          }
          return r(F, String(C), A, I);
        }
      (A = !1),
        (L = n(L, I, 10, F.s)),
        (T = L.indexOf(".")) > -1 ? (L = L.replace(".", "")) : (T = L.length);
    }
    for (_ = 0; L.charCodeAt(_) === 48; _++);
    for (N = L.length; L.charCodeAt(--N) === 48; );
    if ((L = L.slice(_, ++N))) {
      if (((N -= _), A && w.DEBUG && N > 15 && (C > dC || C !== uc(C))))
        throw Error($U + F.s * C);
      if ((T = T - _ - 1) > d) F.c = F.e = null;
      else if (T < u) F.c = [(F.e = 0)];
      else {
        if (
          ((F.e = T), (F.c = []), (_ = (T + 1) % Un), T < 0 && (_ += Un), _ < N)
        ) {
          for (_ && F.c.push(+L.slice(0, _)), N -= Un; _ < N; )
            F.c.push(+L.slice(_, (_ += Un)));
          _ = Un - (L = L.slice(_)).length;
        } else _ -= N;
        for (; _--; L += "0");
        F.c.push(+L);
      }
    } else F.c = [(F.e = 0)];
  }
  (w.clone = _X),
    (w.ROUND_UP = 0),
    (w.ROUND_DOWN = 1),
    (w.ROUND_CEIL = 2),
    (w.ROUND_FLOOR = 3),
    (w.ROUND_HALF_UP = 4),
    (w.ROUND_HALF_DOWN = 5),
    (w.ROUND_HALF_EVEN = 6),
    (w.ROUND_HALF_CEIL = 7),
    (w.ROUND_HALF_FLOOR = 8),
    (w.EUCLID = 9),
    (w.config = w.set =
      function (C) {
        var I, P;
        if (C != null)
          if (typeof C == "object") {
            if (
              (C.hasOwnProperty((I = "DECIMAL_PLACES")) &&
                ((P = C[I]), os(P, 0, fo, I), (o = P)),
              C.hasOwnProperty((I = "ROUNDING_MODE")) &&
                ((P = C[I]), os(P, 0, 8, I), (a = P)),
              C.hasOwnProperty((I = "EXPONENTIAL_AT")) &&
                ((P = C[I]),
                P && P.pop
                  ? (os(P[0], -fo, 0, I),
                    os(P[1], 0, fo, I),
                    (l = P[0]),
                    (c = P[1]))
                  : (os(P, -fo, fo, I), (l = -(c = P < 0 ? -P : P)))),
              C.hasOwnProperty((I = "RANGE")))
            )
              if (((P = C[I]), P && P.pop))
                os(P[0], -fo, -1, I),
                  os(P[1], 1, fo, I),
                  (u = P[0]),
                  (d = P[1]);
              else if ((os(P, -fo, fo, I), P)) u = -(d = P < 0 ? -P : P);
              else throw Error(Ha + I + " cannot be zero: " + P);
            if (C.hasOwnProperty((I = "CRYPTO")))
              if (((P = C[I]), P === !!P))
                if (P)
                  if (
                    typeof crypto < "u" &&
                    crypto &&
                    (crypto.getRandomValues || crypto.randomBytes)
                  )
                    f = P;
                  else throw ((f = !P), Error(Ha + "crypto unavailable"));
                else f = P;
              else throw Error(Ha + I + " not true or false: " + P);
            if (
              (C.hasOwnProperty((I = "MODULO_MODE")) &&
                ((P = C[I]), os(P, 0, 9, I), (h = P)),
              C.hasOwnProperty((I = "POW_PRECISION")) &&
                ((P = C[I]), os(P, 0, fo, I), (p = P)),
              C.hasOwnProperty((I = "FORMAT")))
            )
              if (((P = C[I]), typeof P == "object")) g = P;
              else throw Error(Ha + I + " not an object: " + P);
            if (C.hasOwnProperty((I = "ALPHABET")))
              if (
                ((P = C[I]),
                typeof P == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(P))
              )
                (v = P.slice(0, 10) == "0123456789"), (b = P);
              else throw Error(Ha + I + " invalid: " + P);
          } else throw Error(Ha + "Object expected: " + C);
        return {
          DECIMAL_PLACES: o,
          ROUNDING_MODE: a,
          EXPONENTIAL_AT: [l, c],
          RANGE: [u, d],
          CRYPTO: f,
          MODULO_MODE: h,
          POW_PRECISION: p,
          FORMAT: g,
          ALPHABET: b,
        };
      }),
    (w.isBigNumber = function (C) {
      if (!C || C._isBigNumber !== !0) return !1;
      if (!w.DEBUG) return !0;
      var I,
        P,
        M = C.c,
        k = C.e,
        T = C.s;
      e: if ({}.toString.call(M) == "[object Array]") {
        if ((T === 1 || T === -1) && k >= -fo && k <= fo && k === uc(k)) {
          if (M[0] === 0) {
            if (k === 0 && M.length === 1) return !0;
            break e;
          }
          if (
            ((I = (k + 1) % Un), I < 1 && (I += Un), String(M[0]).length == I)
          ) {
            for (I = 0; I < M.length; I++)
              if (((P = M[I]), P < 0 || P >= nu || P !== uc(P))) break e;
            if (P !== 0) return !0;
          }
        }
      } else if (
        M === null &&
        k === null &&
        (T === null || T === 1 || T === -1)
      )
        return !0;
      throw Error(Ha + "Invalid BigNumber: " + C);
    }),
    (w.maximum = w.max =
      function () {
        return S(arguments, -1);
      }),
    (w.minimum = w.min =
      function () {
        return S(arguments, 1);
      }),
    (w.random = (function () {
      var C = 9007199254740992,
        I =
          (Math.random() * C) & 2097151
            ? function () {
                return uc(Math.random() * C);
              }
            : function () {
                return (
                  ((Math.random() * 1073741824) | 0) * 8388608 +
                  ((Math.random() * 8388608) | 0)
                );
              };
      return function (P) {
        var M,
          k,
          T,
          _,
          A,
          N = 0,
          L = [],
          F = new w(s);
        if ((P == null ? (P = o) : os(P, 0, fo), (_ = uC(P / Un)), f))
          if (crypto.getRandomValues) {
            for (M = crypto.getRandomValues(new Uint32Array((_ *= 2))); N < _; )
              (A = M[N] * 131072 + (M[N + 1] >>> 11)),
                A >= 9e15
                  ? ((k = crypto.getRandomValues(new Uint32Array(2))),
                    (M[N] = k[0]),
                    (M[N + 1] = k[1]))
                  : (L.push(A % 1e14), (N += 2));
            N = _ / 2;
          } else if (crypto.randomBytes) {
            for (M = crypto.randomBytes((_ *= 7)); N < _; )
              (A =
                (M[N] & 31) * 281474976710656 +
                M[N + 1] * 1099511627776 +
                M[N + 2] * 4294967296 +
                M[N + 3] * 16777216 +
                (M[N + 4] << 16) +
                (M[N + 5] << 8) +
                M[N + 6]),
                A >= 9e15
                  ? crypto.randomBytes(7).copy(M, N)
                  : (L.push(A % 1e14), (N += 7));
            N = _ / 7;
          } else throw ((f = !1), Error(Ha + "crypto unavailable"));
        if (!f) for (; N < _; ) (A = I()), A < 9e15 && (L[N++] = A % 1e14);
        for (
          _ = L[--N],
            P %= Un,
            _ && P && ((A = fC[Un - P]), (L[N] = uc(_ / A) * A));
          L[N] === 0;
          L.pop(), N--
        );
        if (N < 0) L = [(T = 0)];
        else {
          for (T = -1; L[0] === 0; L.splice(0, 1), T -= Un);
          for (N = 1, A = L[0]; A >= 10; A /= 10, N++);
          N < Un && (T -= Un - N);
        }
        return (F.e = T), (F.c = L), F;
      };
    })()),
    (w.sum = function () {
      for (var C = 1, I = arguments, P = new w(I[0]); C < I.length; )
        P = P.plus(I[C++]);
      return P;
    }),
    (n = (function () {
      var C = "0123456789";
      function I(P, M, k, T) {
        for (var _, A = [0], N, L = 0, F = P.length; L < F; ) {
          for (N = A.length; N--; A[N] *= M);
          for (A[0] += T.indexOf(P.charAt(L++)), _ = 0; _ < A.length; _++)
            A[_] > k - 1 &&
              (A[_ + 1] == null && (A[_ + 1] = 0),
              (A[_ + 1] += (A[_] / k) | 0),
              (A[_] %= k));
        }
        return A.reverse();
      }
      return function (P, M, k, T, _) {
        var A,
          N,
          L,
          F,
          D,
          j,
          z,
          $,
          K = P.indexOf("."),
          re = o,
          G = a;
        for (
          K >= 0 &&
            ((F = p),
            (p = 0),
            (P = P.replace(".", "")),
            ($ = new w(M)),
            (j = $.pow(P.length - K)),
            (p = F),
            ($.c = I(gf(ac(j.c), j.e, "0"), 10, k, C)),
            ($.e = $.c.length)),
            z = I(P, M, k, _ ? ((A = b), C) : ((A = C), b)),
            L = F = z.length;
          z[--F] == 0;
          z.pop()
        );
        if (!z[0]) return A.charAt(0);
        if (
          (K < 0
            ? --L
            : ((j.c = z),
              (j.e = L),
              (j.s = T),
              (j = t(j, $, re, G, k)),
              (z = j.c),
              (D = j.r),
              (L = j.e)),
          (N = L + re + 1),
          (K = z[N]),
          (F = k / 2),
          (D = D || N < 0 || z[N + 1] != null),
          (D =
            G < 4
              ? (K != null || D) && (G == 0 || G == (j.s < 0 ? 3 : 2))
              : K > F ||
                (K == F &&
                  (G == 4 ||
                    D ||
                    (G == 6 && z[N - 1] & 1) ||
                    G == (j.s < 0 ? 8 : 7)))),
          N < 1 || !z[0])
        )
          P = D ? gf(A.charAt(1), -re, A.charAt(0)) : A.charAt(0);
        else {
          if (((z.length = N), D))
            for (--k; ++z[--N] > k; )
              (z[N] = 0), N || (++L, (z = [1].concat(z)));
          for (F = z.length; !z[--F]; );
          for (K = 0, P = ""; K <= F; P += A.charAt(z[K++]));
          P = gf(P, L, A.charAt(0));
        }
        return P;
      };
    })()),
    (t = (function () {
      function C(M, k, T) {
        var _,
          A,
          N,
          L,
          F = 0,
          D = M.length,
          j = k % Xh,
          z = (k / Xh) | 0;
        for (M = M.slice(); D--; )
          (N = M[D] % Xh),
            (L = (M[D] / Xh) | 0),
            (_ = z * N + L * j),
            (A = j * N + (_ % Xh) * Xh + F),
            (F = ((A / T) | 0) + ((_ / Xh) | 0) + z * L),
            (M[D] = A % T);
        return F && (M = [F].concat(M)), M;
      }
      function I(M, k, T, _) {
        var A, N;
        if (T != _) N = T > _ ? 1 : -1;
        else
          for (A = N = 0; A < T; A++)
            if (M[A] != k[A]) {
              N = M[A] > k[A] ? 1 : -1;
              break;
            }
        return N;
      }
      function P(M, k, T, _) {
        for (var A = 0; T--; )
          (M[T] -= A), (A = M[T] < k[T] ? 1 : 0), (M[T] = A * _ + M[T] - k[T]);
        for (; !M[0] && M.length > 1; M.splice(0, 1));
      }
      return function (M, k, T, _, A) {
        var N,
          L,
          F,
          D,
          j,
          z,
          $,
          K,
          re,
          G,
          ne,
          ae,
          le,
          ge,
          Oe,
          _e,
          Ee,
          He = M.s == k.s ? 1 : -1,
          je = M.c,
          Be = k.c;
        if (!je || !je[0] || !Be || !Be[0])
          return new w(
            !M.s || !k.s || (je ? Be && je[0] == Be[0] : !Be)
              ? NaN
              : (je && je[0] == 0) || !Be
              ? He * 0
              : He / 0
          );
        for (
          K = new w(He),
            re = K.c = [],
            L = M.e - k.e,
            He = T + L + 1,
            A ||
              ((A = nu),
              (L = dc(M.e / Un) - dc(k.e / Un)),
              (He = (He / Un) | 0)),
            F = 0;
          Be[F] == (je[F] || 0);
          F++
        );
        if ((Be[F] > (je[F] || 0) && L--, He < 0)) re.push(1), (D = !0);
        else {
          for (
            ge = je.length,
              _e = Be.length,
              F = 0,
              He += 2,
              j = uc(A / (Be[0] + 1)),
              j > 1 &&
                ((Be = C(Be, j, A)),
                (je = C(je, j, A)),
                (_e = Be.length),
                (ge = je.length)),
              le = _e,
              G = je.slice(0, _e),
              ne = G.length;
            ne < _e;
            G[ne++] = 0
          );
          (Ee = Be.slice()),
            (Ee = [0].concat(Ee)),
            (Oe = Be[0]),
            Be[1] >= A / 2 && Oe++;
          do {
            if (((j = 0), (N = I(Be, G, _e, ne)), N < 0)) {
              if (
                ((ae = G[0]),
                _e != ne && (ae = ae * A + (G[1] || 0)),
                (j = uc(ae / Oe)),
                j > 1)
              )
                for (
                  j >= A && (j = A - 1),
                    z = C(Be, j, A),
                    $ = z.length,
                    ne = G.length;
                  I(z, G, $, ne) == 1;

                )
                  j--, P(z, _e < $ ? Ee : Be, $, A), ($ = z.length), (N = 1);
              else j == 0 && (N = j = 1), (z = Be.slice()), ($ = z.length);
              if (
                ($ < ne && (z = [0].concat(z)),
                P(G, z, ne, A),
                (ne = G.length),
                N == -1)
              )
                for (; I(Be, G, _e, ne) < 1; )
                  j++, P(G, _e < ne ? Ee : Be, ne, A), (ne = G.length);
            } else N === 0 && (j++, (G = [0]));
            (re[F++] = j),
              G[0] ? (G[ne++] = je[le] || 0) : ((G = [je[le]]), (ne = 1));
          } while ((le++ < ge || G[0] != null) && He--);
          (D = G[0] != null), re[0] || re.splice(0, 1);
        }
        if (A == nu) {
          for (F = 1, He = re[0]; He >= 10; He /= 10, F++);
          O(K, T + (K.e = F + L * Un - 1) + 1, _, D);
        } else (K.e = L), (K.r = +D);
        return K;
      };
    })());
  function x(C, I, P, M) {
    var k, T, _, A, N;
    if ((P == null ? (P = a) : os(P, 0, 8), !C.c)) return C.toString();
    if (((k = C.c[0]), (_ = C.e), I == null))
      (N = ac(C.c)),
        (N =
          M == 1 || (M == 2 && (_ <= l || _ >= c)) ? R_(N, _) : gf(N, _, "0"));
    else if (
      ((C = O(new w(C), I, P)),
      (T = C.e),
      (N = ac(C.c)),
      (A = N.length),
      M == 1 || (M == 2 && (I <= T || T <= l)))
    ) {
      for (; A < I; N += "0", A++);
      N = R_(N, T);
    } else if (((I -= _), (N = gf(N, T, "0")), T + 1 > A)) {
      if (--I > 0) for (N += "."; I--; N += "0");
    } else if (((I += T - A), I > 0))
      for (T + 1 == A && (N += "."); I--; N += "0");
    return C.s < 0 && k ? "-" + N : N;
  }
  function S(C, I) {
    for (var P, M, k = 1, T = new w(C[0]); k < C.length; k++)
      (M = new w(C[k])),
        (!M.s || (P = O0(T, M)) === I || (P === 0 && T.s === I)) && (T = M);
    return T;
  }
  function R(C, I, P) {
    for (var M = 1, k = I.length; !I[--k]; I.pop());
    for (k = I[0]; k >= 10; k /= 10, M++);
    return (
      (P = M + P * Un - 1) > d
        ? (C.c = C.e = null)
        : P < u
        ? (C.c = [(C.e = 0)])
        : ((C.e = P), (C.c = I)),
      C
    );
  }
  r = (function () {
    var C = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
      I = /^([^.]+)\.$/,
      P = /^\.([^.]+)$/,
      M = /^-?(Infinity|NaN)$/,
      k = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function (T, _, A, N) {
      var L,
        F = A ? _ : _.replace(k, "");
      if (M.test(F)) T.s = isNaN(F) ? null : F < 0 ? -1 : 1;
      else {
        if (
          !A &&
          ((F = F.replace(C, function (D, j, z) {
            return (
              (L = (z = z.toLowerCase()) == "x" ? 16 : z == "b" ? 2 : 8),
              !N || N == L ? j : D
            );
          })),
          N && ((L = N), (F = F.replace(I, "$1").replace(P, "0.$1"))),
          _ != F)
        )
          return new w(F, L);
        if (w.DEBUG)
          throw Error(Ha + "Not a" + (N ? " base " + N : "") + " number: " + _);
        T.s = null;
      }
      T.c = T.e = null;
    };
  })();
  function O(C, I, P, M) {
    var k,
      T,
      _,
      A,
      N,
      L,
      F,
      D = C.c,
      j = fC;
    if (D) {
      e: {
        for (k = 1, A = D[0]; A >= 10; A /= 10, k++);
        if (((T = I - k), T < 0))
          (T += Un),
            (_ = I),
            (N = D[(L = 0)]),
            (F = uc((N / j[k - _ - 1]) % 10));
        else if (((L = uC((T + 1) / Un)), L >= D.length))
          if (M) {
            for (; D.length <= L; D.push(0));
            (N = F = 0), (k = 1), (T %= Un), (_ = T - Un + 1);
          } else break e;
        else {
          for (N = A = D[L], k = 1; A >= 10; A /= 10, k++);
          (T %= Un),
            (_ = T - Un + k),
            (F = _ < 0 ? 0 : uc((N / j[k - _ - 1]) % 10));
        }
        if (
          ((M =
            M || I < 0 || D[L + 1] != null || (_ < 0 ? N : N % j[k - _ - 1])),
          (M =
            P < 4
              ? (F || M) && (P == 0 || P == (C.s < 0 ? 3 : 2))
              : F > 5 ||
                (F == 5 &&
                  (P == 4 ||
                    M ||
                    (P == 6 &&
                      (T > 0 ? (_ > 0 ? N / j[k - _] : 0) : D[L - 1]) % 10 &
                        1) ||
                    P == (C.s < 0 ? 8 : 7)))),
          I < 1 || !D[0])
        )
          return (
            (D.length = 0),
            M
              ? ((I -= C.e + 1),
                (D[0] = j[(Un - (I % Un)) % Un]),
                (C.e = -I || 0))
              : (D[0] = C.e = 0),
            C
          );
        if (
          (T == 0
            ? ((D.length = L), (A = 1), L--)
            : ((D.length = L + 1),
              (A = j[Un - T]),
              (D[L] = _ > 0 ? uc((N / j[k - _]) % j[_]) * A : 0)),
          M)
        )
          for (;;)
            if (L == 0) {
              for (T = 1, _ = D[0]; _ >= 10; _ /= 10, T++);
              for (_ = D[0] += A, A = 1; _ >= 10; _ /= 10, A++);
              T != A && (C.e++, D[0] == nu && (D[0] = 1));
              break;
            } else {
              if (((D[L] += A), D[L] != nu)) break;
              (D[L--] = 0), (A = 1);
            }
        for (T = D.length; D[--T] === 0; D.pop());
      }
      C.e > d ? (C.c = C.e = null) : C.e < u && (C.c = [(C.e = 0)]);
    }
    return C;
  }
  function B(C) {
    var I,
      P = C.e;
    return P === null
      ? C.toString()
      : ((I = ac(C.c)),
        (I = P <= l || P >= c ? R_(I, P) : gf(I, P, "0")),
        C.s < 0 ? "-" + I : I);
  }
  return (
    (i.absoluteValue = i.abs =
      function () {
        var C = new w(this);
        return C.s < 0 && (C.s = 1), C;
      }),
    (i.comparedTo = function (C, I) {
      return O0(this, new w(C, I));
    }),
    (i.decimalPlaces = i.dp =
      function (C, I) {
        var P,
          M,
          k,
          T = this;
        if (C != null)
          return (
            os(C, 0, fo),
            I == null ? (I = a) : os(I, 0, 8),
            O(new w(T), C + T.e + 1, I)
          );
        if (!(P = T.c)) return null;
        if (((M = ((k = P.length - 1) - dc(this.e / Un)) * Un), (k = P[k])))
          for (; k % 10 == 0; k /= 10, M--);
        return M < 0 && (M = 0), M;
      }),
    (i.dividedBy = i.div =
      function (C, I) {
        return t(this, new w(C, I), o, a);
      }),
    (i.dividedToIntegerBy = i.idiv =
      function (C, I) {
        return t(this, new w(C, I), 0, 1);
      }),
    (i.exponentiatedBy = i.pow =
      function (C, I) {
        var P,
          M,
          k,
          T,
          _,
          A,
          N,
          L,
          F,
          D = this;
        if (((C = new w(C)), C.c && !C.isInteger()))
          throw Error(Ha + "Exponent not an integer: " + B(C));
        if (
          (I != null && (I = new w(I)),
          (A = C.e > 14),
          !D.c ||
            !D.c[0] ||
            (D.c[0] == 1 && !D.e && D.c.length == 1) ||
            !C.c ||
            !C.c[0])
        )
          return (
            (F = new w(Math.pow(+B(D), A ? C.s * (2 - N_(C)) : +B(C)))),
            I ? F.mod(I) : F
          );
        if (((N = C.s < 0), I)) {
          if (I.c ? !I.c[0] : !I.s) return new w(NaN);
          (M = !N && D.isInteger() && I.isInteger()), M && (D = D.mod(I));
        } else {
          if (
            C.e > 9 &&
            (D.e > 0 ||
              D.e < -1 ||
              (D.e == 0
                ? D.c[0] > 1 || (A && D.c[1] >= 24e7)
                : D.c[0] < 8e13 || (A && D.c[0] <= 9999975e7)))
          )
            return (
              (T = D.s < 0 && N_(C) ? -0 : 0),
              D.e > -1 && (T = 1 / T),
              new w(N ? 1 / T : T)
            );
          p && (T = uC(p / Un + 2));
        }
        for (
          A
            ? ((P = new w(0.5)), N && (C.s = 1), (L = N_(C)))
            : ((k = Math.abs(+B(C))), (L = k % 2)),
            F = new w(s);
          ;

        ) {
          if (L) {
            if (((F = F.times(D)), !F.c)) break;
            T ? F.c.length > T && (F.c.length = T) : M && (F = F.mod(I));
          }
          if (k) {
            if (((k = uc(k / 2)), k === 0)) break;
            L = k % 2;
          } else if (((C = C.times(P)), O(C, C.e + 1, 1), C.e > 14)) L = N_(C);
          else {
            if (((k = +B(C)), k === 0)) break;
            L = k % 2;
          }
          (D = D.times(D)),
            T ? D.c && D.c.length > T && (D.c.length = T) : M && (D = D.mod(I));
        }
        return M
          ? F
          : (N && (F = s.div(F)), I ? F.mod(I) : T ? O(F, p, a, _) : F);
      }),
    (i.integerValue = function (C) {
      var I = new w(this);
      return C == null ? (C = a) : os(C, 0, 8), O(I, I.e + 1, C);
    }),
    (i.isEqualTo = i.eq =
      function (C, I) {
        return O0(this, new w(C, I)) === 0;
      }),
    (i.isFinite = function () {
      return !!this.c;
    }),
    (i.isGreaterThan = i.gt =
      function (C, I) {
        return O0(this, new w(C, I)) > 0;
      }),
    (i.isGreaterThanOrEqualTo = i.gte =
      function (C, I) {
        return (I = O0(this, new w(C, I))) === 1 || I === 0;
      }),
    (i.isInteger = function () {
      return !!this.c && dc(this.e / Un) > this.c.length - 2;
    }),
    (i.isLessThan = i.lt =
      function (C, I) {
        return O0(this, new w(C, I)) < 0;
      }),
    (i.isLessThanOrEqualTo = i.lte =
      function (C, I) {
        return (I = O0(this, new w(C, I))) === -1 || I === 0;
      }),
    (i.isNaN = function () {
      return !this.s;
    }),
    (i.isNegative = function () {
      return this.s < 0;
    }),
    (i.isPositive = function () {
      return this.s > 0;
    }),
    (i.isZero = function () {
      return !!this.c && this.c[0] == 0;
    }),
    (i.minus = function (C, I) {
      var P,
        M,
        k,
        T,
        _ = this,
        A = _.s;
      if (((C = new w(C, I)), (I = C.s), !A || !I)) return new w(NaN);
      if (A != I) return (C.s = -I), _.plus(C);
      var N = _.e / Un,
        L = C.e / Un,
        F = _.c,
        D = C.c;
      if (!N || !L) {
        if (!F || !D) return F ? ((C.s = -I), C) : new w(D ? _ : NaN);
        if (!F[0] || !D[0])
          return D[0] ? ((C.s = -I), C) : new w(F[0] ? _ : a == 3 ? -0 : 0);
      }
      if (((N = dc(N)), (L = dc(L)), (F = F.slice()), (A = N - L))) {
        for (
          (T = A < 0) ? ((A = -A), (k = F)) : ((L = N), (k = D)),
            k.reverse(),
            I = A;
          I--;
          k.push(0)
        );
        k.reverse();
      } else
        for (
          M = (T = (A = F.length) < (I = D.length)) ? A : I, A = I = 0;
          I < M;
          I++
        )
          if (F[I] != D[I]) {
            T = F[I] < D[I];
            break;
          }
      if (
        (T && ((k = F), (F = D), (D = k), (C.s = -C.s)),
        (I = (M = D.length) - (P = F.length)),
        I > 0)
      )
        for (; I--; F[P++] = 0);
      for (I = nu - 1; M > A; ) {
        if (F[--M] < D[M]) {
          for (P = M; P && !F[--P]; F[P] = I);
          --F[P], (F[M] += nu);
        }
        F[M] -= D[M];
      }
      for (; F[0] == 0; F.splice(0, 1), --L);
      return F[0]
        ? R(C, F, L)
        : ((C.s = a == 3 ? -1 : 1), (C.c = [(C.e = 0)]), C);
    }),
    (i.modulo = i.mod =
      function (C, I) {
        var P,
          M,
          k = this;
        return (
          (C = new w(C, I)),
          !k.c || !C.s || (C.c && !C.c[0])
            ? new w(NaN)
            : !C.c || (k.c && !k.c[0])
            ? new w(k)
            : (h == 9
                ? ((M = C.s),
                  (C.s = 1),
                  (P = t(k, C, 0, 3)),
                  (C.s = M),
                  (P.s *= M))
                : (P = t(k, C, 0, h)),
              (C = k.minus(P.times(C))),
              !C.c[0] && h == 1 && (C.s = k.s),
              C)
        );
      }),
    (i.multipliedBy = i.times =
      function (C, I) {
        var P,
          M,
          k,
          T,
          _,
          A,
          N,
          L,
          F,
          D,
          j,
          z,
          $,
          K,
          re,
          G = this,
          ne = G.c,
          ae = (C = new w(C, I)).c;
        if (!ne || !ae || !ne[0] || !ae[0])
          return (
            !G.s || !C.s || (ne && !ne[0] && !ae) || (ae && !ae[0] && !ne)
              ? (C.c = C.e = C.s = null)
              : ((C.s *= G.s),
                !ne || !ae ? (C.c = C.e = null) : ((C.c = [0]), (C.e = 0))),
            C
          );
        for (
          M = dc(G.e / Un) + dc(C.e / Un),
            C.s *= G.s,
            N = ne.length,
            D = ae.length,
            N < D && (($ = ne), (ne = ae), (ae = $), (k = N), (N = D), (D = k)),
            k = N + D,
            $ = [];
          k--;
          $.push(0)
        );
        for (K = nu, re = Xh, k = D; --k >= 0; ) {
          for (
            P = 0, j = ae[k] % re, z = (ae[k] / re) | 0, _ = N, T = k + _;
            T > k;

          )
            (L = ne[--_] % re),
              (F = (ne[_] / re) | 0),
              (A = z * L + F * j),
              (L = j * L + (A % re) * re + $[T] + P),
              (P = ((L / K) | 0) + ((A / re) | 0) + z * F),
              ($[T--] = L % K);
          $[T] = P;
        }
        return P ? ++M : $.splice(0, 1), R(C, $, M);
      }),
    (i.negated = function () {
      var C = new w(this);
      return (C.s = -C.s || null), C;
    }),
    (i.plus = function (C, I) {
      var P,
        M = this,
        k = M.s;
      if (((C = new w(C, I)), (I = C.s), !k || !I)) return new w(NaN);
      if (k != I) return (C.s = -I), M.minus(C);
      var T = M.e / Un,
        _ = C.e / Un,
        A = M.c,
        N = C.c;
      if (!T || !_) {
        if (!A || !N) return new w(k / 0);
        if (!A[0] || !N[0]) return N[0] ? C : new w(A[0] ? M : k * 0);
      }
      if (((T = dc(T)), (_ = dc(_)), (A = A.slice()), (k = T - _))) {
        for (
          k > 0 ? ((_ = T), (P = N)) : ((k = -k), (P = A)), P.reverse();
          k--;
          P.push(0)
        );
        P.reverse();
      }
      for (
        k = A.length,
          I = N.length,
          k - I < 0 && ((P = N), (N = A), (A = P), (I = k)),
          k = 0;
        I;

      )
        (k = ((A[--I] = A[I] + N[I] + k) / nu) | 0),
          (A[I] = nu === A[I] ? 0 : A[I] % nu);
      return k && ((A = [k].concat(A)), ++_), R(C, A, _);
    }),
    (i.precision = i.sd =
      function (C, I) {
        var P,
          M,
          k,
          T = this;
        if (C != null && C !== !!C)
          return (
            os(C, 1, fo), I == null ? (I = a) : os(I, 0, 8), O(new w(T), C, I)
          );
        if (!(P = T.c)) return null;
        if (((k = P.length - 1), (M = k * Un + 1), (k = P[k]))) {
          for (; k % 10 == 0; k /= 10, M--);
          for (k = P[0]; k >= 10; k /= 10, M++);
        }
        return C && T.e + 1 > M && (M = T.e + 1), M;
      }),
    (i.shiftedBy = function (C) {
      return os(C, -dC, dC), this.times("1e" + C);
    }),
    (i.squareRoot = i.sqrt =
      function () {
        var C,
          I,
          P,
          M,
          k,
          T = this,
          _ = T.c,
          A = T.s,
          N = T.e,
          L = o + 4,
          F = new w("0.5");
        if (A !== 1 || !_ || !_[0])
          return new w(!A || (A < 0 && (!_ || _[0])) ? NaN : _ ? T : 1 / 0);
        if (
          ((A = Math.sqrt(+B(T))),
          A == 0 || A == 1 / 0
            ? ((I = ac(_)),
              (I.length + N) % 2 == 0 && (I += "0"),
              (A = Math.sqrt(+I)),
              (N = dc((N + 1) / 2) - (N < 0 || N % 2)),
              A == 1 / 0
                ? (I = "5e" + N)
                : ((I = A.toExponential()),
                  (I = I.slice(0, I.indexOf("e") + 1) + N)),
              (P = new w(I)))
            : (P = new w(A + "")),
          P.c[0])
        ) {
          for (N = P.e, A = N + L, A < 3 && (A = 0); ; )
            if (
              ((k = P),
              (P = F.times(k.plus(t(T, k, L, 1)))),
              ac(k.c).slice(0, A) === (I = ac(P.c)).slice(0, A))
            )
              if (
                (P.e < N && --A,
                (I = I.slice(A - 3, A + 1)),
                I == "9999" || (!M && I == "4999"))
              ) {
                if (!M && (O(k, k.e + o + 2, 0), k.times(k).eq(T))) {
                  P = k;
                  break;
                }
                (L += 4), (A += 4), (M = 1);
              } else {
                (!+I || (!+I.slice(1) && I.charAt(0) == "5")) &&
                  (O(P, P.e + o + 2, 1), (C = !P.times(P).eq(T)));
                break;
              }
        }
        return O(P, P.e + o + 1, a, C);
      }),
    (i.toExponential = function (C, I) {
      return C != null && (os(C, 0, fo), C++), x(this, C, I, 1);
    }),
    (i.toFixed = function (C, I) {
      return C != null && (os(C, 0, fo), (C = C + this.e + 1)), x(this, C, I);
    }),
    (i.toFormat = function (C, I, P) {
      var M,
        k = this;
      if (P == null)
        C != null && I && typeof I == "object"
          ? ((P = I), (I = null))
          : C && typeof C == "object"
          ? ((P = C), (C = I = null))
          : (P = g);
      else if (typeof P != "object")
        throw Error(Ha + "Argument not an object: " + P);
      if (((M = k.toFixed(C, I)), k.c)) {
        var T,
          _ = M.split("."),
          A = +P.groupSize,
          N = +P.secondaryGroupSize,
          L = P.groupSeparator || "",
          F = _[0],
          D = _[1],
          j = k.s < 0,
          z = j ? F.slice(1) : F,
          $ = z.length;
        if ((N && ((T = A), (A = N), (N = T), ($ -= T)), A > 0 && $ > 0)) {
          for (T = $ % A || A, F = z.substr(0, T); T < $; T += A)
            F += L + z.substr(T, A);
          N > 0 && (F += L + z.slice(T)), j && (F = "-" + F);
        }
        M = D
          ? F +
            (P.decimalSeparator || "") +
            ((N = +P.fractionGroupSize)
              ? D.replace(
                  new RegExp("\\d{" + N + "}\\B", "g"),
                  "$&" + (P.fractionGroupSeparator || "")
                )
              : D)
          : F;
      }
      return (P.prefix || "") + M + (P.suffix || "");
    }),
    (i.toFraction = function (C) {
      var I,
        P,
        M,
        k,
        T,
        _,
        A,
        N,
        L,
        F,
        D,
        j,
        z = this,
        $ = z.c;
      if (
        C != null &&
        ((A = new w(C)), (!A.isInteger() && (A.c || A.s !== 1)) || A.lt(s))
      )
        throw Error(
          Ha +
            "Argument " +
            (A.isInteger() ? "out of range: " : "not an integer: ") +
            B(A)
        );
      if (!$) return new w(z);
      for (
        I = new w(s),
          L = P = new w(s),
          M = N = new w(s),
          j = ac($),
          T = I.e = j.length - z.e - 1,
          I.c[0] = fC[(_ = T % Un) < 0 ? Un + _ : _],
          C = !C || A.comparedTo(I) > 0 ? (T > 0 ? I : L) : A,
          _ = d,
          d = 1 / 0,
          A = new w(j),
          N.c[0] = 0;
        (F = t(A, I, 0, 1)), (k = P.plus(F.times(M))), k.comparedTo(C) != 1;

      )
        (P = M),
          (M = k),
          (L = N.plus(F.times((k = L)))),
          (N = k),
          (I = A.minus(F.times((k = I)))),
          (A = k);
      return (
        (k = t(C.minus(P), M, 0, 1)),
        (N = N.plus(k.times(L))),
        (P = P.plus(k.times(M))),
        (N.s = L.s = z.s),
        (T = T * 2),
        (D =
          t(L, M, T, a)
            .minus(z)
            .abs()
            .comparedTo(t(N, P, T, a).minus(z).abs()) < 1
            ? [L, M]
            : [N, P]),
        (d = _),
        D
      );
    }),
    (i.toNumber = function () {
      return +B(this);
    }),
    (i.toPrecision = function (C, I) {
      return C != null && os(C, 1, fo), x(this, C, I, 2);
    }),
    (i.toString = function (C) {
      var I,
        P = this,
        M = P.s,
        k = P.e;
      return (
        k === null
          ? M
            ? ((I = "Infinity"), M < 0 && (I = "-" + I))
            : (I = "NaN")
          : (C == null
              ? (I = k <= l || k >= c ? R_(ac(P.c), k) : gf(ac(P.c), k, "0"))
              : C === 10 && v
              ? ((P = O(new w(P), o + k + 1, a)), (I = gf(ac(P.c), P.e, "0")))
              : (os(C, 2, b.length, "Base"),
                (I = n(gf(ac(P.c), k, "0"), 10, C, M, !0))),
            M < 0 && P.c[0] && (I = "-" + I)),
        I
      );
    }),
    (i.valueOf = i.toJSON =
      function () {
        return B(this);
      }),
    (i._isBigNumber = !0),
    (i[Symbol.toStringTag] = "BigNumber"),
    (i[Symbol.for("nodejs.util.inspect.custom")] = i.valueOf),
    e != null && w.set(e),
    w
  );
}
function dc(e) {
  var t = e | 0;
  return e > 0 || e === t ? t : t - 1;
}
function ac(e) {
  for (var t, n, r = 1, i = e.length, s = e[0] + ""; r < i; ) {
    for (t = e[r++] + "", n = Un - t.length; n--; t = "0" + t);
    s += t;
  }
  for (i = s.length; s.charCodeAt(--i) === 48; );
  return s.slice(0, i + 1 || 1);
}
function O0(e, t) {
  var n,
    r,
    i = e.c,
    s = t.c,
    o = e.s,
    a = t.s,
    l = e.e,
    c = t.e;
  if (!o || !a) return null;
  if (((n = i && !i[0]), (r = s && !s[0]), n || r)) return n ? (r ? 0 : -a) : o;
  if (o != a) return o;
  if (((n = o < 0), (r = l == c), !i || !s)) return r ? 0 : !i ^ n ? 1 : -1;
  if (!r) return (l > c) ^ n ? 1 : -1;
  for (a = (l = i.length) < (c = s.length) ? l : c, o = 0; o < a; o++)
    if (i[o] != s[o]) return (i[o] > s[o]) ^ n ? 1 : -1;
  return l == c ? 0 : (l > c) ^ n ? 1 : -1;
}
function os(e, t, n, r) {
  if (e < t || e > n || e !== uc(e))
    throw Error(
      Ha +
        (r || "Argument") +
        (typeof e == "number"
          ? e < t || e > n
            ? " out of range: "
            : " not an integer: "
          : " not a primitive number: ") +
        String(e)
    );
}
function N_(e) {
  var t = e.c.length - 1;
  return dc(e.e / Un) == t && e.c[t] % 2 != 0;
}
function R_(e, t) {
  return (
    (e.length > 1 ? e.charAt(0) + "." + e.slice(1) : e) +
    (t < 0 ? "e" : "e+") +
    t
  );
}
function gf(e, t, n) {
  var r, i;
  if (t < 0) {
    for (i = n + "."; ++t; i += n);
    e = i + e;
  } else if (((r = e.length), ++t > r)) {
    for (i = n, t -= r; --t; i += n);
    e += i;
  } else t < r && (e = e.slice(0, t) + "." + e.slice(t));
  return e;
}
var Re = _X(),
  gn = ((e) => ((e.EVM = "EVM"), (e.SOL = "SOL"), (e.OTHER = "OTHER"), e))(
    gn || {}
  ),
  vi = ((e) => (
    (e.TRANSACTION_IN_PROGRESS = "transaction_in_progress"),
    (e.WRONG_NETWORK = "wrong_network"),
    (e.TRANSACTION_FAILED = "transaction_failed"),
    (e.GAS_PROBLEM = "gas_problem"),
    (e.CONNECT_WALLET = "connect_wallet"),
    e
  ))(vi || {});
const zU = {
    transaction_in_progress: {
      title: "Transaction In Progress",
      text: "Please wait a few moments for network confirmation",
    },
    wrong_network: {
      title: "Wrong Network!",
      text: "Please switch the network in your wallet and try again",
    },
    transaction_failed: {
      title: "Transaction Failed!",
      text: "An error occurred during execution. Please try again",
    },
    gas_problem: {
      title: "Gas Problem!",
      text: "An issue with gas occurred during the transaction",
    },
    connect_wallet: {
      title: "Connect Wallet",
      text: "Using mobile? Open this page in your wallet's built-in browser for seamless access",
    },
  },
  kx = "/svg/assets/arb.svg",
  Tx = "/svg/assets/avax.svg",
  Mx = "/svg/assets/base.svg",
  Ix = "/svg/assets/blast.svg",
  Nx = "/svg/assets/bnb.svg",
  Sc = "/svg/assets/eth.svg",
  Rx = "/svg/assets/linea.svg",
  Ox = "/svg/assets/opt.svg",
  Px = "/svg/assets/pol.svg",
  k8 = "/svg/assets/zk.svg",

  jR = "/svg/assets/btc.svg",
  DR = "/svg/assets/trx.svg",
  BR = "/svg/assets/ton.svg",
  FR = "/svg/assets/doge.svg",
  T8 = "/svg/assets/xrp.svg",
  UR = "/svg/assets/ltc.svg",
  $R = "/svg/assets/bch.svg",
  zR = "/svg/assets/ada.svg",
  Uf = "/svg/assets/dai.svg",
  SX = "/svg/assets/fdust.svg",
  WR = "/svg/assets/shib.svg",
  EX = "/svg/assets/usdb.svg",
  ci = "/svg/assets/usdc.svg",
  Fs = "/svg/assets/usdt.svg",
  _6e = "/svg/assets/usd.svg",
  S6e = "/svg/assets/gbr.svg",
  E6e = "/svg/assets/eur.svg",
  A6e = !1;
var ir = ((e) => (
  (e[(e.eth = 1)] = "eth"),
  (e[(e.bnb = 56)] = "bnb"),
  (e[(e.sepolia = 11155111)] = "sepolia"),
  (e[(e.arbi = 42161)] = "arbi"),
  (e[(e.polygon = 137)] = "polygon"),
  (e[(e.opt = 10)] = "opt"),
  (e[(e.base = 8453)] = "base"),
  (e[(e.avax = 43114)] = "avax"),
  (e[(e.zksync = 324)] = "zksync"),
  (e[(e.linea = 59144)] = "linea"),
  (e[(e.blast = 81457)] = "blast"),

  e
))(ir || {});
const AX = {
    name: "Solana",
    displayName: "Solana",
    icon: _6e,
    shortName: "SOL",
    networkId: 900,
    nativeSymbol: "SOL",
  },
  Lx = [
    {
      name: "Sepolia",
      displayName: "Sepolia",
      icon: Sc,
      shortName: "SepETH",
      networkId: 11155111,
      nativeSymbol: "sepETH",
    },
    {
      name: "Goerli",
      displayName: "Goerli",
      icon: T8,
      shortName: "GoETH",
      networkId: 5,
      nativeSymbol: "ETH",
    },
    {
      name: "Ethereum",
      displayName: "Ethereum",
      icon: Sc,
      shortName: "ETH",
      networkId: 1,
      nativeSymbol: "ETH",
    },
    {
      name: "BNB Chain",
      displayName: "BNB Smart Chain",
      icon: Nx,
      shortName: "BSC",
      networkId: 56,
      nativeSymbol: "BNB",
    },
    {
      name: "Polygon",
      displayName: "Polygon",
      icon: Px,
      shortName: "PLG",
      networkId: 137,
      nativeSymbol: "MATIC",
    },
    {
      name: "Arbitrum One",
      displayName: "Arbitrum",
      icon: kx,
      shortName: "ARB",
      networkId: 42161,
      nativeSymbol: "ETH",
    },
    {
      name: "Base",
      displayName: "Base",
      icon: Mx,
      shortName: "BASE",
      networkId: 8453,
      nativeSymbol: "ETH",
    },
    {
      name: "Avalanche",
      displayName: "Avalanche",
      icon: Tx,
      shortName: "AVAX",
      networkId: 43114,
      nativeSymbol: "AVAX",
    },
    {
      name: "Optimism",
      displayName: "Optimism",
      icon: Ox,
      shortName: "OP",
      networkId: 10,
      nativeSymbol: "ETH",
    },
    {
      name: "Linea",
      displayName: "Linea",
      icon: Rx,
      shortName: "Linea",
      networkId: 59144,
      nativeSymbol: "ETH",
    },
    {
      name: "Blast",
      displayName: "Blast",
      icon: Ix,
      shortName: "Blast",
      networkId: 81457,
      nativeSymbol: "ETH",
    },
    {
      name: "ZkSync",
      displayName: "ZkSync",
      icon: k8,
      shortName: "ZK",
      networkId: 324,
      nativeSymbol: "ETH",
    },
  ],
  WU = [
    {
      name: "Ethereum",
      displayName: "Ethereum",
      icon: Sc,
      shortName: "ETH",
      networkId: 1,
      nativeSymbol: "ETH",
    },
    {
      name: "BNB Chain",
      displayName: "BNB Smart Chain",
      icon: Nx,
      shortName: "Bsc",
      networkId: 56,
      nativeSymbol: "BNB",
    },
    {
      name: "Polygon",
      displayName: "Polygon",
      icon: Px,
      shortName: "PLG",
      networkId: 137,
      nativeSymbol: "MATIC",
    },
    {
      name: "Tron",
      displayName: "Tron",
      icon: DR,
      shortName: "TRX",
      nativeSymbol: "TRX",
    },
    {
      name: "Optimism",
      displayName: "Optimism",
      icon: Ox,
      shortName: "OP",
      networkId: 10,
      nativeSymbol: "ETH",
    },
    {
      name: "Arbitrum One",
      displayName: "Arbitrum",
      icon: kx,
      shortName: "ARB",
      networkId: 42161,
      nativeSymbol: "ETH",
    },
    {
      name: "Avalanche",
      displayName: "Avalanche",
      icon: Tx,
      shortName: "AVAX",
      networkId: 43114,
      nativeSymbol: "AVAX",
    },
    {
      name: "Base",
      displayName: "Base",
      icon: Mx,
      shortName: "BASE",
      networkId: 8453,
      nativeSymbol: "ETH",
    },
    {
      name: "Bitcon",
      displayName: "Bitcoin",
      icon: jR,
      shortName: "BTC",
      nativeSymbol: "BTC",
    },
    {
      name: "BitcoinCash",
      displayName: "BitcoinCash",
      icon: $R,
      shortName: "BCH",
      nativeSymbol: "BCH",
    },
    {
      name: "Blast",
      displayName: "Blast",
      icon: Ix,
      shortName: "Blast",
      networkId: 81457,
      nativeSymbol: "ETH",
    },
    {
      name: "Cardano",
      displayName: "Cardano",
      icon: zR,
      shortName: "ADA",
      nativeSymbol: "ADA",
    },
    {
      name: "Dogecoin",
      displayName: "Dogecoin",
      icon: FR,
      shortName: "DOGE",
      nativeSymbol: "DOGE",
    },
    {
      name: "Linea",
      displayName: "Linea",
      icon: Rx,
      shortName: "Linea",
      networkId: 59144,
      nativeSymbol: "ETH",
    },
    {
      name: "Litecoin",
      displayName: "Litecoin",
      icon: UR,
      shortName: "LTC",
      nativeSymbol: "LTC",
    },
    {
      name: "XRP",
      displayName: "Ripple",
      icon: T8,
      shortName: "XRP",
      nativeSymbol: "XRP",
    },
    {
      name: "Toncoin",
      displayName: "Toncoin",
      icon: BR,
      shortName: "TON",
      nativeSymbol: "TON",
    },
    {
      name: "ZkSync",
      displayName: "ZkSync",
      icon: k8,
      shortName: "ZK",
      networkId: 324,
      nativeSymbol: "ETH",
    },
  ],
  $n = "SOLDEX",
  HR = !1;
const hc = 10 ** 18,
  hC = 10 * 1,
  xw = 10 ** 18,
  CX = 48,
  VR = 3,
  GR = 15,
  C6e = 1e6,
  k6e = 1,
  T6e = 80,
  kX = 5,
  qR = "0x0000000000000000000000000000000000000000",
  Mr = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE",
  HU = "0x9000000000000000000000000000000000000009",
  f0 = "https://api.solanex.ai",
  y5 = "https://statistics.solanex.ai",
  Zm = 1,
  _w = (e) => {
    var t;
    return (
      ((t = [...Lx, AX].find((n) => n.networkId === e)) == null
        ? void 0
        : t.displayName) || ""
    );
  },
  VU = (e) => {
    var t;
    return (
      ((t = [...Lx, AX].find((n) => n.networkId === e)) == null
        ? void 0
        : t.icon) || ""
    );
  },
  Iy = [1, 56, 137, 42161, 43114, 8453, 10, 81457, 59144, 324],
  M6e = [...Iy, 900],
  I6e = {
    idoStorage: {
      1: "0x95FaBdD34AdAC5070607e732a42888cB51666583",
      56: "0x99933c2bC994892870814D96B931CE4fA8CaF793",
      137: "0x44484DFcBEfe4807320e8D023C4C790EE0B9EcBd",
      42161: "0x44484DFcBEfe4807320e8D023C4C790EE0B9EcBd",
      10: "0x44484DFcBEfe4807320e8D023C4C790EE0B9EcBd",
      43114: "0x44484DFcBEfe4807320e8D023C4C790EE0B9EcBd",
      8453: "0xf332Dc4f07BD6742014ed6F550e60a7bA5C9A809",
      59144: "0x44484DFcBEfe4807320e8D023C4C790EE0B9EcBd",
      81457: "0x44484DFcBEfe4807320e8D023C4C790EE0B9EcBd",
      324: "0x90EFFA3665b6d471bd0CF831d92Fe1AC37fB42a2",
    },
    nativeIdo: {
      1: "0xf1e95d0420aEDa75Ebf7804207919AD5616D8792",
      56: "0x7313cD1f2DC319a802e643dB93e5b80F693a0411",
      137: "0xE7125f1fffD03D6EA75d65DEf34FB4330CFb3696",
      42161: "0xE7125f1fffD03D6EA75d65DEf34FB4330CFb3696",
      10: "0xE7125f1fffD03D6EA75d65DEf34FB4330CFb3696",
      43114: "0xE7125f1fffD03D6EA75d65DEf34FB4330CFb3696",
      8453: "0x520302BE193343FC29C66567bED5e1d54Fe0BCB0",
      59144: "0xE7125f1fffD03D6EA75d65DEf34FB4330CFb3696",
      81457: "0xE7125f1fffD03D6EA75d65DEf34FB4330CFb3696",
      324: "0x649eB1DBe1D5D19B3F626AbbFB224BB1B0C04925",
    },
    tokenIdo: {
      1: "0x87982777c02D17133D3833d1911048f9e7dFdE58",
      56: "0xcb7D987fd79E9bB4b945cdE5e126CeA5A9Db87b2",
      137: "0x99933c2bC994892870814D96B931CE4fA8CaF793",
      42161: "0x99933c2bC994892870814D96B931CE4fA8CaF793",
      10: "0x99933c2bC994892870814D96B931CE4fA8CaF793",
      43114: "0x99933c2bC994892870814D96B931CE4fA8CaF793",
      8453: "0x3B052d77E233820901Bf6F178e88bfaD525B02cD",
      59144: "0x99933c2bC994892870814D96B931CE4fA8CaF793",
      81457: "0x99933c2bC994892870814D96B931CE4fA8CaF793",
      324: "0x805E836aC02D2C135C9C62cbF02A0523F4301f8b",
    },
    customIdo: {
      1: "0x322C97806B464C2aCF56ba28dd36D85aaE0e9955",
      56: "0xc63b29Aa91A72F26aBBF9A7CF758Af2Cd8Da7165",
    },
  },
  $l = I6e,
  TX = -19,
  LT = -21,
  Zg = -23,
  N6e = {
    1: "0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419",
    56: "0x14e613AC84a31f709eadbdF89C6CC390fDc9540A",
    137: "0x7bAC85A8a13A4BcD8abb3eB7d6b4d632c5a57676",
    42161: "",
    8453: "",
    10: "",
    43114: "0xff3eeb22b5e3de6e705b44749c2559d704923fd7",
    11155111: "",
    81457: "",
    59144: "",
    324: "",
    900: "0x4ffC43a60e009B551865A93d232E33Fce9f01507",
    [Zg]: "0x8dD1CD88F43aF196ae478e91b9F5E4Ac69A97C61",
  },
  R6e = 8,
  MX = [
    { name: "United States dollar", symbol: "USD", icon: _6e, price: 1 },
    { name: "Pound sterling", symbol: "GBP", icon: S6e, price: 1.27 },
    { name: "Euro", symbol: "EUR", icon: E6e, price: 1.1 },
  ],
  hb = "0x2170Ed0880ac9A755fd29B2688956BD959F933F8",
  pb = "0x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce",
  KR = "0xfff9976782d46cc05630d1f6ebab18b2324d6b14",
  pu = {
    1: [
      { address: Mr, symbol: "ETH", name: "Ethereum", icon: Sc, decimals: 18 },
      {
        address: "0xdac17f958d2ee523a2206206994597c13d831ec7",
        symbol: "USDT",
        name: "USDT",
        icon: Fs,
        decimals: 6,
      },
      {
        address: "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
        symbol: "USDC",
        name: "USDC",
        icon: ci,
        decimals: 6,
      },
      { address: pb, symbol: "SHIB", name: "SHIB", icon: WR, decimals: 18 },
    ],
    56: [
      { address: Mr, symbol: "BNB", name: "BNB", icon: Nx, decimals: 18 },
      {
        address: "0x55d398326f99059ff775485246999027b3197955",
        symbol: "USDT",
        name: "USDT",
        icon: Fs,
        decimals: 18,
      },
      {
        address: "0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d",
        symbol: "USDC",
        name: "USDC",
        icon: ci,
        decimals: 18,
      },
      {
        address: "0xc5f0f7b66764F6ec8C8Dff7BA683102295E16409",
        symbol: "FDUSD",
        name: "First Digital USD",
        icon: SX,
        decimals: 18,
      },
      {
        address: hb,
        symbol: "PegETH",
        name: "Pegged ETH",
        icon: Sc,
        decimals: 18,
      },
    ],
    137: [
      { address: Mr, symbol: "MATIC", name: "Matic", icon: Px, decimals: 18 },
      {
        address: "0xc2132D05D31c914a87C6611C10748AEb04B58e8F",
        symbol: "USDT",
        name: "USDT",
        icon: Fs,
        decimals: 6,
      },
      {
        address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174",
        symbol: "USDC.e",
        name: "Bridged USDC",
        icon: ci,
        decimals: 6,
      },
      {
        address: "0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359",
        symbol: "USDC",
        name: "USDC",
        icon: ci,
        decimals: 6,
      },
    ],
    42161: [
      { address: Mr, symbol: "ETH", name: "Ethereum", icon: kx, decimals: 18 },
      {
        address: "0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9",
        symbol: "USDT",
        name: "USDT",
        icon: Fs,
        decimals: 6,
      },
      {
        address: "0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8",
        symbol: "USDC.e",
        name: "Bridged USDC",
        icon: ci,
        decimals: 6,
      },
      {
        address: "0xaf88d065e77c8cC2239327C5EDb3A432268e5831",
        symbol: "USDC",
        name: "USDC",
        icon: ci,
        decimals: 6,
      },
    ],
    8453: [
      { address: Mr, symbol: "ETH", name: "Ethereum", icon: Mx, decimals: 18 },
      {
        address: "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",
        symbol: "USDC",
        name: "USDC",
        icon: ci,
        decimals: 6,
      },
      {
        address: "0x50c5725949A6F0c72E6C4a641F24049A917DB0Cb",
        symbol: "DAI",
        name: "DAI",
        icon: Uf,
        decimals: 18,
      },
    ],
    10: [
      { address: Mr, symbol: "ETH", name: "Ethereum", icon: Ox, decimals: 18 },
      {
        address: "0x94b008aa00579c1307b0ef2c499ad98a8ce58e58",
        symbol: "USDT",
        name: "USDT",
        icon: Fs,
        decimals: 6,
      },
      {
        address: "0x7F5c764cBc14f9669B88837ca1490cCa17c31607",
        symbol: "USDC.e",
        name: "Bridged USDC",
        icon: ci,
        decimals: 6,
      },
      {
        address: "0x0b2C639c533813f4Aa9D7837CAf62653d097Ff85",
        symbol: "USDC",
        name: "USDC",
        icon: ci,
        decimals: 6,
      },
    ],
    43114: [
      {
        address: Mr,
        symbol: "Avax",
        name: "Avalanche",
        icon: Tx,
        decimals: 18,
      },
      {
        address: "0x9702230A8Ea53601f5cD2dc00fDBc13d4dF4A8c7",
        symbol: "USDT",
        name: "USDT",
        icon: Fs,
        decimals: 6,
      },
      {
        address: "0xA7D7079b0FEaD91F3e65f86E8915Cb59c1a4C664",
        symbol: "USDC.e",
        name: "Bridged USDC",
        icon: ci,
        decimals: 6,
      },
      {
        address: "0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E",
        symbol: "USDC",
        name: "USDC",
        icon: ci,
        decimals: 6,
      },
    ],
    11155111: [
      { address: Mr, symbol: "ETH", name: "Ethereum", icon: Sc, decimals: 18 },
      {
        address: "0x795dF1F5C992fc030F6ab55a18D0A00D8D4a7f29",
        symbol: "USDC",
        name: "Usdc Coin",
        icon: ci,
        decimals: 6,
      },
      {
        address: "0x178773532a839fA285Ea495e462a71456d28140A",
        symbol: "DAI",
        name: "Dai",
        icon: Uf,
        decimals: 18,
      },
      {
        address: "0x42D8BCf255125BB186459AF66bB74EEF8b8cC391",
        symbol: "TTS",
        name: "Wert Test Token",
        icon: "https://openseauserdata.com/files/b318d1353973606204bc9d770fa789a7.png",
        decimals: 18,
        disable: !0,
      },
      {
        address: KR,
        symbol: "WETH",
        name: "Wrapped Ethereum",
        icon: Sc,
        decimals: 18,
      },
    ],
    81457: [
      { address: Mr, symbol: "ETH", name: "Ethereum", icon: Ix, decimals: 18 },
      {
        address: "0x4300000000000000000000000000000000000003",
        symbol: "USDB",
        name: "USDB",
        icon: EX,
        decimals: 18,
      },
    ],
    59144: [
      { address: Mr, symbol: "ETH", name: "Ethereum", icon: Rx, decimals: 18 },
      {
        address: "0xa219439258ca9da29e9cc4ce5596924745e12b93",
        symbol: "USDT",
        name: "USDT",
        icon: Fs,
        decimals: 6,
      },
      {
        address: "0x176211869ca2b568f2a7d4ee941e073a821ee1ff",
        symbol: "USDC",
        name: "USDC",
        icon: ci,
        decimals: 6,
      },
      {
        address: "0x4af15ec2a0bd43db75dd04e62faa3b8ef36b00d5",
        symbol: "DAI",
        name: "DAI",
        icon: Uf,
        decimals: 18,
      },
    ],
    324: [
      { address: Mr, symbol: "ETH", name: "Ethereum", icon: k8, decimals: 18 },
      {
        address: "0x493257fD37EDB34451f62EDf8D2a0C418852bA4C",
        symbol: "USDT",
        name: "USDT",
        icon: Fs,
        decimals: 6,
      },
      {
        address: "0x3355df6d4c9c3035724fd0e3914de96a5a83aaf4",
        symbol: "USDC",
        name: "USDC",
        icon: ci,
        decimals: 6,
      },
      {
        address: "0x4B9eb6c0b6ea15176BBF62841C6B2A8a398cb656",
        symbol: "DAI",
        name: "DAI",
        icon: Uf,
        decimals: 18,
      },
    ],
  },
  jT = {
    1: [
      "https://rpc.ankr.com/eth",
      "https://eth.llamarpc.com",
      "https://ethereum-rpc.publicnode.com",
      "https://eth.merkle.io",
    ],
    56: [
      "https://bsc-dataseed.binance.org",
      "https://bsc-dataseed2.binance.org",
      "https://bsc-dataseed3.binance.org",
      "https://bsc-dataseed4.bnbchain.org",
      "https://bsc.meowrpc.com",
    ],
    137: [
      "https://polygon-mainnet.public.blastapi.io",
      "https://polygon.blockpi.network/v1/rpc/public",
      "https://polygon-rpc.com",
      "https://polygon-bor.publicnode.com",
      "https://rpc.ankr.com/polygon",
    ],
    42161: [
      "https://arbitrum.llamarpc.com",
      "https://arbitrum.meowrpc.com",
      "https://arbitrum-one.public.blastapi.io",
      "https://rpc.ankr.com/arbitrum",
    ],
    8453: [
      "https://mainnet.base.org",
      "https://base-mainnet.public.blastapi.io",
      "https://base.publicnode.com",
      "https://base.llamarpc.com",
    ],
    10: [
      "https://optimism.publicnode.com",
      "https://optimism.drpc.org",
      "https://optimism-mainnet.public.blastapi.io",
      "https://rpc.ankr.com/optimism",
    ],
    43114: [
      "https://rpc.ankr.com/avalanche",
      "https://avalanche.blockpi.network/v1/rpc/public",
      "https://api.avax.network/ext/bc/C/rpc",
      "https://avax.meowrpc.com",
      "https://avalanche.public-rpc.com",
    ],
    81457: [
      "https://rpc.blast.io",
      "https://blast-rpc.publicnode.com",
      "https://blastl2-mainnet.public.blastapi.io",
    ],
    59144: ["https://1rpc.io/linea", "https://rpc.linea.build"],
    324: [
      "https://zksync.meowrpc.com",
      "https://mainnet.era.zksync.io",
      "https://zksync.drpc.org",
    ],
    11155111: [
      "https://ethereum-sepolia.publicnode.com",
      "https://eth-sepolia.public.blastapi.io",
    ],
  },
  O6e = (e) => {
    const t = Math.floor(Math.random() * jT[e].length);
    return jT[e][t];
  },
  IX = {
    1: "https://etherscan.io/tx/",
    56: "https://bscscan.com/tx/",
    137: "https://polygonscan.com/tx/",
    42161: "https://arbiscan.io/tx/",
    8453: "https://basescan.org/tx/",
    10: "https://optimistic.etherscan.io/tx/",
    43114: "https://snowtrace.io/tx/",
    81457: "https://blastscan.io/tx/",
    59144: "https://lineascan.build/tx/",
    324: "https://explorer.zksync.io/tx/",
    11155111: "https://sepolia.etherscan.io/tx/",
  
  },
  P6e = {
    1: new Re("300000000"),
    56: new Re("0"),
    137: new Re("70000000000"),
    8453: new Re("200000"),
    42161: new Re("500000000"),
    10: new Re("200000000"),
    43114: new Re("3000000000"),
    11155111: new Re("300000000"),
    81457: new Re("500000"),
    59144: new Re("500000000"),
    324: new Re("500000"),
  },
  L6e = {
    1: 0.0015,
    56: 0.0015,
    137: 0.05,
    8453: 5e-4,
    42161: 5e-4,
    43114: 0.015,
    10: 5e-4,
    81457: 5e-4,
    59144: 5e-4,
    324: 5e-4,
    11155111: 5e-4,
  },
  NX = {
    1: "0xeefBa1e63905eF1D7ACbA5a8513c70307C1cE441",
    56: "0x1Ee38d535d541c55C9dae27B12edf090C608E6Fb",
    137: "0xc4f1501f337079077842343Ce02665D8960150B0",
    8453: "0x55A3e58E3778010987540D62edf157DD6801a221",
    42161: "0x697d19e322F57911315aA99B5081fF7324A5e6cb",
    10: "0x697d19e322F57911315aA99B5081fF7324A5e6cb",
    43114: "0x873a45FC4B79A99AF3a9026ebB249a636b7298c0",
    81457: "0x77f3C9C81379E105e5596dA3B187BAF9c1929e0F",
    59144: "0x88aFD361818735fB560A6922Cc9c69353a188093",
    324: "0x3CeA7e95fd57e869E17424837110C45B3d81A619",
    11155111: "0x6Fb9DAA671F0872F6B21aF96A8bB070E0424f1F6",
  },
  j6e = {
    partner_id: "",
    origin: "https://sandbox.wert.io",
    currency: "USD",
    skip_init_navigation: !0,
  },
  D6e = {
    partner_id: "01J95Y00TC8MK1P17TK13YPFFN",
    origin: "https://widget.wert.io",
    currency: "USD",
    skip_init_navigation: !0,
  };
var xl = ((e) => (
    (e[(e.TRX = 1e3)] = "TRX"),
    (e[(e.BTC = 1001)] = "BTC"),
    (e[(e.USDT_TRX20 = 1002)] = "USDT_TRX20"),
    (e[(e.LTC = 1003)] = "LTC"),
    (e[(e.DOGE = 1004)] = "DOGE"),
    (e[(e.XRP = 1005)] = "XRP"),
    (e[(e.BCH = 1006)] = "BCH"),
    (e[(e.TON = 1007)] = "TON"),
    (e[(e.ADA = 1008)] = "ADA"),
    (e[(e.DAI = 1009)] = "DAI"),
    (e[(e.SHIB = 1010)] = "SHIB"),
    e
  ))(xl || {}),
  sd = ((e) => (
    (e.Ethereum = "Ethereum"),
    (e.Bsc = "Bsc"),
    (e.Polygon = "Polygon"),
    (e.Arbitrum = "Arbitrum"),
    (e.Base = "Base"),
    (e.Avalanche = "Avalanche"),
    (e.Optimism = "Optimism"),
    (e.Linea = "Linea"),
    (e.ZkSync = "ZkSync"),
    (e.Blast = "Blast"),
  
    (e.Bitcoin = "Bitcoin"),
    (e.Cardano = "Cardano"),
    (e.Ripple = "Ripple"),
    (e.Tron = "Tron"),
    (e.Litecoin = "Litecoin"),
    (e.Dogecoin = "Dogecoin"),
    (e.BitcoinCash = "BitcoinCash"),
    (e.Toncoin = "Toncoin"),
    e
  ))(sd || {}),
  rg = ((e) => (
    (e.ETH = "ETH"),
    (e.BNB = "BNB"),
    (e.MATIC = "MATIC"),
    (e.ARB = "ARB"),
    (e.BASE = "BASE"),
    (e.AVAX = "AVAX"),
    (e.OP = "OP"),
    (e.LINEA = "LINEA"),
    (e.ZK_SYNC = "ZK_SYNC"),
    (e.BLAST = "BLAST"),
    (e.USDC = "USDC"),
    (e.USDT = "USDT"),
    (e.DAI = "DAI"),
    (e.SHIB = "SHIB"),
    (e.USDB = "USDB"),
    (e.FDUST = "FDUST"),
    (e.PEG_ETH = "PEG_ETH"),
    (e.BTC = "BTC"),
    (e.ADA = "ADA"),
    (e.XRP = "XRP"),
    (e.TRX = "TRX"),
    (e.LTC = "LTC"),
    (e.DOGE = "DOGE"),
    (e.BUSDC = "BUSDC"),
    (e.BCH = "BCH"),
    (e.TON = "TON"),
  
    e
  ))(rg || {});
const mu = [
    {
      id: "Ethereum-ETH",
      networkName: "Ethereum",
      address: Mr,
      name: "Ethereum",
      shortName: "ETH",
      symbol: "ETH",
      icon: Sc,
      coinId: 1,
      decimals: 18,
      blockchainType: gn.EVM,
    },
    {
      id: "Bsc-BNB",
      networkName: "Bsc",
      address: Mr,
      name: "BNB Chain",
      shortName: "BSC",
      symbol: "BNB",
      icon: Nx,
      coinId: 56,
      decimals: 18,
      blockchainType: gn.EVM,
    },
    {
      id: "Polygon-MATIC",
      networkName: "Polygon",
      address: Mr,
      name: "Polygon",
      shortName: "POL",
      symbol: "MATIC",
      icon: Px,
      coinId: 137,
      decimals: 18,
      blockchainType: gn.EVM,
    },
    {
      id: "Arbitrum-ETH",
      networkName: "Arbitrum",
      address: Mr,
      name: "Ethereum",
      shortName: "ETH",
      symbol: "ETH",
      icon: kx,
      coinId: 42161,
      decimals: 18,
      blockchainType: gn.EVM,
    },
    {
      id: "Base-ETH",
      networkName: "Base",
      address: Mr,
      name: "Ethereum",
      shortName: "ETH",
      symbol: "ETH",
      icon: Mx,
      coinId: 8453,
      decimals: 18,
      blockchainType: gn.EVM,
    },
    {
      id: "Avalanche-AVAX",
      networkName: "Avalanche",
      address: Mr,
      name: "Avalanche",
      shortName: "AVAX",
      symbol: "AVAX",
      icon: Tx,
      coinId: 43114,
      decimals: 18,
      blockchainType: gn.EVM,
    },
    {
      id: "Optimism-ETH",
      networkName: "Optimism",
      address: Mr,
      name: "Ethereum",
      shortName: "ETH",
      symbol: "ETH",
      icon: Ox,
      coinId: 10,
      decimals: 18,
      blockchainType: gn.EVM,
    },
    {
      id: "Linea-ETH",
      networkName: "Linea",
      address: Mr,
      name: "Ethereum",
      shortName: "ETH",
      symbol: "ETH",
      icon: Rx,
      coinId: 59144,
      decimals: 18,
      blockchainType: gn.EVM,
    },
    {
      id: "Blast-ETH",
      networkName: "Blast",
      address: Mr,
      name: "Ethereum",
      shortName: "ETH",
      symbol: "ETH",
      icon: Ix,
      coinId: 81457,
      decimals: 18,
      blockchainType: gn.EVM,
    },
    {
      id: "ZkSync-ETH",
      networkName: "ZkSync",
      address: Mr,
      name: "Ethereum",
      shortName: "ETH",
      symbol: "ETH",
      icon: k8,
      coinId: 324,
      decimals: 18,
      blockchainType: gn.EVM,
    },
    {
      id: "Ethereum-USDT",
      networkName: "Ethereum",
      address: "0xdac17f958d2ee523a2206206994597c13d831ec7",
      name: "USDT",
      shortName: "USDT",
      symbol: "USDT",
      icon: Fs,
      decimals: 6,
      coinId: 1,
      blockchainType: gn.EVM,
    },
    {
      id: "Ethereum-USDC",
      networkName: "Ethereum",
      address: "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
      name: "USDC",
      shortName: "USDC",
      symbol: "USDC",
      icon: ci,
      decimals: 6,
      coinId: 1,
      blockchainType: gn.EVM,
    },
    {
      id: "Ethereum-SHIB",
      networkName: "Ethereum",
      address: pb,
      name: "SHIB",
      shortName: "SHIB",
      symbol: "SHIB",
      icon: WR,
      decimals: 18,
      coinId: 1,
      blockchainType: gn.EVM,
    },
    {
      id: "Bsc-USDT",
      networkName: "Bsc",
      address: "0x55d398326f99059ff775485246999027b3197955",
      name: "USDT",
      shortName: "USDT",
      symbol: "USDT",
      icon: Fs,
      decimals: 18,
      coinId: 56,
      blockchainType: gn.EVM,
    },
    {
      id: "Bsc-USDC",
      networkName: "Bsc",
      address: "0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d",
      name: "USDC",
      shortName: "USDC",
      symbol: "USDC",
      icon: ci,
      decimals: 18,
      coinId: 56,
      blockchainType: gn.EVM,
    },
    {
      id: "Bsc-FDUST",
      networkName: "Bsc",
      address: "0xc5f0f7b66764F6ec8C8Dff7BA683102295E16409",
      name: "First Digital USD",
      shortName: "FDUSD",
      symbol: "FDUST",
      icon: SX,
      decimals: 18,
      coinId: 56,
      blockchainType: gn.EVM,
    },
    {
      id: "Bsc-PEG_ETH",
      networkName: "Bsc",
      address: hb,
      name: "Pegged ETH",
      shortName: "PegETH",
      symbol: "PEG_ETH",
      icon: Sc,
      decimals: 18,
      coinId: 56,
      blockchainType: gn.EVM,
    },
    {
      id: "Polygon-USDT",
      networkName: "Polygon",
      address: "0xc2132D05D31c914a87C6611C10748AEb04B58e8F",
      name: "USDT",
      shortName: "USDT",
      symbol: "USDT",
      icon: Fs,
      decimals: 6,
      coinId: 137,
      blockchainType: gn.EVM,
    },
    {
      id: "Polygon-USDC",
      networkName: "Polygon",
      address: "0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359",
      name: "USDC",
      shortName: "USDC",
      symbol: "USDC",
      icon: ci,
      decimals: 6,
      coinId: 137,
      blockchainType: gn.EVM,
    },
    {
      id: "Polygon-BUSDC",
      networkName: "Polygon",
      address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174",
      name: "Bridged USDC",
      shortName: "USDC.e",
      symbol: "BUSDC",
      icon: ci,
      decimals: 6,
      coinId: 137,
      blockchainType: gn.EVM,
    },
    {
      id: "Arbitrum-USDT",
      networkName: "Arbitrum",
      address: "0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9",
      name: "USDT",
      shortName: "USDT",
      symbol: "USDT",
      icon: Fs,
      decimals: 6,
      coinId: 42161,
      blockchainType: gn.EVM,
    },
    {
      id: "Arbitrum-USDC",
      networkName: "Arbitrum",
      address: "0xaf88d065e77c8cC2239327C5EDb3A432268e5831",
      name: "USDC",
      shortName: "USDC",
      symbol: "USDC",
      icon: ci,
      decimals: 6,
      coinId: 42161,
      blockchainType: gn.EVM,
    },
    {
      id: "Arbitrum-BUSDC",
      networkName: "Arbitrum",
      address: "0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8",
      name: "Bridged USDC",
      shortName: "USDC.e",
      symbol: "BUSDC",
      icon: ci,
      decimals: 6,
      coinId: 42161,
      blockchainType: gn.EVM,
    },
    {
      id: "Base-USDC",
      networkName: "Base",
      address: "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",
      name: "USDC",
      shortName: "USDC",
      symbol: "USDC",
      icon: ci,
      decimals: 6,
      coinId: 8453,
      blockchainType: gn.EVM,
    },
    {
      id: "Base-DAI",
      networkName: "Base",
      address: "0x50c5725949A6F0c72E6C4a641F24049A917DB0Cb",
      name: "DAI",
      shortName: "DAI",
      symbol: "DAI",
      icon: Uf,
      decimals: 18,
      coinId: 8453,
      blockchainType: gn.EVM,
    },
    {
      id: "Optimism-USDT",
      networkName: "Optimism",
      address: "0x94b008aa00579c1307b0ef2c499ad98a8ce58e58",
      name: "USDT",
      shortName: "USDT",
      symbol: "USDT",
      icon: Fs,
      decimals: 6,
      coinId: 10,
      blockchainType: gn.EVM,
    },
    {
      id: "Optimism-USDC",
      networkName: "Optimism",
      address: "0x0b2C639c533813f4Aa9D7837CAf62653d097Ff85",
      name: "USDC",
      shortName: "USDC",
      symbol: "USDC",
      icon: ci,
      decimals: 6,
      coinId: 10,
      blockchainType: gn.EVM,
    },
    {
      id: "Optimism-BUSDC",
      networkName: "Optimism",
      address: "0x7F5c764cBc14f9669B88837ca1490cCa17c31607",
      name: "Bridged USDC",
      shortName: "USDC.e",
      symbol: "BUSDC",
      icon: ci,
      decimals: 6,
      coinId: 10,
      blockchainType: gn.EVM,
    },
    {
      id: "Avalanche-USDT",
      networkName: "Avalanche",
      address: "0x9702230A8Ea53601f5cD2dc00fDBc13d4dF4A8c7",
      name: "USDT",
      shortName: "USDT",
      symbol: "USDT",
      icon: Fs,
      decimals: 6,
      coinId: 43114,
      blockchainType: gn.EVM,
    },
    {
      id: "Avalanche-USDC",
      networkName: "Avalanche",
      address: "0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E",
      name: "USDC",
      shortName: "USDC",
      symbol: "USDC",
      icon: ci,
      decimals: 6,
      coinId: 43114,
      blockchainType: gn.EVM,
    },
    {
      id: "Avalanche-BUSDC",
      networkName: "Avalanche",
      address: "0xA7D7079b0FEaD91F3e65f86E8915Cb59c1a4C664",
      name: "Bridged USDC",
      shortName: "USDC.e",
      symbol: "BUSDC",
      icon: ci,
      decimals: 6,
      coinId: 43114,
      blockchainType: gn.EVM,
    },
    {
      id: "Blast-USDB",
      networkName: "Blast",
      address: "0x4300000000000000000000000000000000000003",
      name: "USDB",
      shortName: "USDB",
      symbol: "USDB",
      icon: EX,
      decimals: 18,
      coinId: 81457,
      blockchainType: gn.EVM,
    },
    {
      id: "Linea-USDT",
      networkName: "Linea",
      address: "0xa219439258ca9da29e9cc4ce5596924745e12b93",
      name: "USDT",
      shortName: "USDT",
      symbol: "USDT",
      icon: Fs,
      decimals: 6,
      coinId: 59144,
      blockchainType: gn.EVM,
    },
    {
      id: "Linea-USDC",
      networkName: "Linea",
      address: "0x176211869ca2b568f2a7d4ee941e073a821ee1ff",
      name: "USDC",
      shortName: "USDC",
      symbol: "USDC",
      icon: ci,
      decimals: 6,
      coinId: 59144,
      blockchainType: gn.EVM,
    },
    {
      id: "Linea-DAI",
      networkName: "Linea",
      address: "0x4af15ec2a0bd43db75dd04e62faa3b8ef36b00d5",
      name: "DAI",
      shortName: "DAI",
      symbol: "DAI",
      icon: Uf,
      decimals: 18,
      coinId: 59144,
      blockchainType: gn.EVM,
    },
    {
      id: "ZkSync-USDT",
      networkName: "ZkSync",
      address: "0x493257fD37EDB34451f62EDf8D2a0C418852bA4C",
      name: "USDT",
      shortName: "USDT",
      symbol: "USDT",
      icon: Fs,
      decimals: 6,
      coinId: 324,
      blockchainType: gn.EVM,
    },
    {
      id: "ZkSync-USDC",
      networkName: "ZkSync",
      address: "0x3355df6d4c9c3035724fd0e3914de96a5a83aaf4",
      name: "USDC",
      shortName: "USDC",
      symbol: "USDC",
      icon: ci,
      decimals: 6,
      coinId: 324,
      blockchainType: gn.EVM,
    },
    {
      id: "ZkSync-DAI",
      networkName: "ZkSync",
      address: "0x4B9eb6c0b6ea15176BBF62841C6B2A8a398cb656",
      name: "DAI",
      shortName: "DAI",
      symbol: "DAI",
      icon: Uf,
      decimals: 18,
      coinId: 324,
      blockchainType: gn.EVM,
    },
    {
      id: "Bitcoin-BTC",
      networkName: "Bitcoin",
      name: "Bitcoin",
      shortName: "BTC",
      symbol: "BTC",
      nowPaymentsId: 1001,
      icon: jR,
      coinId: 1001,
      blockchainType: gn.OTHER,
    },
    {
      id: "Tron-TRX",
      networkName: "Tron",
      name: "Tron",
      shortName: "TRX",
      symbol: "TRX",
      nowPaymentsId: 1e3,
      icon: DR,
      coinId: 1e3,
      blockchainType: gn.OTHER,
    },
    {
      id: "Litecoin-LTC",
      networkName: "Litecoin",
      name: "Litecoin",
      shortName: "LTC",
      symbol: "LTC",
      nowPaymentsId: 1003,
      icon: UR,
      coinId: 1003,
      blockchainType: gn.OTHER,
    },
    {
      id: "Dogecoin-DOGE",
      networkName: "Dogecoin",
      name: "Dogecoin",
      shortName: "DOGE",
      symbol: "DOGE",
      nowPaymentsId: 1004,
      icon: FR,
      coinId: 1004,
      blockchainType: gn.OTHER,
    },
    {
      id: "Ripple-XRP",
      networkName: "Ripple",
      name: "XRP",
      shortName: "XRP",
      symbol: "XRP",
      nowPaymentsId: 1005,
      icon: T8,
      coinId: 1005,
      blockchainType: gn.OTHER,
    },
    {
      id: "BitcoinCash-BCH",
      networkName: "BitcoinCash",
      name: "Bitcoin Cash",
      shortName: "BCH",
      symbol: "BCH",
      nowPaymentsId: 1006,
      icon: $R,
      coinId: 1006,
      blockchainType: gn.OTHER,
    },
    {
      id: "Toncoin-TON",
      networkName: "Toncoin",
      name: "Toncoin",
      shortName: "TON",
      symbol: "TON",
      nowPaymentsId: 1007,
      icon: BR,
      coinId: 1007,
      blockchainType: gn.OTHER,
    },
    {
      id: "Cardano-ADA",
      networkName: "Cardano",
      name: "Cardano",
      shortName: "ADA",
      symbol: "ADA",
      nowPaymentsId: 1008,
      icon: zR,
      coinId: 1008,
      blockchainType: gn.OTHER,
    },
    {
      id: "Ethereum-DAI",
      networkName: "Ethereum",
      name: "DAI",
      shortName: "DAI",
      symbol: "DAI",
      nowPaymentsId: 1009,
      icon: Uf,
      coinId: 1,
      blockchainType: gn.EVM,
    },
    


    {
      id: "Tron-USDT",
      networkName: "Tron",
      nowPaymentsId: 1002,
      name: "USDT TRC20",
      shortName: "USDTTRC20",
      symbol: "USDT",
      icon: Fs,
      coinId: 1e3,
      blockchainType: gn.OTHER,
    },
  ],
  B6e = "EtWFjjyscJFt29nJp5vJdQmQ3usqY1dKmQnTbbNNPqGY",
  F6e = {
    name: "sale_handler",
    version: "0.1.0",
    spec: "0.1.0",
    description: "Created with Anchor",
  },
  U6e = [
    {
      name: "disable_partner",
      discriminator: [13, 55, 104, 244, 56, 199, 102, 115],
      accounts: [
        { name: "partner", writable: !0 },
        { name: "payer", writable: !0, signer: !0 },
      ],
      args: [],
    },
    {
      name: "disable_sale_handler",
      discriminator: [244, 226, 38, 40, 85, 67, 141, 136],
      accounts: [
        { name: "sale_handler", writable: !0 },
        { name: "payer", writable: !0, signer: !0 },
      ],
      args: [],
    },
    {
      name: "disable_step",
      discriminator: [117, 38, 241, 134, 228, 195, 102, 185],
      accounts: [
        { name: "step", writable: !0 },
        { name: "sale_handler", writable: !0 },
        { name: "payer", writable: !0, signer: !0 },
      ],
      args: [],
    },
    {
      name: "enable_partner",
      discriminator: [72, 14, 80, 99, 208, 251, 194, 163],
      accounts: [
        { name: "partner", writable: !0 },
        { name: "payer", writable: !0, signer: !0 },
      ],
      args: [],
    },
    {
      name: "enable_sale_handler",
      discriminator: [47, 242, 204, 208, 88, 77, 219, 144],
      accounts: [
        { name: "sale_handler", writable: !0 },
        { name: "payer", writable: !0, signer: !0 },
      ],
      args: [],
    },
    {
      name: "enable_step",
      discriminator: [178, 157, 57, 104, 246, 119, 140, 175],
      accounts: [
        { name: "step", writable: !0 },
        { name: "sale_handler", writable: !0 },
        { name: "payer", writable: !0, signer: !0 },
      ],
      args: [],
    },
    {
      name: "init",
      discriminator: [220, 59, 207, 236, 108, 250, 47, 100],
      accounts: [
        { name: "sale_handler", writable: !0, pda: { seeds: [] } },
        { name: "payer", writable: !0, signer: !0 },
        { name: "system_program", address: "11111111111111111111111111111111" },
      ],
      args: [],
    },
    {
      name: "init_partner",
      discriminator: [221, 214, 183, 69, 22, 40, 219, 145],
      accounts: [
        {
          name: "partner",
          writable: !0,
          pda: {
            seeds: [
              { kind: "const", value: [80, 65, 82, 84, 78, 69, 82] },
              { kind: "const", value: [95] },
              { kind: "arg", path: "partner_code" },
            ],
          },
        },
        { name: "payer", writable: !0, signer: !0 },
        { name: "system_program", address: "11111111111111111111111111111111" },
      ],
      args: [
        { name: "_partner_code", type: "string" },
        { name: "main_interest", type: "u64" },
        { name: "secondary_interest", type: "u64" },
      ],
    },
    {
      name: "init_step",
      discriminator: [79, 37, 14, 204, 178, 148, 196, 192],
      accounts: [
        {
          name: "step",
          writable: !0,
          pda: {
            seeds: [
              { kind: "const", value: [83, 84, 69, 80] },
              { kind: "const", value: [95] },
              { kind: "arg", path: "id" },
            ],
          },
        },
        { name: "payer", writable: !0, signer: !0 },
        { name: "system_program", address: "11111111111111111111111111111111" },
      ],
      args: [
        { name: "id", type: "i16" },
        { name: "price", type: "u64" },
        { name: "total_supply", type: "u128" },
      ],
    },
    {
      name: "purchase_with_sol",
      discriminator: [27, 238, 240, 155, 170, 180, 26, 118],
      accounts: [
        { name: "sale_handler", writable: !0 },
        { name: "payer", writable: !0, signer: !0 },
        { name: "step", writable: !0 },
        {
          name: "purchaser",
          writable: !0,
          pda: {
            seeds: [
              { kind: "const", value: [80, 85, 82, 67, 72, 65, 83, 69, 82] },
              { kind: "const", value: [95] },
              { kind: "account", path: "payer" },
            ],
          },
        },
        {
          name: "partner",
          writable: !0,
          pda: {
            seeds: [
              { kind: "const", value: [80, 65, 82, 84, 78, 69, 82] },
              { kind: "const", value: [95] },
              { kind: "arg", path: "partner_code" },
            ],
          },
        },
        { name: "price_update" },
        { name: "bank_info", writable: !0 },
        { name: "system_program", address: "11111111111111111111111111111111" },
      ],
      args: [
        { name: "partner_code", type: "string" },
        { name: "amount", type: "u64" },
      ],
    },
    {
      name: "purchase_with_usdc",
      discriminator: [239, 251, 159, 72, 189, 180, 47, 135],
      accounts: [
        { name: "sale_handler", writable: !0 },
        { name: "payer", writable: !0, signer: !0 },
        { name: "step", writable: !0 },
        {
          name: "purchaser",
          writable: !0,
          pda: {
            seeds: [
              { kind: "const", value: [80, 85, 82, 67, 72, 65, 83, 69, 82] },
              { kind: "const", value: [95] },
              { kind: "account", path: "payer" },
            ],
          },
        },
        {
          name: "partner",
          writable: !0,
          pda: {
            seeds: [
              { kind: "const", value: [80, 65, 82, 84, 78, 69, 82] },
              { kind: "const", value: [95] },
              { kind: "arg", path: "partner_code" },
            ],
          },
        },
        { name: "purchaser_ata", writable: !0 },
        { name: "bank_ata", writable: !0 },
        { name: "partner_pda_ata", writable: !0 },
        {
          name: "token_program",
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
        },
        { name: "system_program", address: "11111111111111111111111111111111" },
      ],
      args: [
        { name: "partner_code", type: "string" },
        { name: "amount", type: "u64" },
      ],
    },
    {
      name: "purchase_with_usdt",
      discriminator: [209, 71, 158, 181, 243, 126, 63, 241],
      accounts: [
        { name: "sale_handler", writable: !0 },
        { name: "payer", writable: !0, signer: !0 },
        { name: "step", writable: !0 },
        {
          name: "purchaser",
          writable: !0,
          pda: {
            seeds: [
              { kind: "const", value: [80, 85, 82, 67, 72, 65, 83, 69, 82] },
              { kind: "const", value: [95] },
              { kind: "account", path: "payer" },
            ],
          },
        },
        {
          name: "partner",
          writable: !0,
          pda: {
            seeds: [
              { kind: "const", value: [80, 65, 82, 84, 78, 69, 82] },
              { kind: "const", value: [95] },
              { kind: "arg", path: "partner_code" },
            ],
          },
        },
        { name: "purchaser_ata", writable: !0 },
        { name: "bank_ata", writable: !0 },
        { name: "partner_pda_ata", writable: !0 },
        {
          name: "token_program",
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
        },
        { name: "system_program", address: "11111111111111111111111111111111" },
      ],
      args: [
        { name: "partner_code", type: "string" },
        { name: "amount", type: "u64" },
      ],
    },
    {
      name: "receive_sol",
      discriminator: [121, 244, 250, 3, 8, 229, 225, 1],
      accounts: [
        {
          name: "partner",
          writable: !0,
          pda: {
            seeds: [
              { kind: "const", value: [80, 65, 82, 84, 78, 69, 82] },
              { kind: "const", value: [95] },
              { kind: "arg", path: "partner_code" },
            ],
          },
        },
        {
          name: "ix_sysvar",
          address: "Sysvar1nstructions1111111111111111111111111",
        },
        { name: "payer", writable: !0, signer: !0 },
      ],
      args: [
        { name: "partner", type: "string" },
        { name: "deadline", type: "u128" },
        { name: "sig", type: { array: ["u8", 64] } },
        { name: "idx", type: "u32" },
      ],
    },
    {
      name: "receive_usdc",
      discriminator: [234, 4, 133, 7, 111, 131, 48, 237],
      accounts: [
        {
          name: "partner",
          writable: !0,
          pda: {
            seeds: [
              { kind: "const", value: [80, 65, 82, 84, 78, 69, 82] },
              { kind: "const", value: [95] },
              { kind: "arg", path: "partner_code" },
            ],
          },
        },
        { name: "partner_ata", writable: !0 },
        { name: "partner_pda_ata", writable: !0 },
        {
          name: "token_program",
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
        },
        {
          name: "ix_sysvar",
          address: "Sysvar1nstructions1111111111111111111111111",
        },
        { name: "payer", writable: !0, signer: !0 },
      ],
      args: [
        { name: "partner", type: "string" },
        { name: "deadline", type: "u128" },
        { name: "sig", type: { array: ["u8", 64] } },
        { name: "idx", type: "u32" },
      ],
    },
    {
      name: "receive_usdt",
      discriminator: [192, 212, 105, 29, 61, 88, 125, 227],
      accounts: [
        {
          name: "partner",
          writable: !0,
          pda: {
            seeds: [
              { kind: "const", value: [80, 65, 82, 84, 78, 69, 82] },
              { kind: "const", value: [95] },
              { kind: "arg", path: "partner_code" },
            ],
          },
        },
        { name: "partner_ata", writable: !0 },
        { name: "partner_pda_ata", writable: !0 },
        {
          name: "token_program",
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
        },
        {
          name: "ix_sysvar",
          address: "Sysvar1nstructions1111111111111111111111111",
        },
        { name: "payer", writable: !0, signer: !0 },
      ],
      args: [
        { name: "partner", type: "string" },
        { name: "deadline", type: "u128" },
        { name: "sig", type: { array: ["u8", 64] } },
        { name: "idx", type: "u32" },
      ],
    },
    {
      name: "set_partner_interest",
      discriminator: [12, 74, 170, 118, 125, 171, 78, 169],
      accounts: [
        { name: "partner", writable: !0 },
        { name: "payer", writable: !0, signer: !0 },
      ],
      args: [
        { name: "main_interest", type: "u64" },
        { name: "secondary_interest", type: "u64" },
      ],
    },
    {
      name: "set_sale_handler_cap",
      discriminator: [176, 174, 114, 22, 87, 53, 72, 6],
      accounts: [
        { name: "sale_handler", writable: !0 },
        { name: "payer", writable: !0, signer: !0 },
      ],
      args: [
        { name: "max_cap", type: "u64" },
        { name: "min_cap", type: "u64" },
      ],
    },
    {
      name: "set_sale_handler_partner_interest",
      discriminator: [66, 243, 19, 3, 139, 168, 76, 185],
      accounts: [
        { name: "sale_handler", writable: !0 },
        { name: "payer", writable: !0, signer: !0 },
      ],
      args: [
        { name: "main_interest", type: "u64" },
        { name: "secondary_interest", type: "u64" },
      ],
    },
    {
      name: "set_sale_handler_purchase_bonus",
      discriminator: [48, 27, 155, 123, 142, 125, 123, 115],
      accounts: [
        { name: "sale_handler", writable: !0 },
        { name: "payer", writable: !0, signer: !0 },
      ],
      args: [
        { name: "thresholds", type: { vec: "u64" } },
        { name: "percents", type: { vec: "u64" } },
      ],
    },
    {
      name: "set_step_price",
      discriminator: [158, 185, 23, 146, 123, 228, 216, 239],
      accounts: [
        { name: "step", writable: !0 },
        { name: "payer", writable: !0, signer: !0 },
      ],
      args: [{ name: "price", type: "u64" }],
    },
    {
      name: "set_step_supply",
      discriminator: [43, 27, 231, 48, 68, 147, 129, 0],
      accounts: [
        { name: "step", writable: !0 },
        { name: "payer", writable: !0, signer: !0 },
      ],
      args: [{ name: "total_supply", type: "u128" }],
    },
  ],
  $6e = [
    { name: "Partner", discriminator: [122, 43, 246, 239, 141, 56, 243, 182] },
    {
      name: "PriceUpdateV2",
      discriminator: [34, 241, 35, 99, 157, 126, 244, 205],
    },
    { name: "Purchaser", discriminator: [97, 76, 239, 54, 67, 65, 19, 121] },
    {
      name: "SaleHandler",
      discriminator: [220, 151, 165, 55, 199, 17, 104, 156],
    },
    { name: "Step", discriminator: [215, 98, 129, 236, 116, 128, 24, 137] },
  ],
  z6e = [
    {
      name: "PurchaseWithSol",
      discriminator: [214, 189, 229, 190, 99, 63, 237, 211],
    },
    {
      name: "PurchaseWithUsdc",
      discriminator: [93, 119, 171, 151, 188, 64, 202, 186],
    },
    {
      name: "PurchaseWithUsdt",
      discriminator: [20, 69, 116, 47, 61, 69, 239, 138],
    },
    {
      name: "ReceiveSol",
      discriminator: [63, 102, 203, 174, 235, 47, 21, 217],
    },
    {
      name: "ReceiveUsdc",
      discriminator: [211, 98, 63, 202, 17, 92, 228, 159],
    },
    {
      name: "ReceiveUsdt",
      discriminator: [32, 152, 86, 93, 220, 243, 230, 201],
    },
  ],
  W6e = [
    { code: 6e3, name: "Unauthorized", msg: "Unauthorized" },
    {
      code: 6001,
      name: "SignatureVerificationFailed",
      msg: "Signature verification failed.",
    },
    {
      code: 6002,
      name: "SaleHandlerEnabled",
      msg: "SaleHandler already enabled",
    },
    {
      code: 6003,
      name: "SaleHandlerDisabled",
      msg: "SaleHandler already disabled",
    },
    {
      code: 6004,
      name: "SaleHandlerNotEnabled",
      msg: "SaleHandler not enabled",
    },
    {
      code: 6005,
      name: "SaleHandlerMinCapTooLarge",
      msg: "SaleHandler min cap larger than max cap",
    },
    {
      code: 6006,
      name: "SaleHandlerMinCapNotReached",
      msg: "SaleHandler min cap not reached",
    },
    {
      code: 6007,
      name: "SaleHandlerMaxCapExceeded",
      msg: "SaleHandler max cap exceeded",
    },
    {
      code: 6008,
      name: "SaleHandlerMainPartnerInterestTooLarge",
      msg: "SaleHandler main partner interest too large",
    },
    {
      code: 6009,
      name: "SaleHandlerSecondaryPartnerInterestTooLarge",
      msg: "SaleHandler secondary partner interest too large",
    },
    { code: 6010, name: "StepSupplyTooSmall", msg: "Step supply is too small" },
    { code: 6011, name: "StepEnabled", msg: "Step already enabled" },
    { code: 6012, name: "StepDisabled", msg: "Step already disabled" },
    { code: 6013, name: "StepNotEnabled", msg: "Step not enabled" },
    {
      code: 6014,
      name: "StepSupplyExceeded",
      msg: "Step total supply exceeded",
    },
    { code: 6015, name: "InactiveStep", msg: "Inactive step account" },
    { code: 6016, name: "WrongPriceFeedId", msg: "Wrong price feed account" },
    { code: 6017, name: "WrongStablecoin", msg: "Wrong stablecoin account" },
    { code: 6018, name: "WrongBank", msg: "Wrong bank account" },
    { code: 6019, name: "PriceIsDown", msg: "Oracle price is down" },
    { code: 6020, name: "PartnerNoFunds", msg: "Partner no funds" },
    { code: 6021, name: "ExpiredSignature", msg: "Expired signature" },
    { code: 6022, name: "WrongBonusesLens", msg: "Wrong Bonuses Lens" },
    { code: 6023, name: "WrongBonusesValues", msg: "Wrong Bonuses Values" },
  ],
  H6e = [
    {
      name: "Partner",
      type: {
        kind: "struct",
        fields: [
          { name: "main_interest", type: "u64" },
          { name: "secondary_interest", type: "u64" },
          { name: "sol_reward", type: "u64" },
          { name: "usdt_reward", type: "u64" },
          { name: "usdc_reward", type: "u64" },
          { name: "token_reward", type: "u128" },
          { name: "enabled", type: "bool" },
        ],
      },
    },
    {
      name: "PriceFeedMessage",
      repr: { kind: "c" },
      type: {
        kind: "struct",
        fields: [
          { name: "feed_id", type: { array: ["u8", 32] } },
          { name: "price", type: "i64" },
          { name: "conf", type: "u64" },
          { name: "exponent", type: "i32" },
          {
            name: "publish_time",
            docs: ["The timestamp of this price update in seconds"],
            type: "i64",
          },
          {
            name: "prev_publish_time",
            docs: [
              "The timestamp of the previous price update. This field is intended to allow users to",
              "identify the single unique price update for any moment in time:",
              "for any time t, the unique update is the one such that prev_publish_time < t <= publish_time.",
              "",
              "Note that there may not be such an update while we are migrating to the new message-sending logic,",
              "as some price updates on pythnet may not be sent to other chains (because the message-sending",
              "logic may not have triggered). We can solve this problem by making the message-sending mandatory",
              "(which we can do once publishers have migrated over).",
              "",
              "Additionally, this field may be equal to publish_time if the message is sent on a slot where",
              "where the aggregation was unsuccesful. This problem will go away once all publishers have",
              "migrated over to a recent version of pyth-agent.",
            ],
            type: "i64",
          },
          { name: "ema_price", type: "i64" },
          { name: "ema_conf", type: "u64" },
        ],
      },
    },
    {
      name: "PriceUpdateV2",
      docs: [
        "A price update account. This account is used by the Pyth Receiver program to store a verified price update from a Pyth price feed.",
        "It contains:",
        "- `write_authority`: The write authority for this account. This authority can close this account to reclaim rent or update the account to contain a different price update.",
        "- `verification_level`: The [`VerificationLevel`] of this price update. This represents how many Wormhole guardian signatures have been verified for this price update.",
        "- `price_message`: The actual price update.",
        "- `posted_slot`: The slot at which this price update was posted.",
      ],
      type: {
        kind: "struct",
        fields: [
          { name: "write_authority", type: "pubkey" },
          {
            name: "verification_level",
            type: { defined: { name: "VerificationLevel" } },
          },
          {
            name: "price_message",
            type: { defined: { name: "PriceFeedMessage" } },
          },
          { name: "posted_slot", type: "u64" },
        ],
      },
    },
    {
      name: "PurchaseWithSol",
      type: {
        kind: "struct",
        fields: [
          { name: "step", type: "i16" },
          { name: "purchaser", type: "pubkey" },
          { name: "partner", type: "string" },
          { name: "usd_equivalent", type: "u128" },
          { name: "sol_amount", type: "u64" },
          { name: "token_amount", type: "u128" },
        ],
      },
    },
    {
      name: "PurchaseWithUsdc",
      type: {
        kind: "struct",
        fields: [
          { name: "step", type: "i16" },
          { name: "purchaser", type: "pubkey" },
          { name: "partner", type: "string" },
          { name: "usd_equivalent", type: "u128" },
          { name: "usdc_amount", type: "u64" },
          { name: "token_amount", type: "u128" },
        ],
      },
    },
    {
      name: "PurchaseWithUsdt",
      type: {
        kind: "struct",
        fields: [
          { name: "step", type: "i16" },
          { name: "purchaser", type: "pubkey" },
          { name: "partner", type: "string" },
          { name: "usd_equivalent", type: "u128" },
          { name: "usdt_amount", type: "u64" },
          { name: "token_amount", type: "u128" },
        ],
      },
    },
    {
      name: "Purchaser",
      type: { kind: "struct", fields: [{ name: "purchased", type: "u128" }] },
    },
    {
      name: "ReceiveSol",
      type: {
        kind: "struct",
        fields: [
          { name: "partner", type: "string" },
          { name: "amount", type: "u64" },
        ],
      },
    },
    {
      name: "ReceiveUsdc",
      type: {
        kind: "struct",
        fields: [
          { name: "partner", type: "string" },
          { name: "amount", type: "u64" },
        ],
      },
    },
    {
      name: "ReceiveUsdt",
      type: {
        kind: "struct",
        fields: [
          { name: "partner", type: "string" },
          { name: "amount", type: "u64" },
        ],
      },
    },
    {
      name: "SaleHandler",
      type: {
        kind: "struct",
        fields: [
          { name: "max_cap", type: "u64" },
          { name: "min_cap", type: "u64" },
          { name: "main_interest", type: "u64" },
          { name: "secondary_interest", type: "u64" },
          { name: "total_sold", type: "u128" },
          { name: "step", type: "i16" },
          {
            name: "status",
            type: {
              defined: { name: "sale_handler::state::sale_handler::Status" },
            },
          },
          { name: "enabled", type: "bool" },
          { name: "bonus_percents", type: { vec: "u64" } },
          { name: "bonus_thresholds", type: { vec: "u64" } },
        ],
      },
    },
    {
      name: "Step",
      type: {
        kind: "struct",
        fields: [
          { name: "id", type: "i16" },
          { name: "price", type: "u64" },
          { name: "total_sold", type: "u128" },
          { name: "total_supply", type: "u128" },
          {
            name: "status",
            type: { defined: { name: "sale_handler::state::step::Status" } },
          },
        ],
      },
    },
    {
      name: "VerificationLevel",
      docs: [
        "Pyth price updates are bridged to all blockchains via Wormhole.",
        "Using the price updates on another chain requires verifying the signatures of the Wormhole guardians.",
        "The usual process is to check the signatures for two thirds of the total number of guardians, but this can be cumbersome on Solana because of the transaction size limits,",
        "so we also allow for partial verification.",
        "",
        "This enum represents how much a price update has been verified:",
        "- If `Full`, we have verified the signatures for two thirds of the current guardians.",
        "- If `Partial`, only `num_signatures` guardian signatures have been checked.",
        "",
        "# Warning",
        "Using partially verified price updates is dangerous, as it lowers the threshold of guardians that need to collude to produce a malicious price update.",
      ],
      type: {
        kind: "enum",
        variants: [
          { name: "Partial", fields: [{ name: "num_signatures", type: "u8" }] },
          { name: "Full" },
        ],
      },
    },
    {
      name: "sale_handler::state::sale_handler::Status",
      type: {
        kind: "enum",
        variants: [{ name: "None" }, { name: "Enabled" }, { name: "Disabled" }],
      },
    },
    {
      name: "sale_handler::state::step::Status",
      type: {
        kind: "enum",
        variants: [{ name: "None" }, { name: "Enabled" }, { name: "Disabled" }],
      },
    },
  ],
  V6e = {
    address: B6e,
    metadata: F6e,
    instructions: U6e,
    accounts: $6e,
    events: z6e,
    errors: W6e,
    types: H6e,
  },
  G6e = [],
  YR = 9,
  DT = "SOL",
  y1 = "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB",
  gv = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
  q6e = "Solana:Usdc",
  K6e = "Solana:Usdt",
  Y6e = {
    name: "Solana",
    displayName: "Solana",
    icon: _6e,
    shortName: DT,
    networkId: ir.solana,
    nativeSymbol: DT,
  },

  v1 = "processed",
  RX = "https://solana-rpc.publicnode.com",
  $s = new gR(RX, v1),
  hd = JSON.parse(JSON.stringify(V6e));
new Pe(hd.address);
const OX = "",
  PX = new Pe("CfDa3Wj5zeDvKXDfiL2RmYR6y9ikiiJAtQopmLRTdNWM"),
  Z6e = new Pe("CfDa3Wj5zeDvKXDfiL2RmYR6y9ikiiJAtQopmLRTdNWM"),
  v5 = new Pe("CfDa3Wj5zeDvKXDfiL2RmYR6y9ikiiJAtQopmLRTdNWM"),
  Q6e = new Pe("CfDa3Wj5zeDvKXDfiL2RmYR6y9ikiiJAtQopmLRTdNWM"),
  X6e = new Pe("CfDa3Wj5zeDvKXDfiL2RmYR6y9ikiiJAtQopmLRTdNWM"),
  Ta = 10 ** YR,
  mb = 10 ** 6,
  w5 = 0.06,
  J6e = "modulepreload",
  e5e = function (e) {
    return "/" + e;
  },
  GU = {},
  At = function (t, n, r) {
    let i = Promise.resolve();
    if (n && n.length > 0) {
      document.getElementsByTagName("link");
      const o = document.querySelector("meta[property=csp-nonce]"),
        a =
          (o == null ? void 0 : o.nonce) ||
          (o == null ? void 0 : o.getAttribute("nonce"));
      i = Promise.allSettled(
        n.map((l) => {
          if (((l = e5e(l)), l in GU)) return;
          GU[l] = !0;
          const c = l.endsWith(".css"),
            u = c ? '[rel="stylesheet"]' : "";
          if (document.querySelector(`link[href="${l}"]${u}`)) return;
          const d = document.createElement("link");
          if (
            ((d.rel = c ? "stylesheet" : J6e),
            c || (d.as = "script"),
            (d.crossOrigin = ""),
            (d.href = l),
            a && d.setAttribute("nonce", a),
            document.head.appendChild(d),
            c)
          )
            return new Promise((f, h) => {
              d.addEventListener("load", f),
                d.addEventListener("error", () =>
                  h(new Error(`Unable to preload CSS for ${l}`))
                );
            });
        })
      );
    }
    function s(o) {
      const a = new Event("vite:preloadError", { cancelable: !0 });
      if (((a.payload = o), window.dispatchEvent(a), !a.defaultPrevented))
        throw o;
    }
    return i.then((o) => {
      for (const a of o || []) a.status === "rejected" && s(a.reason);
      return t().catch(s);
    });
  };
var BT = function (e, t) {
  return (
    (BT =
      Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array &&
        function (n, r) {
          n.__proto__ = r;
        }) ||
      function (n, r) {
        for (var i in r)
          Object.prototype.hasOwnProperty.call(r, i) && (n[i] = r[i]);
      }),
    BT(e, t)
  );
};
function Ou(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError(
      "Class extends value " + String(t) + " is not a constructor or null"
    );
  BT(e, t);
  function n() {
    this.constructor = e;
  }
  e.prototype =
    t === null ? Object.create(t) : ((n.prototype = t.prototype), new n());
}
var ti = function () {
  return (
    (ti =
      Object.assign ||
      function (t) {
        for (var n, r = 1, i = arguments.length; r < i; r++) {
          n = arguments[r];
          for (var s in n)
            Object.prototype.hasOwnProperty.call(n, s) && (t[s] = n[s]);
        }
        return t;
      }),
    ti.apply(this, arguments)
  );
};
function t5e(e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(u) {
      try {
        c(r.next(u));
      } catch (d) {
        o(d);
      }
    }
    function l(u) {
      try {
        c(r.throw(u));
      } catch (d) {
        o(d);
      }
    }
    function c(u) {
      u.done ? s(u.value) : i(u.value).then(a, l);
    }
    c((r = r.apply(e, t || [])).next());
  });
}
function LX(e, t) {
  var n = {
      label: 0,
      sent: function () {
        if (s[0] & 1) throw s[1];
        return s[1];
      },
      trys: [],
      ops: [],
    },
    r,
    i,
    s,
    o = Object.create(
      (typeof Iterator == "function" ? Iterator : Object).prototype
    );
  return (
    (o.next = a(0)),
    (o.throw = a(1)),
    (o.return = a(2)),
    typeof Symbol == "function" &&
      (o[Symbol.iterator] = function () {
        return this;
      }),
    o
  );
  function a(c) {
    return function (u) {
      return l([c, u]);
    };
  }
  function l(c) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; o && ((o = 0), c[0] && (n = 0)), n; )
      try {
        if (
          ((r = 1),
          i &&
            (s =
              c[0] & 2
                ? i.return
                : c[0]
                ? i.throw || ((s = i.return) && s.call(i), 0)
                : i.next) &&
            !(s = s.call(i, c[1])).done)
        )
          return s;
        switch (((i = 0), s && (c = [c[0] & 2, s.value]), c[0])) {
          case 0:
          case 1:
            s = c;
            break;
          case 4:
            return n.label++, { value: c[1], done: !1 };
          case 5:
            n.label++, (i = c[1]), (c = [0]);
            continue;
          case 7:
            (c = n.ops.pop()), n.trys.pop();
            continue;
          default:
            if (
              ((s = n.trys),
              !(s = s.length > 0 && s[s.length - 1]) &&
                (c[0] === 6 || c[0] === 2))
            ) {
              n = 0;
              continue;
            }
            if (c[0] === 3 && (!s || (c[1] > s[0] && c[1] < s[3]))) {
              n.label = c[1];
              break;
            }
            if (c[0] === 6 && n.label < s[1]) {
              (n.label = s[1]), (s = c);
              break;
            }
            if (s && n.label < s[2]) {
              (n.label = s[2]), n.ops.push(c);
              break;
            }
            s[2] && n.ops.pop(), n.trys.pop();
            continue;
        }
        c = t.call(e, n);
      } catch (u) {
        (c = [6, u]), (i = 0);
      } finally {
        r = s = 0;
      }
    if (c[0] & 5) throw c[1];
    return { value: c[0] ? c[1] : void 0, done: !0 };
  }
}
function Ny(e) {
  var t = typeof Symbol == "function" && Symbol.iterator,
    n = t && e[t],
    r = 0;
  if (n) return n.call(e);
  if (e && typeof e.length == "number")
    return {
      next: function () {
        return (
          e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e }
        );
      },
    };
  throw new TypeError(
    t ? "Object is not iterable." : "Symbol.iterator is not defined."
  );
}
function Jp(e, t) {
  var n = typeof Symbol == "function" && e[Symbol.iterator];
  if (!n) return e;
  var r = n.call(e),
    i,
    s = [],
    o;
  try {
    for (; (t === void 0 || t-- > 0) && !(i = r.next()).done; ) s.push(i.value);
  } catch (a) {
    o = { error: a };
  } finally {
    try {
      i && !i.done && (n = r.return) && n.call(r);
    } finally {
      if (o) throw o.error;
    }
  }
  return s;
}
function wd(e, t, n) {
  if (n || arguments.length === 2)
    for (var r = 0, i = t.length, s; r < i; r++)
      (s || !(r in t)) &&
        (s || (s = Array.prototype.slice.call(t, 0, r)), (s[r] = t[r]));
  return e.concat(s || Array.prototype.slice.call(t));
}
function Xg(e) {
  return this instanceof Xg ? ((this.v = e), this) : new Xg(e);
}
function n5e(e, t, n) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = n.apply(e, t || []),
    i,
    s = [];
  return (
    (i = Object.create(
      (typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype
    )),
    a("next"),
    a("throw"),
    a("return", o),
    (i[Symbol.asyncIterator] = function () {
      return this;
    }),
    i
  );
  function o(h) {
    return function (p) {
      return Promise.resolve(p).then(h, d);
    };
  }
  function a(h, p) {
    r[h] &&
      ((i[h] = function (g) {
        return new Promise(function (b, v) {
          s.push([h, g, b, v]) > 1 || l(h, g);
        });
      }),
      p && (i[h] = p(i[h])));
  }
  function l(h, p) {
    try {
      c(r[h](p));
    } catch (g) {
      f(s[0][3], g);
    }
  }
  function c(h) {
    h.value instanceof Xg
      ? Promise.resolve(h.value.v).then(u, d)
      : f(s[0][2], h);
  }
  function u(h) {
    l("next", h);
  }
  function d(h) {
    l("throw", h);
  }
  function f(h, p) {
    h(p), s.shift(), s.length && l(s[0][0], s[0][1]);
  }
}
function r5e(e) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var t = e[Symbol.asyncIterator],
    n;
  return t
    ? t.call(e)
    : ((e = typeof Ny == "function" ? Ny(e) : e[Symbol.iterator]()),
      (n = {}),
      r("next"),
      r("throw"),
      r("return"),
      (n[Symbol.asyncIterator] = function () {
        return this;
      }),
      n);
  function r(s) {
    n[s] =
      e[s] &&
      function (o) {
        return new Promise(function (a, l) {
          (o = e[s](o)), i(a, l, o.done, o.value);
        });
      };
  }
  function i(s, o, a, l) {
    Promise.resolve(l).then(function (c) {
      s({ value: c, done: a });
    }, o);
  }
}
function bi(e) {
  return typeof e == "function";
}
function ZR(e) {
  var t = function (r) {
      Error.call(r), (r.stack = new Error().stack);
    },
    n = e(t);
  return (
    (n.prototype = Object.create(Error.prototype)),
    (n.prototype.constructor = n),
    n
  );
}
var pC = ZR(function (e) {
  return function (n) {
    e(this),
      (this.message = n
        ? n.length +
          ` errors occurred during unsubscription:
` +
          n.map(function (r, i) {
            return i + 1 + ") " + r.toString();
          }).join(`
  `)
        : ""),
      (this.name = "UnsubscriptionError"),
      (this.errors = n);
  };
});
function FT(e, t) {
  if (e) {
    var n = e.indexOf(t);
    0 <= n && e.splice(n, 1);
  }
}
var M8 = (function () {
    function e(t) {
      (this.initialTeardown = t),
        (this.closed = !1),
        (this._parentage = null),
        (this._finalizers = null);
    }
    return (
      (e.prototype.unsubscribe = function () {
        var t, n, r, i, s;
        if (!this.closed) {
          this.closed = !0;
          var o = this._parentage;
          if (o)
            if (((this._parentage = null), Array.isArray(o)))
              try {
                for (var a = Ny(o), l = a.next(); !l.done; l = a.next()) {
                  var c = l.value;
                  c.remove(this);
                }
              } catch (g) {
                t = { error: g };
              } finally {
                try {
                  l && !l.done && (n = a.return) && n.call(a);
                } finally {
                  if (t) throw t.error;
                }
              }
            else o.remove(this);
          var u = this.initialTeardown;
          if (bi(u))
            try {
              u();
            } catch (g) {
              s = g instanceof pC ? g.errors : [g];
            }
          var d = this._finalizers;
          if (d) {
            this._finalizers = null;
            try {
              for (var f = Ny(d), h = f.next(); !h.done; h = f.next()) {
                var p = h.value;
                try {
                  qU(p);
                } catch (g) {
                  (s = s ?? []),
                    g instanceof pC
                      ? (s = wd(wd([], Jp(s)), Jp(g.errors)))
                      : s.push(g);
                }
              }
            } catch (g) {
              r = { error: g };
            } finally {
              try {
                h && !h.done && (i = f.return) && i.call(f);
              } finally {
                if (r) throw r.error;
              }
            }
          }
          if (s) throw new pC(s);
        }
      }),
      (e.prototype.add = function (t) {
        var n;
        if (t && t !== this)
          if (this.closed) qU(t);
          else {
            if (t instanceof e) {
              if (t.closed || t._hasParent(this)) return;
              t._addParent(this);
            }
            (this._finalizers =
              (n = this._finalizers) !== null && n !== void 0 ? n : []).push(t);
          }
      }),
      (e.prototype._hasParent = function (t) {
        var n = this._parentage;
        return n === t || (Array.isArray(n) && n.includes(t));
      }),
      (e.prototype._addParent = function (t) {
        var n = this._parentage;
        this._parentage = Array.isArray(n) ? (n.push(t), n) : n ? [n, t] : t;
      }),
      (e.prototype._removeParent = function (t) {
        var n = this._parentage;
        n === t ? (this._parentage = null) : Array.isArray(n) && FT(n, t);
      }),
      (e.prototype.remove = function (t) {
        var n = this._finalizers;
        n && FT(n, t), t instanceof e && t._removeParent(this);
      }),
      (e.EMPTY = (function () {
        var t = new e();
        return (t.closed = !0), t;
      })()),
      e
    );
  })(),
  jX = M8.EMPTY;
function DX(e) {
  return (
    e instanceof M8 ||
    (e && "closed" in e && bi(e.remove) && bi(e.add) && bi(e.unsubscribe))
  );
}
function qU(e) {
  bi(e) ? e() : e.unsubscribe();
}
var BX = {
    onUnhandledError: null,
    onStoppedNotification: null,
    Promise: void 0,
    useDeprecatedSynchronousErrorHandling: !1,
    useDeprecatedNextContext: !1,
  },
  FX = {
    setTimeout: function (e, t) {
      for (var n = [], r = 2; r < arguments.length; r++)
        n[r - 2] = arguments[r];
      return setTimeout.apply(void 0, wd([e, t], Jp(n)));
    },
    clearTimeout: function (e) {
      var t = FX.delegate;
      return ((t == null ? void 0 : t.clearTimeout) || clearTimeout)(e);
    },
    delegate: void 0,
  };
function UX(e) {
  FX.setTimeout(function () {
    throw e;
  });
}
function b5() {}
function D4(e) {
  e();
}
var QR = (function (e) {
    Ou(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return (
        (r.isStopped = !1),
        n ? ((r.destination = n), DX(n) && n.add(r)) : (r.destination = a5e),
        r
      );
    }
    return (
      (t.create = function (n, r, i) {
        return new Ry(n, r, i);
      }),
      (t.prototype.next = function (n) {
        this.isStopped || this._next(n);
      }),
      (t.prototype.error = function (n) {
        this.isStopped || ((this.isStopped = !0), this._error(n));
      }),
      (t.prototype.complete = function () {
        this.isStopped || ((this.isStopped = !0), this._complete());
      }),
      (t.prototype.unsubscribe = function () {
        this.closed ||
          ((this.isStopped = !0),
          e.prototype.unsubscribe.call(this),
          (this.destination = null));
      }),
      (t.prototype._next = function (n) {
        this.destination.next(n);
      }),
      (t.prototype._error = function (n) {
        try {
          this.destination.error(n);
        } finally {
          this.unsubscribe();
        }
      }),
      (t.prototype._complete = function () {
        try {
          this.destination.complete();
        } finally {
          this.unsubscribe();
        }
      }),
      t
    );
  })(M8),
  i5e = Function.prototype.bind;
function mC(e, t) {
  return i5e.call(e, t);
}
var s5e = (function () {
    function e(t) {
      this.partialObserver = t;
    }
    return (
      (e.prototype.next = function (t) {
        var n = this.partialObserver;
        if (n.next)
          try {
            n.next(t);
          } catch (r) {
            O_(r);
          }
      }),
      (e.prototype.error = function (t) {
        var n = this.partialObserver;
        if (n.error)
          try {
            n.error(t);
          } catch (r) {
            O_(r);
          }
        else O_(t);
      }),
      (e.prototype.complete = function () {
        var t = this.partialObserver;
        if (t.complete)
          try {
            t.complete();
          } catch (n) {
            O_(n);
          }
      }),
      e
    );
  })(),
  Ry = (function (e) {
    Ou(t, e);
    function t(n, r, i) {
      var s = e.call(this) || this,
        o;
      if (bi(n) || !n)
        o = { next: n ?? void 0, error: r ?? void 0, complete: i ?? void 0 };
      else {
        var a;
        s && BX.useDeprecatedNextContext
          ? ((a = Object.create(n)),
            (a.unsubscribe = function () {
              return s.unsubscribe();
            }),
            (o = {
              next: n.next && mC(n.next, a),
              error: n.error && mC(n.error, a),
              complete: n.complete && mC(n.complete, a),
            }))
          : (o = n);
      }
      return (s.destination = new s5e(o)), s;
    }
    return t;
  })(QR);
function O_(e) {
  UX(e);
}
function o5e(e) {
  throw e;
}
var a5e = { closed: !0, next: b5, error: o5e, complete: b5 },
  XR = (function () {
    return (typeof Symbol == "function" && Symbol.observable) || "@@observable";
  })();
function I8(e) {
  return e;
}
function l5e(e) {
  return e.length === 0
    ? I8
    : e.length === 1
    ? e[0]
    : function (n) {
        return e.reduce(function (r, i) {
          return i(r);
        }, n);
      };
}
var Ia = (function () {
  function e(t) {
    t && (this._subscribe = t);
  }
  return (
    (e.prototype.lift = function (t) {
      var n = new e();
      return (n.source = this), (n.operator = t), n;
    }),
    (e.prototype.subscribe = function (t, n, r) {
      var i = this,
        s = u5e(t) ? t : new Ry(t, n, r);
      return (
        D4(function () {
          var o = i,
            a = o.operator,
            l = o.source;
          s.add(a ? a.call(s, l) : l ? i._subscribe(s) : i._trySubscribe(s));
        }),
        s
      );
    }),
    (e.prototype._trySubscribe = function (t) {
      try {
        return this._subscribe(t);
      } catch (n) {
        t.error(n);
      }
    }),
    (e.prototype.forEach = function (t, n) {
      var r = this;
      return (
        (n = KU(n)),
        new n(function (i, s) {
          var o = new Ry({
            next: function (a) {
              try {
                t(a);
              } catch (l) {
                s(l), o.unsubscribe();
              }
            },
            error: s,
            complete: i,
          });
          r.subscribe(o);
        })
      );
    }),
    (e.prototype._subscribe = function (t) {
      var n;
      return (n = this.source) === null || n === void 0
        ? void 0
        : n.subscribe(t);
    }),
    (e.prototype[XR] = function () {
      return this;
    }),
    (e.prototype.pipe = function () {
      for (var t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n];
      return l5e(t)(this);
    }),
    (e.prototype.toPromise = function (t) {
      var n = this;
      return (
        (t = KU(t)),
        new t(function (r, i) {
          var s;
          n.subscribe(
            function (o) {
              return (s = o);
            },
            function (o) {
              return i(o);
            },
            function () {
              return r(s);
            }
          );
        })
      );
    }),
    (e.create = function (t) {
      return new e(t);
    }),
    e
  );
})();
function KU(e) {
  var t;
  return (t = e ?? BX.Promise) !== null && t !== void 0 ? t : Promise;
}
function c5e(e) {
  return e && bi(e.next) && bi(e.error) && bi(e.complete);
}
function u5e(e) {
  return (e && e instanceof QR) || (c5e(e) && DX(e));
}
function d5e(e) {
  return bi(e == null ? void 0 : e.lift);
}
function jc(e) {
  return function (t) {
    if (d5e(t))
      return t.lift(function (n) {
        try {
          return e(n, this);
        } catch (r) {
          this.error(r);
        }
      });
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
function Rc(e, t, n, r, i) {
  return new f5e(e, t, n, r, i);
}
var f5e = (function (e) {
    Ou(t, e);
    function t(n, r, i, s, o, a) {
      var l = e.call(this, n) || this;
      return (
        (l.onFinalize = o),
        (l.shouldUnsubscribe = a),
        (l._next = r
          ? function (c) {
              try {
                r(c);
              } catch (u) {
                n.error(u);
              }
            }
          : e.prototype._next),
        (l._error = s
          ? function (c) {
              try {
                s(c);
              } catch (u) {
                n.error(u);
              } finally {
                this.unsubscribe();
              }
            }
          : e.prototype._error),
        (l._complete = i
          ? function () {
              try {
                i();
              } catch (c) {
                n.error(c);
              } finally {
                this.unsubscribe();
              }
            }
          : e.prototype._complete),
        l
      );
    }
    return (
      (t.prototype.unsubscribe = function () {
        var n;
        if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
          var r = this.closed;
          e.prototype.unsubscribe.call(this),
            !r &&
              ((n = this.onFinalize) === null || n === void 0 || n.call(this));
        }
      }),
      t
    );
  })(QR),
  h5e = ZR(function (e) {
    return function () {
      e(this),
        (this.name = "ObjectUnsubscribedError"),
        (this.message = "object unsubscribed");
    };
  }),
  xh = (function (e) {
    Ou(t, e);
    function t() {
      var n = e.call(this) || this;
      return (
        (n.closed = !1),
        (n.currentObservers = null),
        (n.observers = []),
        (n.isStopped = !1),
        (n.hasError = !1),
        (n.thrownError = null),
        n
      );
    }
    return (
      (t.prototype.lift = function (n) {
        var r = new YU(this, this);
        return (r.operator = n), r;
      }),
      (t.prototype._throwIfClosed = function () {
        if (this.closed) throw new h5e();
      }),
      (t.prototype.next = function (n) {
        var r = this;
        D4(function () {
          var i, s;
          if ((r._throwIfClosed(), !r.isStopped)) {
            r.currentObservers ||
              (r.currentObservers = Array.from(r.observers));
            try {
              for (
                var o = Ny(r.currentObservers), a = o.next();
                !a.done;
                a = o.next()
              ) {
                var l = a.value;
                l.next(n);
              }
            } catch (c) {
              i = { error: c };
            } finally {
              try {
                a && !a.done && (s = o.return) && s.call(o);
              } finally {
                if (i) throw i.error;
              }
            }
          }
        });
      }),
      (t.prototype.error = function (n) {
        var r = this;
        D4(function () {
          if ((r._throwIfClosed(), !r.isStopped)) {
            (r.hasError = r.isStopped = !0), (r.thrownError = n);
            for (var i = r.observers; i.length; ) i.shift().error(n);
          }
        });
      }),
      (t.prototype.complete = function () {
        var n = this;
        D4(function () {
          if ((n._throwIfClosed(), !n.isStopped)) {
            n.isStopped = !0;
            for (var r = n.observers; r.length; ) r.shift().complete();
          }
        });
      }),
      (t.prototype.unsubscribe = function () {
        (this.isStopped = this.closed = !0),
          (this.observers = this.currentObservers = null);
      }),
      Object.defineProperty(t.prototype, "observed", {
        get: function () {
          var n;
          return (
            ((n = this.observers) === null || n === void 0
              ? void 0
              : n.length) > 0
          );
        },
        enumerable: !1,
        configurable: !0,
      }),
      (t.prototype._trySubscribe = function (n) {
        return this._throwIfClosed(), e.prototype._trySubscribe.call(this, n);
      }),
      (t.prototype._subscribe = function (n) {
        return (
          this._throwIfClosed(),
          this._checkFinalizedStatuses(n),
          this._innerSubscribe(n)
        );
      }),
      (t.prototype._innerSubscribe = function (n) {
        var r = this,
          i = this,
          s = i.hasError,
          o = i.isStopped,
          a = i.observers;
        return s || o
          ? jX
          : ((this.currentObservers = null),
            a.push(n),
            new M8(function () {
              (r.currentObservers = null), FT(a, n);
            }));
      }),
      (t.prototype._checkFinalizedStatuses = function (n) {
        var r = this,
          i = r.hasError,
          s = r.thrownError,
          o = r.isStopped;
        i ? n.error(s) : o && n.complete();
      }),
      (t.prototype.asObservable = function () {
        var n = new Ia();
        return (n.source = this), n;
      }),
      (t.create = function (n, r) {
        return new YU(n, r);
      }),
      t
    );
  })(Ia),
  YU = (function (e) {
    Ou(t, e);
    function t(n, r) {
      var i = e.call(this) || this;
      return (i.destination = n), (i.source = r), i;
    }
    return (
      (t.prototype.next = function (n) {
        var r, i;
        (i =
          (r = this.destination) === null || r === void 0 ? void 0 : r.next) ===
          null ||
          i === void 0 ||
          i.call(r, n);
      }),
      (t.prototype.error = function (n) {
        var r, i;
        (i =
          (r = this.destination) === null || r === void 0
            ? void 0
            : r.error) === null ||
          i === void 0 ||
          i.call(r, n);
      }),
      (t.prototype.complete = function () {
        var n, r;
        (r =
          (n = this.destination) === null || n === void 0
            ? void 0
            : n.complete) === null ||
          r === void 0 ||
          r.call(n);
      }),
      (t.prototype._subscribe = function (n) {
        var r, i;
        return (i =
          (r = this.source) === null || r === void 0
            ? void 0
            : r.subscribe(n)) !== null && i !== void 0
          ? i
          : jX;
      }),
      t
    );
  })(xh),
  jx = (function (e) {
    Ou(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return (r._value = n), r;
    }
    return (
      Object.defineProperty(t.prototype, "value", {
        get: function () {
          return this.getValue();
        },
        enumerable: !1,
        configurable: !0,
      }),
      (t.prototype._subscribe = function (n) {
        var r = e.prototype._subscribe.call(this, n);
        return !r.closed && n.next(this._value), r;
      }),
      (t.prototype.getValue = function () {
        var n = this,
          r = n.hasError,
          i = n.thrownError,
          s = n._value;
        if (r) throw i;
        return this._throwIfClosed(), s;
      }),
      (t.prototype.next = function (n) {
        e.prototype.next.call(this, (this._value = n));
      }),
      t
    );
  })(xh),
  $X = {
    now: function () {
      return ($X.delegate || Date).now();
    },
    delegate: void 0,
  },
  p5e = (function (e) {
    Ou(t, e);
    function t(n, r, i) {
      n === void 0 && (n = 1 / 0),
        r === void 0 && (r = 1 / 0),
        i === void 0 && (i = $X);
      var s = e.call(this) || this;
      return (
        (s._bufferSize = n),
        (s._windowTime = r),
        (s._timestampProvider = i),
        (s._buffer = []),
        (s._infiniteTimeWindow = !0),
        (s._infiniteTimeWindow = r === 1 / 0),
        (s._bufferSize = Math.max(1, n)),
        (s._windowTime = Math.max(1, r)),
        s
      );
    }
    return (
      (t.prototype.next = function (n) {
        var r = this,
          i = r.isStopped,
          s = r._buffer,
          o = r._infiniteTimeWindow,
          a = r._timestampProvider,
          l = r._windowTime;
        i || (s.push(n), !o && s.push(a.now() + l)),
          this._trimBuffer(),
          e.prototype.next.call(this, n);
      }),
      (t.prototype._subscribe = function (n) {
        this._throwIfClosed(), this._trimBuffer();
        for (
          var r = this._innerSubscribe(n),
            i = this,
            s = i._infiniteTimeWindow,
            o = i._buffer,
            a = o.slice(),
            l = 0;
          l < a.length && !n.closed;
          l += s ? 1 : 2
        )
          n.next(a[l]);
        return this._checkFinalizedStatuses(n), r;
      }),
      (t.prototype._trimBuffer = function () {
        var n = this,
          r = n._bufferSize,
          i = n._timestampProvider,
          s = n._buffer,
          o = n._infiniteTimeWindow,
          a = (o ? 1 : 2) * r;
        if ((r < 1 / 0 && a < s.length && s.splice(0, s.length - a), !o)) {
          for (var l = i.now(), c = 0, u = 1; u < s.length && s[u] <= l; u += 2)
            c = u;
          c && s.splice(0, c + 1);
        }
      }),
      t
    );
  })(xh),
  m5e = new Ia(function (e) {
    return e.complete();
  });
function g5e(e) {
  return e && bi(e.schedule);
}
function JR(e) {
  return e[e.length - 1];
}
function y5e(e) {
  return bi(JR(e)) ? e.pop() : void 0;
}
function zX(e) {
  return g5e(JR(e)) ? e.pop() : void 0;
}
function Gut(e, t) {
  return typeof JR(e) == "number" ? e.pop() : t;
}
var eO = function (e) {
  return e && typeof e.length == "number" && typeof e != "function";
};
function WX(e) {
  return bi(e == null ? void 0 : e.then);
}
function HX(e) {
  return bi(e[XR]);
}
function VX(e) {
  return (
    Symbol.asyncIterator && bi(e == null ? void 0 : e[Symbol.asyncIterator])
  );
}
function GX(e) {
  return new TypeError(
    "You provided " +
      (e !== null && typeof e == "object"
        ? "an invalid object"
        : "'" + e + "'") +
      " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable."
  );
}
function v5e() {
  return typeof Symbol != "function" || !Symbol.iterator
    ? "@@iterator"
    : Symbol.iterator;
}
var qX = v5e();
function KX(e) {
  return bi(e == null ? void 0 : e[qX]);
}
function YX(e) {
  return n5e(this, arguments, function () {
    var n, r, i, s;
    return LX(this, function (o) {
      switch (o.label) {
        case 0:
          (n = e.getReader()), (o.label = 1);
        case 1:
          o.trys.push([1, , 9, 10]), (o.label = 2);
        case 2:
          return [4, Xg(n.read())];
        case 3:
          return (
            (r = o.sent()),
            (i = r.value),
            (s = r.done),
            s ? [4, Xg(void 0)] : [3, 5]
          );
        case 4:
          return [2, o.sent()];
        case 5:
          return [4, Xg(i)];
        case 6:
          return [4, o.sent()];
        case 7:
          return o.sent(), [3, 2];
        case 8:
          return [3, 10];
        case 9:
          return n.releaseLock(), [7];
        case 10:
          return [2];
      }
    });
  });
}
function ZX(e) {
  return bi(e == null ? void 0 : e.getReader);
}
function Dc(e) {
  if (e instanceof Ia) return e;
  if (e != null) {
    if (HX(e)) return w5e(e);
    if (eO(e)) return b5e(e);
    if (WX(e)) return x5e(e);
    if (VX(e)) return QX(e);
    if (KX(e)) return _5e(e);
    if (ZX(e)) return S5e(e);
  }
  throw GX(e);
}
function w5e(e) {
  return new Ia(function (t) {
    var n = e[XR]();
    if (bi(n.subscribe)) return n.subscribe(t);
    throw new TypeError(
      "Provided object does not correctly implement Symbol.observable"
    );
  });
}
function b5e(e) {
  return new Ia(function (t) {
    for (var n = 0; n < e.length && !t.closed; n++) t.next(e[n]);
    t.complete();
  });
}
function x5e(e) {
  return new Ia(function (t) {
    e.then(
      function (n) {
        t.closed || (t.next(n), t.complete());
      },
      function (n) {
        return t.error(n);
      }
    ).then(null, UX);
  });
}
function _5e(e) {
  return new Ia(function (t) {
    var n, r;
    try {
      for (var i = Ny(e), s = i.next(); !s.done; s = i.next()) {
        var o = s.value;
        if ((t.next(o), t.closed)) return;
      }
    } catch (a) {
      n = { error: a };
    } finally {
      try {
        s && !s.done && (r = i.return) && r.call(i);
      } finally {
        if (n) throw n.error;
      }
    }
    t.complete();
  });
}
function QX(e) {
  return new Ia(function (t) {
    E5e(e, t).catch(function (n) {
      return t.error(n);
    });
  });
}
function S5e(e) {
  return QX(YX(e));
}
function E5e(e, t) {
  var n, r, i, s;
  return t5e(this, void 0, void 0, function () {
    var o, a;
    return LX(this, function (l) {
      switch (l.label) {
        case 0:
          l.trys.push([0, 5, 6, 11]), (n = r5e(e)), (l.label = 1);
        case 1:
          return [4, n.next()];
        case 2:
          if (((r = l.sent()), !!r.done)) return [3, 4];
          if (((o = r.value), t.next(o), t.closed)) return [2];
          l.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          return (a = l.sent()), (i = { error: a }), [3, 11];
        case 6:
          return (
            l.trys.push([6, , 9, 10]),
            r && !r.done && (s = n.return) ? [4, s.call(n)] : [3, 8]
          );
        case 7:
          l.sent(), (l.label = 8);
        case 8:
          return [3, 10];
        case 9:
          if (i) throw i.error;
          return [7];
        case 10:
          return [7];
        case 11:
          return t.complete(), [2];
      }
    });
  });
}
function km(e, t, n, r, i) {
  r === void 0 && (r = 0), i === void 0 && (i = !1);
  var s = t.schedule(function () {
    n(), i ? e.add(this.schedule(null, r)) : this.unsubscribe();
  }, r);
  if ((e.add(s), !i)) return s;
}
function XX(e, t) {
  return (
    t === void 0 && (t = 0),
    jc(function (n, r) {
      n.subscribe(
        Rc(
          r,
          function (i) {
            return km(
              r,
              e,
              function () {
                return r.next(i);
              },
              t
            );
          },
          function () {
            return km(
              r,
              e,
              function () {
                return r.complete();
              },
              t
            );
          },
          function (i) {
            return km(
              r,
              e,
              function () {
                return r.error(i);
              },
              t
            );
          }
        )
      );
    })
  );
}
function JX(e, t) {
  return (
    t === void 0 && (t = 0),
    jc(function (n, r) {
      r.add(
        e.schedule(function () {
          return n.subscribe(r);
        }, t)
      );
    })
  );
}
function A5e(e, t) {
  return Dc(e).pipe(JX(t), XX(t));
}
function C5e(e, t) {
  return Dc(e).pipe(JX(t), XX(t));
}
function k5e(e, t) {
  return new Ia(function (n) {
    var r = 0;
    return t.schedule(function () {
      r === e.length
        ? n.complete()
        : (n.next(e[r++]), n.closed || this.schedule());
    });
  });
}
function T5e(e, t) {
  return new Ia(function (n) {
    var r;
    return (
      km(n, t, function () {
        (r = e[qX]()),
          km(
            n,
            t,
            function () {
              var i, s, o;
              try {
                (i = r.next()), (s = i.value), (o = i.done);
              } catch (a) {
                n.error(a);
                return;
              }
              o ? n.complete() : n.next(s);
            },
            0,
            !0
          );
      }),
      function () {
        return bi(r == null ? void 0 : r.return) && r.return();
      }
    );
  });
}
function eJ(e, t) {
  if (!e) throw new Error("Iterable cannot be null");
  return new Ia(function (n) {
    km(n, t, function () {
      var r = e[Symbol.asyncIterator]();
      km(
        n,
        t,
        function () {
          r.next().then(function (i) {
            i.done ? n.complete() : n.next(i.value);
          });
        },
        0,
        !0
      );
    });
  });
}
function M5e(e, t) {
  return eJ(YX(e), t);
}
function I5e(e, t) {
  if (e != null) {
    if (HX(e)) return A5e(e, t);
    if (eO(e)) return k5e(e, t);
    if (WX(e)) return C5e(e, t);
    if (VX(e)) return eJ(e, t);
    if (KX(e)) return T5e(e, t);
    if (ZX(e)) return M5e(e, t);
  }
  throw GX(e);
}
function N5e(e, t) {
  return t ? I5e(e, t) : Dc(e);
}
var R5e = ZR(function (e) {
  return function () {
    e(this),
      (this.name = "EmptyError"),
      (this.message = "no elements in sequence");
  };
});
function gb(e, t) {
  return new Promise(function (n, r) {
    var i = new Ry({
      next: function (s) {
        n(s), i.unsubscribe();
      },
      error: r,
      complete: function () {
        r(new R5e());
      },
    });
    e.subscribe(i);
  });
}
function Dx(e, t) {
  return jc(function (n, r) {
    var i = 0;
    n.subscribe(
      Rc(r, function (s) {
        r.next(e.call(t, s, i++));
      })
    );
  });
}
var O5e = Array.isArray;
function P5e(e, t) {
  return O5e(t) ? e.apply(void 0, wd([], Jp(t))) : e(t);
}
function L5e(e) {
  return Dx(function (t) {
    return P5e(e, t);
  });
}
function j5e(e, t, n, r, i, s, o, a) {
  var l = [],
    c = 0,
    u = 0,
    d = !1,
    f = function () {
      d && !l.length && !c && t.complete();
    },
    h = function (g) {
      return c < r ? p(g) : l.push(g);
    },
    p = function (g) {
      c++;
      var b = !1;
      Dc(n(g, u++)).subscribe(
        Rc(
          t,
          function (v) {
            t.next(v);
          },
          function () {
            b = !0;
          },
          void 0,
          function () {
            if (b)
              try {
                c--;
                for (
                  var v = function () {
                    var w = l.shift();
                    o || p(w);
                  };
                  l.length && c < r;

                )
                  v();
                f();
              } catch (w) {
                t.error(w);
              }
          }
        )
      );
    };
  return (
    e.subscribe(
      Rc(t, h, function () {
        (d = !0), f();
      })
    ),
    function () {}
  );
}
function tO(e, t, n) {
  return (
    n === void 0 && (n = 1 / 0),
    bi(t)
      ? tO(function (r, i) {
          return Dx(function (s, o) {
            return t(r, s, i, o);
          })(Dc(e(r, i)));
        }, n)
      : (typeof t == "number" && (n = t),
        jc(function (r, i) {
          return j5e(r, i, e, n);
        }))
  );
}
function D5e(e) {
  return e === void 0 && (e = 1 / 0), tO(I8, e);
}
function B5e() {
  return D5e(1);
}
function ZU() {
  for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
  return B5e()(N5e(e, zX(e)));
}
function F5e(e) {
  return new Ia(function (t) {
    Dc(e()).subscribe(t);
  });
}
var U5e = ["addListener", "removeListener"],
  $5e = ["addEventListener", "removeEventListener"],
  z5e = ["on", "off"];
function UT(e, t, n, r) {
  if ((bi(n) && ((r = n), (n = void 0)), r)) return UT(e, t, n).pipe(L5e(r));
  var i = Jp(
      V5e(e)
        ? $5e.map(function (a) {
            return function (l) {
              return e[a](t, l, n);
            };
          })
        : W5e(e)
        ? U5e.map(QU(e, t))
        : H5e(e)
        ? z5e.map(QU(e, t))
        : [],
      2
    ),
    s = i[0],
    o = i[1];
  if (!s && eO(e))
    return tO(function (a) {
      return UT(a, t, n);
    })(Dc(e));
  if (!s) throw new TypeError("Invalid event target");
  return new Ia(function (a) {
    var l = function () {
      for (var c = [], u = 0; u < arguments.length; u++) c[u] = arguments[u];
      return a.next(1 < c.length ? c : c[0]);
    };
    return (
      s(l),
      function () {
        return o(l);
      }
    );
  });
}
function QU(e, t) {
  return function (n) {
    return function (r) {
      return e[n](t, r);
    };
  };
}
function W5e(e) {
  return bi(e.addListener) && bi(e.removeListener);
}
function H5e(e) {
  return bi(e.on) && bi(e.off);
}
function V5e(e) {
  return bi(e.addEventListener) && bi(e.removeEventListener);
}
function tJ(e, t, n) {
  return new Ia(function (r) {
    var i = function () {
        for (var o = [], a = 0; a < arguments.length; a++) o[a] = arguments[a];
        return r.next(o.length === 1 ? o[0] : o);
      },
      s = e(i);
    return bi(t)
      ? function () {
          return t(i, s);
        }
      : void 0;
  });
}
function Oy(e, t) {
  return jc(function (n, r) {
    var i = 0;
    n.subscribe(
      Rc(r, function (s) {
        return e.call(t, s, i++) && r.next(s);
      })
    );
  });
}
function nO(e) {
  return e <= 0
    ? function () {
        return m5e;
      }
    : jc(function (t, n) {
        var r = 0;
        t.subscribe(
          Rc(n, function (i) {
            ++r <= e && (n.next(i), e <= r && n.complete());
          })
        );
      });
}
function gC(e) {
  return Dx(function () {
    return e;
  });
}
function nJ(e, t) {
  return (
    t === void 0 && (t = I8),
    (e = e ?? G5e),
    jc(function (n, r) {
      var i,
        s = !0;
      n.subscribe(
        Rc(r, function (o) {
          var a = t(o);
          (s || !e(i, a)) && ((s = !1), (i = a), r.next(o));
        })
      );
    })
  );
}
function G5e(e, t) {
  return e === t;
}
function q5e(e, t) {
  return nJ(function (n, r) {
    return n[e] === r[e];
  });
}
function rO() {
  for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
  var n = e.length;
  if (n === 0) throw new Error("list of properties cannot be empty.");
  return Dx(function (r) {
    for (var i = r, s = 0; s < n; s++) {
      var o = i == null ? void 0 : i[e[s]];
      if (typeof o < "u") i = o;
      else return;
    }
    return i;
  });
}
function $T(e) {
  e === void 0 && (e = {});
  var t = e.connector,
    n =
      t === void 0
        ? function () {
            return new xh();
          }
        : t,
    r = e.resetOnError,
    i = r === void 0 ? !0 : r,
    s = e.resetOnComplete,
    o = s === void 0 ? !0 : s,
    a = e.resetOnRefCountZero,
    l = a === void 0 ? !0 : a;
  return function (c) {
    var u,
      d,
      f,
      h = 0,
      p = !1,
      g = !1,
      b = function () {
        d == null || d.unsubscribe(), (d = void 0);
      },
      v = function () {
        b(), (u = f = void 0), (p = g = !1);
      },
      w = function () {
        var x = u;
        v(), x == null || x.unsubscribe();
      };
    return jc(function (x, S) {
      h++, !g && !p && b();
      var R = (f = f ?? n());
      S.add(function () {
        h--, h === 0 && !g && !p && (d = yC(w, l));
      }),
        R.subscribe(S),
        !u &&
          h > 0 &&
          ((u = new Ry({
            next: function (O) {
              return R.next(O);
            },
            error: function (O) {
              (g = !0), b(), (d = yC(v, i, O)), R.error(O);
            },
            complete: function () {
              (p = !0), b(), (d = yC(v, o)), R.complete();
            },
          })),
          Dc(x).subscribe(u));
    })(c);
  };
}
function yC(e, t) {
  for (var n = [], r = 2; r < arguments.length; r++) n[r - 2] = arguments[r];
  if (t === !0) {
    e();
    return;
  }
  if (t !== !1) {
    var i = new Ry({
      next: function () {
        i.unsubscribe(), e();
      },
    });
    return Dc(t.apply(void 0, wd([], Jp(n)))).subscribe(i);
  }
}
function Rd(e, t, n) {
  var r,
    i = !1;
  return (
    (r = e),
    $T({
      connector: function () {
        return new p5e(r, t, n);
      },
      resetOnError: !0,
      resetOnComplete: !1,
      resetOnRefCountZero: i,
    })
  );
}
function bd() {
  for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
  var n = zX(e);
  return jc(function (r, i) {
    (n ? ZU(e, r, n) : ZU(e, r)).subscribe(i);
  });
}
function XU(e, t) {
  return jc(function (n, r) {
    var i = null,
      s = 0,
      o = !1,
      a = function () {
        return o && !i && r.complete();
      };
    n.subscribe(
      Rc(
        r,
        function (l) {
          i == null || i.unsubscribe();
          var c = 0,
            u = s++;
          Dc(e(l, u)).subscribe(
            (i = Rc(
              r,
              function (d) {
                return r.next(t ? t(l, d, u, c++) : d);
              },
              function () {
                (i = null), a();
              }
            ))
          );
        },
        function () {
          (o = !0), a();
        }
      )
    );
  });
}
function yb(e) {
  return jc(function (t, n) {
    Dc(e).subscribe(
      Rc(
        n,
        function () {
          return n.complete();
        },
        b5
      )
    ),
      !n.closed && t.subscribe(n);
  });
}
function rJ() {
  for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
  var n = y5e(e);
  return jc(function (r, i) {
    for (
      var s = e.length,
        o = new Array(s),
        a = e.map(function () {
          return !1;
        }),
        l = !1,
        c = function (d) {
          Dc(e[d]).subscribe(
            Rc(
              i,
              function (f) {
                (o[d] = f),
                  !l && !a[d] && ((a[d] = !0), (l = a.every(I8)) && (a = null));
              },
              b5
            )
          );
        },
        u = 0;
      u < s;
      u++
    )
      c(u);
    r.subscribe(
      Rc(i, function (d) {
        if (l) {
          var f = wd([d], Jp(o));
          i.next(n ? n.apply(void 0, wd([], Jp(f))) : f);
        }
      })
    );
  });
}
const K5e = {
    "Amazon Silk": "amazon_silk",
    "Android Browser": "android",
    Bada: "bada",
    BlackBerry: "blackberry",
    Chrome: "chrome",
    Chromium: "chromium",
    Electron: "electron",
    Epiphany: "epiphany",
    Firefox: "firefox",
    Focus: "focus",
    Generic: "generic",
    "Google Search": "google_search",
    Googlebot: "googlebot",
    "Internet Explorer": "ie",
    "K-Meleon": "k_meleon",
    Maxthon: "maxthon",
    "Microsoft Edge": "edge",
    "MZ Browser": "mz",
    "NAVER Whale Browser": "naver",
    Opera: "opera",
    "Opera Coast": "opera_coast",
    PhantomJS: "phantomjs",
    Puffin: "puffin",
    QupZilla: "qupzilla",
    QQ: "qq",
    QQLite: "qqlite",
    Safari: "safari",
    Sailfish: "sailfish",
    "Samsung Internet for Android": "samsung_internet",
    SeaMonkey: "seamonkey",
    Sleipnir: "sleipnir",
    Swing: "swing",
    Tizen: "tizen",
    "UC Browser": "uc",
    Vivaldi: "vivaldi",
    "WebOS Browser": "webos",
    WeChat: "wechat",
    "Yandex Browser": "yandex",
    Roku: "roku",
  },
  iJ = {
    amazon_silk: "Amazon Silk",
    android: "Android Browser",
    bada: "Bada",
    blackberry: "BlackBerry",
    chrome: "Chrome",
    chromium: "Chromium",
    electron: "Electron",
    epiphany: "Epiphany",
    firefox: "Firefox",
    focus: "Focus",
    generic: "Generic",
    googlebot: "Googlebot",
    google_search: "Google Search",
    ie: "Internet Explorer",
    k_meleon: "K-Meleon",
    maxthon: "Maxthon",
    edge: "Microsoft Edge",
    mz: "MZ Browser",
    naver: "NAVER Whale Browser",
    opera: "Opera",
    opera_coast: "Opera Coast",
    phantomjs: "PhantomJS",
    puffin: "Puffin",
    qupzilla: "QupZilla",
    qq: "QQ Browser",
    qqlite: "QQ Browser Lite",
    safari: "Safari",
    sailfish: "Sailfish",
    samsung_internet: "Samsung Internet for Android",
    seamonkey: "SeaMonkey",
    sleipnir: "Sleipnir",
    swing: "Swing",
    tizen: "Tizen",
    uc: "UC Browser",
    vivaldi: "Vivaldi",
    webos: "WebOS Browser",
    wechat: "WeChat",
    yandex: "Yandex Browser",
  },
  Ts = { tablet: "tablet", mobile: "mobile", desktop: "desktop", tv: "tv" },
  va = {
    WindowsPhone: "Windows Phone",
    Windows: "Windows",
    MacOS: "macOS",
    iOS: "iOS",
    Android: "Android",
    WebOS: "WebOS",
    BlackBerry: "BlackBerry",
    Bada: "Bada",
    Tizen: "Tizen",
    Linux: "Linux",
    ChromeOS: "Chrome OS",
    PlayStation4: "PlayStation 4",
    Roku: "Roku",
  },
  ip = {
    EdgeHTML: "EdgeHTML",
    Blink: "Blink",
    Trident: "Trident",
    Presto: "Presto",
    Gecko: "Gecko",
    WebKit: "WebKit",
  };
class Ye {
  static getFirstMatch(t, n) {
    const r = n.match(t);
    return (r && r.length > 0 && r[1]) || "";
  }
  static getSecondMatch(t, n) {
    const r = n.match(t);
    return (r && r.length > 1 && r[2]) || "";
  }
  static matchAndReturnConst(t, n, r) {
    if (t.test(n)) return r;
  }
  static getWindowsVersionName(t) {
    switch (t) {
      case "NT":
        return "NT";
      case "XP":
        return "XP";
      case "NT 5.0":
        return "2000";
      case "NT 5.1":
        return "XP";
      case "NT 5.2":
        return "2003";
      case "NT 6.0":
        return "Vista";
      case "NT 6.1":
        return "7";
      case "NT 6.2":
        return "8";
      case "NT 6.3":
        return "8.1";
      case "NT 10.0":
        return "10";
      default:
        return;
    }
  }
  static getMacOSVersionName(t) {
    const n = t
      .split(".")
      .splice(0, 2)
      .map((r) => parseInt(r, 10) || 0);
    if ((n.push(0), n[0] === 10))
      switch (n[1]) {
        case 5:
          return "Leopard";
        case 6:
          return "Snow Leopard";
        case 7:
          return "Lion";
        case 8:
          return "Mountain Lion";
        case 9:
          return "Mavericks";
        case 10:
          return "Yosemite";
        case 11:
          return "El Capitan";
        case 12:
          return "Sierra";
        case 13:
          return "High Sierra";
        case 14:
          return "Mojave";
        case 15:
          return "Catalina";
        default:
          return;
      }
  }
  static getAndroidVersionName(t) {
    const n = t
      .split(".")
      .splice(0, 2)
      .map((r) => parseInt(r, 10) || 0);
    if ((n.push(0), !(n[0] === 1 && n[1] < 5))) {
      if (n[0] === 1 && n[1] < 6) return "Cupcake";
      if (n[0] === 1 && n[1] >= 6) return "Donut";
      if (n[0] === 2 && n[1] < 2) return "Eclair";
      if (n[0] === 2 && n[1] === 2) return "Froyo";
      if (n[0] === 2 && n[1] > 2) return "Gingerbread";
      if (n[0] === 3) return "Honeycomb";
      if (n[0] === 4 && n[1] < 1) return "Ice Cream Sandwich";
      if (n[0] === 4 && n[1] < 4) return "Jelly Bean";
      if (n[0] === 4 && n[1] >= 4) return "KitKat";
      if (n[0] === 5) return "Lollipop";
      if (n[0] === 6) return "Marshmallow";
      if (n[0] === 7) return "Nougat";
      if (n[0] === 8) return "Oreo";
      if (n[0] === 9) return "Pie";
    }
  }
  static getVersionPrecision(t) {
    return t.split(".").length;
  }
  static compareVersions(t, n, r = !1) {
    const i = Ye.getVersionPrecision(t),
      s = Ye.getVersionPrecision(n);
    let o = Math.max(i, s),
      a = 0;
    const l = Ye.map([t, n], (c) => {
      const u = o - Ye.getVersionPrecision(c),
        d = c + new Array(u + 1).join(".0");
      return Ye.map(
        d.split("."),
        (f) => new Array(20 - f.length).join("0") + f
      ).reverse();
    });
    for (r && (a = o - Math.min(i, s)), o -= 1; o >= a; ) {
      if (l[0][o] > l[1][o]) return 1;
      if (l[0][o] === l[1][o]) {
        if (o === a) return 0;
        o -= 1;
      } else if (l[0][o] < l[1][o]) return -1;
    }
  }
  static map(t, n) {
    const r = [];
    let i;
    if (Array.prototype.map) return Array.prototype.map.call(t, n);
    for (i = 0; i < t.length; i += 1) r.push(n(t[i]));
    return r;
  }
  static find(t, n) {
    let r, i;
    if (Array.prototype.find) return Array.prototype.find.call(t, n);
    for (r = 0, i = t.length; r < i; r += 1) {
      const s = t[r];
      if (n(s, r)) return s;
    }
  }
  static assign(t, ...n) {
    const r = t;
    let i, s;
    if (Object.assign) return Object.assign(t, ...n);
    for (i = 0, s = n.length; i < s; i += 1) {
      const o = n[i];
      typeof o == "object" &&
        o !== null &&
        Object.keys(o).forEach((l) => {
          r[l] = o[l];
        });
    }
    return t;
  }
  static getBrowserAlias(t) {
    return K5e[t];
  }
  static getBrowserTypeByAlias(t) {
    return iJ[t] || "";
  }
}
const ki = /version\/(\d+(\.?_?\d+)+)/i,
  Y5e = [
    {
      test: [/googlebot/i],
      describe(e) {
        const t = { name: "Googlebot" },
          n =
            Ye.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, e) ||
            Ye.getFirstMatch(ki, e);
        return n && (t.version = n), t;
      },
    },
    {
      test: [/opera/i],
      describe(e) {
        const t = { name: "Opera" },
          n =
            Ye.getFirstMatch(ki, e) ||
            Ye.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, e);
        return n && (t.version = n), t;
      },
    },
    {
      test: [/opr\/|opios/i],
      describe(e) {
        const t = { name: "Opera" },
          n =
            Ye.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, e) ||
            Ye.getFirstMatch(ki, e);
        return n && (t.version = n), t;
      },
    },
    {
      test: [/SamsungBrowser/i],
      describe(e) {
        const t = { name: "Samsung Internet for Android" },
          n =
            Ye.getFirstMatch(ki, e) ||
            Ye.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, e);
        return n && (t.version = n), t;
      },
    },
    {
      test: [/Whale/i],
      describe(e) {
        const t = { name: "NAVER Whale Browser" },
          n =
            Ye.getFirstMatch(ki, e) ||
            Ye.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, e);
        return n && (t.version = n), t;
      },
    },
    {
      test: [/MZBrowser/i],
      describe(e) {
        const t = { name: "MZ Browser" },
          n =
            Ye.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, e) ||
            Ye.getFirstMatch(ki, e);
        return n && (t.version = n), t;
      },
    },
    {
      test: [/focus/i],
      describe(e) {
        const t = { name: "Focus" },
          n =
            Ye.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, e) ||
            Ye.getFirstMatch(ki, e);
        return n && (t.version = n), t;
      },
    },
    {
      test: [/swing/i],
      describe(e) {
        const t = { name: "Swing" },
          n =
            Ye.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, e) ||
            Ye.getFirstMatch(ki, e);
        return n && (t.version = n), t;
      },
    },
    {
      test: [/coast/i],
      describe(e) {
        const t = { name: "Opera Coast" },
          n =
            Ye.getFirstMatch(ki, e) ||
            Ye.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, e);
        return n && (t.version = n), t;
      },
    },
    {
      test: [/opt\/\d+(?:.?_?\d+)+/i],
      describe(e) {
        const t = { name: "Opera Touch" },
          n =
            Ye.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, e) ||
            Ye.getFirstMatch(ki, e);
        return n && (t.version = n), t;
      },
    },
    {
      test: [/yabrowser/i],
      describe(e) {
        const t = { name: "Yandex Browser" },
          n =
            Ye.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, e) ||
            Ye.getFirstMatch(ki, e);
        return n && (t.version = n), t;
      },
    },
    {
      test: [/ucbrowser/i],
      describe(e) {
        const t = { name: "UC Browser" },
          n =
            Ye.getFirstMatch(ki, e) ||
            Ye.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, e);
        return n && (t.version = n), t;
      },
    },
    {
      test: [/Maxthon|mxios/i],
      describe(e) {
        const t = { name: "Maxthon" },
          n =
            Ye.getFirstMatch(ki, e) ||
            Ye.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, e);
        return n && (t.version = n), t;
      },
    },
    {
      test: [/epiphany/i],
      describe(e) {
        const t = { name: "Epiphany" },
          n =
            Ye.getFirstMatch(ki, e) ||
            Ye.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, e);
        return n && (t.version = n), t;
      },
    },
    {
      test: [/puffin/i],
      describe(e) {
        const t = { name: "Puffin" },
          n =
            Ye.getFirstMatch(ki, e) ||
            Ye.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, e);
        return n && (t.version = n), t;
      },
    },
    {
      test: [/sleipnir/i],
      describe(e) {
        const t = { name: "Sleipnir" },
          n =
            Ye.getFirstMatch(ki, e) ||
            Ye.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, e);
        return n && (t.version = n), t;
      },
    },
    {
      test: [/k-meleon/i],
      describe(e) {
        const t = { name: "K-Meleon" },
          n =
            Ye.getFirstMatch(ki, e) ||
            Ye.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, e);
        return n && (t.version = n), t;
      },
    },
    {
      test: [/micromessenger/i],
      describe(e) {
        const t = { name: "WeChat" },
          n =
            Ye.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, e) ||
            Ye.getFirstMatch(ki, e);
        return n && (t.version = n), t;
      },
    },
    {
      test: [/qqbrowser/i],
      describe(e) {
        const t = {
            name: /qqbrowserlite/i.test(e) ? "QQ Browser Lite" : "QQ Browser",
          },
          n =
            Ye.getFirstMatch(
              /(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i,
              e
            ) || Ye.getFirstMatch(ki, e);
        return n && (t.version = n), t;
      },
    },
    {
      test: [/msie|trident/i],
      describe(e) {
        const t = { name: "Internet Explorer" },
          n = Ye.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, e);
        return n && (t.version = n), t;
      },
    },
    {
      test: [/\sedg\//i],
      describe(e) {
        const t = { name: "Microsoft Edge" },
          n = Ye.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, e);
        return n && (t.version = n), t;
      },
    },
    {
      test: [/edg([ea]|ios)/i],
      describe(e) {
        const t = { name: "Microsoft Edge" },
          n = Ye.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, e);
        return n && (t.version = n), t;
      },
    },
    {
      test: [/vivaldi/i],
      describe(e) {
        const t = { name: "Vivaldi" },
          n = Ye.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, e);
        return n && (t.version = n), t;
      },
    },
    {
      test: [/seamonkey/i],
      describe(e) {
        const t = { name: "SeaMonkey" },
          n = Ye.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, e);
        return n && (t.version = n), t;
      },
    },
    {
      test: [/sailfish/i],
      describe(e) {
        const t = { name: "Sailfish" },
          n = Ye.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, e);
        return n && (t.version = n), t;
      },
    },
    {
      test: [/silk/i],
      describe(e) {
        const t = { name: "Amazon Silk" },
          n = Ye.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, e);
        return n && (t.version = n), t;
      },
    },
    {
      test: [/phantom/i],
      describe(e) {
        const t = { name: "PhantomJS" },
          n = Ye.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, e);
        return n && (t.version = n), t;
      },
    },
    {
      test: [/slimerjs/i],
      describe(e) {
        const t = { name: "SlimerJS" },
          n = Ye.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, e);
        return n && (t.version = n), t;
      },
    },
    {
      test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
      describe(e) {
        const t = { name: "BlackBerry" },
          n =
            Ye.getFirstMatch(ki, e) ||
            Ye.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, e);
        return n && (t.version = n), t;
      },
    },
    {
      test: [/(web|hpw)[o0]s/i],
      describe(e) {
        const t = { name: "WebOS Browser" },
          n =
            Ye.getFirstMatch(ki, e) ||
            Ye.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, e);
        return n && (t.version = n), t;
      },
    },
    {
      test: [/bada/i],
      describe(e) {
        const t = { name: "Bada" },
          n = Ye.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, e);
        return n && (t.version = n), t;
      },
    },
    {
      test: [/tizen/i],
      describe(e) {
        const t = { name: "Tizen" },
          n =
            Ye.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, e) ||
            Ye.getFirstMatch(ki, e);
        return n && (t.version = n), t;
      },
    },
    {
      test: [/qupzilla/i],
      describe(e) {
        const t = { name: "QupZilla" },
          n =
            Ye.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, e) ||
            Ye.getFirstMatch(ki, e);
        return n && (t.version = n), t;
      },
    },
    {
      test: [/firefox|iceweasel|fxios/i],
      describe(e) {
        const t = { name: "Firefox" },
          n = Ye.getFirstMatch(
            /(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i,
            e
          );
        return n && (t.version = n), t;
      },
    },
    {
      test: [/electron/i],
      describe(e) {
        const t = { name: "Electron" },
          n = Ye.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, e);
        return n && (t.version = n), t;
      },
    },
    {
      test: [/MiuiBrowser/i],
      describe(e) {
        const t = { name: "Miui" },
          n = Ye.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, e);
        return n && (t.version = n), t;
      },
    },
    {
      test: [/chromium/i],
      describe(e) {
        const t = { name: "Chromium" },
          n =
            Ye.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, e) ||
            Ye.getFirstMatch(ki, e);
        return n && (t.version = n), t;
      },
    },
    {
      test: [/chrome|crios|crmo/i],
      describe(e) {
        const t = { name: "Chrome" },
          n = Ye.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, e);
        return n && (t.version = n), t;
      },
    },
    {
      test: [/GSA/i],
      describe(e) {
        const t = { name: "Google Search" },
          n = Ye.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, e);
        return n && (t.version = n), t;
      },
    },
    {
      test(e) {
        const t = !e.test(/like android/i),
          n = e.test(/android/i);
        return t && n;
      },
      describe(e) {
        const t = { name: "Android Browser" },
          n = Ye.getFirstMatch(ki, e);
        return n && (t.version = n), t;
      },
    },
    {
      test: [/playstation 4/i],
      describe(e) {
        const t = { name: "PlayStation 4" },
          n = Ye.getFirstMatch(ki, e);
        return n && (t.version = n), t;
      },
    },
    {
      test: [/safari|applewebkit/i],
      describe(e) {
        const t = { name: "Safari" },
          n = Ye.getFirstMatch(ki, e);
        return n && (t.version = n), t;
      },
    },
    {
      test: [/.*/i],
      describe(e) {
        const t = /^(.*)\/(.*) /,
          n = /^(.*)\/(.*)[ \t]\((.*)/,
          i = e.search("\\(") !== -1 ? n : t;
        return {
          name: Ye.getFirstMatch(i, e),
          version: Ye.getSecondMatch(i, e),
        };
      },
    },
  ],
  Z5e = [
    {
      test: [/Roku\/DVP/],
      describe(e) {
        const t = Ye.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, e);
        return { name: va.Roku, version: t };
      },
    },
    {
      test: [/windows phone/i],
      describe(e) {
        const t = Ye.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, e);
        return { name: va.WindowsPhone, version: t };
      },
    },
    {
      test: [/windows /i],
      describe(e) {
        const t = Ye.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, e),
          n = Ye.getWindowsVersionName(t);
        return { name: va.Windows, version: t, versionName: n };
      },
    },
    {
      test: [/Macintosh(.*?) FxiOS(.*?)\//],
      describe(e) {
        const t = { name: va.iOS },
          n = Ye.getSecondMatch(/(Version\/)(\d[\d.]+)/, e);
        return n && (t.version = n), t;
      },
    },
    {
      test: [/macintosh/i],
      describe(e) {
        const t = Ye.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, e).replace(
            /[_\s]/g,
            "."
          ),
          n = Ye.getMacOSVersionName(t),
          r = { name: va.MacOS, version: t };
        return n && (r.versionName = n), r;
      },
    },
    {
      test: [/(ipod|iphone|ipad)/i],
      describe(e) {
        const t = Ye.getFirstMatch(
          /os (\d+([_\s]\d+)*) like mac os x/i,
          e
        ).replace(/[_\s]/g, ".");
        return { name: va.iOS, version: t };
      },
    },
    {
      test(e) {
        const t = !e.test(/like android/i),
          n = e.test(/android/i);
        return t && n;
      },
      describe(e) {
        const t = Ye.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, e),
          n = Ye.getAndroidVersionName(t),
          r = { name: va.Android, version: t };
        return n && (r.versionName = n), r;
      },
    },
    {
      test: [/(web|hpw)[o0]s/i],
      describe(e) {
        const t = Ye.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, e),
          n = { name: va.WebOS };
        return t && t.length && (n.version = t), n;
      },
    },
    {
      test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
      describe(e) {
        const t =
          Ye.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, e) ||
          Ye.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, e) ||
          Ye.getFirstMatch(/\bbb(\d+)/i, e);
        return { name: va.BlackBerry, version: t };
      },
    },
    {
      test: [/bada/i],
      describe(e) {
        const t = Ye.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, e);
        return { name: va.Bada, version: t };
      },
    },
    {
      test: [/tizen/i],
      describe(e) {
        const t = Ye.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, e);
        return { name: va.Tizen, version: t };
      },
    },
    {
      test: [/linux/i],
      describe() {
        return { name: va.Linux };
      },
    },
    {
      test: [/CrOS/],
      describe() {
        return { name: va.ChromeOS };
      },
    },
    {
      test: [/PlayStation 4/],
      describe(e) {
        const t = Ye.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, e);
        return { name: va.PlayStation4, version: t };
      },
    },
  ],
  Q5e = [
    {
      test: [/googlebot/i],
      describe() {
        return { type: "bot", vendor: "Google" };
      },
    },
    {
      test: [/huawei/i],
      describe(e) {
        const t = Ye.getFirstMatch(/(can-l01)/i, e) && "Nova",
          n = { type: Ts.mobile, vendor: "Huawei" };
        return t && (n.model = t), n;
      },
    },
    {
      test: [/nexus\s*(?:7|8|9|10).*/i],
      describe() {
        return { type: Ts.tablet, vendor: "Nexus" };
      },
    },
    {
      test: [/ipad/i],
      describe() {
        return { type: Ts.tablet, vendor: "Apple", model: "iPad" };
      },
    },
    {
      test: [/Macintosh(.*?) FxiOS(.*?)\//],
      describe() {
        return { type: Ts.tablet, vendor: "Apple", model: "iPad" };
      },
    },
    {
      test: [/kftt build/i],
      describe() {
        return { type: Ts.tablet, vendor: "Amazon", model: "Kindle Fire HD 7" };
      },
    },
    {
      test: [/silk/i],
      describe() {
        return { type: Ts.tablet, vendor: "Amazon" };
      },
    },
    {
      test: [/tablet(?! pc)/i],
      describe() {
        return { type: Ts.tablet };
      },
    },
    {
      test(e) {
        const t = e.test(/ipod|iphone/i),
          n = e.test(/like (ipod|iphone)/i);
        return t && !n;
      },
      describe(e) {
        const t = Ye.getFirstMatch(/(ipod|iphone)/i, e);
        return { type: Ts.mobile, vendor: "Apple", model: t };
      },
    },
    {
      test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
      describe() {
        return { type: Ts.mobile, vendor: "Nexus" };
      },
    },
    {
      test: [/[^-]mobi/i],
      describe() {
        return { type: Ts.mobile };
      },
    },
    {
      test(e) {
        return e.getBrowserName(!0) === "blackberry";
      },
      describe() {
        return { type: Ts.mobile, vendor: "BlackBerry" };
      },
    },
    {
      test(e) {
        return e.getBrowserName(!0) === "bada";
      },
      describe() {
        return { type: Ts.mobile };
      },
    },
    {
      test(e) {
        return e.getBrowserName() === "windows phone";
      },
      describe() {
        return { type: Ts.mobile, vendor: "Microsoft" };
      },
    },
    {
      test(e) {
        const t = Number(String(e.getOSVersion()).split(".")[0]);
        return e.getOSName(!0) === "android" && t >= 3;
      },
      describe() {
        return { type: Ts.tablet };
      },
    },
    {
      test(e) {
        return e.getOSName(!0) === "android";
      },
      describe() {
        return { type: Ts.mobile };
      },
    },
    {
      test(e) {
        return e.getOSName(!0) === "macos";
      },
      describe() {
        return { type: Ts.desktop, vendor: "Apple" };
      },
    },
    {
      test(e) {
        return e.getOSName(!0) === "windows";
      },
      describe() {
        return { type: Ts.desktop };
      },
    },
    {
      test(e) {
        return e.getOSName(!0) === "linux";
      },
      describe() {
        return { type: Ts.desktop };
      },
    },
    {
      test(e) {
        return e.getOSName(!0) === "playstation 4";
      },
      describe() {
        return { type: Ts.tv };
      },
    },
    {
      test(e) {
        return e.getOSName(!0) === "roku";
      },
      describe() {
        return { type: Ts.tv };
      },
    },
  ],
  X5e = [
    {
      test(e) {
        return e.getBrowserName(!0) === "microsoft edge";
      },
      describe(e) {
        if (/\sedg\//i.test(e)) return { name: ip.Blink };
        const n = Ye.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, e);
        return { name: ip.EdgeHTML, version: n };
      },
    },
    {
      test: [/trident/i],
      describe(e) {
        const t = { name: ip.Trident },
          n = Ye.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, e);
        return n && (t.version = n), t;
      },
    },
    {
      test(e) {
        return e.test(/presto/i);
      },
      describe(e) {
        const t = { name: ip.Presto },
          n = Ye.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, e);
        return n && (t.version = n), t;
      },
    },
    {
      test(e) {
        const t = e.test(/gecko/i),
          n = e.test(/like gecko/i);
        return t && !n;
      },
      describe(e) {
        const t = { name: ip.Gecko },
          n = Ye.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, e);
        return n && (t.version = n), t;
      },
    },
    {
      test: [/(apple)?webkit\/537\.36/i],
      describe() {
        return { name: ip.Blink };
      },
    },
    {
      test: [/(apple)?webkit/i],
      describe(e) {
        const t = { name: ip.WebKit },
          n = Ye.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, e);
        return n && (t.version = n), t;
      },
    },
  ];
let JU = class {
  constructor(t, n = !1) {
    if (t == null || t === "")
      throw new Error("UserAgent parameter can't be empty");
    (this._ua = t), (this.parsedResult = {}), n !== !0 && this.parse();
  }
  getUA() {
    return this._ua;
  }
  test(t) {
    return t.test(this._ua);
  }
  parseBrowser() {
    this.parsedResult.browser = {};
    const t = Ye.find(Y5e, (n) => {
      if (typeof n.test == "function") return n.test(this);
      if (n.test instanceof Array) return n.test.some((r) => this.test(r));
      throw new Error("Browser's test function is not valid");
    });
    return (
      t && (this.parsedResult.browser = t.describe(this.getUA())),
      this.parsedResult.browser
    );
  }
  getBrowser() {
    return this.parsedResult.browser
      ? this.parsedResult.browser
      : this.parseBrowser();
  }
  getBrowserName(t) {
    return t
      ? String(this.getBrowser().name).toLowerCase() || ""
      : this.getBrowser().name || "";
  }
  getBrowserVersion() {
    return this.getBrowser().version;
  }
  getOS() {
    return this.parsedResult.os ? this.parsedResult.os : this.parseOS();
  }
  parseOS() {
    this.parsedResult.os = {};
    const t = Ye.find(Z5e, (n) => {
      if (typeof n.test == "function") return n.test(this);
      if (n.test instanceof Array) return n.test.some((r) => this.test(r));
      throw new Error("Browser's test function is not valid");
    });
    return (
      t && (this.parsedResult.os = t.describe(this.getUA())),
      this.parsedResult.os
    );
  }
  getOSName(t) {
    const { name: n } = this.getOS();
    return t ? String(n).toLowerCase() || "" : n || "";
  }
  getOSVersion() {
    return this.getOS().version;
  }
  getPlatform() {
    return this.parsedResult.platform
      ? this.parsedResult.platform
      : this.parsePlatform();
  }
  getPlatformType(t = !1) {
    const { type: n } = this.getPlatform();
    return t ? String(n).toLowerCase() || "" : n || "";
  }
  parsePlatform() {
    this.parsedResult.platform = {};
    const t = Ye.find(Q5e, (n) => {
      if (typeof n.test == "function") return n.test(this);
      if (n.test instanceof Array) return n.test.some((r) => this.test(r));
      throw new Error("Browser's test function is not valid");
    });
    return (
      t && (this.parsedResult.platform = t.describe(this.getUA())),
      this.parsedResult.platform
    );
  }
  getEngine() {
    return this.parsedResult.engine
      ? this.parsedResult.engine
      : this.parseEngine();
  }
  getEngineName(t) {
    return t
      ? String(this.getEngine().name).toLowerCase() || ""
      : this.getEngine().name || "";
  }
  parseEngine() {
    this.parsedResult.engine = {};
    const t = Ye.find(X5e, (n) => {
      if (typeof n.test == "function") return n.test(this);
      if (n.test instanceof Array) return n.test.some((r) => this.test(r));
      throw new Error("Browser's test function is not valid");
    });
    return (
      t && (this.parsedResult.engine = t.describe(this.getUA())),
      this.parsedResult.engine
    );
  }
  parse() {
    return (
      this.parseBrowser(),
      this.parseOS(),
      this.parsePlatform(),
      this.parseEngine(),
      this
    );
  }
  getResult() {
    return Ye.assign({}, this.parsedResult);
  }
  satisfies(t) {
    const n = {};
    let r = 0;
    const i = {};
    let s = 0;
    if (
      (Object.keys(t).forEach((a) => {
        const l = t[a];
        typeof l == "string"
          ? ((i[a] = l), (s += 1))
          : typeof l == "object" && ((n[a] = l), (r += 1));
      }),
      r > 0)
    ) {
      const a = Object.keys(n),
        l = Ye.find(a, (u) => this.isOS(u));
      if (l) {
        const u = this.satisfies(n[l]);
        if (u !== void 0) return u;
      }
      const c = Ye.find(a, (u) => this.isPlatform(u));
      if (c) {
        const u = this.satisfies(n[c]);
        if (u !== void 0) return u;
      }
    }
    if (s > 0) {
      const a = Object.keys(i),
        l = Ye.find(a, (c) => this.isBrowser(c, !0));
      if (l !== void 0) return this.compareVersion(i[l]);
    }
  }
  isBrowser(t, n = !1) {
    const r = this.getBrowserName().toLowerCase();
    let i = t.toLowerCase();
    const s = Ye.getBrowserTypeByAlias(i);
    return n && s && (i = s.toLowerCase()), i === r;
  }
  compareVersion(t) {
    let n = [0],
      r = t,
      i = !1;
    const s = this.getBrowserVersion();
    if (typeof s == "string")
      return (
        t[0] === ">" || t[0] === "<"
          ? ((r = t.substr(1)),
            t[1] === "=" ? ((i = !0), (r = t.substr(2))) : (n = []),
            t[0] === ">" ? n.push(1) : n.push(-1))
          : t[0] === "="
          ? (r = t.substr(1))
          : t[0] === "~" && ((i = !0), (r = t.substr(1))),
        n.indexOf(Ye.compareVersions(s, r, i)) > -1
      );
  }
  isOS(t) {
    return this.getOSName(!0) === String(t).toLowerCase();
  }
  isPlatform(t) {
    return this.getPlatformType(!0) === String(t).toLowerCase();
  }
  isEngine(t) {
    return this.getEngineName(!0) === String(t).toLowerCase();
  }
  is(t, n = !1) {
    return this.isBrowser(t, n) || this.isOS(t) || this.isPlatform(t);
  }
  some(t = []) {
    return t.some((n) => this.is(n));
  }
};
/*!
 * Bowser - a browser detector
 * https://github.com/lancedikson/bowser
 * MIT License | (c) Dustin Diaz 2012-2015
 * MIT License | (c) Denis Demchenko 2015-2019
 */ class J5e {
  static getParser(t, n = !1) {
    if (typeof t != "string") throw new Error("UserAgent should be a string");
    return new JU(t, n);
  }
  static parse(t) {
    return new JU(t).getResult();
  }
  static get BROWSER_MAP() {
    return iJ;
  }
  static get ENGINE_MAP() {
    return ip;
  }
  static get OS_MAP() {
    return va;
  }
  static get PLATFORMS_MAP() {
    return Ts;
  }
}
const zT = globalThis || void 0 || self;
function Jg() {}
function eSe(e) {
  return e();
}
function tSe(e) {
  e.forEach(eSe);
}
function nSe(e) {
  return typeof e == "function";
}
function rSe(e, t) {
  return e != e
    ? t == t
    : e !== t || (e && typeof e == "object") || typeof e == "function";
}
function iSe(e, ...t) {
  if (e == null) return Jg;
  const n = e.subscribe(...t);
  return n.unsubscribe ? () => n.unsubscribe() : n;
}
const H1 = [];
function sSe(e, t) {
  return { subscribe: N8(e, t).subscribe };
}
function N8(e, t = Jg) {
  let n;
  const r = new Set();
  function i(a) {
    if (rSe(e, a) && ((e = a), n)) {
      const l = !H1.length;
      for (const c of r) c[1](), H1.push(c, e);
      if (l) {
        for (let c = 0; c < H1.length; c += 2) H1[c][0](H1[c + 1]);
        H1.length = 0;
      }
    }
  }
  function s(a) {
    i(a(e));
  }
  function o(a, l = Jg) {
    const c = [a, l];
    return (
      r.add(c),
      r.size === 1 && (n = t(i) || Jg),
      a(e),
      () => {
        r.delete(c), r.size === 0 && n && (n(), (n = null));
      }
    );
  }
  return { set: i, update: s, subscribe: o };
}
function yv(e, t, n) {
  const r = !Array.isArray(e),
    i = r ? [e] : e,
    s = t.length < 2;
  return sSe(n, (o) => {
    let a = !1;
    const l = [];
    let c = 0,
      u = Jg;
    const d = () => {
        if (c) return;
        u();
        const h = t(r ? l[0] : l, o);
        s ? o(h) : (u = nSe(h) ? h : Jg);
      },
      f = i.map((h, p) =>
        iSe(
          h,
          (g) => {
            (l[p] = g), (c &= ~(1 << p)), a && d();
          },
          () => {
            c |= 1 << p;
          }
        )
      );
    return (
      (a = !0),
      d(),
      function () {
        tSe(f), u(), (a = !1);
      }
    );
  });
}
var oSe = function (t) {
  return aSe(t) && !lSe(t);
};
function aSe(e) {
  return !!e && typeof e == "object";
}
function lSe(e) {
  var t = Object.prototype.toString.call(e);
  return t === "[object RegExp]" || t === "[object Date]" || dSe(e);
}
var cSe = typeof Symbol == "function" && Symbol.for,
  uSe = cSe ? Symbol.for("react.element") : 60103;
function dSe(e) {
  return e.$$typeof === uSe;
}
function fSe(e) {
  return Array.isArray(e) ? [] : {};
}
function vb(e, t) {
  return t.clone !== !1 && t.isMergeableObject(e) ? Py(fSe(e), e, t) : e;
}
function hSe(e, t, n) {
  return e.concat(t).map(function (r) {
    return vb(r, n);
  });
}
function pSe(e, t) {
  if (!t.customMerge) return Py;
  var n = t.customMerge(e);
  return typeof n == "function" ? n : Py;
}
function mSe(e) {
  return Object.getOwnPropertySymbols
    ? Object.getOwnPropertySymbols(e).filter(function (t) {
        return Object.propertyIsEnumerable.call(e, t);
      })
    : [];
}
function e$(e) {
  return Object.keys(e).concat(mSe(e));
}
function sJ(e, t) {
  try {
    return t in e;
  } catch {
    return !1;
  }
}
function gSe(e, t) {
  return (
    sJ(e, t) &&
    !(
      Object.hasOwnProperty.call(e, t) && Object.propertyIsEnumerable.call(e, t)
    )
  );
}
function ySe(e, t, n) {
  var r = {};
  return (
    n.isMergeableObject(e) &&
      e$(e).forEach(function (i) {
        r[i] = vb(e[i], n);
      }),
    e$(t).forEach(function (i) {
      gSe(e, i) ||
        (sJ(e, i) && n.isMergeableObject(t[i])
          ? (r[i] = pSe(i, n)(e[i], t[i], n))
          : (r[i] = vb(t[i], n)));
    }),
    r
  );
}
function Py(e, t, n) {
  (n = n || {}),
    (n.arrayMerge = n.arrayMerge || hSe),
    (n.isMergeableObject = n.isMergeableObject || oSe),
    (n.cloneUnlessOtherwiseSpecified = vb);
  var r = Array.isArray(t),
    i = Array.isArray(e),
    s = r === i;
  return s ? (r ? n.arrayMerge(e, t, n) : ySe(e, t, n)) : vb(t, n);
}
Py.all = function (t, n) {
  if (!Array.isArray(t)) throw new Error("first argument should be an array");
  return t.reduce(function (r, i) {
    return Py(r, i, n);
  }, {});
};
var vSe = Py,
  wSe = vSe;
const bSe = Gi(wSe);
var kr;
(function (e) {
  (e[(e.EXPECT_ARGUMENT_CLOSING_BRACE = 1)] = "EXPECT_ARGUMENT_CLOSING_BRACE"),
    (e[(e.EMPTY_ARGUMENT = 2)] = "EMPTY_ARGUMENT"),
    (e[(e.MALFORMED_ARGUMENT = 3)] = "MALFORMED_ARGUMENT"),
    (e[(e.EXPECT_ARGUMENT_TYPE = 4)] = "EXPECT_ARGUMENT_TYPE"),
    (e[(e.INVALID_ARGUMENT_TYPE = 5)] = "INVALID_ARGUMENT_TYPE"),
    (e[(e.EXPECT_ARGUMENT_STYLE = 6)] = "EXPECT_ARGUMENT_STYLE"),
    (e[(e.INVALID_NUMBER_SKELETON = 7)] = "INVALID_NUMBER_SKELETON"),
    (e[(e.INVALID_DATE_TIME_SKELETON = 8)] = "INVALID_DATE_TIME_SKELETON"),
    (e[(e.EXPECT_NUMBER_SKELETON = 9)] = "EXPECT_NUMBER_SKELETON"),
    (e[(e.EXPECT_DATE_TIME_SKELETON = 10)] = "EXPECT_DATE_TIME_SKELETON"),
    (e[(e.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE = 11)] =
      "UNCLOSED_QUOTE_IN_ARGUMENT_STYLE"),
    (e[(e.EXPECT_SELECT_ARGUMENT_OPTIONS = 12)] =
      "EXPECT_SELECT_ARGUMENT_OPTIONS"),
    (e[(e.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE = 13)] =
      "EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE"),
    (e[(e.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE = 14)] =
      "INVALID_PLURAL_ARGUMENT_OFFSET_VALUE"),
    (e[(e.EXPECT_SELECT_ARGUMENT_SELECTOR = 15)] =
      "EXPECT_SELECT_ARGUMENT_SELECTOR"),
    (e[(e.EXPECT_PLURAL_ARGUMENT_SELECTOR = 16)] =
      "EXPECT_PLURAL_ARGUMENT_SELECTOR"),
    (e[(e.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT = 17)] =
      "EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT"),
    (e[(e.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT = 18)] =
      "EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT"),
    (e[(e.INVALID_PLURAL_ARGUMENT_SELECTOR = 19)] =
      "INVALID_PLURAL_ARGUMENT_SELECTOR"),
    (e[(e.DUPLICATE_PLURAL_ARGUMENT_SELECTOR = 20)] =
      "DUPLICATE_PLURAL_ARGUMENT_SELECTOR"),
    (e[(e.DUPLICATE_SELECT_ARGUMENT_SELECTOR = 21)] =
      "DUPLICATE_SELECT_ARGUMENT_SELECTOR"),
    (e[(e.MISSING_OTHER_CLAUSE = 22)] = "MISSING_OTHER_CLAUSE"),
    (e[(e.INVALID_TAG = 23)] = "INVALID_TAG"),
    (e[(e.INVALID_TAG_NAME = 25)] = "INVALID_TAG_NAME"),
    (e[(e.UNMATCHED_CLOSING_TAG = 26)] = "UNMATCHED_CLOSING_TAG"),
    (e[(e.UNCLOSED_TAG = 27)] = "UNCLOSED_TAG");
})(kr || (kr = {}));
var Ji;
(function (e) {
  (e[(e.literal = 0)] = "literal"),
    (e[(e.argument = 1)] = "argument"),
    (e[(e.number = 2)] = "number"),
    (e[(e.date = 3)] = "date"),
    (e[(e.time = 4)] = "time"),
    (e[(e.select = 5)] = "select"),
    (e[(e.plural = 6)] = "plural"),
    (e[(e.pound = 7)] = "pound"),
    (e[(e.tag = 8)] = "tag");
})(Ji || (Ji = {}));
var Ly;
(function (e) {
  (e[(e.number = 0)] = "number"), (e[(e.dateTime = 1)] = "dateTime");
})(Ly || (Ly = {}));
function t$(e) {
  return e.type === Ji.literal;
}
function xSe(e) {
  return e.type === Ji.argument;
}
function oJ(e) {
  return e.type === Ji.number;
}
function aJ(e) {
  return e.type === Ji.date;
}
function lJ(e) {
  return e.type === Ji.time;
}
function cJ(e) {
  return e.type === Ji.select;
}
function uJ(e) {
  return e.type === Ji.plural;
}
function _Se(e) {
  return e.type === Ji.pound;
}
function dJ(e) {
  return e.type === Ji.tag;
}
function fJ(e) {
  return !!(e && typeof e == "object" && e.type === Ly.number);
}
function WT(e) {
  return !!(e && typeof e == "object" && e.type === Ly.dateTime);
}
var hJ = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/,
  SSe =
    /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g;
function ESe(e) {
  var t = {};
  return (
    e.replace(SSe, function (n) {
      var r = n.length;
      switch (n[0]) {
        case "G":
          t.era = r === 4 ? "long" : r === 5 ? "narrow" : "short";
          break;
        case "y":
          t.year = r === 2 ? "2-digit" : "numeric";
          break;
        case "Y":
        case "u":
        case "U":
        case "r":
          throw new RangeError(
            "`Y/u/U/r` (year) patterns are not supported, use `y` instead"
          );
        case "q":
        case "Q":
          throw new RangeError("`q/Q` (quarter) patterns are not supported");
        case "M":
        case "L":
          t.month = ["numeric", "2-digit", "short", "long", "narrow"][r - 1];
          break;
        case "w":
        case "W":
          throw new RangeError("`w/W` (week) patterns are not supported");
        case "d":
          t.day = ["numeric", "2-digit"][r - 1];
          break;
        case "D":
        case "F":
        case "g":
          throw new RangeError(
            "`D/F/g` (day) patterns are not supported, use `d` instead"
          );
        case "E":
          t.weekday = r === 4 ? "short" : r === 5 ? "narrow" : "short";
          break;
        case "e":
          if (r < 4)
            throw new RangeError(
              "`e..eee` (weekday) patterns are not supported"
            );
          t.weekday = ["short", "long", "narrow", "short"][r - 4];
          break;
        case "c":
          if (r < 4)
            throw new RangeError(
              "`c..ccc` (weekday) patterns are not supported"
            );
          t.weekday = ["short", "long", "narrow", "short"][r - 4];
          break;
        case "a":
          t.hour12 = !0;
          break;
        case "b":
        case "B":
          throw new RangeError(
            "`b/B` (period) patterns are not supported, use `a` instead"
          );
        case "h":
          (t.hourCycle = "h12"), (t.hour = ["numeric", "2-digit"][r - 1]);
          break;
        case "H":
          (t.hourCycle = "h23"), (t.hour = ["numeric", "2-digit"][r - 1]);
          break;
        case "K":
          (t.hourCycle = "h11"), (t.hour = ["numeric", "2-digit"][r - 1]);
          break;
        case "k":
          (t.hourCycle = "h24"), (t.hour = ["numeric", "2-digit"][r - 1]);
          break;
        case "j":
        case "J":
        case "C":
          throw new RangeError(
            "`j/J/C` (hour) patterns are not supported, use `h/H/K/k` instead"
          );
        case "m":
          t.minute = ["numeric", "2-digit"][r - 1];
          break;
        case "s":
          t.second = ["numeric", "2-digit"][r - 1];
          break;
        case "S":
        case "A":
          throw new RangeError(
            "`S/A` (second) patterns are not supported, use `s` instead"
          );
        case "z":
          t.timeZoneName = r < 4 ? "short" : "long";
          break;
        case "Z":
        case "O":
        case "v":
        case "V":
        case "X":
        case "x":
          throw new RangeError(
            "`Z/O/v/V/X/x` (timeZone) patterns are not supported, use `z` instead"
          );
      }
      return "";
    }),
    t
  );
}
var ASe = /[\t-\r \x85\u200E\u200F\u2028\u2029]/i;
function CSe(e) {
  if (e.length === 0) throw new Error("Number skeleton cannot be empty");
  for (
    var t = e.split(ASe).filter(function (f) {
        return f.length > 0;
      }),
      n = [],
      r = 0,
      i = t;
    r < i.length;
    r++
  ) {
    var s = i[r],
      o = s.split("/");
    if (o.length === 0) throw new Error("Invalid number skeleton");
    for (var a = o[0], l = o.slice(1), c = 0, u = l; c < u.length; c++) {
      var d = u[c];
      if (d.length === 0) throw new Error("Invalid number skeleton");
    }
    n.push({ stem: a, options: l });
  }
  return n;
}
function kSe(e) {
  return e.replace(/^(.*?)-/, "");
}
var n$ = /^\.(?:(0+)(\*)?|(#+)|(0+)(#+))$/g,
  pJ = /^(@+)?(\+|#+)?[rs]?$/g,
  TSe = /(\*)(0+)|(#+)(0+)|(0+)/g,
  mJ = /^(0+)$/;
function r$(e) {
  var t = {};
  return (
    e[e.length - 1] === "r"
      ? (t.roundingPriority = "morePrecision")
      : e[e.length - 1] === "s" && (t.roundingPriority = "lessPrecision"),
    e.replace(pJ, function (n, r, i) {
      return (
        typeof i != "string"
          ? ((t.minimumSignificantDigits = r.length),
            (t.maximumSignificantDigits = r.length))
          : i === "+"
          ? (t.minimumSignificantDigits = r.length)
          : r[0] === "#"
          ? (t.maximumSignificantDigits = r.length)
          : ((t.minimumSignificantDigits = r.length),
            (t.maximumSignificantDigits =
              r.length + (typeof i == "string" ? i.length : 0))),
        ""
      );
    }),
    t
  );
}
function gJ(e) {
  switch (e) {
    case "sign-auto":
      return { signDisplay: "auto" };
    case "sign-accounting":
    case "()":
      return { currencySign: "accounting" };
    case "sign-always":
    case "+!":
      return { signDisplay: "always" };
    case "sign-accounting-always":
    case "()!":
      return { signDisplay: "always", currencySign: "accounting" };
    case "sign-except-zero":
    case "+?":
      return { signDisplay: "exceptZero" };
    case "sign-accounting-except-zero":
    case "()?":
      return { signDisplay: "exceptZero", currencySign: "accounting" };
    case "sign-never":
    case "+_":
      return { signDisplay: "never" };
  }
}
function MSe(e) {
  var t;
  if (
    (e[0] === "E" && e[1] === "E"
      ? ((t = { notation: "engineering" }), (e = e.slice(2)))
      : e[0] === "E" && ((t = { notation: "scientific" }), (e = e.slice(1))),
    t)
  ) {
    var n = e.slice(0, 2);
    if (
      (n === "+!"
        ? ((t.signDisplay = "always"), (e = e.slice(2)))
        : n === "+?" && ((t.signDisplay = "exceptZero"), (e = e.slice(2))),
      !mJ.test(e))
    )
      throw new Error("Malformed concise eng/scientific notation");
    t.minimumIntegerDigits = e.length;
  }
  return t;
}
function i$(e) {
  var t = {},
    n = gJ(e);
  return n || t;
}
function ISe(e) {
  for (var t = {}, n = 0, r = e; n < r.length; n++) {
    var i = r[n];
    switch (i.stem) {
      case "percent":
      case "%":
        t.style = "percent";
        continue;
      case "%x100":
        (t.style = "percent"), (t.scale = 100);
        continue;
      case "currency":
        (t.style = "currency"), (t.currency = i.options[0]);
        continue;
      case "group-off":
      case ",_":
        t.useGrouping = !1;
        continue;
      case "precision-integer":
      case ".":
        t.maximumFractionDigits = 0;
        continue;
      case "measure-unit":
      case "unit":
        (t.style = "unit"), (t.unit = kSe(i.options[0]));
        continue;
      case "compact-short":
      case "K":
        (t.notation = "compact"), (t.compactDisplay = "short");
        continue;
      case "compact-long":
      case "KK":
        (t.notation = "compact"), (t.compactDisplay = "long");
        continue;
      case "scientific":
        t = ti(
          ti(ti({}, t), { notation: "scientific" }),
          i.options.reduce(function (l, c) {
            return ti(ti({}, l), i$(c));
          }, {})
        );
        continue;
      case "engineering":
        t = ti(
          ti(ti({}, t), { notation: "engineering" }),
          i.options.reduce(function (l, c) {
            return ti(ti({}, l), i$(c));
          }, {})
        );
        continue;
      case "notation-simple":
        t.notation = "standard";
        continue;
      case "unit-width-narrow":
        (t.currencyDisplay = "narrowSymbol"), (t.unitDisplay = "narrow");
        continue;
      case "unit-width-short":
        (t.currencyDisplay = "code"), (t.unitDisplay = "short");
        continue;
      case "unit-width-full-name":
        (t.currencyDisplay = "name"), (t.unitDisplay = "long");
        continue;
      case "unit-width-iso-code":
        t.currencyDisplay = "symbol";
        continue;
      case "scale":
        t.scale = parseFloat(i.options[0]);
        continue;
      case "integer-width":
        if (i.options.length > 1)
          throw new RangeError(
            "integer-width stems only accept a single optional option"
          );
        i.options[0].replace(TSe, function (l, c, u, d, f, h) {
          if (c) t.minimumIntegerDigits = u.length;
          else {
            if (d && f)
              throw new Error(
                "We currently do not support maximum integer digits"
              );
            if (h)
              throw new Error(
                "We currently do not support exact integer digits"
              );
          }
          return "";
        });
        continue;
    }
    if (mJ.test(i.stem)) {
      t.minimumIntegerDigits = i.stem.length;
      continue;
    }
    if (n$.test(i.stem)) {
      if (i.options.length > 1)
        throw new RangeError(
          "Fraction-precision stems only accept a single optional option"
        );
      i.stem.replace(n$, function (l, c, u, d, f, h) {
        return (
          u === "*"
            ? (t.minimumFractionDigits = c.length)
            : d && d[0] === "#"
            ? (t.maximumFractionDigits = d.length)
            : f && h
            ? ((t.minimumFractionDigits = f.length),
              (t.maximumFractionDigits = f.length + h.length))
            : ((t.minimumFractionDigits = c.length),
              (t.maximumFractionDigits = c.length)),
          ""
        );
      });
      var s = i.options[0];
      s === "w"
        ? (t = ti(ti({}, t), { trailingZeroDisplay: "stripIfInteger" }))
        : s && (t = ti(ti({}, t), r$(s)));
      continue;
    }
    if (pJ.test(i.stem)) {
      t = ti(ti({}, t), r$(i.stem));
      continue;
    }
    var o = gJ(i.stem);
    o && (t = ti(ti({}, t), o));
    var a = MSe(i.stem);
    a && (t = ti(ti({}, t), a));
  }
  return t;
}
var P_ = {
  AX: ["H"],
  BQ: ["H"],
  CP: ["H"],
  CZ: ["H"],
  DK: ["H"],
  FI: ["H"],
  ID: ["H"],
  IS: ["H"],
  ML: ["H"],
  NE: ["H"],
  RU: ["H"],
  SE: ["H"],
  SJ: ["H"],
  SK: ["H"],
  AS: ["h", "H"],
  BT: ["h", "H"],
  DJ: ["h", "H"],
  ER: ["h", "H"],
  GH: ["h", "H"],
  IN: ["h", "H"],
  LS: ["h", "H"],
  PG: ["h", "H"],
  PW: ["h", "H"],
  SO: ["h", "H"],
  TO: ["h", "H"],
  VU: ["h", "H"],
  WS: ["h", "H"],
  "001": ["H", "h"],
  AL: ["h", "H", "hB"],
  TD: ["h", "H", "hB"],
  "ca-ES": ["H", "h", "hB"],
  CF: ["H", "h", "hB"],
  CM: ["H", "h", "hB"],
  "fr-CA": ["H", "h", "hB"],
  "gl-ES": ["H", "h", "hB"],
  "it-CH": ["H", "h", "hB"],
  "it-IT": ["H", "h", "hB"],
  LU: ["H", "h", "hB"],
  NP: ["H", "h", "hB"],
  PF: ["H", "h", "hB"],
  SC: ["H", "h", "hB"],
  SM: ["H", "h", "hB"],
  SN: ["H", "h", "hB"],
  TF: ["H", "h", "hB"],
  VA: ["H", "h", "hB"],
  CY: ["h", "H", "hb", "hB"],
  GR: ["h", "H", "hb", "hB"],
  CO: ["h", "H", "hB", "hb"],
  DO: ["h", "H", "hB", "hb"],
  KP: ["h", "H", "hB", "hb"],
  KR: ["h", "H", "hB", "hb"],
  NA: ["h", "H", "hB", "hb"],
  PA: ["h", "H", "hB", "hb"],
  PR: ["h", "H", "hB", "hb"],
  VE: ["h", "H", "hB", "hb"],
  AC: ["H", "h", "hb", "hB"],
  AI: ["H", "h", "hb", "hB"],
  BW: ["H", "h", "hb", "hB"],
  BZ: ["H", "h", "hb", "hB"],
  CC: ["H", "h", "hb", "hB"],
  CK: ["H", "h", "hb", "hB"],
  CX: ["H", "h", "hb", "hB"],
  DG: ["H", "h", "hb", "hB"],
  FK: ["H", "h", "hb", "hB"],
  GB: ["H", "h", "hb", "hB"],
  GG: ["H", "h", "hb", "hB"],
  GI: ["H", "h", "hb", "hB"],
  IE: ["H", "h", "hb", "hB"],
  IM: ["H", "h", "hb", "hB"],
  IO: ["H", "h", "hb", "hB"],
  JE: ["H", "h", "hb", "hB"],
  LT: ["H", "h", "hb", "hB"],
  MK: ["H", "h", "hb", "hB"],
  MN: ["H", "h", "hb", "hB"],
  MS: ["H", "h", "hb", "hB"],
  NF: ["H", "h", "hb", "hB"],
  NG: ["H", "h", "hb", "hB"],
  NR: ["H", "h", "hb", "hB"],
  NU: ["H", "h", "hb", "hB"],
  PN: ["H", "h", "hb", "hB"],
  SH: ["H", "h", "hb", "hB"],
  SX: ["H", "h", "hb", "hB"],
  TA: ["H", "h", "hb", "hB"],
  ZA: ["H", "h", "hb", "hB"],
  "af-ZA": ["H", "h", "hB", "hb"],
  AR: ["H", "h", "hB", "hb"],
  CL: ["H", "h", "hB", "hb"],
  CR: ["H", "h", "hB", "hb"],
  CU: ["H", "h", "hB", "hb"],
  EA: ["H", "h", "hB", "hb"],
  "es-BO": ["H", "h", "hB", "hb"],
  "es-BR": ["H", "h", "hB", "hb"],
  "es-EC": ["H", "h", "hB", "hb"],
  "es-ES": ["H", "h", "hB", "hb"],
  "es-GQ": ["H", "h", "hB", "hb"],
  "es-PE": ["H", "h", "hB", "hb"],
  GT: ["H", "h", "hB", "hb"],
  HN: ["H", "h", "hB", "hb"],
  IC: ["H", "h", "hB", "hb"],
  KG: ["H", "h", "hB", "hb"],
  KM: ["H", "h", "hB", "hb"],
  LK: ["H", "h", "hB", "hb"],
  MA: ["H", "h", "hB", "hb"],
  MX: ["H", "h", "hB", "hb"],
  NI: ["H", "h", "hB", "hb"],
  PY: ["H", "h", "hB", "hb"],
  SV: ["H", "h", "hB", "hb"],
  UY: ["H", "h", "hB", "hb"],
  JP: ["H", "h", "K"],
  AD: ["H", "hB"],
  AM: ["H", "hB"],
  AO: ["H", "hB"],
  AT: ["H", "hB"],
  AW: ["H", "hB"],
  BE: ["H", "hB"],
  BF: ["H", "hB"],
  BJ: ["H", "hB"],
  BL: ["H", "hB"],
  BR: ["H", "hB"],
  CG: ["H", "hB"],
  CI: ["H", "hB"],
  CV: ["H", "hB"],
  DE: ["H", "hB"],
  EE: ["H", "hB"],
  FR: ["H", "hB"],
  GA: ["H", "hB"],
  GF: ["H", "hB"],
  GN: ["H", "hB"],
  GP: ["H", "hB"],
  GW: ["H", "hB"],
  HR: ["H", "hB"],
  IL: ["H", "hB"],
  IT: ["H", "hB"],
  KZ: ["H", "hB"],
  MC: ["H", "hB"],
  MD: ["H", "hB"],
  MF: ["H", "hB"],
  MQ: ["H", "hB"],
  MZ: ["H", "hB"],
  NC: ["H", "hB"],
  NL: ["H", "hB"],
  PM: ["H", "hB"],
  PT: ["H", "hB"],
  RE: ["H", "hB"],
  RO: ["H", "hB"],
  SI: ["H", "hB"],
  SR: ["H", "hB"],
  ST: ["H", "hB"],
  TG: ["H", "hB"],
  TR: ["H", "hB"],
  WF: ["H", "hB"],
  YT: ["H", "hB"],
  BD: ["h", "hB", "H"],
  PK: ["h", "hB", "H"],
  AZ: ["H", "hB", "h"],
  BA: ["H", "hB", "h"],
  BG: ["H", "hB", "h"],
  CH: ["H", "hB", "h"],
  GE: ["H", "hB", "h"],
  LI: ["H", "hB", "h"],
  ME: ["H", "hB", "h"],
  RS: ["H", "hB", "h"],
  UA: ["H", "hB", "h"],
  UZ: ["H", "hB", "h"],
  XK: ["H", "hB", "h"],
  AG: ["h", "hb", "H", "hB"],
  AU: ["h", "hb", "H", "hB"],
  BB: ["h", "hb", "H", "hB"],
  BM: ["h", "hb", "H", "hB"],
  BS: ["h", "hb", "H", "hB"],
  CA: ["h", "hb", "H", "hB"],
  DM: ["h", "hb", "H", "hB"],
  "en-001": ["h", "hb", "H", "hB"],
  FJ: ["h", "hb", "H", "hB"],
  FM: ["h", "hb", "H", "hB"],
  GD: ["h", "hb", "H", "hB"],
  GM: ["h", "hb", "H", "hB"],
  GU: ["h", "hb", "H", "hB"],
  GY: ["h", "hb", "H", "hB"],
  JM: ["h", "hb", "H", "hB"],
  KI: ["h", "hb", "H", "hB"],
  KN: ["h", "hb", "H", "hB"],
  KY: ["h", "hb", "H", "hB"],
  LC: ["h", "hb", "H", "hB"],
  LR: ["h", "hb", "H", "hB"],
  MH: ["h", "hb", "H", "hB"],
  MP: ["h", "hb", "H", "hB"],
  MW: ["h", "hb", "H", "hB"],
  NZ: ["h", "hb", "H", "hB"],
  SB: ["h", "hb", "H", "hB"],
  SG: ["h", "hb", "H", "hB"],
  SL: ["h", "hb", "H", "hB"],
  SS: ["h", "hb", "H", "hB"],
  SZ: ["h", "hb", "H", "hB"],
  TC: ["h", "hb", "H", "hB"],
  TT: ["h", "hb", "H", "hB"],
  UM: ["h", "hb", "H", "hB"],
  US: ["h", "hb", "H", "hB"],
  VC: ["h", "hb", "H", "hB"],
  VG: ["h", "hb", "H", "hB"],
  VI: ["h", "hb", "H", "hB"],
  ZM: ["h", "hb", "H", "hB"],
  BO: ["H", "hB", "h", "hb"],
  EC: ["H", "hB", "h", "hb"],
  ES: ["H", "hB", "h", "hb"],
  GQ: ["H", "hB", "h", "hb"],
  PE: ["H", "hB", "h", "hb"],
  AE: ["h", "hB", "hb", "H"],
  "ar-001": ["h", "hB", "hb", "H"],
  BH: ["h", "hB", "hb", "H"],
  DZ: ["h", "hB", "hb", "H"],
  EG: ["h", "hB", "hb", "H"],
  EH: ["h", "hB", "hb", "H"],
  HK: ["h", "hB", "hb", "H"],
  IQ: ["h", "hB", "hb", "H"],
  JO: ["h", "hB", "hb", "H"],
  KW: ["h", "hB", "hb", "H"],
  LB: ["h", "hB", "hb", "H"],
  LY: ["h", "hB", "hb", "H"],
  MO: ["h", "hB", "hb", "H"],
  MR: ["h", "hB", "hb", "H"],
  OM: ["h", "hB", "hb", "H"],
  PH: ["h", "hB", "hb", "H"],
  PS: ["h", "hB", "hb", "H"],
  QA: ["h", "hB", "hb", "H"],
  SA: ["h", "hB", "hb", "H"],
  SD: ["h", "hB", "hb", "H"],
  SY: ["h", "hB", "hb", "H"],
  TN: ["h", "hB", "hb", "H"],
  YE: ["h", "hB", "hb", "H"],
  AF: ["H", "hb", "hB", "h"],
  LA: ["H", "hb", "hB", "h"],
  CN: ["H", "hB", "hb", "h"],
  LV: ["H", "hB", "hb", "h"],
  TL: ["H", "hB", "hb", "h"],
  "zu-ZA": ["H", "hB", "hb", "h"],
  CD: ["hB", "H"],
  IR: ["hB", "H"],
  "hi-IN": ["hB", "h", "H"],
  "kn-IN": ["hB", "h", "H"],
  "ml-IN": ["hB", "h", "H"],
  "te-IN": ["hB", "h", "H"],
  KH: ["hB", "h", "H", "hb"],
  "ta-IN": ["hB", "h", "hb", "H"],
  BN: ["hb", "hB", "h", "H"],
  MY: ["hb", "hB", "h", "H"],
  ET: ["hB", "hb", "h", "H"],
  "gu-IN": ["hB", "hb", "h", "H"],
  "mr-IN": ["hB", "hb", "h", "H"],
  "pa-IN": ["hB", "hb", "h", "H"],
  TW: ["hB", "hb", "h", "H"],
  KE: ["hB", "hb", "H", "h"],
  MM: ["hB", "hb", "H", "h"],
  TZ: ["hB", "hb", "H", "h"],
  UG: ["hB", "hb", "H", "h"],
};
function NSe(e, t) {
  for (var n = "", r = 0; r < e.length; r++) {
    var i = e.charAt(r);
    if (i === "j") {
      for (var s = 0; r + 1 < e.length && e.charAt(r + 1) === i; ) s++, r++;
      var o = 1 + (s & 1),
        a = s < 2 ? 1 : 3 + (s >> 1),
        l = "a",
        c = RSe(t);
      for ((c == "H" || c == "k") && (a = 0); a-- > 0; ) n += l;
      for (; o-- > 0; ) n = c + n;
    } else i === "J" ? (n += "H") : (n += i);
  }
  return n;
}
function RSe(e) {
  var t = e.hourCycle;
  if (
    (t === void 0 &&
      e.hourCycles &&
      e.hourCycles.length &&
      (t = e.hourCycles[0]),
    t)
  )
    switch (t) {
      case "h24":
        return "k";
      case "h23":
        return "H";
      case "h12":
        return "h";
      case "h11":
        return "K";
      default:
        throw new Error("Invalid hourCycle");
    }
  var n = e.language,
    r;
  n !== "root" && (r = e.maximize().region);
  var i = P_[r || ""] || P_[n || ""] || P_["".concat(n, "-001")] || P_["001"];
  return i[0];
}
var vC,
  OSe = new RegExp("^".concat(hJ.source, "*")),
  PSe = new RegExp("".concat(hJ.source, "*$"));
function Or(e, t) {
  return { start: e, end: t };
}
var LSe = !!String.prototype.startsWith,
  jSe = !!String.fromCodePoint,
  DSe = !!Object.fromEntries,
  BSe = !!String.prototype.codePointAt,
  FSe = !!String.prototype.trimStart,
  USe = !!String.prototype.trimEnd,
  $Se = !!Number.isSafeInteger,
  zSe = $Se
    ? Number.isSafeInteger
    : function (e) {
        return (
          typeof e == "number" &&
          isFinite(e) &&
          Math.floor(e) === e &&
          Math.abs(e) <= 9007199254740991
        );
      },
  HT = !0;
try {
  var WSe = vJ("([^\\p{White_Space}\\p{Pattern_Syntax}]*)", "yu");
  HT =
    ((vC = WSe.exec("a")) === null || vC === void 0 ? void 0 : vC[0]) === "a";
} catch {
  HT = !1;
}
var s$ = LSe
    ? function (t, n, r) {
        return t.startsWith(n, r);
      }
    : function (t, n, r) {
        return t.slice(r, r + n.length) === n;
      },
  VT = jSe
    ? String.fromCodePoint
    : function () {
        for (var t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n];
        for (var r = "", i = t.length, s = 0, o; i > s; ) {
          if (((o = t[s++]), o > 1114111))
            throw RangeError(o + " is not a valid code point");
          r +=
            o < 65536
              ? String.fromCharCode(o)
              : String.fromCharCode(
                  ((o -= 65536) >> 10) + 55296,
                  (o % 1024) + 56320
                );
        }
        return r;
      },
  o$ = DSe
    ? Object.fromEntries
    : function (t) {
        for (var n = {}, r = 0, i = t; r < i.length; r++) {
          var s = i[r],
            o = s[0],
            a = s[1];
          n[o] = a;
        }
        return n;
      },
  yJ = BSe
    ? function (t, n) {
        return t.codePointAt(n);
      }
    : function (t, n) {
        var r = t.length;
        if (!(n < 0 || n >= r)) {
          var i = t.charCodeAt(n),
            s;
          return i < 55296 ||
            i > 56319 ||
            n + 1 === r ||
            (s = t.charCodeAt(n + 1)) < 56320 ||
            s > 57343
            ? i
            : ((i - 55296) << 10) + (s - 56320) + 65536;
        }
      },
  HSe = FSe
    ? function (t) {
        return t.trimStart();
      }
    : function (t) {
        return t.replace(OSe, "");
      },
  VSe = USe
    ? function (t) {
        return t.trimEnd();
      }
    : function (t) {
        return t.replace(PSe, "");
      };
function vJ(e, t) {
  return new RegExp(e, t);
}
var GT;
if (HT) {
  var a$ = vJ("([^\\p{White_Space}\\p{Pattern_Syntax}]*)", "yu");
  GT = function (t, n) {
    var r;
    a$.lastIndex = n;
    var i = a$.exec(t);
    return (r = i[1]) !== null && r !== void 0 ? r : "";
  };
} else
  GT = function (t, n) {
    for (var r = []; ; ) {
      var i = yJ(t, n);
      if (i === void 0 || wJ(i) || YSe(i)) break;
      r.push(i), (n += i >= 65536 ? 2 : 1);
    }
    return VT.apply(void 0, r);
  };
var GSe = (function () {
  function e(t, n) {
    n === void 0 && (n = {}),
      (this.message = t),
      (this.position = { offset: 0, line: 1, column: 1 }),
      (this.ignoreTag = !!n.ignoreTag),
      (this.locale = n.locale),
      (this.requiresOtherClause = !!n.requiresOtherClause),
      (this.shouldParseSkeletons = !!n.shouldParseSkeletons);
  }
  return (
    (e.prototype.parse = function () {
      if (this.offset() !== 0) throw Error("parser can only be used once");
      return this.parseMessage(0, "", !1);
    }),
    (e.prototype.parseMessage = function (t, n, r) {
      for (var i = []; !this.isEOF(); ) {
        var s = this.char();
        if (s === 123) {
          var o = this.parseArgument(t, r);
          if (o.err) return o;
          i.push(o.val);
        } else {
          if (s === 125 && t > 0) break;
          if (s === 35 && (n === "plural" || n === "selectordinal")) {
            var a = this.clonePosition();
            this.bump(),
              i.push({ type: Ji.pound, location: Or(a, this.clonePosition()) });
          } else if (s === 60 && !this.ignoreTag && this.peek() === 47) {
            if (r) break;
            return this.error(
              kr.UNMATCHED_CLOSING_TAG,
              Or(this.clonePosition(), this.clonePosition())
            );
          } else if (s === 60 && !this.ignoreTag && qT(this.peek() || 0)) {
            var o = this.parseTag(t, n);
            if (o.err) return o;
            i.push(o.val);
          } else {
            var o = this.parseLiteral(t, n);
            if (o.err) return o;
            i.push(o.val);
          }
        }
      }
      return { val: i, err: null };
    }),
    (e.prototype.parseTag = function (t, n) {
      var r = this.clonePosition();
      this.bump();
      var i = this.parseTagName();
      if ((this.bumpSpace(), this.bumpIf("/>")))
        return {
          val: {
            type: Ji.literal,
            value: "<".concat(i, "/>"),
            location: Or(r, this.clonePosition()),
          },
          err: null,
        };
      if (this.bumpIf(">")) {
        var s = this.parseMessage(t + 1, n, !0);
        if (s.err) return s;
        var o = s.val,
          a = this.clonePosition();
        if (this.bumpIf("</")) {
          if (this.isEOF() || !qT(this.char()))
            return this.error(kr.INVALID_TAG, Or(a, this.clonePosition()));
          var l = this.clonePosition(),
            c = this.parseTagName();
          return i !== c
            ? this.error(kr.UNMATCHED_CLOSING_TAG, Or(l, this.clonePosition()))
            : (this.bumpSpace(),
              this.bumpIf(">")
                ? {
                    val: {
                      type: Ji.tag,
                      value: i,
                      children: o,
                      location: Or(r, this.clonePosition()),
                    },
                    err: null,
                  }
                : this.error(kr.INVALID_TAG, Or(a, this.clonePosition())));
        } else return this.error(kr.UNCLOSED_TAG, Or(r, this.clonePosition()));
      } else return this.error(kr.INVALID_TAG, Or(r, this.clonePosition()));
    }),
    (e.prototype.parseTagName = function () {
      var t = this.offset();
      for (this.bump(); !this.isEOF() && KSe(this.char()); ) this.bump();
      return this.message.slice(t, this.offset());
    }),
    (e.prototype.parseLiteral = function (t, n) {
      for (var r = this.clonePosition(), i = ""; ; ) {
        var s = this.tryParseQuote(n);
        if (s) {
          i += s;
          continue;
        }
        var o = this.tryParseUnquoted(t, n);
        if (o) {
          i += o;
          continue;
        }
        var a = this.tryParseLeftAngleBracket();
        if (a) {
          i += a;
          continue;
        }
        break;
      }
      var l = Or(r, this.clonePosition());
      return { val: { type: Ji.literal, value: i, location: l }, err: null };
    }),
    (e.prototype.tryParseLeftAngleBracket = function () {
      return !this.isEOF() &&
        this.char() === 60 &&
        (this.ignoreTag || !qSe(this.peek() || 0))
        ? (this.bump(), "<")
        : null;
    }),
    (e.prototype.tryParseQuote = function (t) {
      if (this.isEOF() || this.char() !== 39) return null;
      switch (this.peek()) {
        case 39:
          return this.bump(), this.bump(), "'";
        case 123:
        case 60:
        case 62:
        case 125:
          break;
        case 35:
          if (t === "plural" || t === "selectordinal") break;
          return null;
        default:
          return null;
      }
      this.bump();
      var n = [this.char()];
      for (this.bump(); !this.isEOF(); ) {
        var r = this.char();
        if (r === 39)
          if (this.peek() === 39) n.push(39), this.bump();
          else {
            this.bump();
            break;
          }
        else n.push(r);
        this.bump();
      }
      return VT.apply(void 0, n);
    }),
    (e.prototype.tryParseUnquoted = function (t, n) {
      if (this.isEOF()) return null;
      var r = this.char();
      return r === 60 ||
        r === 123 ||
        (r === 35 && (n === "plural" || n === "selectordinal")) ||
        (r === 125 && t > 0)
        ? null
        : (this.bump(), VT(r));
    }),
    (e.prototype.parseArgument = function (t, n) {
      var r = this.clonePosition();
      if ((this.bump(), this.bumpSpace(), this.isEOF()))
        return this.error(
          kr.EXPECT_ARGUMENT_CLOSING_BRACE,
          Or(r, this.clonePosition())
        );
      if (this.char() === 125)
        return (
          this.bump(),
          this.error(kr.EMPTY_ARGUMENT, Or(r, this.clonePosition()))
        );
      var i = this.parseIdentifierIfPossible().value;
      if (!i)
        return this.error(kr.MALFORMED_ARGUMENT, Or(r, this.clonePosition()));
      if ((this.bumpSpace(), this.isEOF()))
        return this.error(
          kr.EXPECT_ARGUMENT_CLOSING_BRACE,
          Or(r, this.clonePosition())
        );
      switch (this.char()) {
        case 125:
          return (
            this.bump(),
            {
              val: {
                type: Ji.argument,
                value: i,
                location: Or(r, this.clonePosition()),
              },
              err: null,
            }
          );
        case 44:
          return (
            this.bump(),
            this.bumpSpace(),
            this.isEOF()
              ? this.error(
                  kr.EXPECT_ARGUMENT_CLOSING_BRACE,
                  Or(r, this.clonePosition())
                )
              : this.parseArgumentOptions(t, n, i, r)
          );
        default:
          return this.error(kr.MALFORMED_ARGUMENT, Or(r, this.clonePosition()));
      }
    }),
    (e.prototype.parseIdentifierIfPossible = function () {
      var t = this.clonePosition(),
        n = this.offset(),
        r = GT(this.message, n),
        i = n + r.length;
      this.bumpTo(i);
      var s = this.clonePosition(),
        o = Or(t, s);
      return { value: r, location: o };
    }),
    (e.prototype.parseArgumentOptions = function (t, n, r, i) {
      var s,
        o = this.clonePosition(),
        a = this.parseIdentifierIfPossible().value,
        l = this.clonePosition();
      switch (a) {
        case "":
          return this.error(kr.EXPECT_ARGUMENT_TYPE, Or(o, l));
        case "number":
        case "date":
        case "time": {
          this.bumpSpace();
          var c = null;
          if (this.bumpIf(",")) {
            this.bumpSpace();
            var u = this.clonePosition(),
              d = this.parseSimpleArgStyleIfPossible();
            if (d.err) return d;
            var f = VSe(d.val);
            if (f.length === 0)
              return this.error(
                kr.EXPECT_ARGUMENT_STYLE,
                Or(this.clonePosition(), this.clonePosition())
              );
            var h = Or(u, this.clonePosition());
            c = { style: f, styleLocation: h };
          }
          var p = this.tryParseArgumentClose(i);
          if (p.err) return p;
          var g = Or(i, this.clonePosition());
          if (c && s$(c == null ? void 0 : c.style, "::", 0)) {
            var b = HSe(c.style.slice(2));
            if (a === "number") {
              var d = this.parseNumberSkeletonFromString(b, c.styleLocation);
              return d.err
                ? d
                : {
                    val: {
                      type: Ji.number,
                      value: r,
                      location: g,
                      style: d.val,
                    },
                    err: null,
                  };
            } else {
              if (b.length === 0)
                return this.error(kr.EXPECT_DATE_TIME_SKELETON, g);
              var v = b;
              this.locale && (v = NSe(b, this.locale));
              var f = {
                  type: Ly.dateTime,
                  pattern: v,
                  location: c.styleLocation,
                  parsedOptions: this.shouldParseSkeletons ? ESe(v) : {},
                },
                w = a === "date" ? Ji.date : Ji.time;
              return {
                val: { type: w, value: r, location: g, style: f },
                err: null,
              };
            }
          }
          return {
            val: {
              type:
                a === "number" ? Ji.number : a === "date" ? Ji.date : Ji.time,
              value: r,
              location: g,
              style:
                (s = c == null ? void 0 : c.style) !== null && s !== void 0
                  ? s
                  : null,
            },
            err: null,
          };
        }
        case "plural":
        case "selectordinal":
        case "select": {
          var x = this.clonePosition();
          if ((this.bumpSpace(), !this.bumpIf(",")))
            return this.error(
              kr.EXPECT_SELECT_ARGUMENT_OPTIONS,
              Or(x, ti({}, x))
            );
          this.bumpSpace();
          var S = this.parseIdentifierIfPossible(),
            R = 0;
          if (a !== "select" && S.value === "offset") {
            if (!this.bumpIf(":"))
              return this.error(
                kr.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE,
                Or(this.clonePosition(), this.clonePosition())
              );
            this.bumpSpace();
            var d = this.tryParseDecimalInteger(
              kr.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE,
              kr.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE
            );
            if (d.err) return d;
            this.bumpSpace(),
              (S = this.parseIdentifierIfPossible()),
              (R = d.val);
          }
          var O = this.tryParsePluralOrSelectOptions(t, a, n, S);
          if (O.err) return O;
          var p = this.tryParseArgumentClose(i);
          if (p.err) return p;
          var B = Or(i, this.clonePosition());
          return a === "select"
            ? {
                val: {
                  type: Ji.select,
                  value: r,
                  options: o$(O.val),
                  location: B,
                },
                err: null,
              }
            : {
                val: {
                  type: Ji.plural,
                  value: r,
                  options: o$(O.val),
                  offset: R,
                  pluralType: a === "plural" ? "cardinal" : "ordinal",
                  location: B,
                },
                err: null,
              };
        }
        default:
          return this.error(kr.INVALID_ARGUMENT_TYPE, Or(o, l));
      }
    }),
    (e.prototype.tryParseArgumentClose = function (t) {
      return this.isEOF() || this.char() !== 125
        ? this.error(
            kr.EXPECT_ARGUMENT_CLOSING_BRACE,
            Or(t, this.clonePosition())
          )
        : (this.bump(), { val: !0, err: null });
    }),
    (e.prototype.parseSimpleArgStyleIfPossible = function () {
      for (var t = 0, n = this.clonePosition(); !this.isEOF(); ) {
        var r = this.char();
        switch (r) {
          case 39: {
            this.bump();
            var i = this.clonePosition();
            if (!this.bumpUntil("'"))
              return this.error(
                kr.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE,
                Or(i, this.clonePosition())
              );
            this.bump();
            break;
          }
          case 123: {
            (t += 1), this.bump();
            break;
          }
          case 125: {
            if (t > 0) t -= 1;
            else
              return {
                val: this.message.slice(n.offset, this.offset()),
                err: null,
              };
            break;
          }
          default:
            this.bump();
            break;
        }
      }
      return { val: this.message.slice(n.offset, this.offset()), err: null };
    }),
    (e.prototype.parseNumberSkeletonFromString = function (t, n) {
      var r = [];
      try {
        r = CSe(t);
      } catch {
        return this.error(kr.INVALID_NUMBER_SKELETON, n);
      }
      return {
        val: {
          type: Ly.number,
          tokens: r,
          location: n,
          parsedOptions: this.shouldParseSkeletons ? ISe(r) : {},
        },
        err: null,
      };
    }),
    (e.prototype.tryParsePluralOrSelectOptions = function (t, n, r, i) {
      for (
        var s, o = !1, a = [], l = new Set(), c = i.value, u = i.location;
        ;

      ) {
        if (c.length === 0) {
          var d = this.clonePosition();
          if (n !== "select" && this.bumpIf("=")) {
            var f = this.tryParseDecimalInteger(
              kr.EXPECT_PLURAL_ARGUMENT_SELECTOR,
              kr.INVALID_PLURAL_ARGUMENT_SELECTOR
            );
            if (f.err) return f;
            (u = Or(d, this.clonePosition())),
              (c = this.message.slice(d.offset, this.offset()));
          } else break;
        }
        if (l.has(c))
          return this.error(
            n === "select"
              ? kr.DUPLICATE_SELECT_ARGUMENT_SELECTOR
              : kr.DUPLICATE_PLURAL_ARGUMENT_SELECTOR,
            u
          );
        c === "other" && (o = !0), this.bumpSpace();
        var h = this.clonePosition();
        if (!this.bumpIf("{"))
          return this.error(
            n === "select"
              ? kr.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT
              : kr.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT,
            Or(this.clonePosition(), this.clonePosition())
          );
        var p = this.parseMessage(t + 1, n, r);
        if (p.err) return p;
        var g = this.tryParseArgumentClose(h);
        if (g.err) return g;
        a.push([c, { value: p.val, location: Or(h, this.clonePosition()) }]),
          l.add(c),
          this.bumpSpace(),
          (s = this.parseIdentifierIfPossible()),
          (c = s.value),
          (u = s.location);
      }
      return a.length === 0
        ? this.error(
            n === "select"
              ? kr.EXPECT_SELECT_ARGUMENT_SELECTOR
              : kr.EXPECT_PLURAL_ARGUMENT_SELECTOR,
            Or(this.clonePosition(), this.clonePosition())
          )
        : this.requiresOtherClause && !o
        ? this.error(
            kr.MISSING_OTHER_CLAUSE,
            Or(this.clonePosition(), this.clonePosition())
          )
        : { val: a, err: null };
    }),
    (e.prototype.tryParseDecimalInteger = function (t, n) {
      var r = 1,
        i = this.clonePosition();
      this.bumpIf("+") || (this.bumpIf("-") && (r = -1));
      for (var s = !1, o = 0; !this.isEOF(); ) {
        var a = this.char();
        if (a >= 48 && a <= 57) (s = !0), (o = o * 10 + (a - 48)), this.bump();
        else break;
      }
      var l = Or(i, this.clonePosition());
      return s
        ? ((o *= r), zSe(o) ? { val: o, err: null } : this.error(n, l))
        : this.error(t, l);
    }),
    (e.prototype.offset = function () {
      return this.position.offset;
    }),
    (e.prototype.isEOF = function () {
      return this.offset() === this.message.length;
    }),
    (e.prototype.clonePosition = function () {
      return {
        offset: this.position.offset,
        line: this.position.line,
        column: this.position.column,
      };
    }),
    (e.prototype.char = function () {
      var t = this.position.offset;
      if (t >= this.message.length) throw Error("out of bound");
      var n = yJ(this.message, t);
      if (n === void 0)
        throw Error(
          "Offset ".concat(t, " is at invalid UTF-16 code unit boundary")
        );
      return n;
    }),
    (e.prototype.error = function (t, n) {
      return {
        val: null,
        err: { kind: t, message: this.message, location: n },
      };
    }),
    (e.prototype.bump = function () {
      if (!this.isEOF()) {
        var t = this.char();
        t === 10
          ? ((this.position.line += 1),
            (this.position.column = 1),
            (this.position.offset += 1))
          : ((this.position.column += 1),
            (this.position.offset += t < 65536 ? 1 : 2));
      }
    }),
    (e.prototype.bumpIf = function (t) {
      if (s$(this.message, t, this.offset())) {
        for (var n = 0; n < t.length; n++) this.bump();
        return !0;
      }
      return !1;
    }),
    (e.prototype.bumpUntil = function (t) {
      var n = this.offset(),
        r = this.message.indexOf(t, n);
      return r >= 0
        ? (this.bumpTo(r), !0)
        : (this.bumpTo(this.message.length), !1);
    }),
    (e.prototype.bumpTo = function (t) {
      if (this.offset() > t)
        throw Error(
          "targetOffset "
            .concat(t, " must be greater than or equal to the current offset ")
            .concat(this.offset())
        );
      for (t = Math.min(t, this.message.length); ; ) {
        var n = this.offset();
        if (n === t) break;
        if (n > t)
          throw Error(
            "targetOffset ".concat(
              t,
              " is at invalid UTF-16 code unit boundary"
            )
          );
        if ((this.bump(), this.isEOF())) break;
      }
    }),
    (e.prototype.bumpSpace = function () {
      for (; !this.isEOF() && wJ(this.char()); ) this.bump();
    }),
    (e.prototype.peek = function () {
      if (this.isEOF()) return null;
      var t = this.char(),
        n = this.offset(),
        r = this.message.charCodeAt(n + (t >= 65536 ? 2 : 1));
      return r ?? null;
    }),
    e
  );
})();
function qT(e) {
  return (e >= 97 && e <= 122) || (e >= 65 && e <= 90);
}
function qSe(e) {
  return qT(e) || e === 47;
}
function KSe(e) {
  return (
    e === 45 ||
    e === 46 ||
    (e >= 48 && e <= 57) ||
    e === 95 ||
    (e >= 97 && e <= 122) ||
    (e >= 65 && e <= 90) ||
    e == 183 ||
    (e >= 192 && e <= 214) ||
    (e >= 216 && e <= 246) ||
    (e >= 248 && e <= 893) ||
    (e >= 895 && e <= 8191) ||
    (e >= 8204 && e <= 8205) ||
    (e >= 8255 && e <= 8256) ||
    (e >= 8304 && e <= 8591) ||
    (e >= 11264 && e <= 12271) ||
    (e >= 12289 && e <= 55295) ||
    (e >= 63744 && e <= 64975) ||
    (e >= 65008 && e <= 65533) ||
    (e >= 65536 && e <= 983039)
  );
}
function wJ(e) {
  return (
    (e >= 9 && e <= 13) ||
    e === 32 ||
    e === 133 ||
    (e >= 8206 && e <= 8207) ||
    e === 8232 ||
    e === 8233
  );
}
function YSe(e) {
  return (
    (e >= 33 && e <= 35) ||
    e === 36 ||
    (e >= 37 && e <= 39) ||
    e === 40 ||
    e === 41 ||
    e === 42 ||
    e === 43 ||
    e === 44 ||
    e === 45 ||
    (e >= 46 && e <= 47) ||
    (e >= 58 && e <= 59) ||
    (e >= 60 && e <= 62) ||
    (e >= 63 && e <= 64) ||
    e === 91 ||
    e === 92 ||
    e === 93 ||
    e === 94 ||
    e === 96 ||
    e === 123 ||
    e === 124 ||
    e === 125 ||
    e === 126 ||
    e === 161 ||
    (e >= 162 && e <= 165) ||
    e === 166 ||
    e === 167 ||
    e === 169 ||
    e === 171 ||
    e === 172 ||
    e === 174 ||
    e === 176 ||
    e === 177 ||
    e === 182 ||
    e === 187 ||
    e === 191 ||
    e === 215 ||
    e === 247 ||
    (e >= 8208 && e <= 8213) ||
    (e >= 8214 && e <= 8215) ||
    e === 8216 ||
    e === 8217 ||
    e === 8218 ||
    (e >= 8219 && e <= 8220) ||
    e === 8221 ||
    e === 8222 ||
    e === 8223 ||
    (e >= 8224 && e <= 8231) ||
    (e >= 8240 && e <= 8248) ||
    e === 8249 ||
    e === 8250 ||
    (e >= 8251 && e <= 8254) ||
    (e >= 8257 && e <= 8259) ||
    e === 8260 ||
    e === 8261 ||
    e === 8262 ||
    (e >= 8263 && e <= 8273) ||
    e === 8274 ||
    e === 8275 ||
    (e >= 8277 && e <= 8286) ||
    (e >= 8592 && e <= 8596) ||
    (e >= 8597 && e <= 8601) ||
    (e >= 8602 && e <= 8603) ||
    (e >= 8604 && e <= 8607) ||
    e === 8608 ||
    (e >= 8609 && e <= 8610) ||
    e === 8611 ||
    (e >= 8612 && e <= 8613) ||
    e === 8614 ||
    (e >= 8615 && e <= 8621) ||
    e === 8622 ||
    (e >= 8623 && e <= 8653) ||
    (e >= 8654 && e <= 8655) ||
    (e >= 8656 && e <= 8657) ||
    e === 8658 ||
    e === 8659 ||
    e === 8660 ||
    (e >= 8661 && e <= 8691) ||
    (e >= 8692 && e <= 8959) ||
    (e >= 8960 && e <= 8967) ||
    e === 8968 ||
    e === 8969 ||
    e === 8970 ||
    e === 8971 ||
    (e >= 8972 && e <= 8991) ||
    (e >= 8992 && e <= 8993) ||
    (e >= 8994 && e <= 9e3) ||
    e === 9001 ||
    e === 9002 ||
    (e >= 9003 && e <= 9083) ||
    e === 9084 ||
    (e >= 9085 && e <= 9114) ||
    (e >= 9115 && e <= 9139) ||
    (e >= 9140 && e <= 9179) ||
    (e >= 9180 && e <= 9185) ||
    (e >= 9186 && e <= 9254) ||
    (e >= 9255 && e <= 9279) ||
    (e >= 9280 && e <= 9290) ||
    (e >= 9291 && e <= 9311) ||
    (e >= 9472 && e <= 9654) ||
    e === 9655 ||
    (e >= 9656 && e <= 9664) ||
    e === 9665 ||
    (e >= 9666 && e <= 9719) ||
    (e >= 9720 && e <= 9727) ||
    (e >= 9728 && e <= 9838) ||
    e === 9839 ||
    (e >= 9840 && e <= 10087) ||
    e === 10088 ||
    e === 10089 ||
    e === 10090 ||
    e === 10091 ||
    e === 10092 ||
    e === 10093 ||
    e === 10094 ||
    e === 10095 ||
    e === 10096 ||
    e === 10097 ||
    e === 10098 ||
    e === 10099 ||
    e === 10100 ||
    e === 10101 ||
    (e >= 10132 && e <= 10175) ||
    (e >= 10176 && e <= 10180) ||
    e === 10181 ||
    e === 10182 ||
    (e >= 10183 && e <= 10213) ||
    e === 10214 ||
    e === 10215 ||
    e === 10216 ||
    e === 10217 ||
    e === 10218 ||
    e === 10219 ||
    e === 10220 ||
    e === 10221 ||
    e === 10222 ||
    e === 10223 ||
    (e >= 10224 && e <= 10239) ||
    (e >= 10240 && e <= 10495) ||
    (e >= 10496 && e <= 10626) ||
    e === 10627 ||
    e === 10628 ||
    e === 10629 ||
    e === 10630 ||
    e === 10631 ||
    e === 10632 ||
    e === 10633 ||
    e === 10634 ||
    e === 10635 ||
    e === 10636 ||
    e === 10637 ||
    e === 10638 ||
    e === 10639 ||
    e === 10640 ||
    e === 10641 ||
    e === 10642 ||
    e === 10643 ||
    e === 10644 ||
    e === 10645 ||
    e === 10646 ||
    e === 10647 ||
    e === 10648 ||
    (e >= 10649 && e <= 10711) ||
    e === 10712 ||
    e === 10713 ||
    e === 10714 ||
    e === 10715 ||
    (e >= 10716 && e <= 10747) ||
    e === 10748 ||
    e === 10749 ||
    (e >= 10750 && e <= 11007) ||
    (e >= 11008 && e <= 11055) ||
    (e >= 11056 && e <= 11076) ||
    (e >= 11077 && e <= 11078) ||
    (e >= 11079 && e <= 11084) ||
    (e >= 11085 && e <= 11123) ||
    (e >= 11124 && e <= 11125) ||
    (e >= 11126 && e <= 11157) ||
    e === 11158 ||
    (e >= 11159 && e <= 11263) ||
    (e >= 11776 && e <= 11777) ||
    e === 11778 ||
    e === 11779 ||
    e === 11780 ||
    e === 11781 ||
    (e >= 11782 && e <= 11784) ||
    e === 11785 ||
    e === 11786 ||
    e === 11787 ||
    e === 11788 ||
    e === 11789 ||
    (e >= 11790 && e <= 11798) ||
    e === 11799 ||
    (e >= 11800 && e <= 11801) ||
    e === 11802 ||
    e === 11803 ||
    e === 11804 ||
    e === 11805 ||
    (e >= 11806 && e <= 11807) ||
    e === 11808 ||
    e === 11809 ||
    e === 11810 ||
    e === 11811 ||
    e === 11812 ||
    e === 11813 ||
    e === 11814 ||
    e === 11815 ||
    e === 11816 ||
    e === 11817 ||
    (e >= 11818 && e <= 11822) ||
    e === 11823 ||
    (e >= 11824 && e <= 11833) ||
    (e >= 11834 && e <= 11835) ||
    (e >= 11836 && e <= 11839) ||
    e === 11840 ||
    e === 11841 ||
    e === 11842 ||
    (e >= 11843 && e <= 11855) ||
    (e >= 11856 && e <= 11857) ||
    e === 11858 ||
    (e >= 11859 && e <= 11903) ||
    (e >= 12289 && e <= 12291) ||
    e === 12296 ||
    e === 12297 ||
    e === 12298 ||
    e === 12299 ||
    e === 12300 ||
    e === 12301 ||
    e === 12302 ||
    e === 12303 ||
    e === 12304 ||
    e === 12305 ||
    (e >= 12306 && e <= 12307) ||
    e === 12308 ||
    e === 12309 ||
    e === 12310 ||
    e === 12311 ||
    e === 12312 ||
    e === 12313 ||
    e === 12314 ||
    e === 12315 ||
    e === 12316 ||
    e === 12317 ||
    (e >= 12318 && e <= 12319) ||
    e === 12320 ||
    e === 12336 ||
    e === 64830 ||
    e === 64831 ||
    (e >= 65093 && e <= 65094)
  );
}
function KT(e) {
  e.forEach(function (t) {
    if ((delete t.location, cJ(t) || uJ(t)))
      for (var n in t.options)
        delete t.options[n].location, KT(t.options[n].value);
    else
      (oJ(t) && fJ(t.style)) || ((aJ(t) || lJ(t)) && WT(t.style))
        ? delete t.style.location
        : dJ(t) && KT(t.children);
  });
}
function ZSe(e, t) {
  t === void 0 && (t = {}),
    (t = ti({ shouldParseSkeletons: !0, requiresOtherClause: !0 }, t));
  var n = new GSe(e, t).parse();
  if (n.err) {
    var r = SyntaxError(kr[n.err.kind]);
    throw (
      ((r.location = n.err.location), (r.originalMessage = n.err.message), r)
    );
  }
  return (t != null && t.captureLocation) || KT(n.val), n.val;
}
function wC(e, t) {
  var n = t && t.cache ? t.cache : n8e,
    r = t && t.serializer ? t.serializer : t8e,
    i = t && t.strategy ? t.strategy : XSe;
  return i(e, { cache: n, serializer: r });
}
function QSe(e) {
  return e == null || typeof e == "number" || typeof e == "boolean";
}
function bJ(e, t, n, r) {
  var i = QSe(r) ? r : n(r),
    s = t.get(i);
  return typeof s > "u" && ((s = e.call(this, r)), t.set(i, s)), s;
}
function xJ(e, t, n) {
  var r = Array.prototype.slice.call(arguments, 3),
    i = n(r),
    s = t.get(i);
  return typeof s > "u" && ((s = e.apply(this, r)), t.set(i, s)), s;
}
function iO(e, t, n, r, i) {
  return n.bind(t, e, r, i);
}
function XSe(e, t) {
  var n = e.length === 1 ? bJ : xJ;
  return iO(e, this, n, t.cache.create(), t.serializer);
}
function JSe(e, t) {
  return iO(e, this, xJ, t.cache.create(), t.serializer);
}
function e8e(e, t) {
  return iO(e, this, bJ, t.cache.create(), t.serializer);
}
var t8e = function () {
  return JSON.stringify(arguments);
};
function sO() {
  this.cache = Object.create(null);
}
sO.prototype.get = function (e) {
  return this.cache[e];
};
sO.prototype.set = function (e, t) {
  this.cache[e] = t;
};
var n8e = {
    create: function () {
      return new sO();
    },
  },
  bC = { variadic: JSe, monadic: e8e },
  jy;
(function (e) {
  (e.MISSING_VALUE = "MISSING_VALUE"),
    (e.INVALID_VALUE = "INVALID_VALUE"),
    (e.MISSING_INTL_API = "MISSING_INTL_API");
})(jy || (jy = {}));
var R8 = (function (e) {
    Ou(t, e);
    function t(n, r, i) {
      var s = e.call(this, n) || this;
      return (s.code = r), (s.originalMessage = i), s;
    }
    return (
      (t.prototype.toString = function () {
        return "[formatjs Error: ".concat(this.code, "] ").concat(this.message);
      }),
      t
    );
  })(Error),
  l$ = (function (e) {
    Ou(t, e);
    function t(n, r, i, s) {
      return (
        e.call(
          this,
          'Invalid values for "'
            .concat(n, '": "')
            .concat(r, '". Options are "')
            .concat(Object.keys(i).join('", "'), '"'),
          jy.INVALID_VALUE,
          s
        ) || this
      );
    }
    return t;
  })(R8),
  r8e = (function (e) {
    Ou(t, e);
    function t(n, r, i) {
      return (
        e.call(
          this,
          'Value for "'.concat(n, '" must be of type ').concat(r),
          jy.INVALID_VALUE,
          i
        ) || this
      );
    }
    return t;
  })(R8),
  i8e = (function (e) {
    Ou(t, e);
    function t(n, r) {
      return (
        e.call(
          this,
          'The intl string context variable "'
            .concat(n, '" was not provided to the string "')
            .concat(r, '"'),
          jy.MISSING_VALUE,
          r
        ) || this
      );
    }
    return t;
  })(R8),
  wa;
(function (e) {
  (e[(e.literal = 0)] = "literal"), (e[(e.object = 1)] = "object");
})(wa || (wa = {}));
function s8e(e) {
  return e.length < 2
    ? e
    : e.reduce(function (t, n) {
        var r = t[t.length - 1];
        return (
          !r || r.type !== wa.literal || n.type !== wa.literal
            ? t.push(n)
            : (r.value += n.value),
          t
        );
      }, []);
}
function o8e(e) {
  return typeof e == "function";
}
function B4(e, t, n, r, i, s, o) {
  if (e.length === 1 && t$(e[0]))
    return [{ type: wa.literal, value: e[0].value }];
  for (var a = [], l = 0, c = e; l < c.length; l++) {
    var u = c[l];
    if (t$(u)) {
      a.push({ type: wa.literal, value: u.value });
      continue;
    }
    if (_Se(u)) {
      typeof s == "number" &&
        a.push({ type: wa.literal, value: n.getNumberFormat(t).format(s) });
      continue;
    }
    var d = u.value;
    if (!(i && d in i)) throw new i8e(d, o);
    var f = i[d];
    if (xSe(u)) {
      (!f || typeof f == "string" || typeof f == "number") &&
        (f = typeof f == "string" || typeof f == "number" ? String(f) : ""),
        a.push({
          type: typeof f == "string" ? wa.literal : wa.object,
          value: f,
        });
      continue;
    }
    if (aJ(u)) {
      var h =
        typeof u.style == "string"
          ? r.date[u.style]
          : WT(u.style)
          ? u.style.parsedOptions
          : void 0;
      a.push({ type: wa.literal, value: n.getDateTimeFormat(t, h).format(f) });
      continue;
    }
    if (lJ(u)) {
      var h =
        typeof u.style == "string"
          ? r.time[u.style]
          : WT(u.style)
          ? u.style.parsedOptions
          : r.time.medium;
      a.push({ type: wa.literal, value: n.getDateTimeFormat(t, h).format(f) });
      continue;
    }
    if (oJ(u)) {
      var h =
        typeof u.style == "string"
          ? r.number[u.style]
          : fJ(u.style)
          ? u.style.parsedOptions
          : void 0;
      h && h.scale && (f = f * (h.scale || 1)),
        a.push({ type: wa.literal, value: n.getNumberFormat(t, h).format(f) });
      continue;
    }
    if (dJ(u)) {
      var p = u.children,
        g = u.value,
        b = i[g];
      if (!o8e(b)) throw new r8e(g, "function", o);
      var v = B4(p, t, n, r, i, s),
        w = b(
          v.map(function (R) {
            return R.value;
          })
        );
      Array.isArray(w) || (w = [w]),
        a.push.apply(
          a,
          w.map(function (R) {
            return {
              type: typeof R == "string" ? wa.literal : wa.object,
              value: R,
            };
          })
        );
    }
    if (cJ(u)) {
      var x = u.options[f] || u.options.other;
      if (!x) throw new l$(u.value, f, Object.keys(u.options), o);
      a.push.apply(a, B4(x.value, t, n, r, i));
      continue;
    }
    if (uJ(u)) {
      var x = u.options["=".concat(f)];
      if (!x) {
        if (!Intl.PluralRules)
          throw new R8(
            `Intl.PluralRules is not available in this environment.
Try polyfilling it using "@formatjs/intl-pluralrules"
`,
            jy.MISSING_INTL_API,
            o
          );
        var S = n
          .getPluralRules(t, { type: u.pluralType })
          .select(f - (u.offset || 0));
        x = u.options[S] || u.options.other;
      }
      if (!x) throw new l$(u.value, f, Object.keys(u.options), o);
      a.push.apply(a, B4(x.value, t, n, r, i, f - (u.offset || 0)));
      continue;
    }
  }
  return s8e(a);
}
function a8e(e, t) {
  return t
    ? ti(
        ti(ti({}, e || {}), t || {}),
        Object.keys(e).reduce(function (n, r) {
          return (n[r] = ti(ti({}, e[r]), t[r] || {})), n;
        }, {})
      )
    : e;
}
function l8e(e, t) {
  return t
    ? Object.keys(e).reduce(function (n, r) {
        return (n[r] = a8e(e[r], t[r])), n;
      }, ti({}, e))
    : e;
}
function xC(e) {
  return {
    create: function () {
      return {
        get: function (t) {
          return e[t];
        },
        set: function (t, n) {
          e[t] = n;
        },
      };
    },
  };
}
function c8e(e) {
  return (
    e === void 0 && (e = { number: {}, dateTime: {}, pluralRules: {} }),
    {
      getNumberFormat: wC(
        function () {
          for (var t, n = [], r = 0; r < arguments.length; r++)
            n[r] = arguments[r];
          return new ((t = Intl.NumberFormat).bind.apply(
            t,
            wd([void 0], n, !1)
          ))();
        },
        { cache: xC(e.number), strategy: bC.variadic }
      ),
      getDateTimeFormat: wC(
        function () {
          for (var t, n = [], r = 0; r < arguments.length; r++)
            n[r] = arguments[r];
          return new ((t = Intl.DateTimeFormat).bind.apply(
            t,
            wd([void 0], n, !1)
          ))();
        },
        { cache: xC(e.dateTime), strategy: bC.variadic }
      ),
      getPluralRules: wC(
        function () {
          for (var t, n = [], r = 0; r < arguments.length; r++)
            n[r] = arguments[r];
          return new ((t = Intl.PluralRules).bind.apply(
            t,
            wd([void 0], n, !1)
          ))();
        },
        { cache: xC(e.pluralRules), strategy: bC.variadic }
      ),
    }
  );
}
var _J = (function () {
  function e(t, n, r, i) {
    var s = this;
    if (
      (n === void 0 && (n = e.defaultLocale),
      (this.formatterCache = { number: {}, dateTime: {}, pluralRules: {} }),
      (this.format = function (o) {
        var a = s.formatToParts(o);
        if (a.length === 1) return a[0].value;
        var l = a.reduce(function (c, u) {
          return (
            !c.length ||
            u.type !== wa.literal ||
            typeof c[c.length - 1] != "string"
              ? c.push(u.value)
              : (c[c.length - 1] += u.value),
            c
          );
        }, []);
        return l.length <= 1 ? l[0] || "" : l;
      }),
      (this.formatToParts = function (o) {
        return B4(
          s.ast,
          s.locales,
          s.formatters,
          s.formats,
          o,
          void 0,
          s.message
        );
      }),
      (this.resolvedOptions = function () {
        return { locale: s.resolvedLocale.toString() };
      }),
      (this.getAst = function () {
        return s.ast;
      }),
      (this.locales = n),
      (this.resolvedLocale = e.resolveLocale(n)),
      typeof t == "string")
    ) {
      if (((this.message = t), !e.__parse))
        throw new TypeError(
          "IntlMessageFormat.__parse must be set to process `message` of type `string`"
        );
      this.ast = e.__parse(t, {
        ignoreTag: i == null ? void 0 : i.ignoreTag,
        locale: this.resolvedLocale,
      });
    } else this.ast = t;
    if (!Array.isArray(this.ast))
      throw new TypeError("A message must be provided as a String or AST.");
    (this.formats = l8e(e.formats, r)),
      (this.formatters = (i && i.formatters) || c8e(this.formatterCache));
  }
  return (
    Object.defineProperty(e, "defaultLocale", {
      get: function () {
        return (
          e.memoizedDefaultLocale ||
            (e.memoizedDefaultLocale =
              new Intl.NumberFormat().resolvedOptions().locale),
          e.memoizedDefaultLocale
        );
      },
      enumerable: !1,
      configurable: !0,
    }),
    (e.memoizedDefaultLocale = null),
    (e.resolveLocale = function (t) {
      var n = Intl.NumberFormat.supportedLocalesOf(t);
      return n.length > 0
        ? new Intl.Locale(n[0])
        : new Intl.Locale(typeof t == "string" ? t : t[0]);
    }),
    (e.__parse = ZSe),
    (e.formats = {
      number: {
        integer: { maximumFractionDigits: 0 },
        currency: { style: "currency" },
        percent: { style: "percent" },
      },
      date: {
        short: { month: "numeric", day: "numeric", year: "2-digit" },
        medium: { month: "short", day: "numeric", year: "numeric" },
        long: { month: "long", day: "numeric", year: "numeric" },
        full: {
          weekday: "long",
          month: "long",
          day: "numeric",
          year: "numeric",
        },
      },
      time: {
        short: { hour: "numeric", minute: "numeric" },
        medium: { hour: "numeric", minute: "numeric", second: "numeric" },
        long: {
          hour: "numeric",
          minute: "numeric",
          second: "numeric",
          timeZoneName: "short",
        },
        full: {
          hour: "numeric",
          minute: "numeric",
          second: "numeric",
          timeZoneName: "short",
        },
      },
    }),
    e
  );
})();
function u8e(e, t) {
  if (t == null) return;
  if (t in e) return e[t];
  const n = t.split(".");
  let r = e;
  for (let i = 0; i < n.length; i++)
    if (typeof r == "object") {
      if (i > 0) {
        const s = n.slice(i, n.length).join(".");
        if (s in r) {
          r = r[s];
          break;
        }
      }
      r = r[n[i]];
    } else r = void 0;
  return r;
}
const Ep = {},
  d8e = (e, t, n) =>
    n && (t in Ep || (Ep[t] = {}), e in Ep[t] || (Ep[t][e] = n), n),
  SJ = (e, t) => {
    if (t == null) return;
    if (t in Ep && e in Ep[t]) return Ep[t][e];
    const n = Fx(t);
    for (let r = 0; r < n.length; r++) {
      const i = n[r],
        s = h8e(i, e);
      if (s) return d8e(e, t, s);
    }
  };
let oO;
const Bx = N8({});
function f8e(e) {
  return oO[e] || null;
}
function EJ(e) {
  return e in oO;
}
function h8e(e, t) {
  if (!EJ(e)) return null;
  const n = f8e(e);
  return u8e(n, t);
}
function p8e(e) {
  if (e == null) return;
  const t = Fx(e);
  for (let n = 0; n < t.length; n++) {
    const r = t[n];
    if (EJ(r)) return r;
  }
}
function F4(e, ...t) {
  delete Ep[e], Bx.update((n) => ((n[e] = bSe.all([n[e] || {}, ...t])), n));
}
yv([Bx], ([e]) => Object.keys(e));
Bx.subscribe((e) => (oO = e));
const U4 = {};
function m8e(e, t) {
  U4[e].delete(t), U4[e].size === 0 && delete U4[e];
}
function AJ(e) {
  return U4[e];
}
function g8e(e) {
  return Fx(e)
    .map((t) => {
      const n = AJ(t);
      return [t, n ? [...n] : []];
    })
    .filter(([, t]) => t.length > 0);
}
function x5(e) {
  return e == null
    ? !1
    : Fx(e).some((t) => {
        var n;
        return (n = AJ(t)) == null ? void 0 : n.size;
      });
}
function y8e(e, t) {
  return Promise.all(
    t.map((r) => (m8e(e, r), r().then((i) => i.default || i)))
  ).then((r) => F4(e, ...r));
}
const E2 = {};
function CJ(e) {
  if (!x5(e)) return e in E2 ? E2[e] : Promise.resolve();
  const t = g8e(e);
  return (
    (E2[e] = Promise.all(t.map(([n, r]) => y8e(n, r))).then(() => {
      if (x5(e)) return CJ(e);
      delete E2[e];
    })),
    E2[e]
  );
}
var c$ = Object.getOwnPropertySymbols,
  v8e = Object.prototype.hasOwnProperty,
  w8e = Object.prototype.propertyIsEnumerable,
  b8e = (e, t) => {
    var n = {};
    for (var r in e) v8e.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
    if (e != null && c$)
      for (var r of c$(e)) t.indexOf(r) < 0 && w8e.call(e, r) && (n[r] = e[r]);
    return n;
  };
const x8e = {
  number: {
    scientific: { notation: "scientific" },
    engineering: { notation: "engineering" },
    compactLong: { notation: "compact", compactDisplay: "long" },
    compactShort: { notation: "compact", compactDisplay: "short" },
  },
  date: {
    short: { month: "numeric", day: "numeric", year: "2-digit" },
    medium: { month: "short", day: "numeric", year: "numeric" },
    long: { month: "long", day: "numeric", year: "numeric" },
    full: { weekday: "long", month: "long", day: "numeric", year: "numeric" },
  },
  time: {
    short: { hour: "numeric", minute: "numeric" },
    medium: { hour: "numeric", minute: "numeric", second: "numeric" },
    long: {
      hour: "numeric",
      minute: "numeric",
      second: "numeric",
      timeZoneName: "short",
    },
    full: {
      hour: "numeric",
      minute: "numeric",
      second: "numeric",
      timeZoneName: "short",
    },
  },
};
function _8e({ locale: e, id: t }) {
  console.warn(
    `[svelte-i18n] The message "${t}" was not found in "${Fx(e).join(
      '", "'
    )}".${
      x5(h0())
        ? `

Note: there are at least one loader still registered to this locale that wasn't executed.`
        : ""
    }`
  );
}
const S8e = {
    fallbackLocale: null,
    loadingDelay: 200,
    formats: x8e,
    warnOnMissingMessages: !0,
    handleMissingMessage: void 0,
    ignoreTag: !0,
  },
  Z2 = S8e;
function Dy() {
  return Z2;
}
function E8e(e) {
  const t = e,
    { formats: n } = t,
    r = b8e(t, ["formats"]);
  let i = e.fallbackLocale;
  if (e.initialLocale)
    try {
      _J.resolveLocale(e.initialLocale) && (i = e.initialLocale);
    } catch {
      console.warn(
        `[svelte-i18n] The initial locale "${e.initialLocale}" is not a valid locale.`
      );
    }
  return (
    r.warnOnMissingMessages &&
      (delete r.warnOnMissingMessages,
      r.handleMissingMessage == null
        ? (r.handleMissingMessage = _8e)
        : console.warn(
            '[svelte-i18n] The "warnOnMissingMessages" option is deprecated. Please use the "handleMissingMessage" option instead.'
          )),
    Object.assign(Z2, r, { initialLocale: i }),
    n &&
      ("number" in n && Object.assign(Z2.formats.number, n.number),
      "date" in n && Object.assign(Z2.formats.date, n.date),
      "time" in n && Object.assign(Z2.formats.time, n.time)),
    w1.set(i)
  );
}
const _C = N8(!1);
var A8e = Object.defineProperty,
  C8e = Object.defineProperties,
  k8e = Object.getOwnPropertyDescriptors,
  u$ = Object.getOwnPropertySymbols,
  T8e = Object.prototype.hasOwnProperty,
  M8e = Object.prototype.propertyIsEnumerable,
  d$ = (e, t, n) =>
    t in e
      ? A8e(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (e[t] = n),
  I8e = (e, t) => {
    for (var n in t || (t = {})) T8e.call(t, n) && d$(e, n, t[n]);
    if (u$) for (var n of u$(t)) M8e.call(t, n) && d$(e, n, t[n]);
    return e;
  },
  N8e = (e, t) => C8e(e, k8e(t));
let YT;
const _5 = N8(null);
function f$(e) {
  return e
    .split("-")
    .map((t, n, r) => r.slice(0, n + 1).join("-"))
    .reverse();
}
function Fx(e, t = Dy().fallbackLocale) {
  const n = f$(e);
  return t ? [...new Set([...n, ...f$(t)])] : n;
}
function h0() {
  return YT ?? void 0;
}
_5.subscribe((e) => {
  (YT = e ?? void 0),
    typeof window < "u" &&
      e != null &&
      document.documentElement.setAttribute("lang", e);
});
const R8e = (e) => {
    if (e && p8e(e) && x5(e)) {
      const { loadingDelay: t } = Dy();
      let n;
      return (
        typeof window < "u" && h0() != null && t
          ? (n = window.setTimeout(() => _C.set(!0), t))
          : _C.set(!0),
        CJ(e)
          .then(() => {
            _5.set(e);
          })
          .finally(() => {
            clearTimeout(n), _C.set(!1);
          })
      );
    }
    return _5.set(e);
  },
  w1 = N8e(I8e({}, _5), { set: R8e }),
  O8e = () =>
    typeof window > "u"
      ? null
      : window.navigator.language || window.navigator.languages[0],
  O8 = (e) => {
    const t = Object.create(null);
    return (r) => {
      const i = JSON.stringify(r);
      return i in t ? t[i] : (t[i] = e(r));
    };
  };
var P8e = Object.defineProperty,
  S5 = Object.getOwnPropertySymbols,
  kJ = Object.prototype.hasOwnProperty,
  TJ = Object.prototype.propertyIsEnumerable,
  h$ = (e, t, n) =>
    t in e
      ? P8e(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (e[t] = n),
  aO = (e, t) => {
    for (var n in t || (t = {})) kJ.call(t, n) && h$(e, n, t[n]);
    if (S5) for (var n of S5(t)) TJ.call(t, n) && h$(e, n, t[n]);
    return e;
  },
  vv = (e, t) => {
    var n = {};
    for (var r in e) kJ.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
    if (e != null && S5)
      for (var r of S5(e)) t.indexOf(r) < 0 && TJ.call(e, r) && (n[r] = e[r]);
    return n;
  };
const wb = (e, t) => {
    const { formats: n } = Dy();
    if (e in n && t in n[e]) return n[e][t];
    throw new Error(`[svelte-i18n] Unknown "${t}" ${e} format.`);
  },
  L8e = O8((e) => {
    var t = e,
      { locale: n, format: r } = t,
      i = vv(t, ["locale", "format"]);
    if (n == null)
      throw new Error('[svelte-i18n] A "locale" must be set to format numbers');
    return r && (i = wb("number", r)), new Intl.NumberFormat(n, i);
  }),
  j8e = O8((e) => {
    var t = e,
      { locale: n, format: r } = t,
      i = vv(t, ["locale", "format"]);
    if (n == null)
      throw new Error('[svelte-i18n] A "locale" must be set to format dates');
    return (
      r
        ? (i = wb("date", r))
        : Object.keys(i).length === 0 && (i = wb("date", "short")),
      new Intl.DateTimeFormat(n, i)
    );
  }),
  D8e = O8((e) => {
    var t = e,
      { locale: n, format: r } = t,
      i = vv(t, ["locale", "format"]);
    if (n == null)
      throw new Error(
        '[svelte-i18n] A "locale" must be set to format time values'
      );
    return (
      r
        ? (i = wb("time", r))
        : Object.keys(i).length === 0 && (i = wb("time", "short")),
      new Intl.DateTimeFormat(n, i)
    );
  }),
  B8e = (e = {}) => {
    var t = e,
      { locale: n = h0() } = t,
      r = vv(t, ["locale"]);
    return L8e(aO({ locale: n }, r));
  },
  F8e = (e = {}) => {
    var t = e,
      { locale: n = h0() } = t,
      r = vv(t, ["locale"]);
    return j8e(aO({ locale: n }, r));
  },
  U8e = (e = {}) => {
    var t = e,
      { locale: n = h0() } = t,
      r = vv(t, ["locale"]);
    return D8e(aO({ locale: n }, r));
  },
  $8e = O8(
    (e, t = h0()) => new _J(e, t, Dy().formats, { ignoreTag: Dy().ignoreTag })
  ),
  z8e = (e, t = {}) => {
    var n, r, i, s;
    let o = t;
    typeof e == "object" && ((o = e), (e = o.id));
    const { values: a, locale: l = h0(), default: c } = o;
    if (l == null)
      throw new Error(
        "[svelte-i18n] Cannot format a message without first setting the initial locale."
      );
    let u = SJ(e, l);
    if (!u)
      u =
        (s =
          (i =
            (r = (n = Dy()).handleMissingMessage) == null
              ? void 0
              : r.call(n, { locale: l, id: e, defaultValue: c })) != null
            ? i
            : c) != null
          ? s
          : e;
    else if (typeof u != "string")
      return (
        console.warn(
          `[svelte-i18n] Message with id "${e}" must be of type "string", found: "${typeof u}". Gettin its value through the "$format" method is deprecated; use the "json" method instead.`
        ),
        u
      );
    if (!a) return u;
    let d = u;
    try {
      d = $8e(u, l).format(a);
    } catch (f) {
      f instanceof Error &&
        console.warn(
          `[svelte-i18n] Message "${e}" has syntax error:`,
          f.message
        );
    }
    return d;
  },
  W8e = (e, t) => U8e(t).format(e),
  H8e = (e, t) => F8e(t).format(e),
  V8e = (e, t) => B8e(t).format(e),
  G8e = (e, t = h0()) => SJ(e, t),
  _h = yv([w1, Bx], () => z8e);
yv([w1], () => W8e);
yv([w1], () => H8e);
yv([w1], () => V8e);
yv([w1, Bx], () => G8e);
let q8e = (e = 21) =>
  crypto
    .getRandomValues(new Uint8Array(e))
    .reduce(
      (t, n) => (
        (n &= 63),
        n < 36
          ? (t += n.toString(36))
          : n < 62
          ? (t += (n - 26).toString(36).toUpperCase())
          : n > 62
          ? (t += "-")
          : (t += "_"),
        t
      ),
      ""
    );
var MJ = { exports: {} };
(function (e, t) {
  (function (n, r) {
    e.exports = r();
  })(self, () => {
    return (
      (n = {
        7629: (i, s, o) => {
          const a = o(375),
            l = o(8571),
            c = o(9474),
            u = o(1687),
            d = o(8652),
            f = o(8160),
            h = o(3292),
            p = o(6354),
            g = o(8901),
            b = o(9708),
            v = o(6914),
            w = o(2294),
            x = o(6133),
            S = o(1152),
            R = o(8863),
            O = o(2036),
            B = {
              Base: class {
                constructor(C) {
                  (this.type = C),
                    (this.$_root = null),
                    (this._definition = {}),
                    this._reset();
                }
                _reset() {
                  (this._ids = new w.Ids()),
                    (this._preferences = null),
                    (this._refs = new x.Manager()),
                    (this._cache = null),
                    (this._valids = null),
                    (this._invalids = null),
                    (this._flags = {}),
                    (this._rules = []),
                    (this._singleRules = new Map()),
                    (this.$_terms = {}),
                    (this.$_temp = { ruleset: null, whens: {} });
                }
                describe() {
                  return (
                    a(
                      typeof b.describe == "function",
                      "Manifest functionality disabled"
                    ),
                    b.describe(this)
                  );
                }
                allow() {
                  for (
                    var C = arguments.length, I = new Array(C), P = 0;
                    P < C;
                    P++
                  )
                    I[P] = arguments[P];
                  return f.verifyFlat(I, "allow"), this._values(I, "_valids");
                }
                alter(C) {
                  a(
                    C && typeof C == "object" && !Array.isArray(C),
                    "Invalid targets argument"
                  ),
                    a(
                      !this._inRuleset(),
                      "Cannot set alterations inside a ruleset"
                    );
                  const I = this.clone();
                  I.$_terms.alterations = I.$_terms.alterations || [];
                  for (const P in C) {
                    const M = C[P];
                    a(
                      typeof M == "function",
                      "Alteration adjuster for",
                      P,
                      "must be a function"
                    ),
                      I.$_terms.alterations.push({ target: P, adjuster: M });
                  }
                  return (I.$_temp.ruleset = !1), I;
                }
                artifact(C) {
                  return (
                    a(C !== void 0, "Artifact cannot be undefined"),
                    a(!this._cache, "Cannot set an artifact with a rule cache"),
                    this.$_setFlag("artifact", C)
                  );
                }
                cast(C) {
                  return (
                    a(C === !1 || typeof C == "string", "Invalid to value"),
                    a(
                      C === !1 || this._definition.cast[C],
                      "Type",
                      this.type,
                      "does not support casting to",
                      C
                    ),
                    this.$_setFlag("cast", C === !1 ? void 0 : C)
                  );
                }
                default(C, I) {
                  return this._default("default", C, I);
                }
                description(C) {
                  return (
                    a(
                      C && typeof C == "string",
                      "Description must be a non-empty string"
                    ),
                    this.$_setFlag("description", C)
                  );
                }
                empty(C) {
                  const I = this.clone();
                  return (
                    C !== void 0 && (C = I.$_compile(C, { override: !1 })),
                    I.$_setFlag("empty", C, { clone: !1 })
                  );
                }
                error(C) {
                  return (
                    a(C, "Missing error"),
                    a(
                      C instanceof Error || typeof C == "function",
                      "Must provide a valid Error object or a function"
                    ),
                    this.$_setFlag("error", C)
                  );
                }
                example(C) {
                  let I =
                    arguments.length > 1 && arguments[1] !== void 0
                      ? arguments[1]
                      : {};
                  return (
                    a(C !== void 0, "Missing example"),
                    f.assertOptions(I, ["override"]),
                    this._inner("examples", C, {
                      single: !0,
                      override: I.override,
                    })
                  );
                }
                external(C, I) {
                  return (
                    typeof C == "object" &&
                      (a(!I, "Cannot combine options with description"),
                      (I = C.description),
                      (C = C.method)),
                    a(typeof C == "function", "Method must be a function"),
                    a(
                      I === void 0 || (I && typeof I == "string"),
                      "Description must be a non-empty string"
                    ),
                    this._inner(
                      "externals",
                      { method: C, description: I },
                      { single: !0 }
                    )
                  );
                }
                failover(C, I) {
                  return this._default("failover", C, I);
                }
                forbidden() {
                  return this.presence("forbidden");
                }
                id(C) {
                  return C
                    ? (a(typeof C == "string", "id must be a non-empty string"),
                      a(
                        /^[^\.]+$/.test(C),
                        "id cannot contain period character"
                      ),
                      this.$_setFlag("id", C))
                    : this.$_setFlag("id", void 0);
                }
                invalid() {
                  for (
                    var C = arguments.length, I = new Array(C), P = 0;
                    P < C;
                    P++
                  )
                    I[P] = arguments[P];
                  return this._values(I, "_invalids");
                }
                label(C) {
                  return (
                    a(
                      C && typeof C == "string",
                      "Label name must be a non-empty string"
                    ),
                    this.$_setFlag("label", C)
                  );
                }
                meta(C) {
                  return (
                    a(C !== void 0, "Meta cannot be undefined"),
                    this._inner("metas", C, { single: !0 })
                  );
                }
                note() {
                  for (
                    var C = arguments.length, I = new Array(C), P = 0;
                    P < C;
                    P++
                  )
                    I[P] = arguments[P];
                  a(I.length, "Missing notes");
                  for (const M of I)
                    a(
                      M && typeof M == "string",
                      "Notes must be non-empty strings"
                    );
                  return this._inner("notes", I);
                }
                only() {
                  let C =
                    !(arguments.length > 0 && arguments[0] !== void 0) ||
                    arguments[0];
                  return (
                    a(typeof C == "boolean", "Invalid mode:", C),
                    this.$_setFlag("only", C)
                  );
                }
                optional() {
                  return this.presence("optional");
                }
                prefs(C) {
                  a(C, "Missing preferences"),
                    a(C.context === void 0, "Cannot override context"),
                    a(C.externals === void 0, "Cannot override externals"),
                    a(C.warnings === void 0, "Cannot override warnings"),
                    a(C.debug === void 0, "Cannot override debug"),
                    f.checkPreferences(C);
                  const I = this.clone();
                  return (I._preferences = f.preferences(I._preferences, C)), I;
                }
                presence(C) {
                  return (
                    a(
                      ["optional", "required", "forbidden"].includes(C),
                      "Unknown presence mode",
                      C
                    ),
                    this.$_setFlag("presence", C)
                  );
                }
                raw() {
                  let C =
                    !(arguments.length > 0 && arguments[0] !== void 0) ||
                    arguments[0];
                  return this.$_setFlag("result", C ? "raw" : void 0);
                }
                result(C) {
                  return (
                    a(["raw", "strip"].includes(C), "Unknown result mode", C),
                    this.$_setFlag("result", C)
                  );
                }
                required() {
                  return this.presence("required");
                }
                strict(C) {
                  const I = this.clone(),
                    P = C !== void 0 && !C;
                  return (
                    (I._preferences = f.preferences(I._preferences, {
                      convert: P,
                    })),
                    I
                  );
                }
                strip() {
                  let C =
                    !(arguments.length > 0 && arguments[0] !== void 0) ||
                    arguments[0];
                  return this.$_setFlag("result", C ? "strip" : void 0);
                }
                tag() {
                  for (
                    var C = arguments.length, I = new Array(C), P = 0;
                    P < C;
                    P++
                  )
                    I[P] = arguments[P];
                  a(I.length, "Missing tags");
                  for (const M of I)
                    a(
                      M && typeof M == "string",
                      "Tags must be non-empty strings"
                    );
                  return this._inner("tags", I);
                }
                unit(C) {
                  return (
                    a(
                      C && typeof C == "string",
                      "Unit name must be a non-empty string"
                    ),
                    this.$_setFlag("unit", C)
                  );
                }
                valid() {
                  for (
                    var C = arguments.length, I = new Array(C), P = 0;
                    P < C;
                    P++
                  )
                    I[P] = arguments[P];
                  f.verifyFlat(I, "valid");
                  const M = this.allow(...I);
                  return M.$_setFlag("only", !!M._valids, { clone: !1 }), M;
                }
                when(C, I) {
                  const P = this.clone();
                  P.$_terms.whens || (P.$_terms.whens = []);
                  const M = h.when(P, C, I);
                  if (!["any", "link"].includes(P.type)) {
                    const k = M.is ? [M] : M.switch;
                    for (const T of k)
                      a(
                        !T.then ||
                          T.then.type === "any" ||
                          T.then.type === P.type,
                        "Cannot combine",
                        P.type,
                        "with",
                        T.then && T.then.type
                      ),
                        a(
                          !T.otherwise ||
                            T.otherwise.type === "any" ||
                            T.otherwise.type === P.type,
                          "Cannot combine",
                          P.type,
                          "with",
                          T.otherwise && T.otherwise.type
                        );
                  }
                  return P.$_terms.whens.push(M), P.$_mutateRebuild();
                }
                cache(C) {
                  a(!this._inRuleset(), "Cannot set caching inside a ruleset"),
                    a(!this._cache, "Cannot override schema cache"),
                    a(
                      this._flags.artifact === void 0,
                      "Cannot cache a rule with an artifact"
                    );
                  const I = this.clone();
                  return (
                    (I._cache = C || d.provider.provision()),
                    (I.$_temp.ruleset = !1),
                    I
                  );
                }
                clone() {
                  const C = Object.create(Object.getPrototypeOf(this));
                  return this._assign(C);
                }
                concat(C) {
                  a(f.isSchema(C), "Invalid schema object"),
                    a(
                      this.type === "any" ||
                        C.type === "any" ||
                        C.type === this.type,
                      "Cannot merge type",
                      this.type,
                      "with another type:",
                      C.type
                    ),
                    a(
                      !this._inRuleset(),
                      "Cannot concatenate onto a schema with open ruleset"
                    ),
                    a(
                      !C._inRuleset(),
                      "Cannot concatenate a schema with open ruleset"
                    );
                  let I = this.clone();
                  if (this.type === "any" && C.type !== "any") {
                    const P = C.clone();
                    for (const M of Object.keys(I))
                      M !== "type" && (P[M] = I[M]);
                    I = P;
                  }
                  I._ids.concat(C._ids),
                    I._refs.register(C, x.toSibling),
                    (I._preferences = I._preferences
                      ? f.preferences(I._preferences, C._preferences)
                      : C._preferences),
                    (I._valids = O.merge(I._valids, C._valids, C._invalids)),
                    (I._invalids = O.merge(
                      I._invalids,
                      C._invalids,
                      C._valids
                    ));
                  for (const P of C._singleRules.keys())
                    I._singleRules.has(P) &&
                      ((I._rules = I._rules.filter(
                        (M) => M.keep || M.name !== P
                      )),
                      I._singleRules.delete(P));
                  for (const P of C._rules)
                    C._definition.rules[P.method].multi ||
                      I._singleRules.set(P.name, P),
                      I._rules.push(P);
                  if (I._flags.empty && C._flags.empty) {
                    I._flags.empty = I._flags.empty.concat(C._flags.empty);
                    const P = Object.assign({}, C._flags);
                    delete P.empty, u(I._flags, P);
                  } else if (C._flags.empty) {
                    I._flags.empty = C._flags.empty;
                    const P = Object.assign({}, C._flags);
                    delete P.empty, u(I._flags, P);
                  } else u(I._flags, C._flags);
                  for (const P in C.$_terms) {
                    const M = C.$_terms[P];
                    M
                      ? I.$_terms[P]
                        ? (I.$_terms[P] = I.$_terms[P].concat(M))
                        : (I.$_terms[P] = M.slice())
                      : I.$_terms[P] || (I.$_terms[P] = M);
                  }
                  return (
                    this.$_root._tracer &&
                      this.$_root._tracer._combine(I, [this, C]),
                    I.$_mutateRebuild()
                  );
                }
                extend(C) {
                  return (
                    a(!C.base, "Cannot extend type with another base"),
                    g.type(this, C)
                  );
                }
                extract(C) {
                  return (
                    (C = Array.isArray(C) ? C : C.split(".")),
                    this._ids.reach(C)
                  );
                }
                fork(C, I) {
                  a(!this._inRuleset(), "Cannot fork inside a ruleset");
                  let P = this;
                  for (let M of [].concat(C))
                    (M = Array.isArray(M) ? M : M.split(".")),
                      (P = P._ids.fork(M, I, P));
                  return (P.$_temp.ruleset = !1), P;
                }
                rule(C) {
                  const I = this._definition;
                  f.assertOptions(C, Object.keys(I.modifiers)),
                    a(
                      this.$_temp.ruleset !== !1,
                      "Cannot apply rules to empty ruleset or the last rule added does not support rule properties"
                    );
                  const P =
                    this.$_temp.ruleset === null
                      ? this._rules.length - 1
                      : this.$_temp.ruleset;
                  a(
                    P >= 0 && P < this._rules.length,
                    "Cannot apply rules to empty ruleset"
                  );
                  const M = this.clone();
                  for (let k = P; k < M._rules.length; ++k) {
                    const T = M._rules[k],
                      _ = l(T);
                    for (const A in C)
                      I.modifiers[A](_, C[A]),
                        a(_.name === T.name, "Cannot change rule name");
                    (M._rules[k] = _),
                      M._singleRules.get(_.name) === T &&
                        M._singleRules.set(_.name, _);
                  }
                  return (M.$_temp.ruleset = !1), M.$_mutateRebuild();
                }
                get ruleset() {
                  a(
                    !this._inRuleset(),
                    "Cannot start a new ruleset without closing the previous one"
                  );
                  const C = this.clone();
                  return (C.$_temp.ruleset = C._rules.length), C;
                }
                get $() {
                  return this.ruleset;
                }
                tailor(C) {
                  (C = [].concat(C)),
                    a(!this._inRuleset(), "Cannot tailor inside a ruleset");
                  let I = this;
                  if (this.$_terms.alterations)
                    for (const { target: P, adjuster: M } of this.$_terms
                      .alterations)
                      C.includes(P) &&
                        ((I = M(I)),
                        a(
                          f.isSchema(I),
                          "Alteration adjuster for",
                          P,
                          "failed to return a schema object"
                        ));
                  return (
                    (I = I.$_modify({ each: (P) => P.tailor(C), ref: !1 })),
                    (I.$_temp.ruleset = !1),
                    I.$_mutateRebuild()
                  );
                }
                tracer() {
                  return S.location ? S.location(this) : this;
                }
                validate(C, I) {
                  return R.entry(C, this, I);
                }
                validateAsync(C, I) {
                  return R.entryAsync(C, this, I);
                }
                $_addRule(C) {
                  typeof C == "string" && (C = { name: C }),
                    a(C && typeof C == "object", "Invalid options"),
                    a(C.name && typeof C.name == "string", "Invalid rule name");
                  for (const T in C)
                    a(T[0] !== "_", "Cannot set private rule properties");
                  const I = Object.assign({}, C);
                  (I._resolve = []), (I.method = I.method || I.name);
                  const P = this._definition.rules[I.method],
                    M = I.args;
                  a(P, "Unknown rule", I.method);
                  const k = this.clone();
                  if (M) {
                    a(
                      Object.keys(M).length === 1 ||
                        Object.keys(M).length ===
                          this._definition.rules[I.name].args.length,
                      "Invalid rule definition for",
                      this.type,
                      I.name
                    );
                    for (const T in M) {
                      let _ = M[T];
                      if (P.argsByName) {
                        const A = P.argsByName.get(T);
                        if (A.ref && f.isResolvable(_))
                          I._resolve.push(T), k.$_mutateRegister(_);
                        else if (
                          (A.normalize && ((_ = A.normalize(_)), (M[T] = _)),
                          A.assert)
                        ) {
                          const N = f.validateArg(_, T, A);
                          a(!N, N, "or reference");
                        }
                      }
                      _ !== void 0 ? (M[T] = _) : delete M[T];
                    }
                  }
                  return (
                    P.multi ||
                      (k._ruleRemove(I.name, { clone: !1 }),
                      k._singleRules.set(I.name, I)),
                    k.$_temp.ruleset === !1 && (k.$_temp.ruleset = null),
                    P.priority ? k._rules.unshift(I) : k._rules.push(I),
                    k
                  );
                }
                $_compile(C, I) {
                  return h.schema(this.$_root, C, I);
                }
                $_createError(C, I, P, M, k) {
                  let T =
                    arguments.length > 5 && arguments[5] !== void 0
                      ? arguments[5]
                      : {};
                  const _ = T.flags !== !1 ? this._flags : {},
                    A = T.messages
                      ? v.merge(this._definition.messages, T.messages)
                      : this._definition.messages;
                  return new p.Report(C, I, P, _, A, M, k);
                }
                $_getFlag(C) {
                  return this._flags[C];
                }
                $_getRule(C) {
                  return this._singleRules.get(C);
                }
                $_mapLabels(C) {
                  return (
                    (C = Array.isArray(C) ? C : C.split(".")),
                    this._ids.labels(C)
                  );
                }
                $_match(C, I, P, M) {
                  ((P = Object.assign({}, P)).abortEarly = !0),
                    (P._externals = !1),
                    I.snapshot();
                  const k = !R.validate(C, this, I, P, M).errors;
                  return I.restore(), k;
                }
                $_modify(C) {
                  return (
                    f.assertOptions(C, ["each", "once", "ref", "schema"]),
                    w.schema(this, C) || this
                  );
                }
                $_mutateRebuild() {
                  return (
                    a(
                      !this._inRuleset(),
                      "Cannot add this rule inside a ruleset"
                    ),
                    this._refs.reset(),
                    this._ids.reset(),
                    this.$_modify({
                      each: (C, I) => {
                        let { source: P, name: M, path: k, key: T } = I;
                        const _ =
                          this._definition[P][M] &&
                          this._definition[P][M].register;
                        _ !== !1 &&
                          this.$_mutateRegister(C, { family: _, key: T });
                      },
                    }),
                    this._definition.rebuild && this._definition.rebuild(this),
                    (this.$_temp.ruleset = !1),
                    this
                  );
                }
                $_mutateRegister(C) {
                  let { family: I, key: P } =
                    arguments.length > 1 && arguments[1] !== void 0
                      ? arguments[1]
                      : {};
                  this._refs.register(C, I), this._ids.register(C, { key: P });
                }
                $_property(C) {
                  return this._definition.properties[C];
                }
                $_reach(C) {
                  return this._ids.reach(C);
                }
                $_rootReferences() {
                  return this._refs.roots();
                }
                $_setFlag(C, I) {
                  let P =
                    arguments.length > 2 && arguments[2] !== void 0
                      ? arguments[2]
                      : {};
                  a(
                    C[0] === "_" || !this._inRuleset(),
                    "Cannot set flag inside a ruleset"
                  );
                  const M = this._definition.flags[C] || {};
                  if ((c(I, M.default) && (I = void 0), c(I, this._flags[C])))
                    return this;
                  const k = P.clone !== !1 ? this.clone() : this;
                  return (
                    I !== void 0
                      ? ((k._flags[C] = I), k.$_mutateRegister(I))
                      : delete k._flags[C],
                    C[0] !== "_" && (k.$_temp.ruleset = !1),
                    k
                  );
                }
                $_parent(C) {
                  for (
                    var I = arguments.length,
                      P = new Array(I > 1 ? I - 1 : 0),
                      M = 1;
                    M < I;
                    M++
                  )
                    P[M - 1] = arguments[M];
                  return this[C][f.symbols.parent].call(this, ...P);
                }
                $_validate(C, I, P) {
                  return R.validate(C, this, I, P);
                }
                _assign(C) {
                  (C.type = this.type),
                    (C.$_root = this.$_root),
                    (C.$_temp = Object.assign({}, this.$_temp)),
                    (C.$_temp.whens = {}),
                    (C._ids = this._ids.clone()),
                    (C._preferences = this._preferences),
                    (C._valids = this._valids && this._valids.clone()),
                    (C._invalids = this._invalids && this._invalids.clone()),
                    (C._rules = this._rules.slice()),
                    (C._singleRules = l(this._singleRules, { shallow: !0 })),
                    (C._refs = this._refs.clone()),
                    (C._flags = Object.assign({}, this._flags)),
                    (C._cache = null),
                    (C.$_terms = {});
                  for (const I in this.$_terms)
                    C.$_terms[I] = this.$_terms[I]
                      ? this.$_terms[I].slice()
                      : null;
                  C.$_super = {};
                  for (const I in this.$_super)
                    C.$_super[I] = this._super[I].bind(C);
                  return C;
                }
                _bare() {
                  const C = this.clone();
                  C._reset();
                  const I = C._definition.terms;
                  for (const P in I) {
                    const M = I[P];
                    C.$_terms[P] = M.init;
                  }
                  return C.$_mutateRebuild();
                }
                _default(C, I) {
                  let P =
                    arguments.length > 2 && arguments[2] !== void 0
                      ? arguments[2]
                      : {};
                  return (
                    f.assertOptions(P, "literal"),
                    a(I !== void 0, "Missing", C, "value"),
                    a(
                      typeof I == "function" || !P.literal,
                      "Only function value supports literal option"
                    ),
                    typeof I == "function" &&
                      P.literal &&
                      (I = { [f.symbols.literal]: !0, literal: I }),
                    this.$_setFlag(C, I)
                  );
                }
                _generate(C, I, P) {
                  if (!this.$_terms.whens) return { schema: this };
                  const M = [],
                    k = [];
                  for (let A = 0; A < this.$_terms.whens.length; ++A) {
                    const N = this.$_terms.whens[A];
                    if (N.concat) {
                      M.push(N.concat), k.push(`${A}.concat`);
                      continue;
                    }
                    const L = N.ref ? N.ref.resolve(C, I, P) : C,
                      F = N.is ? [N] : N.switch,
                      D = k.length;
                    for (let j = 0; j < F.length; ++j) {
                      const { is: z, then: $, otherwise: K } = F[j],
                        re = `${A}${N.switch ? "." + j : ""}`;
                      if (z.$_match(L, I.nest(z, `${re}.is`), P)) {
                        if ($) {
                          const G = I.localize(
                              [...I.path, `${re}.then`],
                              I.ancestors,
                              I.schemas
                            ),
                            { schema: ne, id: ae } = $._generate(C, G, P);
                          M.push(ne),
                            k.push(`${re}.then${ae ? `(${ae})` : ""}`);
                          break;
                        }
                      } else if (K) {
                        const G = I.localize(
                            [...I.path, `${re}.otherwise`],
                            I.ancestors,
                            I.schemas
                          ),
                          { schema: ne, id: ae } = K._generate(C, G, P);
                        M.push(ne),
                          k.push(`${re}.otherwise${ae ? `(${ae})` : ""}`);
                        break;
                      }
                    }
                    if (N.break && k.length > D) break;
                  }
                  const T = k.join(", ");
                  if ((I.mainstay.tracer.debug(I, "rule", "when", T), !T))
                    return { schema: this };
                  if (!I.mainstay.tracer.active && this.$_temp.whens[T])
                    return { schema: this.$_temp.whens[T], id: T };
                  let _ = this;
                  this._definition.generate &&
                    (_ = this._definition.generate(this, C, I, P));
                  for (const A of M) _ = _.concat(A);
                  return (
                    this.$_root._tracer &&
                      this.$_root._tracer._combine(_, [this, ...M]),
                    (this.$_temp.whens[T] = _),
                    { schema: _, id: T }
                  );
                }
                _inner(C, I) {
                  let P =
                    arguments.length > 2 && arguments[2] !== void 0
                      ? arguments[2]
                      : {};
                  a(!this._inRuleset(), `Cannot set ${C} inside a ruleset`);
                  const M = this.clone();
                  return (
                    (M.$_terms[C] && !P.override) || (M.$_terms[C] = []),
                    P.single ? M.$_terms[C].push(I) : M.$_terms[C].push(...I),
                    (M.$_temp.ruleset = !1),
                    M
                  );
                }
                _inRuleset() {
                  return (
                    this.$_temp.ruleset !== null && this.$_temp.ruleset !== !1
                  );
                }
                _ruleRemove(C) {
                  let I =
                    arguments.length > 1 && arguments[1] !== void 0
                      ? arguments[1]
                      : {};
                  if (!this._singleRules.has(C)) return this;
                  const P = I.clone !== !1 ? this.clone() : this;
                  P._singleRules.delete(C);
                  const M = [];
                  for (let k = 0; k < P._rules.length; ++k) {
                    const T = P._rules[k];
                    T.name !== C || T.keep
                      ? M.push(T)
                      : P._inRuleset() &&
                        k < P.$_temp.ruleset &&
                        --P.$_temp.ruleset;
                  }
                  return (P._rules = M), P;
                }
                _values(C, I) {
                  f.verifyFlat(C, I.slice(1, -1));
                  const P = this.clone(),
                    M = C[0] === f.symbols.override;
                  if (
                    (M && (C = C.slice(1)),
                    !P[I] && C.length
                      ? (P[I] = new O())
                      : M &&
                        ((P[I] = C.length ? new O() : null),
                        P.$_mutateRebuild()),
                    !P[I])
                  )
                    return P;
                  M && P[I].override();
                  for (const k of C) {
                    a(
                      k !== void 0,
                      "Cannot call allow/valid/invalid with undefined"
                    ),
                      a(
                        k !== f.symbols.override,
                        "Override must be the first value"
                      );
                    const T = I === "_invalids" ? "_valids" : "_invalids";
                    P[T] &&
                      (P[T].remove(k),
                      P[T].length ||
                        (a(
                          I === "_valids" || !P._flags.only,
                          "Setting invalid value",
                          k,
                          "leaves schema rejecting all values due to previous valid rule"
                        ),
                        (P[T] = null))),
                      P[I].add(k, P._refs);
                  }
                  return P;
                }
              },
            };
          (B.Base.prototype[f.symbols.any] = {
            version: f.version,
            compile: h.compile,
            root: "$_root",
          }),
            (B.Base.prototype.isImmutable = !0),
            (B.Base.prototype.deny = B.Base.prototype.invalid),
            (B.Base.prototype.disallow = B.Base.prototype.invalid),
            (B.Base.prototype.equal = B.Base.prototype.valid),
            (B.Base.prototype.exist = B.Base.prototype.required),
            (B.Base.prototype.not = B.Base.prototype.invalid),
            (B.Base.prototype.options = B.Base.prototype.prefs),
            (B.Base.prototype.preferences = B.Base.prototype.prefs),
            (i.exports = new B.Base());
        },
        8652: (i, s, o) => {
          const a = o(375),
            l = o(8571),
            c = o(8160),
            u = {
              max: 1e3,
              supported: new Set(["undefined", "boolean", "number", "string"]),
            };
          (s.provider = { provision: (d) => new u.Cache(d) }),
            (u.Cache = class {
              constructor() {
                let d =
                  arguments.length > 0 && arguments[0] !== void 0
                    ? arguments[0]
                    : {};
                c.assertOptions(d, ["max"]),
                  a(
                    d.max === void 0 || (d.max && d.max > 0 && isFinite(d.max)),
                    "Invalid max cache size"
                  ),
                  (this._max = d.max || u.max),
                  (this._map = new Map()),
                  (this._list = new u.List());
              }
              get length() {
                return this._map.size;
              }
              set(d, f) {
                if (d !== null && !u.supported.has(typeof d)) return;
                let h = this._map.get(d);
                if (h) return (h.value = f), void this._list.first(h);
                (h = this._list.unshift({ key: d, value: f })),
                  this._map.set(d, h),
                  this._compact();
              }
              get(d) {
                const f = this._map.get(d);
                if (f) return this._list.first(f), l(f.value);
              }
              _compact() {
                if (this._map.size > this._max) {
                  const d = this._list.pop();
                  this._map.delete(d.key);
                }
              }
            }),
            (u.List = class {
              constructor() {
                (this.tail = null), (this.head = null);
              }
              unshift(d) {
                return (
                  (d.next = null),
                  (d.prev = this.head),
                  this.head && (this.head.next = d),
                  (this.head = d),
                  this.tail || (this.tail = d),
                  d
                );
              }
              first(d) {
                d !== this.head && (this._remove(d), this.unshift(d));
              }
              pop() {
                return this._remove(this.tail);
              }
              _remove(d) {
                const { next: f, prev: h } = d;
                return (
                  (f.prev = h),
                  h && (h.next = f),
                  d === this.tail && (this.tail = f),
                  (d.prev = null),
                  (d.next = null),
                  d
                );
              }
            });
        },
        8160: (i, s, o) => {
          const a = o(375),
            l = o(7916),
            c = o(5934);
          let u, d;
          const f = {
            isoDate:
              /^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/,
          };
          (s.version = c.version),
            (s.defaults = {
              abortEarly: !0,
              allowUnknown: !1,
              artifacts: !1,
              cache: !0,
              context: null,
              convert: !0,
              dateFormat: "iso",
              errors: {
                escapeHtml: !1,
                label: "path",
                language: null,
                render: !0,
                stack: !1,
                wrap: { label: '"', array: "[]" },
              },
              externals: !0,
              messages: {},
              nonEnumerables: !1,
              noDefaults: !1,
              presence: "optional",
              skipFunctions: !1,
              stripUnknown: !1,
              warnings: !1,
            }),
            (s.symbols = {
              any: Symbol.for("@hapi/joi/schema"),
              arraySingle: Symbol("arraySingle"),
              deepDefault: Symbol("deepDefault"),
              errors: Symbol("errors"),
              literal: Symbol("literal"),
              override: Symbol("override"),
              parent: Symbol("parent"),
              prefs: Symbol("prefs"),
              ref: Symbol("ref"),
              template: Symbol("template"),
              values: Symbol("values"),
            }),
            (s.assertOptions = function (h, p) {
              let g =
                arguments.length > 2 && arguments[2] !== void 0
                  ? arguments[2]
                  : "Options";
              a(
                h && typeof h == "object" && !Array.isArray(h),
                "Options must be of type object"
              );
              const b = Object.keys(h).filter((v) => !p.includes(v));
              a(b.length === 0, `${g} contain unknown keys: ${b}`);
            }),
            (s.checkPreferences = function (h) {
              d = d || o(3378);
              const p = d.preferences.validate(h);
              if (p.error) throw new l([p.error.details[0].message]);
            }),
            (s.compare = function (h, p, g) {
              switch (g) {
                case "=":
                  return h === p;
                case ">":
                  return h > p;
                case "<":
                  return h < p;
                case ">=":
                  return h >= p;
                case "<=":
                  return h <= p;
              }
            }),
            (s.default = function (h, p) {
              return h === void 0 ? p : h;
            }),
            (s.isIsoDate = function (h) {
              return f.isoDate.test(h);
            }),
            (s.isNumber = function (h) {
              return typeof h == "number" && !isNaN(h);
            }),
            (s.isResolvable = function (h) {
              return !!h && (h[s.symbols.ref] || h[s.symbols.template]);
            }),
            (s.isSchema = function (h) {
              let p =
                arguments.length > 1 && arguments[1] !== void 0
                  ? arguments[1]
                  : {};
              const g = h && h[s.symbols.any];
              return (
                !!g &&
                (a(
                  p.legacy || g.version === s.version,
                  "Cannot mix different versions of joi schemas"
                ),
                !0)
              );
            }),
            (s.isValues = function (h) {
              return h[s.symbols.values];
            }),
            (s.limit = function (h) {
              return Number.isSafeInteger(h) && h >= 0;
            }),
            (s.preferences = function (h, p) {
              (u = u || o(6914)), (h = h || {}), (p = p || {});
              const g = Object.assign({}, h, p);
              return (
                p.errors &&
                  h.errors &&
                  ((g.errors = Object.assign({}, h.errors, p.errors)),
                  (g.errors.wrap = Object.assign(
                    {},
                    h.errors.wrap,
                    p.errors.wrap
                  ))),
                p.messages && (g.messages = u.compile(p.messages, h.messages)),
                delete g[s.symbols.prefs],
                g
              );
            }),
            (s.tryWithPath = function (h, p) {
              let g =
                arguments.length > 2 && arguments[2] !== void 0
                  ? arguments[2]
                  : {};
              try {
                return h();
              } catch (b) {
                throw (
                  (b.path !== void 0
                    ? (b.path = p + "." + b.path)
                    : (b.path = p),
                  g.append && (b.message = `${b.message} (${b.path})`),
                  b)
                );
              }
            }),
            (s.validateArg = function (h, p, g) {
              let { assert: b, message: v } = g;
              if (s.isSchema(b)) {
                const w = b.validate(h);
                return w.error ? w.error.message : void 0;
              }
              if (!b(h)) return p ? `${p} ${v}` : v;
            }),
            (s.verifyFlat = function (h, p) {
              for (const g of h)
                a(
                  !Array.isArray(g),
                  "Method no longer accepts array arguments:",
                  p
                );
            });
        },
        3292: (i, s, o) => {
          const a = o(375),
            l = o(8160),
            c = o(6133),
            u = {};
          (s.schema = function (d, f) {
            let h =
              arguments.length > 2 && arguments[2] !== void 0
                ? arguments[2]
                : {};
            l.assertOptions(h, ["appendPath", "override"]);
            try {
              return u.schema(d, f, h);
            } catch (p) {
              throw (
                (h.appendPath &&
                  p.path !== void 0 &&
                  (p.message = `${p.message} (${p.path})`),
                p)
              );
            }
          }),
            (u.schema = function (d, f, h) {
              a(f !== void 0, "Invalid undefined schema"),
                Array.isArray(f) &&
                  (a(f.length, "Invalid empty array schema"),
                  f.length === 1 && (f = f[0]));
              const p = function (g) {
                for (
                  var b = arguments.length,
                    v = new Array(b > 1 ? b - 1 : 0),
                    w = 1;
                  w < b;
                  w++
                )
                  v[w - 1] = arguments[w];
                return h.override !== !1
                  ? g.valid(d.override, ...v)
                  : g.valid(...v);
              };
              if (u.simple(f)) return p(d, f);
              if (typeof f == "function") return d.custom(f);
              if (
                (a(typeof f == "object", "Invalid schema content:", typeof f),
                l.isResolvable(f))
              )
                return p(d, f);
              if (l.isSchema(f)) return f;
              if (Array.isArray(f)) {
                for (const g of f)
                  if (!u.simple(g)) return d.alternatives().try(...f);
                return p(d, ...f);
              }
              return f instanceof RegExp
                ? d.string().regex(f)
                : f instanceof Date
                ? p(d.date(), f)
                : (a(
                    Object.getPrototypeOf(f) === Object.getPrototypeOf({}),
                    "Schema can only contain plain objects"
                  ),
                  d.object().keys(f));
            }),
            (s.ref = function (d, f) {
              return c.isRef(d) ? d : c.create(d, f);
            }),
            (s.compile = function (d, f) {
              let h =
                arguments.length > 2 && arguments[2] !== void 0
                  ? arguments[2]
                  : {};
              l.assertOptions(h, ["legacy"]);
              const p = f && f[l.symbols.any];
              if (p)
                return (
                  a(
                    h.legacy || p.version === l.version,
                    "Cannot mix different versions of joi schemas:",
                    p.version,
                    l.version
                  ),
                  f
                );
              if (typeof f != "object" || !h.legacy)
                return s.schema(d, f, { appendPath: !0 });
              const g = u.walk(f);
              return g
                ? g.compile(g.root, f)
                : s.schema(d, f, { appendPath: !0 });
            }),
            (u.walk = function (d) {
              if (typeof d != "object") return null;
              if (Array.isArray(d)) {
                for (const h of d) {
                  const p = u.walk(h);
                  if (p) return p;
                }
                return null;
              }
              const f = d[l.symbols.any];
              if (f) return { root: d[f.root], compile: f.compile };
              a(
                Object.getPrototypeOf(d) === Object.getPrototypeOf({}),
                "Schema can only contain plain objects"
              );
              for (const h in d) {
                const p = u.walk(d[h]);
                if (p) return p;
              }
              return null;
            }),
            (u.simple = function (d) {
              return (
                d === null || ["boolean", "string", "number"].includes(typeof d)
              );
            }),
            (s.when = function (d, f, h) {
              if (
                (h === void 0 &&
                  (a(f && typeof f == "object", "Missing options"),
                  (h = f),
                  (f = c.create("."))),
                Array.isArray(h) && (h = { switch: h }),
                l.assertOptions(h, [
                  "is",
                  "not",
                  "then",
                  "otherwise",
                  "switch",
                  "break",
                ]),
                l.isSchema(f))
              )
                return (
                  a(
                    h.is === void 0,
                    '"is" can not be used with a schema condition'
                  ),
                  a(
                    h.not === void 0,
                    '"not" can not be used with a schema condition'
                  ),
                  a(
                    h.switch === void 0,
                    '"switch" can not be used with a schema condition'
                  ),
                  u.condition(d, {
                    is: f,
                    then: h.then,
                    otherwise: h.otherwise,
                    break: h.break,
                  })
                );
              if (
                (a(c.isRef(f) || typeof f == "string", "Invalid condition:", f),
                a(
                  h.not === void 0 || h.is === void 0,
                  'Cannot combine "is" with "not"'
                ),
                h.switch === void 0)
              ) {
                let g = h;
                h.not !== void 0 &&
                  (g = {
                    is: h.not,
                    then: h.otherwise,
                    otherwise: h.then,
                    break: h.break,
                  });
                let b =
                  g.is !== void 0
                    ? d.$_compile(g.is)
                    : d.$_root.invalid(null, !1, 0, "").required();
                return (
                  a(
                    g.then !== void 0 || g.otherwise !== void 0,
                    'options must have at least one of "then", "otherwise", or "switch"'
                  ),
                  a(
                    g.break === void 0 ||
                      g.then === void 0 ||
                      g.otherwise === void 0,
                    "Cannot specify then, otherwise, and break all together"
                  ),
                  h.is === void 0 ||
                    c.isRef(h.is) ||
                    l.isSchema(h.is) ||
                    (b = b.required()),
                  u.condition(d, {
                    ref: s.ref(f),
                    is: b,
                    then: g.then,
                    otherwise: g.otherwise,
                    break: g.break,
                  })
                );
              }
              a(Array.isArray(h.switch), '"switch" must be an array'),
                a(h.is === void 0, 'Cannot combine "switch" with "is"'),
                a(h.not === void 0, 'Cannot combine "switch" with "not"'),
                a(h.then === void 0, 'Cannot combine "switch" with "then"');
              const p = { ref: s.ref(f), switch: [], break: h.break };
              for (let g = 0; g < h.switch.length; ++g) {
                const b = h.switch[g],
                  v = g === h.switch.length - 1;
                l.assertOptions(
                  b,
                  v ? ["is", "then", "otherwise"] : ["is", "then"]
                ),
                  a(b.is !== void 0, 'Switch statement missing "is"'),
                  a(b.then !== void 0, 'Switch statement missing "then"');
                const w = { is: d.$_compile(b.is), then: d.$_compile(b.then) };
                if (
                  (c.isRef(b.is) ||
                    l.isSchema(b.is) ||
                    (w.is = w.is.required()),
                  v)
                ) {
                  a(
                    h.otherwise === void 0 || b.otherwise === void 0,
                    'Cannot specify "otherwise" inside and outside a "switch"'
                  );
                  const x = h.otherwise !== void 0 ? h.otherwise : b.otherwise;
                  x !== void 0 &&
                    (a(
                      p.break === void 0,
                      "Cannot specify both otherwise and break"
                    ),
                    (w.otherwise = d.$_compile(x)));
                }
                p.switch.push(w);
              }
              return p;
            }),
            (u.condition = function (d, f) {
              for (const h of ["then", "otherwise"])
                f[h] === void 0 ? delete f[h] : (f[h] = d.$_compile(f[h]));
              return f;
            });
        },
        6354: (i, s, o) => {
          const a = o(5688),
            l = o(8160),
            c = o(3328);
          (s.Report = class {
            constructor(u, d, f, h, p, g, b) {
              if (
                ((this.code = u),
                (this.flags = h),
                (this.messages = p),
                (this.path = g.path),
                (this.prefs = b),
                (this.state = g),
                (this.value = d),
                (this.message = null),
                (this.template = null),
                (this.local = f || {}),
                (this.local.label = s.label(
                  this.flags,
                  this.state,
                  this.prefs,
                  this.messages
                )),
                this.value === void 0 ||
                  this.local.hasOwnProperty("value") ||
                  (this.local.value = this.value),
                this.path.length)
              ) {
                const v = this.path[this.path.length - 1];
                typeof v != "object" && (this.local.key = v);
              }
            }
            _setTemplate(u) {
              if (
                ((this.template = u),
                !this.flags.label && this.path.length === 0)
              ) {
                const d = this._template(this.template, "root");
                d && (this.local.label = d);
              }
            }
            toString() {
              if (this.message) return this.message;
              const u = this.code;
              if (!this.prefs.errors.render) return this.code;
              const d =
                this._template(this.template) ||
                this._template(this.prefs.messages) ||
                this._template(this.messages);
              return d === void 0
                ? `Error code "${u}" is not defined, your custom type is missing the correct messages definition`
                : ((this.message = d.render(
                    this.value,
                    this.state,
                    this.prefs,
                    this.local,
                    {
                      errors: this.prefs.errors,
                      messages: [this.prefs.messages, this.messages],
                    }
                  )),
                  this.prefs.errors.label ||
                    (this.message = this.message.replace(/^"" /, "").trim()),
                  this.message);
            }
            _template(u, d) {
              return s.template(
                this.value,
                u,
                d || this.code,
                this.state,
                this.prefs
              );
            }
          }),
            (s.path = function (u) {
              let d = "";
              for (const f of u)
                typeof f != "object" &&
                  (typeof f == "string"
                    ? (d && (d += "."), (d += f))
                    : (d += `[${f}]`));
              return d;
            }),
            (s.template = function (u, d, f, h, p) {
              if (!d) return;
              if (c.isTemplate(d)) return f !== "root" ? d : null;
              let g = p.errors.language;
              if ((l.isResolvable(g) && (g = g.resolve(u, h, p)), g && d[g])) {
                if (d[g][f] !== void 0) return d[g][f];
                if (d[g]["*"] !== void 0) return d[g]["*"];
              }
              return d[f] ? d[f] : d["*"];
            }),
            (s.label = function (u, d, f, h) {
              if (u.label) return u.label;
              if (!f.errors.label) return "";
              let p = d.path;
              return (
                f.errors.label === "key" &&
                  d.path.length > 1 &&
                  (p = d.path.slice(-1)),
                s.path(p) ||
                  s.template(null, f.messages, "root", d, f) ||
                  (h && s.template(null, h, "root", d, f)) ||
                  "value"
              );
            }),
            (s.process = function (u, d, f) {
              if (!u) return null;
              const { override: h, message: p, details: g } = s.details(u);
              if (h) return h;
              if (f.errors.stack) return new s.ValidationError(p, g, d);
              const b = Error.stackTraceLimit;
              Error.stackTraceLimit = 0;
              const v = new s.ValidationError(p, g, d);
              return (Error.stackTraceLimit = b), v;
            }),
            (s.details = function (u) {
              let d =
                  arguments.length > 1 && arguments[1] !== void 0
                    ? arguments[1]
                    : {},
                f = [];
              const h = [];
              for (const p of u) {
                if (p instanceof Error) {
                  if (d.override !== !1) return { override: p };
                  const b = p.toString();
                  f.push(b),
                    h.push({
                      message: b,
                      type: "override",
                      context: { error: p },
                    });
                  continue;
                }
                const g = p.toString();
                f.push(g),
                  h.push({
                    message: g,
                    path: p.path.filter((b) => typeof b != "object"),
                    type: p.code,
                    context: p.local,
                  });
              }
              return (
                f.length > 1 && (f = [...new Set(f)]),
                { message: f.join(". "), details: h }
              );
            }),
            (s.ValidationError = class extends Error {
              constructor(u, d, f) {
                super(u), (this._original = f), (this.details = d);
              }
              static isError(u) {
                return u instanceof s.ValidationError;
              }
            }),
            (s.ValidationError.prototype.isJoi = !0),
            (s.ValidationError.prototype.name = "ValidationError"),
            (s.ValidationError.prototype.annotate = a.error);
        },
        8901: (i, s, o) => {
          const a = o(375),
            l = o(8571),
            c = o(8160),
            u = o(6914),
            d = {};
          (s.type = function (f, h) {
            const p = Object.getPrototypeOf(f),
              g = l(p),
              b = f._assign(Object.create(g)),
              v = Object.assign({}, h);
            delete v.base, (g._definition = v);
            const w = p._definition || {};
            (v.messages = u.merge(w.messages, v.messages)),
              (v.properties = Object.assign({}, w.properties, v.properties)),
              (b.type = v.type),
              (v.flags = Object.assign({}, w.flags, v.flags));
            const x = Object.assign({}, w.terms);
            if (v.terms)
              for (const B in v.terms) {
                const C = v.terms[B];
                a(
                  b.$_terms[B] === void 0,
                  "Invalid term override for",
                  v.type,
                  B
                ),
                  (b.$_terms[B] = C.init),
                  (x[B] = C);
              }
            (v.terms = x),
              v.args || (v.args = w.args),
              (v.prepare = d.prepare(v.prepare, w.prepare)),
              v.coerce &&
                (typeof v.coerce == "function" &&
                  (v.coerce = { method: v.coerce }),
                v.coerce.from &&
                  !Array.isArray(v.coerce.from) &&
                  (v.coerce = {
                    method: v.coerce.method,
                    from: [].concat(v.coerce.from),
                  })),
              (v.coerce = d.coerce(v.coerce, w.coerce)),
              (v.validate = d.validate(v.validate, w.validate));
            const S = Object.assign({}, w.rules);
            if (v.rules)
              for (const B in v.rules) {
                const C = v.rules[B];
                a(
                  typeof C == "object",
                  "Invalid rule definition for",
                  v.type,
                  B
                );
                let I = C.method;
                if (
                  (I === void 0 &&
                    (I = function () {
                      return this.$_addRule(B);
                    }),
                  I && (a(!g[B], "Rule conflict in", v.type, B), (g[B] = I)),
                  a(!S[B], "Rule conflict in", v.type, B),
                  (S[B] = C),
                  C.alias)
                ) {
                  const P = [].concat(C.alias);
                  for (const M of P) g[M] = C.method;
                }
                C.args &&
                  ((C.argsByName = new Map()),
                  (C.args = C.args.map(
                    (P) => (
                      typeof P == "string" && (P = { name: P }),
                      a(
                        !C.argsByName.has(P.name),
                        "Duplicated argument name",
                        P.name
                      ),
                      c.isSchema(P.assert) &&
                        (P.assert = P.assert.strict().label(P.name)),
                      C.argsByName.set(P.name, P),
                      P
                    )
                  )));
              }
            v.rules = S;
            const R = Object.assign({}, w.modifiers);
            if (v.modifiers)
              for (const B in v.modifiers) {
                a(!g[B], "Rule conflict in", v.type, B);
                const C = v.modifiers[B];
                a(
                  typeof C == "function",
                  "Invalid modifier definition for",
                  v.type,
                  B
                );
                const I = function (P) {
                  return this.rule({ [B]: P });
                };
                (g[B] = I), (R[B] = C);
              }
            if (((v.modifiers = R), v.overrides)) {
              (g._super = p), (b.$_super = {});
              for (const B in v.overrides)
                a(p[B], "Cannot override missing", B),
                  (v.overrides[B][c.symbols.parent] = p[B]),
                  (b.$_super[B] = p[B].bind(b));
              Object.assign(g, v.overrides);
            }
            v.cast = Object.assign({}, w.cast, v.cast);
            const O = Object.assign({}, w.manifest, v.manifest);
            return (
              (O.build = d.build(
                v.manifest && v.manifest.build,
                w.manifest && w.manifest.build
              )),
              (v.manifest = O),
              (v.rebuild = d.rebuild(v.rebuild, w.rebuild)),
              b
            );
          }),
            (d.build = function (f, h) {
              return f && h
                ? function (p, g) {
                    return h(f(p, g), g);
                  }
                : f || h;
            }),
            (d.coerce = function (f, h) {
              return f && h
                ? {
                    from:
                      f.from && h.from
                        ? [...new Set([...f.from, ...h.from])]
                        : null,
                    method(p, g) {
                      let b;
                      if (
                        (!h.from || h.from.includes(typeof p)) &&
                        ((b = h.method(p, g)), b)
                      ) {
                        if (b.errors || b.value === void 0) return b;
                        p = b.value;
                      }
                      if (!f.from || f.from.includes(typeof p)) {
                        const v = f.method(p, g);
                        if (v) return v;
                      }
                      return b;
                    },
                  }
                : f || h;
            }),
            (d.prepare = function (f, h) {
              return f && h
                ? function (p, g) {
                    const b = f(p, g);
                    if (b) {
                      if (b.errors || b.value === void 0) return b;
                      p = b.value;
                    }
                    return h(p, g) || b;
                  }
                : f || h;
            }),
            (d.rebuild = function (f, h) {
              return f && h
                ? function (p) {
                    h(p), f(p);
                  }
                : f || h;
            }),
            (d.validate = function (f, h) {
              return f && h
                ? function (p, g) {
                    const b = h(p, g);
                    if (b) {
                      if (
                        b.errors &&
                        (!Array.isArray(b.errors) || b.errors.length)
                      )
                        return b;
                      p = b.value;
                    }
                    return f(p, g) || b;
                  }
                : f || h;
            });
        },
        5107: (i, s, o) => {
          const a = o(375),
            l = o(8571),
            c = o(8652),
            u = o(8160),
            d = o(3292),
            f = o(6354),
            h = o(8901),
            p = o(9708),
            g = o(6133),
            b = o(3328),
            v = o(1152);
          let w;
          const x = {
            types: {
              alternatives: o(4946),
              any: o(8068),
              array: o(546),
              boolean: o(4937),
              date: o(7500),
              function: o(390),
              link: o(8785),
              number: o(3832),
              object: o(8966),
              string: o(7417),
              symbol: o(8826),
            },
            aliases: { alt: "alternatives", bool: "boolean", func: "function" },
            root: function () {
              const S = { _types: new Set(Object.keys(x.types)) };
              for (const R of S._types)
                S[R] = function () {
                  for (
                    var O = arguments.length, B = new Array(O), C = 0;
                    C < O;
                    C++
                  )
                    B[C] = arguments[C];
                  return (
                    a(
                      !B.length ||
                        ["alternatives", "link", "object"].includes(R),
                      "The",
                      R,
                      "type does not allow arguments"
                    ),
                    x.generate(this, x.types[R], B)
                  );
                };
              for (const R of [
                "allow",
                "custom",
                "disallow",
                "equal",
                "exist",
                "forbidden",
                "invalid",
                "not",
                "only",
                "optional",
                "options",
                "prefs",
                "preferences",
                "required",
                "strip",
                "valid",
                "when",
              ])
                S[R] = function () {
                  return this.any()[R](...arguments);
                };
              Object.assign(S, x.methods);
              for (const R in x.aliases) {
                const O = x.aliases[R];
                S[R] = S[O];
              }
              return (S.x = S.expression), v.setup && v.setup(S), S;
            },
          };
          (x.methods = {
            ValidationError: f.ValidationError,
            version: u.version,
            cache: c.provider,
            assert(S, R) {
              for (
                var O = arguments.length,
                  B = new Array(O > 2 ? O - 2 : 0),
                  C = 2;
                C < O;
                C++
              )
                B[C - 2] = arguments[C];
              x.assert(S, R, !0, B);
            },
            attempt(S, R) {
              for (
                var O = arguments.length,
                  B = new Array(O > 2 ? O - 2 : 0),
                  C = 2;
                C < O;
                C++
              )
                B[C - 2] = arguments[C];
              return x.assert(S, R, !1, B);
            },
            build(S) {
              return (
                a(
                  typeof p.build == "function",
                  "Manifest functionality disabled"
                ),
                p.build(this, S)
              );
            },
            checkPreferences(S) {
              u.checkPreferences(S);
            },
            compile(S, R) {
              return d.compile(this, S, R);
            },
            defaults(S) {
              a(typeof S == "function", "modifier must be a function");
              const R = Object.assign({}, this);
              for (const O of R._types) {
                const B = S(R[O]());
                a(u.isSchema(B), "modifier must return a valid schema object"),
                  (R[O] = function () {
                    for (
                      var C = arguments.length, I = new Array(C), P = 0;
                      P < C;
                      P++
                    )
                      I[P] = arguments[P];
                    return x.generate(this, B, I);
                  });
              }
              return R;
            },
            expression() {
              for (
                var S = arguments.length, R = new Array(S), O = 0;
                O < S;
                O++
              )
                R[O] = arguments[O];
              return new b(...R);
            },
            extend() {
              for (
                var S = arguments.length, R = new Array(S), O = 0;
                O < S;
                O++
              )
                R[O] = arguments[O];
              u.verifyFlat(R, "extend"),
                (w = w || o(3378)),
                a(R.length, "You need to provide at least one extension"),
                this.assert(R, w.extensions);
              const B = Object.assign({}, this);
              B._types = new Set(B._types);
              for (let C of R) {
                typeof C == "function" && (C = C(B)),
                  this.assert(C, w.extension);
                const I = x.expandExtension(C, B);
                for (const P of I) {
                  a(
                    B[P.type] === void 0 || B._types.has(P.type),
                    "Cannot override name",
                    P.type
                  );
                  const M = P.base || this.any(),
                    k = h.type(M, P);
                  B._types.add(P.type),
                    (B[P.type] = function () {
                      for (
                        var T = arguments.length, _ = new Array(T), A = 0;
                        A < T;
                        A++
                      )
                        _[A] = arguments[A];
                      return x.generate(this, k, _);
                    });
                }
              }
              return B;
            },
            isError: f.ValidationError.isError,
            isExpression: b.isTemplate,
            isRef: g.isRef,
            isSchema: u.isSchema,
            in() {
              return g.in(...arguments);
            },
            override: u.symbols.override,
            ref() {
              return g.create(...arguments);
            },
            types() {
              const S = {};
              for (const R of this._types) S[R] = this[R]();
              for (const R in x.aliases) S[R] = this[R]();
              return S;
            },
          }),
            (x.assert = function (S, R, O, B) {
              const C =
                  B[0] instanceof Error || typeof B[0] == "string"
                    ? B[0]
                    : null,
                I = C !== null ? B[1] : B[0],
                P = R.validate(
                  S,
                  u.preferences({ errors: { stack: !0 } }, I || {})
                );
              let M = P.error;
              if (!M) return P.value;
              if (C instanceof Error) throw C;
              const k =
                O && typeof M.annotate == "function" ? M.annotate() : M.message;
              throw (
                (M instanceof f.ValidationError == 0 && (M = l(M)),
                (M.message = C ? `${C} ${k}` : k),
                M)
              );
            }),
            (x.generate = function (S, R, O) {
              return (
                a(S, "Must be invoked on a Joi instance."),
                (R.$_root = S),
                R._definition.args && O.length ? R._definition.args(R, ...O) : R
              );
            }),
            (x.expandExtension = function (S, R) {
              if (typeof S.type == "string") return [S];
              const O = [];
              for (const B of R._types)
                if (S.type.test(B)) {
                  const C = Object.assign({}, S);
                  (C.type = B), (C.base = R[B]()), O.push(C);
                }
              return O;
            }),
            (i.exports = x.root());
        },
        6914: (i, s, o) => {
          const a = o(375),
            l = o(8571),
            c = o(3328);
          (s.compile = function (u, d) {
            if (typeof u == "string")
              return a(!d, "Cannot set single message string"), new c(u);
            if (c.isTemplate(u))
              return a(!d, "Cannot set single message template"), u;
            a(
              typeof u == "object" && !Array.isArray(u),
              "Invalid message options"
            ),
              (d = d ? l(d) : {});
            for (let f in u) {
              const h = u[f];
              if (f === "root" || c.isTemplate(h)) {
                d[f] = h;
                continue;
              }
              if (typeof h == "string") {
                d[f] = new c(h);
                continue;
              }
              a(
                typeof h == "object" && !Array.isArray(h),
                "Invalid message for",
                f
              );
              const p = f;
              for (f in ((d[p] = d[p] || {}), h)) {
                const g = h[f];
                f === "root" || c.isTemplate(g)
                  ? (d[p][f] = g)
                  : (a(typeof g == "string", "Invalid message for", f, "in", p),
                    (d[p][f] = new c(g)));
              }
            }
            return d;
          }),
            (s.decompile = function (u) {
              const d = {};
              for (let f in u) {
                const h = u[f];
                if (f === "root") {
                  d.root = h;
                  continue;
                }
                if (c.isTemplate(h)) {
                  d[f] = h.describe({ compact: !0 });
                  continue;
                }
                const p = f;
                for (f in ((d[p] = {}), h)) {
                  const g = h[f];
                  f !== "root"
                    ? (d[p][f] = g.describe({ compact: !0 }))
                    : (d[p].root = g);
                }
              }
              return d;
            }),
            (s.merge = function (u, d) {
              if (!u) return s.compile(d);
              if (!d) return u;
              if (typeof d == "string") return new c(d);
              if (c.isTemplate(d)) return d;
              const f = l(u);
              for (let h in d) {
                const p = d[h];
                if (h === "root" || c.isTemplate(p)) {
                  f[h] = p;
                  continue;
                }
                if (typeof p == "string") {
                  f[h] = new c(p);
                  continue;
                }
                a(
                  typeof p == "object" && !Array.isArray(p),
                  "Invalid message for",
                  h
                );
                const g = h;
                for (h in ((f[g] = f[g] || {}), p)) {
                  const b = p[h];
                  h === "root" || c.isTemplate(b)
                    ? (f[g][h] = b)
                    : (a(
                        typeof b == "string",
                        "Invalid message for",
                        h,
                        "in",
                        g
                      ),
                      (f[g][h] = new c(b)));
                }
              }
              return f;
            });
        },
        2294: (i, s, o) => {
          const a = o(375),
            l = o(8160),
            c = o(6133),
            u = {};
          (s.Ids = u.Ids =
            class {
              constructor() {
                (this._byId = new Map()),
                  (this._byKey = new Map()),
                  (this._schemaChain = !1);
              }
              clone() {
                const d = new u.Ids();
                return (
                  (d._byId = new Map(this._byId)),
                  (d._byKey = new Map(this._byKey)),
                  (d._schemaChain = this._schemaChain),
                  d
                );
              }
              concat(d) {
                d._schemaChain && (this._schemaChain = !0);
                for (const [f, h] of d._byId.entries())
                  a(
                    !this._byKey.has(f),
                    "Schema id conflicts with existing key:",
                    f
                  ),
                    this._byId.set(f, h);
                for (const [f, h] of d._byKey.entries())
                  a(
                    !this._byId.has(f),
                    "Schema key conflicts with existing id:",
                    f
                  ),
                    this._byKey.set(f, h);
              }
              fork(d, f, h) {
                const p = this._collect(d);
                p.push({ schema: h });
                const g = p.shift();
                let b = { id: g.id, schema: f(g.schema) };
                a(
                  l.isSchema(b.schema),
                  "adjuster function failed to return a joi schema type"
                );
                for (const v of p)
                  b = { id: v.id, schema: u.fork(v.schema, b.id, b.schema) };
                return b.schema;
              }
              labels(d) {
                let f =
                  arguments.length > 1 && arguments[1] !== void 0
                    ? arguments[1]
                    : [];
                const h = d[0],
                  p = this._get(h);
                if (!p) return [...f, ...d].join(".");
                const g = d.slice(1);
                return (
                  (f = [...f, p.schema._flags.label || h]),
                  g.length ? p.schema._ids.labels(g, f) : f.join(".")
                );
              }
              reach(d) {
                let f =
                  arguments.length > 1 && arguments[1] !== void 0
                    ? arguments[1]
                    : [];
                const h = d[0],
                  p = this._get(h);
                a(p, "Schema does not contain path", [...f, ...d].join("."));
                const g = d.slice(1);
                return g.length ? p.schema._ids.reach(g, [...f, h]) : p.schema;
              }
              register(d) {
                let { key: f } =
                  arguments.length > 1 && arguments[1] !== void 0
                    ? arguments[1]
                    : {};
                if (!d || !l.isSchema(d)) return;
                (d.$_property("schemaChain") || d._ids._schemaChain) &&
                  (this._schemaChain = !0);
                const h = d._flags.id;
                if (h) {
                  const p = this._byId.get(h);
                  a(
                    !p || p.schema === d,
                    "Cannot add different schemas with the same id:",
                    h
                  ),
                    a(
                      !this._byKey.has(h),
                      "Schema id conflicts with existing key:",
                      h
                    ),
                    this._byId.set(h, { schema: d, id: h });
                }
                f &&
                  (a(!this._byKey.has(f), "Schema already contains key:", f),
                  a(
                    !this._byId.has(f),
                    "Schema key conflicts with existing id:",
                    f
                  ),
                  this._byKey.set(f, { schema: d, id: f }));
              }
              reset() {
                (this._byId = new Map()),
                  (this._byKey = new Map()),
                  (this._schemaChain = !1);
              }
              _collect(d) {
                let f =
                    arguments.length > 1 && arguments[1] !== void 0
                      ? arguments[1]
                      : [],
                  h =
                    arguments.length > 2 && arguments[2] !== void 0
                      ? arguments[2]
                      : [];
                const p = d[0],
                  g = this._get(p);
                a(g, "Schema does not contain path", [...f, ...d].join(".")),
                  (h = [g, ...h]);
                const b = d.slice(1);
                return b.length ? g.schema._ids._collect(b, [...f, p], h) : h;
              }
              _get(d) {
                return this._byId.get(d) || this._byKey.get(d);
              }
            }),
            (u.fork = function (d, f, h) {
              const p = s.schema(d, {
                each: (g, b) => {
                  let { key: v } = b;
                  if (f === (g._flags.id || v)) return h;
                },
                ref: !1,
              });
              return p ? p.$_mutateRebuild() : d;
            }),
            (s.schema = function (d, f) {
              let h;
              for (const p in d._flags) {
                if (p[0] === "_") continue;
                const g = u.scan(d._flags[p], { source: "flags", name: p }, f);
                g !== void 0 && ((h = h || d.clone()), (h._flags[p] = g));
              }
              for (let p = 0; p < d._rules.length; ++p) {
                const g = d._rules[p],
                  b = u.scan(g.args, { source: "rules", name: g.name }, f);
                if (b !== void 0) {
                  h = h || d.clone();
                  const v = Object.assign({}, g);
                  (v.args = b),
                    (h._rules[p] = v),
                    h._singleRules.get(g.name) === g &&
                      h._singleRules.set(g.name, v);
                }
              }
              for (const p in d.$_terms) {
                if (p[0] === "_") continue;
                const g = u.scan(d.$_terms[p], { source: "terms", name: p }, f);
                g !== void 0 && ((h = h || d.clone()), (h.$_terms[p] = g));
              }
              return h;
            }),
            (u.scan = function (d, f, h, p, g) {
              const b = p || [];
              if (d === null || typeof d != "object") return;
              let v;
              if (Array.isArray(d)) {
                for (let w = 0; w < d.length; ++w) {
                  const x =
                      f.source === "terms" && f.name === "keys" && d[w].key,
                    S = u.scan(d[w], f, h, [w, ...b], x);
                  S !== void 0 && ((v = v || d.slice()), (v[w] = S));
                }
                return v;
              }
              if (
                (h.schema !== !1 && l.isSchema(d)) ||
                (h.ref !== !1 && c.isRef(d))
              ) {
                const w = h.each(d, { ...f, path: b, key: g });
                return w === d ? void 0 : w;
              }
              for (const w in d) {
                if (w[0] === "_") continue;
                const x = u.scan(d[w], f, h, [w, ...b], g);
                x !== void 0 && ((v = v || Object.assign({}, d)), (v[w] = x));
              }
              return v;
            });
        },
        6133: (i, s, o) => {
          const a = o(375),
            l = o(8571),
            c = o(9621),
            u = o(8160);
          let d;
          const f = {
            symbol: Symbol("ref"),
            defaults: {
              adjust: null,
              in: !1,
              iterables: null,
              map: null,
              separator: ".",
              type: "value",
            },
          };
          (s.create = function (h) {
            let p =
              arguments.length > 1 && arguments[1] !== void 0
                ? arguments[1]
                : {};
            a(typeof h == "string", "Invalid reference key:", h),
              u.assertOptions(p, [
                "adjust",
                "ancestor",
                "in",
                "iterables",
                "map",
                "prefix",
                "render",
                "separator",
              ]),
              a(
                !p.prefix || typeof p.prefix == "object",
                "options.prefix must be of type object"
              );
            const g = Object.assign({}, f.defaults, p);
            delete g.prefix;
            const b = g.separator,
              v = f.context(h, b, p.prefix);
            if (((g.type = v.type), (h = v.key), g.type === "value"))
              if (
                (v.root &&
                  (a(
                    !b || h[0] !== b,
                    "Cannot specify relative path with root prefix"
                  ),
                  (g.ancestor = "root"),
                  h || (h = null)),
                b && b === h)
              )
                (h = null), (g.ancestor = 0);
              else if (g.ancestor !== void 0)
                a(
                  !b || !h || h[0] !== b,
                  "Cannot combine prefix with ancestor option"
                );
              else {
                const [w, x] = f.ancestor(h, b);
                x && (h = h.slice(x)) === "" && (h = null), (g.ancestor = w);
              }
            return (
              (g.path = b ? (h === null ? [] : h.split(b)) : [h]), new f.Ref(g)
            );
          }),
            (s.in = function (h) {
              let p =
                arguments.length > 1 && arguments[1] !== void 0
                  ? arguments[1]
                  : {};
              return s.create(h, { ...p, in: !0 });
            }),
            (s.isRef = function (h) {
              return !!h && !!h[u.symbols.ref];
            }),
            (f.Ref = class {
              constructor(h) {
                a(typeof h == "object", "Invalid reference construction"),
                  u.assertOptions(h, [
                    "adjust",
                    "ancestor",
                    "in",
                    "iterables",
                    "map",
                    "path",
                    "render",
                    "separator",
                    "type",
                    "depth",
                    "key",
                    "root",
                    "display",
                  ]),
                  a(
                    [!1, void 0].includes(h.separator) ||
                      (typeof h.separator == "string" &&
                        h.separator.length === 1),
                    "Invalid separator"
                  ),
                  a(
                    !h.adjust || typeof h.adjust == "function",
                    "options.adjust must be a function"
                  ),
                  a(
                    !h.map || Array.isArray(h.map),
                    "options.map must be an array"
                  ),
                  a(
                    !h.map || !h.adjust,
                    "Cannot set both map and adjust options"
                  ),
                  Object.assign(this, f.defaults, h),
                  a(
                    this.type === "value" || this.ancestor === void 0,
                    "Non-value references cannot reference ancestors"
                  ),
                  Array.isArray(this.map) && (this.map = new Map(this.map)),
                  (this.depth = this.path.length),
                  (this.key = this.path.length
                    ? this.path.join(this.separator)
                    : null),
                  (this.root = this.path[0]),
                  this.updateDisplay();
              }
              resolve(h, p, g, b) {
                let v =
                  arguments.length > 4 && arguments[4] !== void 0
                    ? arguments[4]
                    : {};
                return (
                  a(!this.in || v.in, "Invalid in() reference usage"),
                  this.type === "global"
                    ? this._resolve(g.context, p, v)
                    : this.type === "local"
                    ? this._resolve(b, p, v)
                    : this.ancestor
                    ? this.ancestor === "root"
                      ? this._resolve(p.ancestors[p.ancestors.length - 1], p, v)
                      : (a(
                          this.ancestor <= p.ancestors.length,
                          "Invalid reference exceeds the schema root:",
                          this.display
                        ),
                        this._resolve(p.ancestors[this.ancestor - 1], p, v))
                    : this._resolve(h, p, v)
                );
              }
              _resolve(h, p, g) {
                let b;
                if (
                  (this.type === "value" &&
                    p.mainstay.shadow &&
                    g.shadow !== !1 &&
                    (b = p.mainstay.shadow.get(this.absolute(p))),
                  b === void 0 &&
                    (b = c(h, this.path, {
                      iterables: this.iterables,
                      functions: !0,
                    })),
                  this.adjust && (b = this.adjust(b)),
                  this.map)
                ) {
                  const v = this.map.get(b);
                  v !== void 0 && (b = v);
                }
                return p.mainstay && p.mainstay.tracer.resolve(p, this, b), b;
              }
              toString() {
                return this.display;
              }
              absolute(h) {
                return [...h.path.slice(0, -this.ancestor), ...this.path];
              }
              clone() {
                return new f.Ref(this);
              }
              describe() {
                const h = { path: this.path };
                this.type !== "value" && (h.type = this.type),
                  this.separator !== "." && (h.separator = this.separator),
                  this.type === "value" &&
                    this.ancestor !== 1 &&
                    (h.ancestor = this.ancestor),
                  this.map && (h.map = [...this.map]);
                for (const p of ["adjust", "iterables", "render"])
                  this[p] !== null && this[p] !== void 0 && (h[p] = this[p]);
                return this.in !== !1 && (h.in = !0), { ref: h };
              }
              updateDisplay() {
                const h = this.key !== null ? this.key : "";
                if (this.type !== "value")
                  return void (this.display = `ref:${this.type}:${h}`);
                if (!this.separator) return void (this.display = `ref:${h}`);
                if (!this.ancestor)
                  return void (this.display = `ref:${this.separator}${h}`);
                if (this.ancestor === "root")
                  return void (this.display = `ref:root:${h}`);
                if (this.ancestor === 1)
                  return void (this.display = `ref:${h || ".."}`);
                const p = new Array(this.ancestor + 1)
                  .fill(this.separator)
                  .join("");
                this.display = `ref:${p}${h || ""}`;
              }
            }),
            (f.Ref.prototype[u.symbols.ref] = !0),
            (s.build = function (h) {
              return (
                (h = Object.assign({}, f.defaults, h)).type === "value" &&
                  h.ancestor === void 0 &&
                  (h.ancestor = 1),
                new f.Ref(h)
              );
            }),
            (f.context = function (h, p) {
              let g =
                arguments.length > 2 && arguments[2] !== void 0
                  ? arguments[2]
                  : {};
              if (((h = h.trim()), g)) {
                const b = g.global === void 0 ? "$" : g.global;
                if (b !== p && h.startsWith(b))
                  return { key: h.slice(b.length), type: "global" };
                const v = g.local === void 0 ? "#" : g.local;
                if (v !== p && h.startsWith(v))
                  return { key: h.slice(v.length), type: "local" };
                const w = g.root === void 0 ? "/" : g.root;
                if (w !== p && h.startsWith(w))
                  return { key: h.slice(w.length), type: "value", root: !0 };
              }
              return { key: h, type: "value" };
            }),
            (f.ancestor = function (h, p) {
              if (!p) return [1, 0];
              if (h[0] !== p) return [1, 0];
              if (h[1] !== p) return [0, 1];
              let g = 2;
              for (; h[g] === p; ) ++g;
              return [g - 1, g];
            }),
            (s.toSibling = 0),
            (s.toParent = 1),
            (s.Manager = class {
              constructor() {
                this.refs = [];
              }
              register(h, p) {
                if (h)
                  if (((p = p === void 0 ? s.toParent : p), Array.isArray(h)))
                    for (const g of h) this.register(g, p);
                  else if (u.isSchema(h))
                    for (const g of h._refs.refs)
                      g.ancestor - p >= 0 &&
                        this.refs.push({
                          ancestor: g.ancestor - p,
                          root: g.root,
                        });
                  else
                    s.isRef(h) &&
                      h.type === "value" &&
                      h.ancestor - p >= 0 &&
                      this.refs.push({
                        ancestor: h.ancestor - p,
                        root: h.root,
                      }),
                      (d = d || o(3328)),
                      d.isTemplate(h) && this.register(h.refs(), p);
              }
              get length() {
                return this.refs.length;
              }
              clone() {
                const h = new s.Manager();
                return (h.refs = l(this.refs)), h;
              }
              reset() {
                this.refs = [];
              }
              roots() {
                return this.refs.filter((h) => !h.ancestor).map((h) => h.root);
              }
            });
        },
        3378: (i, s, o) => {
          const a = o(5107),
            l = {};
          (l.wrap = a.string().min(1).max(2).allow(!1)),
            (s.preferences = a
              .object({
                allowUnknown: a.boolean(),
                abortEarly: a.boolean(),
                artifacts: a.boolean(),
                cache: a.boolean(),
                context: a.object(),
                convert: a.boolean(),
                dateFormat: a.valid("date", "iso", "string", "time", "utc"),
                debug: a.boolean(),
                errors: {
                  escapeHtml: a.boolean(),
                  label: a.valid("path", "key", !1),
                  language: [a.string(), a.object().ref()],
                  render: a.boolean(),
                  stack: a.boolean(),
                  wrap: { label: l.wrap, array: l.wrap, string: l.wrap },
                },
                externals: a.boolean(),
                messages: a.object(),
                noDefaults: a.boolean(),
                nonEnumerables: a.boolean(),
                presence: a.valid("required", "optional", "forbidden"),
                skipFunctions: a.boolean(),
                stripUnknown: a
                  .object({ arrays: a.boolean(), objects: a.boolean() })
                  .or("arrays", "objects")
                  .allow(!0, !1),
                warnings: a.boolean(),
              })
              .strict()),
            (l.nameRx = /^[a-zA-Z0-9]\w*$/),
            (l.rule = a.object({
              alias: a.array().items(a.string().pattern(l.nameRx)).single(),
              args: a
                .array()
                .items(
                  a.string(),
                  a.object({
                    name: a.string().pattern(l.nameRx).required(),
                    ref: a.boolean(),
                    assert: a
                      .alternatives([a.function(), a.object().schema()])
                      .conditional("ref", { is: !0, then: a.required() }),
                    normalize: a.function(),
                    message: a
                      .string()
                      .when("assert", { is: a.function(), then: a.required() }),
                  })
                ),
              convert: a.boolean(),
              manifest: a.boolean(),
              method: a.function().allow(!1),
              multi: a.boolean(),
              validate: a.function(),
            })),
            (s.extension = a
              .object({
                type: a
                  .alternatives([a.string(), a.object().regex()])
                  .required(),
                args: a.function(),
                cast: a
                  .object()
                  .pattern(
                    l.nameRx,
                    a.object({
                      from: a.function().maxArity(1).required(),
                      to: a.function().minArity(1).maxArity(2).required(),
                    })
                  ),
                base: a
                  .object()
                  .schema()
                  .when("type", {
                    is: a.object().regex(),
                    then: a.forbidden(),
                  }),
                coerce: [
                  a.function().maxArity(3),
                  a.object({
                    method: a.function().maxArity(3).required(),
                    from: a.array().items(a.string()).single(),
                  }),
                ],
                flags: a
                  .object()
                  .pattern(
                    l.nameRx,
                    a.object({ setter: a.string(), default: a.any() })
                  ),
                manifest: { build: a.function().arity(2) },
                messages: [a.object(), a.string()],
                modifiers: a
                  .object()
                  .pattern(l.nameRx, a.function().minArity(1).maxArity(2)),
                overrides: a.object().pattern(l.nameRx, a.function()),
                prepare: a.function().maxArity(3),
                rebuild: a.function().arity(1),
                rules: a.object().pattern(l.nameRx, l.rule),
                terms: a
                  .object()
                  .pattern(
                    l.nameRx,
                    a.object({
                      init: a.array().allow(null).required(),
                      manifest: a
                        .object()
                        .pattern(/.+/, [
                          a.valid("schema", "single"),
                          a.object({
                            mapped: a
                              .object({
                                from: a.string().required(),
                                to: a.string().required(),
                              })
                              .required(),
                          }),
                        ]),
                    })
                  ),
                validate: a.function().maxArity(3),
              })
              .strict()),
            (s.extensions = a
              .array()
              .items(a.object(), a.function().arity(1))
              .strict()),
            (l.desc = {
              buffer: a.object({ buffer: a.string() }),
              func: a.object({
                function: a.function().required(),
                options: { literal: !0 },
              }),
              override: a.object({ override: !0 }),
              ref: a.object({
                ref: a
                  .object({
                    type: a.valid("value", "global", "local"),
                    path: a.array().required(),
                    separator: a.string().length(1).allow(!1),
                    ancestor: a.number().min(0).integer().allow("root"),
                    map: a.array().items(a.array().length(2)).min(1),
                    adjust: a.function(),
                    iterables: a.boolean(),
                    in: a.boolean(),
                    render: a.boolean(),
                  })
                  .required(),
              }),
              regex: a.object({ regex: a.string().min(3) }),
              special: a.object({ special: a.valid("deep").required() }),
              template: a.object({
                template: a.string().required(),
                options: a.object(),
              }),
              value: a.object({
                value: a.alternatives([a.object(), a.array()]).required(),
              }),
            }),
            (l.desc.entity = a.alternatives([
              a.array().items(a.link("...")),
              a.boolean(),
              a.function(),
              a.number(),
              a.string(),
              l.desc.buffer,
              l.desc.func,
              l.desc.ref,
              l.desc.regex,
              l.desc.special,
              l.desc.template,
              l.desc.value,
              a.link("/"),
            ])),
            (l.desc.values = a
              .array()
              .items(
                null,
                a.boolean(),
                a.function(),
                a.number().allow(1 / 0, -1 / 0),
                a.string().allow(""),
                a.symbol(),
                l.desc.buffer,
                l.desc.func,
                l.desc.override,
                l.desc.ref,
                l.desc.regex,
                l.desc.template,
                l.desc.value
              )),
            (l.desc.messages = a
              .object()
              .pattern(/.+/, [
                a.string(),
                l.desc.template,
                a.object().pattern(/.+/, [a.string(), l.desc.template]),
              ])),
            (s.description = a
              .object({
                type: a.string().required(),
                flags: a
                  .object({
                    cast: a.string(),
                    default: a.any(),
                    description: a.string(),
                    empty: a.link("/"),
                    failover: l.desc.entity,
                    id: a.string(),
                    label: a.string(),
                    only: !0,
                    presence: ["optional", "required", "forbidden"],
                    result: ["raw", "strip"],
                    strip: a.boolean(),
                    unit: a.string(),
                  })
                  .unknown(),
                preferences: {
                  allowUnknown: a.boolean(),
                  abortEarly: a.boolean(),
                  artifacts: a.boolean(),
                  cache: a.boolean(),
                  convert: a.boolean(),
                  dateFormat: ["date", "iso", "string", "time", "utc"],
                  errors: {
                    escapeHtml: a.boolean(),
                    label: ["path", "key"],
                    language: [a.string(), l.desc.ref],
                    wrap: { label: l.wrap, array: l.wrap },
                  },
                  externals: a.boolean(),
                  messages: l.desc.messages,
                  noDefaults: a.boolean(),
                  nonEnumerables: a.boolean(),
                  presence: ["required", "optional", "forbidden"],
                  skipFunctions: a.boolean(),
                  stripUnknown: a
                    .object({ arrays: a.boolean(), objects: a.boolean() })
                    .or("arrays", "objects")
                    .allow(!0, !1),
                  warnings: a.boolean(),
                },
                allow: l.desc.values,
                invalid: l.desc.values,
                rules: a
                  .array()
                  .min(1)
                  .items({
                    name: a.string().required(),
                    args: a.object().min(1),
                    keep: a.boolean(),
                    message: [a.string(), l.desc.messages],
                    warn: a.boolean(),
                  }),
                keys: a.object().pattern(/.*/, a.link("/")),
                link: l.desc.ref,
              })
              .pattern(/^[a-z]\w*$/, a.any()));
        },
        493: (i, s, o) => {
          const a = o(8571),
            l = o(9621),
            c = o(8160),
            u = { value: Symbol("value") };
          (i.exports = u.State =
            class {
              constructor(d, f, h) {
                (this.path = d),
                  (this.ancestors = f),
                  (this.mainstay = h.mainstay),
                  (this.schemas = h.schemas),
                  (this.debug = null);
              }
              localize(d) {
                let f =
                    arguments.length > 1 && arguments[1] !== void 0
                      ? arguments[1]
                      : null,
                  h =
                    arguments.length > 2 && arguments[2] !== void 0
                      ? arguments[2]
                      : null;
                const p = new u.State(d, f, this);
                return (
                  h && p.schemas && (p.schemas = [u.schemas(h), ...p.schemas]),
                  p
                );
              }
              nest(d, f) {
                const h = new u.State(this.path, this.ancestors, this);
                return (
                  (h.schemas = h.schemas && [u.schemas(d), ...h.schemas]),
                  (h.debug = f),
                  h
                );
              }
              shadow(d, f) {
                (this.mainstay.shadow = this.mainstay.shadow || new u.Shadow()),
                  this.mainstay.shadow.set(this.path, d, f);
              }
              snapshot() {
                this.mainstay.shadow &&
                  (this._snapshot = a(this.mainstay.shadow.node(this.path))),
                  this.mainstay.snapshot();
              }
              restore() {
                this.mainstay.shadow &&
                  (this.mainstay.shadow.override(this.path, this._snapshot),
                  (this._snapshot = void 0)),
                  this.mainstay.restore();
              }
            }),
            (u.schemas = function (d) {
              return c.isSchema(d) ? { schema: d } : d;
            }),
            (u.Shadow = class {
              constructor() {
                this._values = null;
              }
              set(d, f, h) {
                if (
                  !d.length ||
                  (h === "strip" && typeof d[d.length - 1] == "number")
                )
                  return;
                this._values = this._values || new Map();
                let p = this._values;
                for (let g = 0; g < d.length; ++g) {
                  const b = d[g];
                  let v = p.get(b);
                  v || ((v = new Map()), p.set(b, v)), (p = v);
                }
                p[u.value] = f;
              }
              get(d) {
                const f = this.node(d);
                if (f) return f[u.value];
              }
              node(d) {
                if (this._values) return l(this._values, d, { iterables: !0 });
              }
              override(d, f) {
                if (!this._values) return;
                const h = d.slice(0, -1),
                  p = d[d.length - 1],
                  g = l(this._values, h, { iterables: !0 });
                f ? g.set(p, f) : g && g.delete(p);
              }
            });
        },
        3328: (i, s, o) => {
          const a = o(375),
            l = o(8571),
            c = o(5277),
            u = o(1447),
            d = o(8160),
            f = o(6354),
            h = o(6133),
            p = {
              symbol: Symbol("template"),
              opens: new Array(1e3).join("\0"),
              closes: new Array(1e3).join(""),
              dateFormat: {
                date: Date.prototype.toDateString,
                iso: Date.prototype.toISOString,
                string: Date.prototype.toString,
                time: Date.prototype.toTimeString,
                utc: Date.prototype.toUTCString,
              },
            };
          (i.exports = p.Template =
            class {
              constructor(g, b) {
                a(typeof g == "string", "Template source must be a string"),
                  a(
                    !g.includes("\0") && !g.includes(""),
                    "Template source cannot contain reserved control characters"
                  ),
                  (this.source = g),
                  (this.rendered = g),
                  (this._template = null),
                  (this._settings = l(b)),
                  this._parse();
              }
              _parse() {
                if (!this.source.includes("{")) return;
                const g = p.encode(this.source),
                  b = p.split(g);
                let v = !1;
                const w = [],
                  x = b.shift();
                x && w.push(x);
                for (const S of b) {
                  const R = S[0] !== "{",
                    O = R ? "}" : "}}",
                    B = S.indexOf(O);
                  if (B === -1 || S[1] === "{") {
                    w.push(`{${p.decode(S)}`);
                    continue;
                  }
                  let C = S.slice(R ? 0 : 1, B);
                  const I = C[0] === ":";
                  I && (C = C.slice(1));
                  const P = this._ref(p.decode(C), { raw: R, wrapped: I });
                  w.push(P), typeof P != "string" && (v = !0);
                  const M = S.slice(B + O.length);
                  M && w.push(p.decode(M));
                }
                v ? (this._template = w) : (this.rendered = w.join(""));
              }
              static date(g, b) {
                return p.dateFormat[b.dateFormat].call(g);
              }
              describe() {
                let g =
                  arguments.length > 0 && arguments[0] !== void 0
                    ? arguments[0]
                    : {};
                if (!this._settings && g.compact) return this.source;
                const b = { template: this.source };
                return this._settings && (b.options = this._settings), b;
              }
              static build(g) {
                return new p.Template(g.template, g.options);
              }
              isDynamic() {
                return !!this._template;
              }
              static isTemplate(g) {
                return !!g && !!g[d.symbols.template];
              }
              refs() {
                if (!this._template) return;
                const g = [];
                for (const b of this._template)
                  typeof b != "string" && g.push(...b.refs);
                return g;
              }
              resolve(g, b, v, w) {
                return this._template && this._template.length === 1
                  ? this._part(this._template[0], g, b, v, w, {})
                  : this.render(g, b, v, w);
              }
              _part(g) {
                for (
                  var b = arguments.length,
                    v = new Array(b > 1 ? b - 1 : 0),
                    w = 1;
                  w < b;
                  w++
                )
                  v[w - 1] = arguments[w];
                return g.ref ? g.ref.resolve(...v) : g.formula.evaluate(v);
              }
              render(g, b, v, w) {
                let x =
                  arguments.length > 4 && arguments[4] !== void 0
                    ? arguments[4]
                    : {};
                if (!this.isDynamic()) return this.rendered;
                const S = [];
                for (const R of this._template)
                  if (typeof R == "string") S.push(R);
                  else {
                    const O = this._part(R, g, b, v, w, x),
                      B = p.stringify(O, g, b, v, w, x);
                    if (B !== void 0) {
                      const C =
                        R.raw || (x.errors && x.errors.escapeHtml) === !1
                          ? B
                          : c(B);
                      S.push(p.wrap(C, R.wrapped && v.errors.wrap.label));
                    }
                  }
                return S.join("");
              }
              _ref(g, b) {
                let { raw: v, wrapped: w } = b;
                const x = [],
                  S = (O) => {
                    const B = h.create(O, this._settings);
                    return x.push(B), (C) => B.resolve(...C);
                  };
                try {
                  var R = new u.Parser(g, {
                    reference: S,
                    functions: p.functions,
                    constants: p.constants,
                  });
                } catch (O) {
                  throw (
                    ((O.message = `Invalid template variable "${g}" fails due to: ${O.message}`),
                    O)
                  );
                }
                if (R.single) {
                  if (R.single.type === "reference") {
                    const O = x[0];
                    return {
                      ref: O,
                      raw: v,
                      refs: x,
                      wrapped: w || (O.type === "local" && O.key === "label"),
                    };
                  }
                  return p.stringify(R.single.value);
                }
                return { formula: R, raw: v, refs: x };
              }
              toString() {
                return this.source;
              }
            }),
            (p.Template.prototype[d.symbols.template] = !0),
            (p.Template.prototype.isImmutable = !0),
            (p.encode = function (g) {
              return g
                .replace(/\\(\{+)/g, (b, v) => p.opens.slice(0, v.length))
                .replace(/\\(\}+)/g, (b, v) => p.closes.slice(0, v.length));
            }),
            (p.decode = function (g) {
              return g.replace(/\u0000/g, "{").replace(/\u0001/g, "}");
            }),
            (p.split = function (g) {
              const b = [];
              let v = "";
              for (let w = 0; w < g.length; ++w) {
                const x = g[w];
                if (x === "{") {
                  let S = "";
                  for (; w + 1 < g.length && g[w + 1] === "{"; )
                    (S += "{"), ++w;
                  b.push(v), (v = S);
                } else v += x;
              }
              return b.push(v), b;
            }),
            (p.wrap = function (g, b) {
              return b
                ? b.length === 1
                  ? `${b}${g}${b}`
                  : `${b[0]}${g}${b[1]}`
                : g;
            }),
            (p.stringify = function (g, b, v, w, x) {
              let S =
                arguments.length > 5 && arguments[5] !== void 0
                  ? arguments[5]
                  : {};
              const R = typeof g,
                O = (w && w.errors && w.errors.wrap) || {};
              let B = !1;
              if (
                (h.isRef(g) &&
                  g.render &&
                  ((B = g.in), (g = g.resolve(b, v, w, x, { in: g.in, ...S }))),
                g === null)
              )
                return "null";
              if (R === "string") return p.wrap(g, S.arrayItems && O.string);
              if (R === "number" || R === "function" || R === "symbol")
                return g.toString();
              if (R !== "object") return JSON.stringify(g);
              if (g instanceof Date) return p.Template.date(g, w);
              if (g instanceof Map) {
                const I = [];
                for (const [P, M] of g.entries())
                  I.push(`${P.toString()} -> ${M.toString()}`);
                g = I;
              }
              if (!Array.isArray(g)) return g.toString();
              const C = [];
              for (const I of g)
                C.push(p.stringify(I, b, v, w, x, { arrayItems: !0, ...S }));
              return p.wrap(C.join(", "), !B && O.array);
            }),
            (p.constants = {
              true: !0,
              false: !1,
              null: null,
              second: 1e3,
              minute: 6e4,
              hour: 36e5,
              day: 864e5,
            }),
            (p.functions = {
              if: (g, b, v) => (g ? b : v),
              length: (g) =>
                typeof g == "string"
                  ? g.length
                  : g && typeof g == "object"
                  ? Array.isArray(g)
                    ? g.length
                    : Object.keys(g).length
                  : null,
              msg(g) {
                const [b, v, w, x, S] = this,
                  R = S.messages;
                if (!R) return "";
                const O =
                  f.template(b, R[0], g, v, w) || f.template(b, R[1], g, v, w);
                return O ? O.render(b, v, w, x, S) : "";
              },
              number: (g) =>
                typeof g == "number"
                  ? g
                  : typeof g == "string"
                  ? parseFloat(g)
                  : typeof g == "boolean"
                  ? g
                    ? 1
                    : 0
                  : g instanceof Date
                  ? g.getTime()
                  : null,
            });
        },
        4946: (i, s, o) => {
          const a = o(375),
            l = o(1687),
            c = o(8068),
            u = o(8160),
            d = o(3292),
            f = o(6354),
            h = o(6133),
            p = {};
          (i.exports = c.extend({
            type: "alternatives",
            flags: { match: { default: "any" } },
            terms: { matches: { init: [], register: h.toSibling } },
            args(g) {
              for (
                var b = arguments.length,
                  v = new Array(b > 1 ? b - 1 : 0),
                  w = 1;
                w < b;
                w++
              )
                v[w - 1] = arguments[w];
              return v.length === 1 && Array.isArray(v[0])
                ? g.try(...v[0])
                : g.try(...v);
            },
            validate(g, b) {
              const { schema: v, error: w, state: x, prefs: S } = b;
              if (v._flags.match) {
                const O = [],
                  B = [];
                for (let I = 0; I < v.$_terms.matches.length; ++I) {
                  const P = v.$_terms.matches[I],
                    M = x.nest(P.schema, `match.${I}`);
                  M.snapshot();
                  const k = P.schema.$_validate(g, M, S);
                  k.errors ? (B.push(k.errors), M.restore()) : O.push(k.value);
                }
                if (O.length === 0)
                  return {
                    errors: w("alternatives.any", {
                      details: B.map((I) => f.details(I, { override: !1 })),
                    }),
                  };
                if (v._flags.match === "one")
                  return O.length === 1
                    ? { value: O[0] }
                    : { errors: w("alternatives.one") };
                if (O.length !== v.$_terms.matches.length)
                  return {
                    errors: w("alternatives.all", {
                      details: B.map((I) => f.details(I, { override: !1 })),
                    }),
                  };
                const C = (I) =>
                  I.$_terms.matches.some(
                    (P) =>
                      P.schema.type === "object" ||
                      (P.schema.type === "alternatives" && C(P.schema))
                  );
                return C(v)
                  ? { value: O.reduce((I, P) => l(I, P, { mergeArrays: !1 })) }
                  : { value: O[O.length - 1] };
              }
              const R = [];
              for (let O = 0; O < v.$_terms.matches.length; ++O) {
                const B = v.$_terms.matches[O];
                if (B.schema) {
                  const P = x.nest(B.schema, `match.${O}`);
                  P.snapshot();
                  const M = B.schema.$_validate(g, P, S);
                  if (!M.errors) return M;
                  P.restore(), R.push({ schema: B.schema, reports: M.errors });
                  continue;
                }
                const C = B.ref ? B.ref.resolve(g, x, S) : g,
                  I = B.is ? [B] : B.switch;
                for (let P = 0; P < I.length; ++P) {
                  const M = I[P],
                    { is: k, then: T, otherwise: _ } = M,
                    A = `match.${O}${B.switch ? "." + P : ""}`;
                  if (k.$_match(C, x.nest(k, `${A}.is`), S)) {
                    if (T) return T.$_validate(g, x.nest(T, `${A}.then`), S);
                  } else if (_)
                    return _.$_validate(g, x.nest(_, `${A}.otherwise`), S);
                }
              }
              return p.errors(R, b);
            },
            rules: {
              conditional: {
                method(g, b) {
                  a(!this._flags._endedSwitch, "Unreachable condition"),
                    a(
                      !this._flags.match,
                      "Cannot combine match mode",
                      this._flags.match,
                      "with conditional rule"
                    ),
                    a(
                      b.break === void 0,
                      "Cannot use break option with alternatives conditional"
                    );
                  const v = this.clone(),
                    w = d.when(v, g, b),
                    x = w.is ? [w] : w.switch;
                  for (const S of x)
                    if (S.then && S.otherwise) {
                      v.$_setFlag("_endedSwitch", !0, { clone: !1 });
                      break;
                    }
                  return v.$_terms.matches.push(w), v.$_mutateRebuild();
                },
              },
              match: {
                method(g) {
                  if (
                    (a(
                      ["any", "one", "all"].includes(g),
                      "Invalid alternatives match mode",
                      g
                    ),
                    g !== "any")
                  )
                    for (const b of this.$_terms.matches)
                      a(
                        b.schema,
                        "Cannot combine match mode",
                        g,
                        "with conditional rules"
                      );
                  return this.$_setFlag("match", g);
                },
              },
              try: {
                method() {
                  for (
                    var g = arguments.length, b = new Array(g), v = 0;
                    v < g;
                    v++
                  )
                    b[v] = arguments[v];
                  a(b.length, "Missing alternative schemas"),
                    u.verifyFlat(b, "try"),
                    a(!this._flags._endedSwitch, "Unreachable condition");
                  const w = this.clone();
                  for (const x of b)
                    w.$_terms.matches.push({ schema: w.$_compile(x) });
                  return w.$_mutateRebuild();
                },
              },
            },
            overrides: {
              label(g) {
                return this.$_parent("label", g).$_modify({
                  each: (b, v) => (v.path[0] !== "is" ? b.label(g) : void 0),
                  ref: !1,
                });
              },
            },
            rebuild(g) {
              g.$_modify({
                each: (b) => {
                  u.isSchema(b) &&
                    b.type === "array" &&
                    g.$_setFlag("_arrayItems", !0, { clone: !1 });
                },
              });
            },
            manifest: {
              build(g, b) {
                if (b.matches)
                  for (const v of b.matches) {
                    const {
                      schema: w,
                      ref: x,
                      is: S,
                      not: R,
                      then: O,
                      otherwise: B,
                    } = v;
                    g = w
                      ? g.try(w)
                      : x
                      ? g.conditional(x, {
                          is: S,
                          then: O,
                          not: R,
                          otherwise: B,
                          switch: v.switch,
                        })
                      : g.conditional(S, { then: O, otherwise: B });
                  }
                return g;
              },
            },
            messages: {
              "alternatives.all":
                "{{#label}} does not match all of the required types",
              "alternatives.any":
                "{{#label}} does not match any of the allowed types",
              "alternatives.match":
                "{{#label}} does not match any of the allowed types",
              "alternatives.one":
                "{{#label}} matches more than one allowed type",
              "alternatives.types": "{{#label}} must be one of {{#types}}",
            },
          })),
            (p.errors = function (g, b) {
              let { error: v, state: w } = b;
              if (!g.length) return { errors: v("alternatives.any") };
              if (g.length === 1) return { errors: g[0].reports };
              const x = new Set(),
                S = [];
              for (const { reports: R, schema: O } of g) {
                if (R.length > 1) return p.unmatched(g, v);
                const B = R[0];
                if (B instanceof f.Report == 0) return p.unmatched(g, v);
                if (B.state.path.length !== w.path.length) {
                  S.push({ type: O.type, report: B });
                  continue;
                }
                if (B.code === "any.only") {
                  for (const P of B.local.valids) x.add(P);
                  continue;
                }
                const [C, I] = B.code.split(".");
                I === "base" ? x.add(C) : S.push({ type: O.type, report: B });
              }
              return S.length
                ? S.length === 1
                  ? { errors: S[0].report }
                  : p.unmatched(g, v)
                : { errors: v("alternatives.types", { types: [...x] }) };
            }),
            (p.unmatched = function (g, b) {
              const v = [];
              for (const w of g) v.push(...w.reports);
              return {
                errors: b("alternatives.match", f.details(v, { override: !1 })),
              };
            });
        },
        8068: (i, s, o) => {
          const a = o(375),
            l = o(7629),
            c = o(8160),
            u = o(6914);
          i.exports = l.extend({
            type: "any",
            flags: { only: { default: !1 } },
            terms: {
              alterations: { init: null },
              examples: { init: null },
              externals: { init: null },
              metas: { init: [] },
              notes: { init: [] },
              shared: { init: null },
              tags: { init: [] },
              whens: { init: null },
            },
            rules: {
              custom: {
                method(d, f) {
                  return (
                    a(typeof d == "function", "Method must be a function"),
                    a(
                      f === void 0 || (f && typeof f == "string"),
                      "Description must be a non-empty string"
                    ),
                    this.$_addRule({
                      name: "custom",
                      args: { method: d, description: f },
                    })
                  );
                },
                validate(d, f, h) {
                  let { method: p } = h;
                  try {
                    return p(d, f);
                  } catch (g) {
                    return f.error("any.custom", { error: g });
                  }
                },
                args: ["method", "description"],
                multi: !0,
              },
              messages: {
                method(d) {
                  return this.prefs({ messages: d });
                },
              },
              shared: {
                method(d) {
                  a(
                    c.isSchema(d) && d._flags.id,
                    "Schema must be a schema with an id"
                  );
                  const f = this.clone();
                  return (
                    (f.$_terms.shared = f.$_terms.shared || []),
                    f.$_terms.shared.push(d),
                    f.$_mutateRegister(d),
                    f
                  );
                },
              },
              warning: {
                method(d, f) {
                  return (
                    a(d && typeof d == "string", "Invalid warning code"),
                    this.$_addRule({
                      name: "warning",
                      args: { code: d, local: f },
                      warn: !0,
                    })
                  );
                },
                validate(d, f, h) {
                  let { code: p, local: g } = h;
                  return f.error(p, g);
                },
                args: ["code", "local"],
                multi: !0,
              },
            },
            modifiers: {
              keep(d) {
                let f =
                  !(arguments.length > 1 && arguments[1] !== void 0) ||
                  arguments[1];
                d.keep = f;
              },
              message(d, f) {
                d.message = u.compile(f);
              },
              warn(d) {
                let f =
                  !(arguments.length > 1 && arguments[1] !== void 0) ||
                  arguments[1];
                d.warn = f;
              },
            },
            manifest: {
              build(d, f) {
                for (const h in f) {
                  const p = f[h];
                  if (
                    [
                      "examples",
                      "externals",
                      "metas",
                      "notes",
                      "tags",
                    ].includes(h)
                  )
                    for (const g of p) d = d[h.slice(0, -1)](g);
                  else if (h !== "alterations")
                    if (h !== "whens") {
                      if (h === "shared") for (const g of p) d = d.shared(g);
                    } else
                      for (const g of p) {
                        const {
                          ref: b,
                          is: v,
                          not: w,
                          then: x,
                          otherwise: S,
                          concat: R,
                        } = g;
                        d = R
                          ? d.concat(R)
                          : b
                          ? d.when(b, {
                              is: v,
                              not: w,
                              then: x,
                              otherwise: S,
                              switch: g.switch,
                              break: g.break,
                            })
                          : d.when(v, {
                              then: x,
                              otherwise: S,
                              break: g.break,
                            });
                      }
                  else {
                    const g = {};
                    for (const { target: b, adjuster: v } of p) g[b] = v;
                    d = d.alter(g);
                  }
                }
                return d;
              },
            },
            messages: {
              "any.custom":
                "{{#label}} failed custom validation because {{#error.message}}",
              "any.default":
                "{{#label}} threw an error when running default method",
              "any.failover":
                "{{#label}} threw an error when running failover method",
              "any.invalid": "{{#label}} contains an invalid value",
              "any.only":
                '{{#label}} must be {if(#valids.length == 1, "", "one of ")}{{#valids}}',
              "any.ref":
                "{{#label}} {{#arg}} references {{:#ref}} which {{#reason}}",
              "any.required": "{{#label}} is required",
              "any.unknown": "{{#label}} is not allowed",
            },
          });
        },
        546: (i, s, o) => {
          const a = o(375),
            l = o(9474),
            c = o(9621),
            u = o(8068),
            d = o(8160),
            f = o(3292),
            h = {};
          (i.exports = u.extend({
            type: "array",
            flags: { single: { default: !1 }, sparse: { default: !1 } },
            terms: {
              items: { init: [], manifest: "schema" },
              ordered: { init: [], manifest: "schema" },
              _exclusions: { init: [] },
              _inclusions: { init: [] },
              _requireds: { init: [] },
            },
            coerce: {
              from: "object",
              method(p, g) {
                let { schema: b, state: v, prefs: w } = g;
                if (!Array.isArray(p)) return;
                const x = b.$_getRule("sort");
                return x ? h.sort(b, p, x.args.options, v, w) : void 0;
              },
            },
            validate(p, g) {
              let { schema: b, error: v } = g;
              if (!Array.isArray(p)) {
                if (b._flags.single) {
                  const w = [p];
                  return (w[d.symbols.arraySingle] = !0), { value: w };
                }
                return { errors: v("array.base") };
              }
              if (b.$_getRule("items") || b.$_terms.externals)
                return { value: p.slice() };
            },
            rules: {
              has: {
                method(p) {
                  p = this.$_compile(p, { appendPath: !0 });
                  const g = this.$_addRule({
                    name: "has",
                    args: { schema: p },
                  });
                  return g.$_mutateRegister(p), g;
                },
                validate(p, g, b) {
                  let { state: v, prefs: w, error: x } = g,
                    { schema: S } = b;
                  const R = [p, ...v.ancestors];
                  for (let B = 0; B < p.length; ++B) {
                    const C = v.localize([...v.path, B], R, S);
                    if (S.$_match(p[B], C, w)) return p;
                  }
                  const O = S._flags.label;
                  return O
                    ? x("array.hasKnown", { patternLabel: O })
                    : x("array.hasUnknown", null);
                },
                multi: !0,
              },
              items: {
                method() {
                  for (
                    var p = arguments.length, g = new Array(p), b = 0;
                    b < p;
                    b++
                  )
                    g[b] = arguments[b];
                  d.verifyFlat(g, "items");
                  const v = this.$_addRule("items");
                  for (let w = 0; w < g.length; ++w) {
                    const x = d.tryWithPath(() => this.$_compile(g[w]), w, {
                      append: !0,
                    });
                    v.$_terms.items.push(x);
                  }
                  return v.$_mutateRebuild();
                },
                validate(p, g) {
                  let {
                    schema: b,
                    error: v,
                    state: w,
                    prefs: x,
                    errorsArray: S,
                  } = g;
                  const R = b.$_terms._requireds.slice(),
                    O = b.$_terms.ordered.slice(),
                    B = [...b.$_terms._inclusions, ...R],
                    C = !p[d.symbols.arraySingle];
                  delete p[d.symbols.arraySingle];
                  const I = S();
                  let P = p.length;
                  for (let M = 0; M < P; ++M) {
                    const k = p[M];
                    let T = !1,
                      _ = !1;
                    const A = C ? M : new Number(M),
                      N = [...w.path, A];
                    if (!b._flags.sparse && k === void 0) {
                      if (
                        (I.push(
                          v(
                            "array.sparse",
                            { key: A, path: N, pos: M, value: void 0 },
                            w.localize(N)
                          )
                        ),
                        x.abortEarly)
                      )
                        return I;
                      O.shift();
                      continue;
                    }
                    const L = [p, ...w.ancestors];
                    for (const z of b.$_terms._exclusions)
                      if (
                        z.$_match(k, w.localize(N, L, z), x, {
                          presence: "ignore",
                        })
                      ) {
                        if (
                          (I.push(
                            v(
                              "array.excludes",
                              { pos: M, value: k },
                              w.localize(N)
                            )
                          ),
                          x.abortEarly)
                        )
                          return I;
                        (T = !0), O.shift();
                        break;
                      }
                    if (T) continue;
                    if (b.$_terms.ordered.length) {
                      if (O.length) {
                        const z = O.shift(),
                          $ = z.$_validate(k, w.localize(N, L, z), x);
                        if ($.errors) {
                          if ((I.push(...$.errors), x.abortEarly)) return I;
                        } else if (z._flags.result === "strip")
                          h.fastSplice(p, M), --M, --P;
                        else {
                          if (!b._flags.sparse && $.value === void 0) {
                            if (
                              (I.push(
                                v(
                                  "array.sparse",
                                  { key: A, path: N, pos: M, value: void 0 },
                                  w.localize(N)
                                )
                              ),
                              x.abortEarly)
                            )
                              return I;
                            continue;
                          }
                          p[M] = $.value;
                        }
                        continue;
                      }
                      if (!b.$_terms.items.length) {
                        if (
                          (I.push(
                            v("array.orderedLength", {
                              pos: M,
                              limit: b.$_terms.ordered.length,
                            })
                          ),
                          x.abortEarly)
                        )
                          return I;
                        break;
                      }
                    }
                    const F = [];
                    let D = R.length;
                    for (let z = 0; z < D; ++z) {
                      const $ = w.localize(N, L, R[z]);
                      $.snapshot();
                      const K = R[z].$_validate(k, $, x);
                      if (((F[z] = K), !K.errors)) {
                        if (
                          ((p[M] = K.value),
                          (_ = !0),
                          h.fastSplice(R, z),
                          --z,
                          --D,
                          !b._flags.sparse &&
                            K.value === void 0 &&
                            (I.push(
                              v(
                                "array.sparse",
                                { key: A, path: N, pos: M, value: void 0 },
                                w.localize(N)
                              )
                            ),
                            x.abortEarly))
                        )
                          return I;
                        break;
                      }
                      $.restore();
                    }
                    if (_) continue;
                    const j = (x.stripUnknown && !!x.stripUnknown.arrays) || !1;
                    D = B.length;
                    for (const z of B) {
                      let $;
                      const K = R.indexOf(z);
                      if (K !== -1) $ = F[K];
                      else {
                        const re = w.localize(N, L, z);
                        if (
                          (re.snapshot(),
                          ($ = z.$_validate(k, re, x)),
                          !$.errors)
                        ) {
                          z._flags.result === "strip"
                            ? (h.fastSplice(p, M), --M, --P)
                            : b._flags.sparse || $.value !== void 0
                            ? (p[M] = $.value)
                            : (I.push(
                                v(
                                  "array.sparse",
                                  { key: A, path: N, pos: M, value: void 0 },
                                  w.localize(N)
                                )
                              ),
                              (T = !0)),
                            (_ = !0);
                          break;
                        }
                        re.restore();
                      }
                      if (D === 1) {
                        if (j) {
                          h.fastSplice(p, M), --M, --P, (_ = !0);
                          break;
                        }
                        if ((I.push(...$.errors), x.abortEarly)) return I;
                        T = !0;
                        break;
                      }
                    }
                    if (
                      !T &&
                      (b.$_terms._inclusions.length ||
                        b.$_terms._requireds.length) &&
                      !_
                    ) {
                      if (j) {
                        h.fastSplice(p, M), --M, --P;
                        continue;
                      }
                      if (
                        (I.push(
                          v(
                            "array.includes",
                            { pos: M, value: k },
                            w.localize(N)
                          )
                        ),
                        x.abortEarly)
                      )
                        return I;
                    }
                  }
                  return (
                    R.length && h.fillMissedErrors(b, I, R, p, w, x),
                    O.length &&
                      (h.fillOrderedErrors(b, I, O, p, w, x),
                      I.length || h.fillDefault(O, p, w, x)),
                    I.length ? I : p
                  );
                },
                priority: !0,
                manifest: !1,
              },
              length: {
                method(p) {
                  return this.$_addRule({
                    name: "length",
                    args: { limit: p },
                    operator: "=",
                  });
                },
                validate(p, g, b, v) {
                  let { limit: w } = b,
                    { name: x, operator: S, args: R } = v;
                  return d.compare(p.length, w, S)
                    ? p
                    : g.error("array." + x, { limit: R.limit, value: p });
                },
                args: [
                  {
                    name: "limit",
                    ref: !0,
                    assert: d.limit,
                    message: "must be a positive integer",
                  },
                ],
              },
              max: {
                method(p) {
                  return this.$_addRule({
                    name: "max",
                    method: "length",
                    args: { limit: p },
                    operator: "<=",
                  });
                },
              },
              min: {
                method(p) {
                  return this.$_addRule({
                    name: "min",
                    method: "length",
                    args: { limit: p },
                    operator: ">=",
                  });
                },
              },
              ordered: {
                method() {
                  for (
                    var p = arguments.length, g = new Array(p), b = 0;
                    b < p;
                    b++
                  )
                    g[b] = arguments[b];
                  d.verifyFlat(g, "ordered");
                  const v = this.$_addRule("items");
                  for (let w = 0; w < g.length; ++w) {
                    const x = d.tryWithPath(() => this.$_compile(g[w]), w, {
                      append: !0,
                    });
                    h.validateSingle(x, v),
                      v.$_mutateRegister(x),
                      v.$_terms.ordered.push(x);
                  }
                  return v.$_mutateRebuild();
                },
              },
              single: {
                method(p) {
                  const g = p === void 0 || !!p;
                  return (
                    a(
                      !g || !this._flags._arrayItems,
                      "Cannot specify single rule when array has array items"
                    ),
                    this.$_setFlag("single", g)
                  );
                },
              },
              sort: {
                method() {
                  let p =
                    arguments.length > 0 && arguments[0] !== void 0
                      ? arguments[0]
                      : {};
                  d.assertOptions(p, ["by", "order"]);
                  const g = { order: p.order || "ascending" };
                  return (
                    p.by &&
                      ((g.by = f.ref(p.by, { ancestor: 0 })),
                      a(!g.by.ancestor, "Cannot sort by ancestor")),
                    this.$_addRule({ name: "sort", args: { options: g } })
                  );
                },
                validate(p, g, b) {
                  let { error: v, state: w, prefs: x, schema: S } = g,
                    { options: R } = b;
                  const { value: O, errors: B } = h.sort(S, p, R, w, x);
                  if (B) return B;
                  for (let C = 0; C < p.length; ++C)
                    if (p[C] !== O[C])
                      return v("array.sort", {
                        order: R.order,
                        by: R.by ? R.by.key : "value",
                      });
                  return p;
                },
                convert: !0,
              },
              sparse: {
                method(p) {
                  const g = p === void 0 || !!p;
                  return this._flags.sparse === g
                    ? this
                    : (g ? this.clone() : this.$_addRule("items")).$_setFlag(
                        "sparse",
                        g,
                        { clone: !1 }
                      );
                },
              },
              unique: {
                method(p) {
                  let g =
                    arguments.length > 1 && arguments[1] !== void 0
                      ? arguments[1]
                      : {};
                  a(
                    !p || typeof p == "function" || typeof p == "string",
                    "comparator must be a function or a string"
                  ),
                    d.assertOptions(g, ["ignoreUndefined", "separator"]);
                  const b = {
                    name: "unique",
                    args: { options: g, comparator: p },
                  };
                  if (p)
                    if (typeof p == "string") {
                      const v = d.default(g.separator, ".");
                      b.path = v ? p.split(v) : [p];
                    } else b.comparator = p;
                  return this.$_addRule(b);
                },
                validate(p, g, b, v) {
                  let { state: w, error: x, schema: S } = g,
                    { comparator: R, options: O } = b,
                    { comparator: B, path: C } = v;
                  const I = {
                      string: Object.create(null),
                      number: Object.create(null),
                      undefined: Object.create(null),
                      boolean: Object.create(null),
                      object: new Map(),
                      function: new Map(),
                      custom: new Map(),
                    },
                    P = B || l,
                    M = O.ignoreUndefined;
                  for (let k = 0; k < p.length; ++k) {
                    const T = C ? c(p[k], C) : p[k],
                      _ = B ? I.custom : I[typeof T];
                    if (
                      (a(
                        _,
                        "Failed to find unique map container for type",
                        typeof T
                      ),
                      _ instanceof Map)
                    ) {
                      const A = _.entries();
                      let N;
                      for (; !(N = A.next()).done; )
                        if (P(N.value[0], T)) {
                          const L = w.localize(
                              [...w.path, k],
                              [p, ...w.ancestors]
                            ),
                            F = {
                              pos: k,
                              value: p[k],
                              dupePos: N.value[1],
                              dupeValue: p[N.value[1]],
                            };
                          return C && (F.path = R), x("array.unique", F, L);
                        }
                      _.set(T, k);
                    } else {
                      if ((!M || T !== void 0) && _[T] !== void 0) {
                        const A = {
                          pos: k,
                          value: p[k],
                          dupePos: _[T],
                          dupeValue: p[_[T]],
                        };
                        return (
                          C && (A.path = R),
                          x(
                            "array.unique",
                            A,
                            w.localize([...w.path, k], [p, ...w.ancestors])
                          )
                        );
                      }
                      _[T] = k;
                    }
                  }
                  return p;
                },
                args: ["comparator", "options"],
                multi: !0,
              },
            },
            cast: { set: { from: Array.isArray, to: (p, g) => new Set(p) } },
            rebuild(p) {
              (p.$_terms._inclusions = []),
                (p.$_terms._exclusions = []),
                (p.$_terms._requireds = []);
              for (const g of p.$_terms.items)
                h.validateSingle(g, p),
                  g._flags.presence === "required"
                    ? p.$_terms._requireds.push(g)
                    : g._flags.presence === "forbidden"
                    ? p.$_terms._exclusions.push(g)
                    : p.$_terms._inclusions.push(g);
              for (const g of p.$_terms.ordered) h.validateSingle(g, p);
            },
            manifest: {
              build: (p, g) => (
                g.items && (p = p.items(...g.items)),
                g.ordered && (p = p.ordered(...g.ordered)),
                p
              ),
            },
            messages: {
              "array.base": "{{#label}} must be an array",
              "array.excludes": "{{#label}} contains an excluded value",
              "array.hasKnown":
                "{{#label}} does not contain at least one required match for type {:#patternLabel}",
              "array.hasUnknown":
                "{{#label}} does not contain at least one required match",
              "array.includes":
                "{{#label}} does not match any of the allowed types",
              "array.includesRequiredBoth":
                "{{#label}} does not contain {{#knownMisses}} and {{#unknownMisses}} other required value(s)",
              "array.includesRequiredKnowns":
                "{{#label}} does not contain {{#knownMisses}}",
              "array.includesRequiredUnknowns":
                "{{#label}} does not contain {{#unknownMisses}} required value(s)",
              "array.length": "{{#label}} must contain {{#limit}} items",
              "array.max":
                "{{#label}} must contain less than or equal to {{#limit}} items",
              "array.min": "{{#label}} must contain at least {{#limit}} items",
              "array.orderedLength":
                "{{#label}} must contain at most {{#limit}} items",
              "array.sort":
                "{{#label}} must be sorted in {#order} order by {{#by}}",
              "array.sort.mismatching":
                "{{#label}} cannot be sorted due to mismatching types",
              "array.sort.unsupported":
                "{{#label}} cannot be sorted due to unsupported type {#type}",
              "array.sparse": "{{#label}} must not be a sparse array item",
              "array.unique": "{{#label}} contains a duplicate value",
            },
          })),
            (h.fillMissedErrors = function (p, g, b, v, w, x) {
              const S = [];
              let R = 0;
              for (const O of b) {
                const B = O._flags.label;
                B ? S.push(B) : ++R;
              }
              S.length
                ? R
                  ? g.push(
                      p.$_createError(
                        "array.includesRequiredBoth",
                        v,
                        { knownMisses: S, unknownMisses: R },
                        w,
                        x
                      )
                    )
                  : g.push(
                      p.$_createError(
                        "array.includesRequiredKnowns",
                        v,
                        { knownMisses: S },
                        w,
                        x
                      )
                    )
                : g.push(
                    p.$_createError(
                      "array.includesRequiredUnknowns",
                      v,
                      { unknownMisses: R },
                      w,
                      x
                    )
                  );
            }),
            (h.fillOrderedErrors = function (p, g, b, v, w, x) {
              const S = [];
              for (const R of b) R._flags.presence === "required" && S.push(R);
              S.length && h.fillMissedErrors(p, g, S, v, w, x);
            }),
            (h.fillDefault = function (p, g, b, v) {
              const w = [];
              let x = !0;
              for (let S = p.length - 1; S >= 0; --S) {
                const R = p[S],
                  O = [g, ...b.ancestors],
                  B = R.$_validate(void 0, b.localize(b.path, O, R), v).value;
                if (x) {
                  if (B === void 0) continue;
                  x = !1;
                }
                w.unshift(B);
              }
              w.length && g.push(...w);
            }),
            (h.fastSplice = function (p, g) {
              let b = g;
              for (; b < p.length; ) p[b++] = p[b];
              --p.length;
            }),
            (h.validateSingle = function (p, g) {
              (p.type === "array" || p._flags._arrayItems) &&
                (a(
                  !g._flags.single,
                  "Cannot specify array item with single rule enabled"
                ),
                g.$_setFlag("_arrayItems", !0, { clone: !1 }));
            }),
            (h.sort = function (p, g, b, v, w) {
              const x = b.order === "ascending" ? 1 : -1,
                S = -1 * x,
                R = x,
                O = (B, C) => {
                  let I = h.compare(B, C, S, R);
                  if (
                    I !== null ||
                    (b.by &&
                      ((B = b.by.resolve(B, v, w)),
                      (C = b.by.resolve(C, v, w))),
                    (I = h.compare(B, C, S, R)),
                    I !== null)
                  )
                    return I;
                  const P = typeof B;
                  if (P !== typeof C)
                    throw p.$_createError(
                      "array.sort.mismatching",
                      g,
                      null,
                      v,
                      w
                    );
                  if (P !== "number" && P !== "string")
                    throw p.$_createError(
                      "array.sort.unsupported",
                      g,
                      { type: P },
                      v,
                      w
                    );
                  return P === "number" ? (B - C) * x : B < C ? S : R;
                };
              try {
                return { value: g.slice().sort(O) };
              } catch (B) {
                return { errors: B };
              }
            }),
            (h.compare = function (p, g, b, v) {
              return p === g
                ? 0
                : p === void 0
                ? 1
                : g === void 0
                ? -1
                : p === null
                ? v
                : g === null
                ? b
                : null;
            });
        },
        4937: (i, s, o) => {
          const a = o(375),
            l = o(8068),
            c = o(8160),
            u = o(2036),
            d = {
              isBool: function (f) {
                return typeof f == "boolean";
              },
            };
          i.exports = l.extend({
            type: "boolean",
            flags: { sensitive: { default: !1 } },
            terms: {
              falsy: { init: null, manifest: "values" },
              truthy: { init: null, manifest: "values" },
            },
            coerce(f, h) {
              let { schema: p } = h;
              if (typeof f != "boolean") {
                if (typeof f == "string") {
                  const g = p._flags.sensitive ? f : f.toLowerCase();
                  f = g === "true" || (g !== "false" && f);
                }
                return (
                  typeof f != "boolean" &&
                    (f =
                      (p.$_terms.truthy &&
                        p.$_terms.truthy.has(
                          f,
                          null,
                          null,
                          !p._flags.sensitive
                        )) ||
                      ((!p.$_terms.falsy ||
                        !p.$_terms.falsy.has(
                          f,
                          null,
                          null,
                          !p._flags.sensitive
                        )) &&
                        f)),
                  { value: f }
                );
              }
            },
            validate(f, h) {
              let { error: p } = h;
              if (typeof f != "boolean")
                return { value: f, errors: p("boolean.base") };
            },
            rules: {
              truthy: {
                method() {
                  for (
                    var f = arguments.length, h = new Array(f), p = 0;
                    p < f;
                    p++
                  )
                    h[p] = arguments[p];
                  c.verifyFlat(h, "truthy");
                  const g = this.clone();
                  g.$_terms.truthy = g.$_terms.truthy || new u();
                  for (let b = 0; b < h.length; ++b) {
                    const v = h[b];
                    a(v !== void 0, "Cannot call truthy with undefined"),
                      g.$_terms.truthy.add(v);
                  }
                  return g;
                },
              },
              falsy: {
                method() {
                  for (
                    var f = arguments.length, h = new Array(f), p = 0;
                    p < f;
                    p++
                  )
                    h[p] = arguments[p];
                  c.verifyFlat(h, "falsy");
                  const g = this.clone();
                  g.$_terms.falsy = g.$_terms.falsy || new u();
                  for (let b = 0; b < h.length; ++b) {
                    const v = h[b];
                    a(v !== void 0, "Cannot call falsy with undefined"),
                      g.$_terms.falsy.add(v);
                  }
                  return g;
                },
              },
              sensitive: {
                method() {
                  let f =
                    !(arguments.length > 0 && arguments[0] !== void 0) ||
                    arguments[0];
                  return this.$_setFlag("sensitive", f);
                },
              },
            },
            cast: {
              number: { from: d.isBool, to: (f, h) => (f ? 1 : 0) },
              string: { from: d.isBool, to: (f, h) => (f ? "true" : "false") },
            },
            manifest: {
              build: (f, h) => (
                h.truthy && (f = f.truthy(...h.truthy)),
                h.falsy && (f = f.falsy(...h.falsy)),
                f
              ),
            },
            messages: { "boolean.base": "{{#label}} must be a boolean" },
          });
        },
        7500: (i, s, o) => {
          const a = o(375),
            l = o(8068),
            c = o(8160),
            u = o(3328),
            d = {
              isDate: function (f) {
                return f instanceof Date;
              },
            };
          (i.exports = l.extend({
            type: "date",
            coerce: {
              from: ["number", "string"],
              method(f, h) {
                let { schema: p } = h;
                return { value: d.parse(f, p._flags.format) || f };
              },
            },
            validate(f, h) {
              let { schema: p, error: g, prefs: b } = h;
              if (f instanceof Date && !isNaN(f.getTime())) return;
              const v = p._flags.format;
              return b.convert && v && typeof f == "string"
                ? { value: f, errors: g("date.format", { format: v }) }
                : { value: f, errors: g("date.base") };
            },
            rules: {
              compare: {
                method: !1,
                validate(f, h, p, g) {
                  let { date: b } = p,
                    { name: v, operator: w, args: x } = g;
                  const S = b === "now" ? Date.now() : b.getTime();
                  return c.compare(f.getTime(), S, w)
                    ? f
                    : h.error("date." + v, { limit: x.date, value: f });
                },
                args: [
                  {
                    name: "date",
                    ref: !0,
                    normalize: (f) => (f === "now" ? f : d.parse(f)),
                    assert: (f) => f !== null,
                    message: "must have a valid date format",
                  },
                ],
              },
              format: {
                method(f) {
                  return (
                    a(
                      ["iso", "javascript", "unix"].includes(f),
                      "Unknown date format",
                      f
                    ),
                    this.$_setFlag("format", f)
                  );
                },
              },
              greater: {
                method(f) {
                  return this.$_addRule({
                    name: "greater",
                    method: "compare",
                    args: { date: f },
                    operator: ">",
                  });
                },
              },
              iso: {
                method() {
                  return this.format("iso");
                },
              },
              less: {
                method(f) {
                  return this.$_addRule({
                    name: "less",
                    method: "compare",
                    args: { date: f },
                    operator: "<",
                  });
                },
              },
              max: {
                method(f) {
                  return this.$_addRule({
                    name: "max",
                    method: "compare",
                    args: { date: f },
                    operator: "<=",
                  });
                },
              },
              min: {
                method(f) {
                  return this.$_addRule({
                    name: "min",
                    method: "compare",
                    args: { date: f },
                    operator: ">=",
                  });
                },
              },
              timestamp: {
                method() {
                  let f =
                    arguments.length > 0 && arguments[0] !== void 0
                      ? arguments[0]
                      : "javascript";
                  return (
                    a(
                      ["javascript", "unix"].includes(f),
                      '"type" must be one of "javascript, unix"'
                    ),
                    this.format(f)
                  );
                },
              },
            },
            cast: {
              number: { from: d.isDate, to: (f, h) => f.getTime() },
              string: {
                from: d.isDate,
                to(f, h) {
                  let { prefs: p } = h;
                  return u.date(f, p);
                },
              },
            },
            messages: {
              "date.base": "{{#label}} must be a valid date",
              "date.format":
                '{{#label}} must be in {msg("date.format." + #format) || #format} format',
              "date.greater": "{{#label}} must be greater than {{:#limit}}",
              "date.less": "{{#label}} must be less than {{:#limit}}",
              "date.max":
                "{{#label}} must be less than or equal to {{:#limit}}",
              "date.min":
                "{{#label}} must be greater than or equal to {{:#limit}}",
              "date.format.iso": "ISO 8601 date",
              "date.format.javascript": "timestamp or number of milliseconds",
              "date.format.unix": "timestamp or number of seconds",
            },
          })),
            (d.parse = function (f, h) {
              if (f instanceof Date) return f;
              if (
                (typeof f != "string" && (isNaN(f) || !isFinite(f))) ||
                /^\s*$/.test(f)
              )
                return null;
              if (h === "iso")
                return c.isIsoDate(f) ? d.date(f.toString()) : null;
              const p = f;
              if (
                (typeof f == "string" &&
                  /^[+-]?\d+(\.\d+)?$/.test(f) &&
                  (f = parseFloat(f)),
                h)
              ) {
                if (h === "javascript") return d.date(1 * f);
                if (h === "unix") return d.date(1e3 * f);
                if (typeof p == "string") return null;
              }
              return d.date(f);
            }),
            (d.date = function (f) {
              const h = new Date(f);
              return isNaN(h.getTime()) ? null : h;
            });
        },
        390: (i, s, o) => {
          const a = o(375),
            l = o(7824);
          i.exports = l.extend({
            type: "function",
            properties: { typeof: "function" },
            rules: {
              arity: {
                method(c) {
                  return (
                    a(
                      Number.isSafeInteger(c) && c >= 0,
                      "n must be a positive integer"
                    ),
                    this.$_addRule({ name: "arity", args: { n: c } })
                  );
                },
                validate(c, u, d) {
                  let { n: f } = d;
                  return c.length === f
                    ? c
                    : u.error("function.arity", { n: f });
                },
              },
              class: {
                method() {
                  return this.$_addRule("class");
                },
                validate: (c, u) =>
                  /^\s*class\s/.test(c.toString())
                    ? c
                    : u.error("function.class", { value: c }),
              },
              minArity: {
                method(c) {
                  return (
                    a(
                      Number.isSafeInteger(c) && c > 0,
                      "n must be a strict positive integer"
                    ),
                    this.$_addRule({ name: "minArity", args: { n: c } })
                  );
                },
                validate(c, u, d) {
                  let { n: f } = d;
                  return c.length >= f
                    ? c
                    : u.error("function.minArity", { n: f });
                },
              },
              maxArity: {
                method(c) {
                  return (
                    a(
                      Number.isSafeInteger(c) && c >= 0,
                      "n must be a positive integer"
                    ),
                    this.$_addRule({ name: "maxArity", args: { n: c } })
                  );
                },
                validate(c, u, d) {
                  let { n: f } = d;
                  return c.length <= f
                    ? c
                    : u.error("function.maxArity", { n: f });
                },
              },
            },
            messages: {
              "function.arity": "{{#label}} must have an arity of {{#n}}",
              "function.class": "{{#label}} must be a class",
              "function.maxArity":
                "{{#label}} must have an arity lesser or equal to {{#n}}",
              "function.minArity":
                "{{#label}} must have an arity greater or equal to {{#n}}",
            },
          });
        },
        7824: (i, s, o) => {
          const a = o(978),
            l = o(375),
            c = o(8571),
            u = o(3652),
            d = o(8068),
            f = o(8160),
            h = o(3292),
            p = o(6354),
            g = o(6133),
            b = o(3328),
            v = { renameDefaults: { alias: !1, multiple: !1, override: !1 } };
          (i.exports = d.extend({
            type: "_keys",
            properties: { typeof: "object" },
            flags: { unknown: { default: !1 } },
            terms: {
              dependencies: { init: null },
              keys: {
                init: null,
                manifest: { mapped: { from: "schema", to: "key" } },
              },
              patterns: { init: null },
              renames: { init: null },
            },
            args: (w, x) => w.keys(x),
            validate(w, x) {
              let { schema: S, error: R, state: O, prefs: B } = x;
              if (!w || typeof w !== S.$_property("typeof") || Array.isArray(w))
                return {
                  value: w,
                  errors: R("object.base", { type: S.$_property("typeof") }),
                };
              if (
                !(
                  S.$_terms.renames ||
                  S.$_terms.dependencies ||
                  S.$_terms.keys ||
                  S.$_terms.patterns ||
                  S.$_terms.externals
                )
              )
                return;
              w = v.clone(w, B);
              const C = [];
              if (S.$_terms.renames && !v.rename(S, w, O, B, C))
                return { value: w, errors: C };
              if (
                !S.$_terms.keys &&
                !S.$_terms.patterns &&
                !S.$_terms.dependencies
              )
                return { value: w, errors: C };
              const I = new Set(Object.keys(w));
              if (S.$_terms.keys) {
                const P = [w, ...O.ancestors];
                for (const M of S.$_terms.keys) {
                  const k = M.key,
                    T = w[k];
                  I.delete(k);
                  const _ = O.localize([...O.path, k], P, M),
                    A = M.schema.$_validate(T, _, B);
                  if (A.errors) {
                    if (B.abortEarly) return { value: w, errors: A.errors };
                    A.value !== void 0 && (w[k] = A.value), C.push(...A.errors);
                  } else
                    M.schema._flags.result === "strip" ||
                    (A.value === void 0 && T !== void 0)
                      ? delete w[k]
                      : A.value !== void 0 && (w[k] = A.value);
                }
              }
              if (I.size || S._flags._hasPatternMatch) {
                const P = v.unknown(S, w, I, C, O, B);
                if (P) return P;
              }
              if (S.$_terms.dependencies)
                for (const P of S.$_terms.dependencies) {
                  if (
                    P.key !== null &&
                    v.isPresent(P.options)(
                      P.key.resolve(w, O, B, null, { shadow: !1 })
                    ) === !1
                  )
                    continue;
                  const M = v.dependencies[P.rel](S, P, w, O, B);
                  if (M) {
                    const k = S.$_createError(M.code, w, M.context, O, B);
                    if (B.abortEarly) return { value: w, errors: k };
                    C.push(k);
                  }
                }
              return { value: w, errors: C };
            },
            rules: {
              and: {
                method() {
                  for (
                    var w = arguments.length, x = new Array(w), S = 0;
                    S < w;
                    S++
                  )
                    x[S] = arguments[S];
                  return (
                    f.verifyFlat(x, "and"), v.dependency(this, "and", null, x)
                  );
                },
              },
              append: {
                method(w) {
                  return w == null || Object.keys(w).length === 0
                    ? this
                    : this.keys(w);
                },
              },
              assert: {
                method(w, x, S) {
                  b.isTemplate(w) || (w = h.ref(w)),
                    l(
                      S === void 0 || typeof S == "string",
                      "Message must be a string"
                    ),
                    (x = this.$_compile(x, { appendPath: !0 }));
                  const R = this.$_addRule({
                    name: "assert",
                    args: { subject: w, schema: x, message: S },
                  });
                  return R.$_mutateRegister(w), R.$_mutateRegister(x), R;
                },
                validate(w, x, S) {
                  let { error: R, prefs: O, state: B } = x,
                    { subject: C, schema: I, message: P } = S;
                  const M = C.resolve(w, B, O),
                    k = g.isRef(C) ? C.absolute(B) : [];
                  return I.$_match(M, B.localize(k, [w, ...B.ancestors], I), O)
                    ? w
                    : R("object.assert", { subject: C, message: P });
                },
                args: ["subject", "schema", "message"],
                multi: !0,
              },
              instance: {
                method(w, x) {
                  return (
                    l(typeof w == "function", "constructor must be a function"),
                    (x = x || w.name),
                    this.$_addRule({
                      name: "instance",
                      args: { constructor: w, name: x },
                    })
                  );
                },
                validate(w, x, S) {
                  let { constructor: R, name: O } = S;
                  return w instanceof R
                    ? w
                    : x.error("object.instance", { type: O, value: w });
                },
                args: ["constructor", "name"],
              },
              keys: {
                method(w) {
                  l(
                    w === void 0 || typeof w == "object",
                    "Object schema must be a valid object"
                  ),
                    l(!f.isSchema(w), "Object schema cannot be a joi schema");
                  const x = this.clone();
                  if (w)
                    if (Object.keys(w).length) {
                      x.$_terms.keys = x.$_terms.keys
                        ? x.$_terms.keys.filter((S) => !w.hasOwnProperty(S.key))
                        : new v.Keys();
                      for (const S in w)
                        f.tryWithPath(
                          () =>
                            x.$_terms.keys.push({
                              key: S,
                              schema: this.$_compile(w[S]),
                            }),
                          S
                        );
                    } else x.$_terms.keys = new v.Keys();
                  else x.$_terms.keys = null;
                  return x.$_mutateRebuild();
                },
              },
              length: {
                method(w) {
                  return this.$_addRule({
                    name: "length",
                    args: { limit: w },
                    operator: "=",
                  });
                },
                validate(w, x, S, R) {
                  let { limit: O } = S,
                    { name: B, operator: C, args: I } = R;
                  return f.compare(Object.keys(w).length, O, C)
                    ? w
                    : x.error("object." + B, { limit: I.limit, value: w });
                },
                args: [
                  {
                    name: "limit",
                    ref: !0,
                    assert: f.limit,
                    message: "must be a positive integer",
                  },
                ],
              },
              max: {
                method(w) {
                  return this.$_addRule({
                    name: "max",
                    method: "length",
                    args: { limit: w },
                    operator: "<=",
                  });
                },
              },
              min: {
                method(w) {
                  return this.$_addRule({
                    name: "min",
                    method: "length",
                    args: { limit: w },
                    operator: ">=",
                  });
                },
              },
              nand: {
                method() {
                  for (
                    var w = arguments.length, x = new Array(w), S = 0;
                    S < w;
                    S++
                  )
                    x[S] = arguments[S];
                  return (
                    f.verifyFlat(x, "nand"), v.dependency(this, "nand", null, x)
                  );
                },
              },
              or: {
                method() {
                  for (
                    var w = arguments.length, x = new Array(w), S = 0;
                    S < w;
                    S++
                  )
                    x[S] = arguments[S];
                  return (
                    f.verifyFlat(x, "or"), v.dependency(this, "or", null, x)
                  );
                },
              },
              oxor: {
                method() {
                  for (
                    var w = arguments.length, x = new Array(w), S = 0;
                    S < w;
                    S++
                  )
                    x[S] = arguments[S];
                  return v.dependency(this, "oxor", null, x);
                },
              },
              pattern: {
                method(w, x) {
                  let S =
                    arguments.length > 2 && arguments[2] !== void 0
                      ? arguments[2]
                      : {};
                  const R = w instanceof RegExp;
                  R || (w = this.$_compile(w, { appendPath: !0 })),
                    l(x !== void 0, "Invalid rule"),
                    f.assertOptions(S, ["fallthrough", "matches"]),
                    R &&
                      l(
                        !w.flags.includes("g") && !w.flags.includes("y"),
                        "pattern should not use global or sticky mode"
                      ),
                    (x = this.$_compile(x, { appendPath: !0 }));
                  const O = this.clone();
                  O.$_terms.patterns = O.$_terms.patterns || [];
                  const B = { [R ? "regex" : "schema"]: w, rule: x };
                  return (
                    S.matches &&
                      ((B.matches = this.$_compile(S.matches)),
                      B.matches.type !== "array" &&
                        (B.matches = B.matches.$_root.array().items(B.matches)),
                      O.$_mutateRegister(B.matches),
                      O.$_setFlag("_hasPatternMatch", !0, { clone: !1 })),
                    S.fallthrough && (B.fallthrough = !0),
                    O.$_terms.patterns.push(B),
                    O.$_mutateRegister(x),
                    O
                  );
                },
              },
              ref: {
                method() {
                  return this.$_addRule("ref");
                },
                validate: (w, x) =>
                  g.isRef(w) ? w : x.error("object.refType", { value: w }),
              },
              regex: {
                method() {
                  return this.$_addRule("regex");
                },
                validate: (w, x) =>
                  w instanceof RegExp
                    ? w
                    : x.error("object.regex", { value: w }),
              },
              rename: {
                method(w, x) {
                  let S =
                    arguments.length > 2 && arguments[2] !== void 0
                      ? arguments[2]
                      : {};
                  l(
                    typeof w == "string" || w instanceof RegExp,
                    "Rename missing the from argument"
                  ),
                    l(
                      typeof x == "string" || x instanceof b,
                      "Invalid rename to argument"
                    ),
                    l(x !== w, "Cannot rename key to same name:", w),
                    f.assertOptions(S, [
                      "alias",
                      "ignoreUndefined",
                      "override",
                      "multiple",
                    ]);
                  const R = this.clone();
                  R.$_terms.renames = R.$_terms.renames || [];
                  for (const O of R.$_terms.renames)
                    l(
                      O.from !== w,
                      "Cannot rename the same key multiple times"
                    );
                  return (
                    x instanceof b && R.$_mutateRegister(x),
                    R.$_terms.renames.push({
                      from: w,
                      to: x,
                      options: a(v.renameDefaults, S),
                    }),
                    R
                  );
                },
              },
              schema: {
                method() {
                  let w =
                    arguments.length > 0 && arguments[0] !== void 0
                      ? arguments[0]
                      : "any";
                  return this.$_addRule({ name: "schema", args: { type: w } });
                },
                validate(w, x, S) {
                  let { type: R } = S;
                  return !f.isSchema(w) || (R !== "any" && w.type !== R)
                    ? x.error("object.schema", { type: R })
                    : w;
                },
              },
              unknown: {
                method(w) {
                  return this.$_setFlag("unknown", w !== !1);
                },
              },
              with: {
                method(w, x) {
                  let S =
                    arguments.length > 2 && arguments[2] !== void 0
                      ? arguments[2]
                      : {};
                  return v.dependency(this, "with", w, x, S);
                },
              },
              without: {
                method(w, x) {
                  let S =
                    arguments.length > 2 && arguments[2] !== void 0
                      ? arguments[2]
                      : {};
                  return v.dependency(this, "without", w, x, S);
                },
              },
              xor: {
                method() {
                  for (
                    var w = arguments.length, x = new Array(w), S = 0;
                    S < w;
                    S++
                  )
                    x[S] = arguments[S];
                  return (
                    f.verifyFlat(x, "xor"), v.dependency(this, "xor", null, x)
                  );
                },
              },
            },
            overrides: {
              default(w, x) {
                return (
                  w === void 0 && (w = f.symbols.deepDefault),
                  this.$_parent("default", w, x)
                );
              },
            },
            rebuild(w) {
              if (w.$_terms.keys) {
                const x = new u.Sorter();
                for (const S of w.$_terms.keys)
                  f.tryWithPath(
                    () =>
                      x.add(S, {
                        after: S.schema.$_rootReferences(),
                        group: S.key,
                      }),
                    S.key
                  );
                w.$_terms.keys = new v.Keys(...x.nodes);
              }
            },
            manifest: {
              build(w, x) {
                if ((x.keys && (w = w.keys(x.keys)), x.dependencies))
                  for (const {
                    rel: S,
                    key: R = null,
                    peers: O,
                    options: B,
                  } of x.dependencies)
                    w = v.dependency(w, S, R, O, B);
                if (x.patterns)
                  for (const {
                    regex: S,
                    schema: R,
                    rule: O,
                    fallthrough: B,
                    matches: C,
                  } of x.patterns)
                    w = w.pattern(S || R, O, { fallthrough: B, matches: C });
                if (x.renames)
                  for (const { from: S, to: R, options: O } of x.renames)
                    w = w.rename(S, R, O);
                return w;
              },
            },
            messages: {
              "object.and":
                "{{#label}} contains {{#presentWithLabels}} without its required peers {{#missingWithLabels}}",
              "object.assert":
                '{{#label}} is invalid because {if(#subject.key, `"` + #subject.key + `" failed to ` + (#message || "pass the assertion test"), #message || "the assertion failed")}',
              "object.base": "{{#label}} must be of type {{#type}}",
              "object.instance": "{{#label}} must be an instance of {{:#type}}",
              "object.length":
                '{{#label}} must have {{#limit}} key{if(#limit == 1, "", "s")}',
              "object.max":
                '{{#label}} must have less than or equal to {{#limit}} key{if(#limit == 1, "", "s")}',
              "object.min":
                '{{#label}} must have at least {{#limit}} key{if(#limit == 1, "", "s")}',
              "object.missing":
                "{{#label}} must contain at least one of {{#peersWithLabels}}",
              "object.nand":
                "{{:#mainWithLabel}} must not exist simultaneously with {{#peersWithLabels}}",
              "object.oxor":
                "{{#label}} contains a conflict between optional exclusive peers {{#peersWithLabels}}",
              "object.pattern.match":
                "{{#label}} keys failed to match pattern requirements",
              "object.refType": "{{#label}} must be a Joi reference",
              "object.regex": "{{#label}} must be a RegExp object",
              "object.rename.multiple":
                "{{#label}} cannot rename {{:#from}} because multiple renames are disabled and another key was already renamed to {{:#to}}",
              "object.rename.override":
                "{{#label}} cannot rename {{:#from}} because override is disabled and target {{:#to}} exists",
              "object.schema":
                "{{#label}} must be a Joi schema of {{#type}} type",
              "object.unknown": "{{#label}} is not allowed",
              "object.with":
                "{{:#mainWithLabel}} missing required peer {{:#peerWithLabel}}",
              "object.without":
                "{{:#mainWithLabel}} conflict with forbidden peer {{:#peerWithLabel}}",
              "object.xor":
                "{{#label}} contains a conflict between exclusive peers {{#peersWithLabels}}",
            },
          })),
            (v.clone = function (w, x) {
              if (typeof w == "object") {
                if (x.nonEnumerables) return c(w, { shallow: !0 });
                const R = Object.create(Object.getPrototypeOf(w));
                return Object.assign(R, w), R;
              }
              const S = function () {
                for (
                  var R = arguments.length, O = new Array(R), B = 0;
                  B < R;
                  B++
                )
                  O[B] = arguments[B];
                return w.apply(this, O);
              };
              return (
                (S.prototype = c(w.prototype)),
                Object.defineProperty(S, "name", {
                  value: w.name,
                  writable: !1,
                }),
                Object.defineProperty(S, "length", {
                  value: w.length,
                  writable: !1,
                }),
                Object.assign(S, w),
                S
              );
            }),
            (v.dependency = function (w, x, S, R, O) {
              l(S === null || typeof S == "string", x, "key must be a strings"),
                O ||
                  (O =
                    R.length > 1 && typeof R[R.length - 1] == "object"
                      ? R.pop()
                      : {}),
                f.assertOptions(O, ["separator", "isPresent"]),
                (R = [].concat(R));
              const B = f.default(O.separator, "."),
                C = [];
              for (const P of R)
                l(typeof P == "string", x, "peers must be strings"),
                  C.push(h.ref(P, { separator: B, ancestor: 0, prefix: !1 }));
              S !== null &&
                (S = h.ref(S, { separator: B, ancestor: 0, prefix: !1 }));
              const I = w.clone();
              return (
                (I.$_terms.dependencies = I.$_terms.dependencies || []),
                I.$_terms.dependencies.push(new v.Dependency(x, S, C, R, O)),
                I
              );
            }),
            (v.dependencies = {
              and(w, x, S, R, O) {
                const B = [],
                  C = [],
                  I = x.peers.length,
                  P = v.isPresent(x.options);
                for (const M of x.peers)
                  P(M.resolve(S, R, O, null, { shadow: !1 })) === !1
                    ? B.push(M.key)
                    : C.push(M.key);
                if (B.length !== I && C.length !== I)
                  return {
                    code: "object.and",
                    context: {
                      present: C,
                      presentWithLabels: v.keysToLabels(w, C),
                      missing: B,
                      missingWithLabels: v.keysToLabels(w, B),
                    },
                  };
              },
              nand(w, x, S, R, O) {
                const B = [],
                  C = v.isPresent(x.options);
                for (const M of x.peers)
                  C(M.resolve(S, R, O, null, { shadow: !1 })) && B.push(M.key);
                if (B.length !== x.peers.length) return;
                const I = x.paths[0],
                  P = x.paths.slice(1);
                return {
                  code: "object.nand",
                  context: {
                    main: I,
                    mainWithLabel: v.keysToLabels(w, I),
                    peers: P,
                    peersWithLabels: v.keysToLabels(w, P),
                  },
                };
              },
              or(w, x, S, R, O) {
                const B = v.isPresent(x.options);
                for (const C of x.peers)
                  if (B(C.resolve(S, R, O, null, { shadow: !1 }))) return;
                return {
                  code: "object.missing",
                  context: {
                    peers: x.paths,
                    peersWithLabels: v.keysToLabels(w, x.paths),
                  },
                };
              },
              oxor(w, x, S, R, O) {
                const B = [],
                  C = v.isPresent(x.options);
                for (const P of x.peers)
                  C(P.resolve(S, R, O, null, { shadow: !1 })) && B.push(P.key);
                if (!B.length || B.length === 1) return;
                const I = {
                  peers: x.paths,
                  peersWithLabels: v.keysToLabels(w, x.paths),
                };
                return (
                  (I.present = B),
                  (I.presentWithLabels = v.keysToLabels(w, B)),
                  { code: "object.oxor", context: I }
                );
              },
              with(w, x, S, R, O) {
                const B = v.isPresent(x.options);
                for (const C of x.peers)
                  if (B(C.resolve(S, R, O, null, { shadow: !1 })) === !1)
                    return {
                      code: "object.with",
                      context: {
                        main: x.key.key,
                        mainWithLabel: v.keysToLabels(w, x.key.key),
                        peer: C.key,
                        peerWithLabel: v.keysToLabels(w, C.key),
                      },
                    };
              },
              without(w, x, S, R, O) {
                const B = v.isPresent(x.options);
                for (const C of x.peers)
                  if (B(C.resolve(S, R, O, null, { shadow: !1 })))
                    return {
                      code: "object.without",
                      context: {
                        main: x.key.key,
                        mainWithLabel: v.keysToLabels(w, x.key.key),
                        peer: C.key,
                        peerWithLabel: v.keysToLabels(w, C.key),
                      },
                    };
              },
              xor(w, x, S, R, O) {
                const B = [],
                  C = v.isPresent(x.options);
                for (const P of x.peers)
                  C(P.resolve(S, R, O, null, { shadow: !1 })) && B.push(P.key);
                if (B.length === 1) return;
                const I = {
                  peers: x.paths,
                  peersWithLabels: v.keysToLabels(w, x.paths),
                };
                return B.length === 0
                  ? { code: "object.missing", context: I }
                  : ((I.present = B),
                    (I.presentWithLabels = v.keysToLabels(w, B)),
                    { code: "object.xor", context: I });
              },
            }),
            (v.keysToLabels = function (w, x) {
              return Array.isArray(x)
                ? x.map((S) => w.$_mapLabels(S))
                : w.$_mapLabels(x);
            }),
            (v.isPresent = function (w) {
              return typeof w.isPresent == "function"
                ? w.isPresent
                : (x) => x !== void 0;
            }),
            (v.rename = function (w, x, S, R, O) {
              const B = {};
              for (const C of w.$_terms.renames) {
                const I = [],
                  P = typeof C.from != "string";
                if (P)
                  for (const M in x) {
                    if (
                      (x[M] === void 0 && C.options.ignoreUndefined) ||
                      M === C.to
                    )
                      continue;
                    const k = C.from.exec(M);
                    k && I.push({ from: M, to: C.to, match: k });
                  }
                else
                  !Object.prototype.hasOwnProperty.call(x, C.from) ||
                    (x[C.from] === void 0 && C.options.ignoreUndefined) ||
                    I.push(C);
                for (const M of I) {
                  const k = M.from;
                  let T = M.to;
                  if (
                    (T instanceof b && (T = T.render(x, S, R, M.match)),
                    k !== T)
                  ) {
                    if (
                      (!C.options.multiple &&
                        B[T] &&
                        (O.push(
                          w.$_createError(
                            "object.rename.multiple",
                            x,
                            { from: k, to: T, pattern: P },
                            S,
                            R
                          )
                        ),
                        R.abortEarly)) ||
                      (Object.prototype.hasOwnProperty.call(x, T) &&
                        !C.options.override &&
                        !B[T] &&
                        (O.push(
                          w.$_createError(
                            "object.rename.override",
                            x,
                            { from: k, to: T, pattern: P },
                            S,
                            R
                          )
                        ),
                        R.abortEarly))
                    )
                      return !1;
                    x[k] === void 0 ? delete x[T] : (x[T] = x[k]),
                      (B[T] = !0),
                      C.options.alias || delete x[k];
                  }
                }
              }
              return !0;
            }),
            (v.unknown = function (w, x, S, R, O, B) {
              if (w.$_terms.patterns) {
                let C = !1;
                const I = w.$_terms.patterns.map((M) => {
                    if (M.matches) return (C = !0), [];
                  }),
                  P = [x, ...O.ancestors];
                for (const M of S) {
                  const k = x[M],
                    T = [...O.path, M];
                  for (let _ = 0; _ < w.$_terms.patterns.length; ++_) {
                    const A = w.$_terms.patterns[_];
                    if (A.regex) {
                      const F = A.regex.test(M);
                      if (
                        (O.mainstay.tracer.debug(
                          O,
                          "rule",
                          `pattern.${_}`,
                          F ? "pass" : "error"
                        ),
                        !F)
                      )
                        continue;
                    } else if (
                      !A.schema.$_match(M, O.nest(A.schema, `pattern.${_}`), B)
                    )
                      continue;
                    S.delete(M);
                    const N = O.localize(T, P, { schema: A.rule, key: M }),
                      L = A.rule.$_validate(k, N, B);
                    if (L.errors) {
                      if (B.abortEarly) return { value: x, errors: L.errors };
                      R.push(...L.errors);
                    }
                    if (
                      (A.matches && I[_].push(M),
                      (x[M] = L.value),
                      !A.fallthrough)
                    )
                      break;
                  }
                }
                if (C)
                  for (let M = 0; M < I.length; ++M) {
                    const k = I[M];
                    if (!k) continue;
                    const T = w.$_terms.patterns[M].matches,
                      _ = O.localize(O.path, P, T),
                      A = T.$_validate(k, _, B);
                    if (A.errors) {
                      const N = p.details(A.errors, { override: !1 });
                      N.matches = k;
                      const L = w.$_createError(
                        "object.pattern.match",
                        x,
                        N,
                        O,
                        B
                      );
                      if (B.abortEarly) return { value: x, errors: L };
                      R.push(L);
                    }
                  }
              }
              if (S.size && (w.$_terms.keys || w.$_terms.patterns)) {
                if ((B.stripUnknown && !w._flags.unknown) || B.skipFunctions) {
                  const C = !(
                    !B.stripUnknown ||
                    (B.stripUnknown !== !0 && !B.stripUnknown.objects)
                  );
                  for (const I of S)
                    C
                      ? (delete x[I], S.delete(I))
                      : typeof x[I] == "function" && S.delete(I);
                }
                if (!f.default(w._flags.unknown, B.allowUnknown))
                  for (const C of S) {
                    const I = O.localize([...O.path, C], []),
                      P = w.$_createError(
                        "object.unknown",
                        x[C],
                        { child: C },
                        I,
                        B,
                        { flags: !1 }
                      );
                    if (B.abortEarly) return { value: x, errors: P };
                    R.push(P);
                  }
              }
            }),
            (v.Dependency = class {
              constructor(w, x, S, R, O) {
                (this.rel = w),
                  (this.key = x),
                  (this.peers = S),
                  (this.paths = R),
                  (this.options = O);
              }
              describe() {
                const w = { rel: this.rel, peers: this.paths };
                return (
                  this.key !== null && (w.key = this.key.key),
                  this.peers[0].separator !== "." &&
                    (w.options = {
                      ...w.options,
                      separator: this.peers[0].separator,
                    }),
                  this.options.isPresent &&
                    (w.options = {
                      ...w.options,
                      isPresent: this.options.isPresent,
                    }),
                  w
                );
              }
            }),
            (v.Keys = class extends Array {
              concat(w) {
                const x = this.slice(),
                  S = new Map();
                for (let R = 0; R < x.length; ++R) S.set(x[R].key, R);
                for (const R of w) {
                  const O = R.key,
                    B = S.get(O);
                  B !== void 0
                    ? (x[B] = { key: O, schema: x[B].schema.concat(R.schema) })
                    : x.push(R);
                }
                return x;
              }
            });
        },
        8785: (i, s, o) => {
          const a = o(375),
            l = o(8068),
            c = o(8160),
            u = o(3292),
            d = o(6354),
            f = {};
          (i.exports = l.extend({
            type: "link",
            properties: { schemaChain: !0 },
            terms: { link: { init: null, manifest: "single", register: !1 } },
            args: (h, p) => h.ref(p),
            validate(h, p) {
              let { schema: g, state: b, prefs: v } = p;
              a(g.$_terms.link, "Uninitialized link schema");
              const w = f.generate(g, h, b, v),
                x = g.$_terms.link[0].ref;
              return w.$_validate(
                h,
                b.nest(w, `link:${x.display}:${w.type}`),
                v
              );
            },
            generate: (h, p, g, b) => f.generate(h, p, g, b),
            rules: {
              ref: {
                method(h) {
                  a(!this.$_terms.link, "Cannot reinitialize schema"),
                    (h = u.ref(h)),
                    a(
                      h.type === "value" || h.type === "local",
                      "Invalid reference type:",
                      h.type
                    ),
                    a(
                      h.type === "local" ||
                        h.ancestor === "root" ||
                        h.ancestor > 0,
                      "Link cannot reference itself"
                    );
                  const p = this.clone();
                  return (p.$_terms.link = [{ ref: h }]), p;
                },
              },
              relative: {
                method() {
                  let h =
                    !(arguments.length > 0 && arguments[0] !== void 0) ||
                    arguments[0];
                  return this.$_setFlag("relative", h);
                },
              },
            },
            overrides: {
              concat(h) {
                a(this.$_terms.link, "Uninitialized link schema"),
                  a(c.isSchema(h), "Invalid schema object"),
                  a(
                    h.type !== "link",
                    "Cannot merge type link with another link"
                  );
                const p = this.clone();
                return (
                  p.$_terms.whens || (p.$_terms.whens = []),
                  p.$_terms.whens.push({ concat: h }),
                  p.$_mutateRebuild()
                );
              },
            },
            manifest: {
              build: (h, p) => (
                a(p.link, "Invalid link description missing link"),
                h.ref(p.link)
              ),
            },
          })),
            (f.generate = function (h, p, g, b) {
              let v = g.mainstay.links.get(h);
              if (v) return v._generate(p, g, b).schema;
              const w = h.$_terms.link[0].ref,
                { perspective: x, path: S } = f.perspective(w, g);
              f.assert(x, "which is outside of schema boundaries", w, h, g, b);
              try {
                v = S.length ? x.$_reach(S) : x;
              } catch {
                f.assert(!1, "to non-existing schema", w, h, g, b);
              }
              return (
                f.assert(
                  v.type !== "link",
                  "which is another link",
                  w,
                  h,
                  g,
                  b
                ),
                h._flags.relative || g.mainstay.links.set(h, v),
                v._generate(p, g, b).schema
              );
            }),
            (f.perspective = function (h, p) {
              if (h.type === "local") {
                for (const { schema: g, key: b } of p.schemas) {
                  if ((g._flags.id || b) === h.path[0])
                    return { perspective: g, path: h.path.slice(1) };
                  if (g.$_terms.shared) {
                    for (const v of g.$_terms.shared)
                      if (v._flags.id === h.path[0])
                        return { perspective: v, path: h.path.slice(1) };
                  }
                }
                return { perspective: null, path: null };
              }
              return h.ancestor === "root"
                ? {
                    perspective: p.schemas[p.schemas.length - 1].schema,
                    path: h.path,
                  }
                : {
                    perspective:
                      p.schemas[h.ancestor] && p.schemas[h.ancestor].schema,
                    path: h.path,
                  };
            }),
            (f.assert = function (h, p, g, b, v, w) {
              h ||
                a(
                  !1,
                  `"${d.label(b._flags, v, w)}" contains link reference "${
                    g.display
                  }" ${p}`
                );
            });
        },
        3832: (i, s, o) => {
          const a = o(375),
            l = o(8068),
            c = o(8160),
            u = {
              numberRx:
                /^\s*[+-]?(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:e([+-]?\d+))?\s*$/i,
              precisionRx: /(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/,
              exponentialPartRegex: /[eE][+-]?\d+$/,
              leadingSignAndZerosRegex: /^[+-]?(0*)?/,
              dotRegex: /\./,
              trailingZerosRegex: /0+$/,
            };
          (i.exports = l.extend({
            type: "number",
            flags: { unsafe: { default: !1 } },
            coerce: {
              from: "string",
              method(d, f) {
                let { schema: h, error: p } = f;
                if (!d.match(u.numberRx)) return;
                d = d.trim();
                const g = { value: parseFloat(d) };
                if ((g.value === 0 && (g.value = 0), !h._flags.unsafe))
                  if (d.match(/e/i)) {
                    if (
                      u.extractSignificantDigits(d) !==
                      u.extractSignificantDigits(String(g.value))
                    )
                      return (g.errors = p("number.unsafe")), g;
                  } else {
                    const b = g.value.toString();
                    if (b.match(/e/i)) return g;
                    if (b !== u.normalizeDecimal(d))
                      return (g.errors = p("number.unsafe")), g;
                  }
                return g;
              },
            },
            validate(d, f) {
              let { schema: h, error: p, prefs: g } = f;
              if (d === 1 / 0 || d === -1 / 0)
                return { value: d, errors: p("number.infinity") };
              if (!c.isNumber(d)) return { value: d, errors: p("number.base") };
              const b = { value: d };
              if (g.convert) {
                const v = h.$_getRule("precision");
                if (v) {
                  const w = Math.pow(10, v.args.limit);
                  b.value = Math.round(b.value * w) / w;
                }
              }
              return (
                b.value === 0 && (b.value = 0),
                !h._flags.unsafe &&
                  (d > Number.MAX_SAFE_INTEGER ||
                    d < Number.MIN_SAFE_INTEGER) &&
                  (b.errors = p("number.unsafe")),
                b
              );
            },
            rules: {
              compare: {
                method: !1,
                validate(d, f, h, p) {
                  let { limit: g } = h,
                    { name: b, operator: v, args: w } = p;
                  return c.compare(d, g, v)
                    ? d
                    : f.error("number." + b, { limit: w.limit, value: d });
                },
                args: [
                  {
                    name: "limit",
                    ref: !0,
                    assert: c.isNumber,
                    message: "must be a number",
                  },
                ],
              },
              greater: {
                method(d) {
                  return this.$_addRule({
                    name: "greater",
                    method: "compare",
                    args: { limit: d },
                    operator: ">",
                  });
                },
              },
              integer: {
                method() {
                  return this.$_addRule("integer");
                },
                validate: (d, f) =>
                  Math.trunc(d) - d == 0 ? d : f.error("number.integer"),
              },
              less: {
                method(d) {
                  return this.$_addRule({
                    name: "less",
                    method: "compare",
                    args: { limit: d },
                    operator: "<",
                  });
                },
              },
              max: {
                method(d) {
                  return this.$_addRule({
                    name: "max",
                    method: "compare",
                    args: { limit: d },
                    operator: "<=",
                  });
                },
              },
              min: {
                method(d) {
                  return this.$_addRule({
                    name: "min",
                    method: "compare",
                    args: { limit: d },
                    operator: ">=",
                  });
                },
              },
              multiple: {
                method(d) {
                  return this.$_addRule({
                    name: "multiple",
                    args: { base: d },
                  });
                },
                validate(d, f, h, p) {
                  let { base: g } = h;
                  return (d * (1 / g)) % 1 == 0
                    ? d
                    : f.error("number.multiple", {
                        multiple: p.args.base,
                        value: d,
                      });
                },
                args: [
                  {
                    name: "base",
                    ref: !0,
                    assert: (d) => typeof d == "number" && isFinite(d) && d > 0,
                    message: "must be a positive number",
                  },
                ],
                multi: !0,
              },
              negative: {
                method() {
                  return this.sign("negative");
                },
              },
              port: {
                method() {
                  return this.$_addRule("port");
                },
                validate: (d, f) =>
                  Number.isSafeInteger(d) && d >= 0 && d <= 65535
                    ? d
                    : f.error("number.port"),
              },
              positive: {
                method() {
                  return this.sign("positive");
                },
              },
              precision: {
                method(d) {
                  return (
                    a(Number.isSafeInteger(d), "limit must be an integer"),
                    this.$_addRule({ name: "precision", args: { limit: d } })
                  );
                },
                validate(d, f, h) {
                  let { limit: p } = h;
                  const g = d.toString().match(u.precisionRx);
                  return Math.max(
                    (g[1] ? g[1].length : 0) - (g[2] ? parseInt(g[2], 10) : 0),
                    0
                  ) <= p
                    ? d
                    : f.error("number.precision", { limit: p, value: d });
                },
                convert: !0,
              },
              sign: {
                method(d) {
                  return (
                    a(["negative", "positive"].includes(d), "Invalid sign", d),
                    this.$_addRule({ name: "sign", args: { sign: d } })
                  );
                },
                validate(d, f, h) {
                  let { sign: p } = h;
                  return (p === "negative" && d < 0) ||
                    (p === "positive" && d > 0)
                    ? d
                    : f.error(`number.${p}`);
                },
              },
              unsafe: {
                method() {
                  let d =
                    !(arguments.length > 0 && arguments[0] !== void 0) ||
                    arguments[0];
                  return (
                    a(typeof d == "boolean", "enabled must be a boolean"),
                    this.$_setFlag("unsafe", d)
                  );
                },
              },
            },
            cast: {
              string: {
                from: (d) => typeof d == "number",
                to: (d, f) => d.toString(),
              },
            },
            messages: {
              "number.base": "{{#label}} must be a number",
              "number.greater": "{{#label}} must be greater than {{#limit}}",
              "number.infinity": "{{#label}} cannot be infinity",
              "number.integer": "{{#label}} must be an integer",
              "number.less": "{{#label}} must be less than {{#limit}}",
              "number.max":
                "{{#label}} must be less than or equal to {{#limit}}",
              "number.min":
                "{{#label}} must be greater than or equal to {{#limit}}",
              "number.multiple":
                "{{#label}} must be a multiple of {{#multiple}}",
              "number.negative": "{{#label}} must be a negative number",
              "number.port": "{{#label}} must be a valid port",
              "number.positive": "{{#label}} must be a positive number",
              "number.precision":
                "{{#label}} must have no more than {{#limit}} decimal places",
              "number.unsafe": "{{#label}} must be a safe number",
            },
          })),
            (u.extractSignificantDigits = function (d) {
              return d
                .replace(u.exponentialPartRegex, "")
                .replace(u.dotRegex, "")
                .replace(u.trailingZerosRegex, "")
                .replace(u.leadingSignAndZerosRegex, "");
            }),
            (u.normalizeDecimal = function (d) {
              return (
                (d = d
                  .replace(/^\+/, "")
                  .replace(/\.0*$/, "")
                  .replace(/^(-?)\.([^\.]*)$/, "$10.$2")
                  .replace(/^(-?)0+([0-9])/, "$1$2")).includes(".") &&
                  d.endsWith("0") &&
                  (d = d.replace(/0+$/, "")),
                d === "-0" ? "0" : d
              );
            });
        },
        8966: (i, s, o) => {
          const a = o(7824);
          i.exports = a.extend({
            type: "object",
            cast: {
              map: {
                from: (l) => l && typeof l == "object",
                to: (l, c) => new Map(Object.entries(l)),
              },
            },
          });
        },
        7417: (i, s, o) => {
          const a = o(375),
            l = o(5380),
            c = o(1745),
            u = o(9959),
            d = o(6064),
            f = o(9926),
            h = o(5752),
            p = o(8068),
            g = o(8160),
            b = {
              tlds: f instanceof Set && { tlds: { allow: f, deny: null } },
              base64Regex: {
                true: {
                  true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}==|[\w\-]{3}=)?$/,
                  false:
                    /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/,
                },
                false: {
                  true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}(==)?|[\w\-]{3}=?)?$/,
                  false:
                    /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/,
                },
              },
              dataUriRegex:
                /^data:[\w+.-]+\/[\w+.-]+;((charset=[\w-]+|base64),)?(.*)$/,
              hexRegex: /^[a-f0-9]+$/i,
              ipRegex: u.regex({ cidr: "forbidden" }).regex,
              isoDurationRegex:
                /^P(?!$)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?$/,
              guidBrackets: { "{": "}", "[": "]", "(": ")", "": "" },
              guidVersions: {
                uuidv1: "1",
                uuidv2: "2",
                uuidv3: "3",
                uuidv4: "4",
                uuidv5: "5",
              },
              guidSeparators: new Set([void 0, !0, !1, "-", ":"]),
              normalizationForms: ["NFC", "NFD", "NFKC", "NFKD"],
            };
          (i.exports = p.extend({
            type: "string",
            flags: { insensitive: { default: !1 }, truncate: { default: !1 } },
            terms: { replacements: { init: null } },
            coerce: {
              from: "string",
              method(v, w) {
                let { schema: x, state: S, prefs: R } = w;
                const O = x.$_getRule("normalize");
                O && (v = v.normalize(O.args.form));
                const B = x.$_getRule("case");
                B &&
                  (v =
                    B.args.direction === "upper"
                      ? v.toLocaleUpperCase()
                      : v.toLocaleLowerCase());
                const C = x.$_getRule("trim");
                if (
                  (C && C.args.enabled && (v = v.trim()),
                  x.$_terms.replacements)
                )
                  for (const P of x.$_terms.replacements)
                    v = v.replace(P.pattern, P.replacement);
                const I = x.$_getRule("hex");
                if (
                  (I &&
                    I.args.options.byteAligned &&
                    v.length % 2 != 0 &&
                    (v = `0${v}`),
                  x.$_getRule("isoDate"))
                ) {
                  const P = b.isoDate(v);
                  P && (v = P);
                }
                if (x._flags.truncate) {
                  const P = x.$_getRule("max");
                  if (P) {
                    let M = P.args.limit;
                    if (
                      g.isResolvable(M) &&
                      ((M = M.resolve(v, S, R)), !g.limit(M))
                    )
                      return {
                        value: v,
                        errors: x.$_createError(
                          "any.ref",
                          M,
                          {
                            ref: P.args.limit,
                            arg: "limit",
                            reason: "must be a positive integer",
                          },
                          S,
                          R
                        ),
                      };
                    v = v.slice(0, M);
                  }
                }
                return { value: v };
              },
            },
            validate(v, w) {
              let { schema: x, error: S } = w;
              if (typeof v != "string")
                return { value: v, errors: S("string.base") };
              if (v === "") {
                const R = x.$_getRule("min");
                return R && R.args.limit === 0
                  ? void 0
                  : { value: v, errors: S("string.empty") };
              }
            },
            rules: {
              alphanum: {
                method() {
                  return this.$_addRule("alphanum");
                },
                validate: (v, w) =>
                  /^[a-zA-Z0-9]+$/.test(v) ? v : w.error("string.alphanum"),
              },
              base64: {
                method() {
                  let v =
                    arguments.length > 0 && arguments[0] !== void 0
                      ? arguments[0]
                      : {};
                  return (
                    g.assertOptions(v, ["paddingRequired", "urlSafe"]),
                    (v = { urlSafe: !1, paddingRequired: !0, ...v }),
                    a(
                      typeof v.paddingRequired == "boolean",
                      "paddingRequired must be boolean"
                    ),
                    a(typeof v.urlSafe == "boolean", "urlSafe must be boolean"),
                    this.$_addRule({ name: "base64", args: { options: v } })
                  );
                },
                validate(v, w, x) {
                  let { options: S } = x;
                  return b.base64Regex[S.paddingRequired][S.urlSafe].test(v)
                    ? v
                    : w.error("string.base64");
                },
              },
              case: {
                method(v) {
                  return (
                    a(["lower", "upper"].includes(v), "Invalid case:", v),
                    this.$_addRule({ name: "case", args: { direction: v } })
                  );
                },
                validate(v, w, x) {
                  let { direction: S } = x;
                  return (S === "lower" && v === v.toLocaleLowerCase()) ||
                    (S === "upper" && v === v.toLocaleUpperCase())
                    ? v
                    : w.error(`string.${S}case`);
                },
                convert: !0,
              },
              creditCard: {
                method() {
                  return this.$_addRule("creditCard");
                },
                validate(v, w) {
                  let x = v.length,
                    S = 0,
                    R = 1;
                  for (; x--; ) {
                    const O = v.charAt(x) * R;
                    (S += O - 9 * (O > 9)), (R ^= 3);
                  }
                  return S > 0 && S % 10 == 0
                    ? v
                    : w.error("string.creditCard");
                },
              },
              dataUri: {
                method() {
                  let v =
                    arguments.length > 0 && arguments[0] !== void 0
                      ? arguments[0]
                      : {};
                  return (
                    g.assertOptions(v, ["paddingRequired"]),
                    (v = { paddingRequired: !0, ...v }),
                    a(
                      typeof v.paddingRequired == "boolean",
                      "paddingRequired must be boolean"
                    ),
                    this.$_addRule({ name: "dataUri", args: { options: v } })
                  );
                },
                validate(v, w, x) {
                  let { options: S } = x;
                  const R = v.match(b.dataUriRegex);
                  return R &&
                    (!R[2] ||
                      R[2] !== "base64" ||
                      b.base64Regex[S.paddingRequired].false.test(R[3]))
                    ? v
                    : w.error("string.dataUri");
                },
              },
              domain: {
                method(v) {
                  v &&
                    g.assertOptions(v, [
                      "allowFullyQualified",
                      "allowUnicode",
                      "maxDomainSegments",
                      "minDomainSegments",
                      "tlds",
                    ]);
                  const w = b.addressOptions(v);
                  return this.$_addRule({
                    name: "domain",
                    args: { options: v },
                    address: w,
                  });
                },
                validate(v, w, x, S) {
                  let { address: R } = S;
                  return l.isValid(v, R) ? v : w.error("string.domain");
                },
              },
              email: {
                method() {
                  let v =
                    arguments.length > 0 && arguments[0] !== void 0
                      ? arguments[0]
                      : {};
                  g.assertOptions(v, [
                    "allowFullyQualified",
                    "allowUnicode",
                    "ignoreLength",
                    "maxDomainSegments",
                    "minDomainSegments",
                    "multiple",
                    "separator",
                    "tlds",
                  ]),
                    a(
                      v.multiple === void 0 || typeof v.multiple == "boolean",
                      "multiple option must be an boolean"
                    );
                  const w = b.addressOptions(v),
                    x = new RegExp(
                      `\\s*[${v.separator ? d(v.separator) : ","}]\\s*`
                    );
                  return this.$_addRule({
                    name: "email",
                    args: { options: v },
                    regex: x,
                    address: w,
                  });
                },
                validate(v, w, x, S) {
                  let { options: R } = x,
                    { regex: O, address: B } = S;
                  const C = R.multiple ? v.split(O) : [v],
                    I = [];
                  for (const P of C) c.isValid(P, B) || I.push(P);
                  return I.length
                    ? w.error("string.email", { value: v, invalids: I })
                    : v;
                },
              },
              guid: {
                alias: "uuid",
                method() {
                  let v =
                    arguments.length > 0 && arguments[0] !== void 0
                      ? arguments[0]
                      : {};
                  g.assertOptions(v, ["version", "separator"]);
                  let w = "";
                  if (v.version) {
                    const R = [].concat(v.version);
                    a(
                      R.length >= 1,
                      "version must have at least 1 valid version specified"
                    );
                    const O = new Set();
                    for (let B = 0; B < R.length; ++B) {
                      const C = R[B];
                      a(
                        typeof C == "string",
                        "version at position " + B + " must be a string"
                      );
                      const I = b.guidVersions[C.toLowerCase()];
                      a(
                        I,
                        "version at position " +
                          B +
                          " must be one of " +
                          Object.keys(b.guidVersions).join(", ")
                      ),
                        a(
                          !O.has(I),
                          "version at position " +
                            B +
                            " must not be a duplicate"
                        ),
                        (w += I),
                        O.add(I);
                    }
                  }
                  a(
                    b.guidSeparators.has(v.separator),
                    'separator must be one of true, false, "-", or ":"'
                  );
                  const x =
                      v.separator === void 0
                        ? "[:-]?"
                        : v.separator === !0
                        ? "[:-]"
                        : v.separator === !1
                        ? "[]?"
                        : `\\${v.separator}`,
                    S = new RegExp(
                      `^([\\[{\\(]?)[0-9A-F]{8}(${x})[0-9A-F]{4}\\2?[${
                        w || "0-9A-F"
                      }][0-9A-F]{3}\\2?[${
                        w ? "89AB" : "0-9A-F"
                      }][0-9A-F]{3}\\2?[0-9A-F]{12}([\\]}\\)]?)$`,
                      "i"
                    );
                  return this.$_addRule({
                    name: "guid",
                    args: { options: v },
                    regex: S,
                  });
                },
                validate(v, w, x, S) {
                  let { regex: R } = S;
                  const O = R.exec(v);
                  return O
                    ? b.guidBrackets[O[1]] !== O[O.length - 1]
                      ? w.error("string.guid")
                      : v
                    : w.error("string.guid");
                },
              },
              hex: {
                method() {
                  let v =
                    arguments.length > 0 && arguments[0] !== void 0
                      ? arguments[0]
                      : {};
                  return (
                    g.assertOptions(v, ["byteAligned"]),
                    (v = { byteAligned: !1, ...v }),
                    a(
                      typeof v.byteAligned == "boolean",
                      "byteAligned must be boolean"
                    ),
                    this.$_addRule({ name: "hex", args: { options: v } })
                  );
                },
                validate(v, w, x) {
                  let { options: S } = x;
                  return b.hexRegex.test(v)
                    ? S.byteAligned && v.length % 2 != 0
                      ? w.error("string.hexAlign")
                      : v
                    : w.error("string.hex");
                },
              },
              hostname: {
                method() {
                  return this.$_addRule("hostname");
                },
                validate: (v, w) =>
                  l.isValid(v, { minDomainSegments: 1 }) || b.ipRegex.test(v)
                    ? v
                    : w.error("string.hostname"),
              },
              insensitive: {
                method() {
                  return this.$_setFlag("insensitive", !0);
                },
              },
              ip: {
                method() {
                  let v =
                    arguments.length > 0 && arguments[0] !== void 0
                      ? arguments[0]
                      : {};
                  g.assertOptions(v, ["cidr", "version"]);
                  const { cidr: w, versions: x, regex: S } = u.regex(v),
                    R = v.version ? x : void 0;
                  return this.$_addRule({
                    name: "ip",
                    args: { options: { cidr: w, version: R } },
                    regex: S,
                  });
                },
                validate(v, w, x, S) {
                  let { options: R } = x,
                    { regex: O } = S;
                  return O.test(v)
                    ? v
                    : R.version
                    ? w.error("string.ipVersion", {
                        value: v,
                        cidr: R.cidr,
                        version: R.version,
                      })
                    : w.error("string.ip", { value: v, cidr: R.cidr });
                },
              },
              isoDate: {
                method() {
                  return this.$_addRule("isoDate");
                },
                validate(v, w) {
                  let { error: x } = w;
                  return b.isoDate(v) ? v : x("string.isoDate");
                },
              },
              isoDuration: {
                method() {
                  return this.$_addRule("isoDuration");
                },
                validate: (v, w) =>
                  b.isoDurationRegex.test(v)
                    ? v
                    : w.error("string.isoDuration"),
              },
              length: {
                method(v, w) {
                  return b.length(this, "length", v, "=", w);
                },
                validate(v, w, x, S) {
                  let { limit: R, encoding: O } = x,
                    { name: B, operator: C, args: I } = S;
                  const P = !O && v.length;
                  return g.compare(P, R, C)
                    ? v
                    : w.error("string." + B, {
                        limit: I.limit,
                        value: v,
                        encoding: O,
                      });
                },
                args: [
                  {
                    name: "limit",
                    ref: !0,
                    assert: g.limit,
                    message: "must be a positive integer",
                  },
                  "encoding",
                ],
              },
              lowercase: {
                method() {
                  return this.case("lower");
                },
              },
              max: {
                method(v, w) {
                  return b.length(this, "max", v, "<=", w);
                },
                args: ["limit", "encoding"],
              },
              min: {
                method(v, w) {
                  return b.length(this, "min", v, ">=", w);
                },
                args: ["limit", "encoding"],
              },
              normalize: {
                method() {
                  let v =
                    arguments.length > 0 && arguments[0] !== void 0
                      ? arguments[0]
                      : "NFC";
                  return (
                    a(
                      b.normalizationForms.includes(v),
                      "normalization form must be one of " +
                        b.normalizationForms.join(", ")
                    ),
                    this.$_addRule({ name: "normalize", args: { form: v } })
                  );
                },
                validate(v, w, x) {
                  let { error: S } = w,
                    { form: R } = x;
                  return v === v.normalize(R)
                    ? v
                    : S("string.normalize", { value: v, form: R });
                },
                convert: !0,
              },
              pattern: {
                alias: "regex",
                method(v) {
                  let w =
                    arguments.length > 1 && arguments[1] !== void 0
                      ? arguments[1]
                      : {};
                  a(v instanceof RegExp, "regex must be a RegExp"),
                    a(
                      !v.flags.includes("g") && !v.flags.includes("y"),
                      "regex should not use global or sticky mode"
                    ),
                    typeof w == "string" && (w = { name: w }),
                    g.assertOptions(w, ["invert", "name"]);
                  const x = [
                    "string.pattern",
                    w.invert ? ".invert" : "",
                    w.name ? ".name" : ".base",
                  ].join("");
                  return this.$_addRule({
                    name: "pattern",
                    args: { regex: v, options: w },
                    errorCode: x,
                  });
                },
                validate(v, w, x, S) {
                  let { regex: R, options: O } = x,
                    { errorCode: B } = S;
                  return R.test(v) ^ O.invert
                    ? v
                    : w.error(B, { name: O.name, regex: R, value: v });
                },
                args: ["regex", "options"],
                multi: !0,
              },
              replace: {
                method(v, w) {
                  typeof v == "string" && (v = new RegExp(d(v), "g")),
                    a(v instanceof RegExp, "pattern must be a RegExp"),
                    a(typeof w == "string", "replacement must be a String");
                  const x = this.clone();
                  return (
                    x.$_terms.replacements || (x.$_terms.replacements = []),
                    x.$_terms.replacements.push({ pattern: v, replacement: w }),
                    x
                  );
                },
              },
              token: {
                method() {
                  return this.$_addRule("token");
                },
                validate: (v, w) =>
                  /^\w+$/.test(v) ? v : w.error("string.token"),
              },
              trim: {
                method() {
                  let v =
                    !(arguments.length > 0 && arguments[0] !== void 0) ||
                    arguments[0];
                  return (
                    a(typeof v == "boolean", "enabled must be a boolean"),
                    this.$_addRule({ name: "trim", args: { enabled: v } })
                  );
                },
                validate(v, w, x) {
                  let { enabled: S } = x;
                  return S && v !== v.trim() ? w.error("string.trim") : v;
                },
                convert: !0,
              },
              truncate: {
                method() {
                  let v =
                    !(arguments.length > 0 && arguments[0] !== void 0) ||
                    arguments[0];
                  return (
                    a(typeof v == "boolean", "enabled must be a boolean"),
                    this.$_setFlag("truncate", v)
                  );
                },
              },
              uppercase: {
                method() {
                  return this.case("upper");
                },
              },
              uri: {
                method() {
                  let v =
                    arguments.length > 0 && arguments[0] !== void 0
                      ? arguments[0]
                      : {};
                  g.assertOptions(v, [
                    "allowRelative",
                    "allowQuerySquareBrackets",
                    "domain",
                    "relativeOnly",
                    "scheme",
                  ]),
                    v.domain &&
                      g.assertOptions(v.domain, [
                        "allowFullyQualified",
                        "allowUnicode",
                        "maxDomainSegments",
                        "minDomainSegments",
                        "tlds",
                      ]);
                  const { regex: w, scheme: x } = h.regex(v),
                    S = v.domain ? b.addressOptions(v.domain) : null;
                  return this.$_addRule({
                    name: "uri",
                    args: { options: v },
                    regex: w,
                    domain: S,
                    scheme: x,
                  });
                },
                validate(v, w, x, S) {
                  let { options: R } = x,
                    { regex: O, domain: B, scheme: C } = S;
                  if (["http:/", "https:/"].includes(v))
                    return w.error("string.uri");
                  const I = O.exec(v);
                  if (I) {
                    const P = I[1] || I[2];
                    return !B || (R.allowRelative && !P) || l.isValid(P, B)
                      ? v
                      : w.error("string.domain", { value: P });
                  }
                  return R.relativeOnly
                    ? w.error("string.uriRelativeOnly")
                    : R.scheme
                    ? w.error("string.uriCustomScheme", { scheme: C, value: v })
                    : w.error("string.uri");
                },
              },
            },
            manifest: {
              build(v, w) {
                if (w.replacements)
                  for (const { pattern: x, replacement: S } of w.replacements)
                    v = v.replace(x, S);
                return v;
              },
            },
            messages: {
              "string.alphanum":
                "{{#label}} must only contain alpha-numeric characters",
              "string.base": "{{#label}} must be a string",
              "string.base64": "{{#label}} must be a valid base64 string",
              "string.creditCard": "{{#label}} must be a credit card",
              "string.dataUri": "{{#label}} must be a valid dataUri string",
              "string.domain": "{{#label}} must contain a valid domain name",
              "string.email": "{{#label}} must be a valid email",
              "string.empty": "{{#label}} is not allowed to be empty",
              "string.guid": "{{#label}} must be a valid GUID",
              "string.hex":
                "{{#label}} must only contain hexadecimal characters",
              "string.hexAlign":
                "{{#label}} hex decoded representation must be byte aligned",
              "string.hostname": "{{#label}} must be a valid hostname",
              "string.ip":
                "{{#label}} must be a valid ip address with a {{#cidr}} CIDR",
              "string.ipVersion":
                "{{#label}} must be a valid ip address of one of the following versions {{#version}} with a {{#cidr}} CIDR",
              "string.isoDate": "{{#label}} must be in iso format",
              "string.isoDuration":
                "{{#label}} must be a valid ISO 8601 duration",
              "string.length":
                "{{#label}} length must be {{#limit}} characters long",
              "string.lowercase":
                "{{#label}} must only contain lowercase characters",
              "string.max":
                "{{#label}} length must be less than or equal to {{#limit}} characters long",
              "string.min":
                "{{#label}} length must be at least {{#limit}} characters long",
              "string.normalize":
                "{{#label}} must be unicode normalized in the {{#form}} form",
              "string.token":
                "{{#label}} must only contain alpha-numeric and underscore characters",
              "string.pattern.base":
                "{{#label}} with value {:[.]} fails to match the required pattern: {{#regex}}",
              "string.pattern.name":
                "{{#label}} with value {:[.]} fails to match the {{#name}} pattern",
              "string.pattern.invert.base":
                "{{#label}} with value {:[.]} matches the inverted pattern: {{#regex}}",
              "string.pattern.invert.name":
                "{{#label}} with value {:[.]} matches the inverted {{#name}} pattern",
              "string.trim":
                "{{#label}} must not have leading or trailing whitespace",
              "string.uri": "{{#label}} must be a valid uri",
              "string.uriCustomScheme":
                "{{#label}} must be a valid uri with a scheme matching the {{#scheme}} pattern",
              "string.uriRelativeOnly":
                "{{#label}} must be a valid relative uri",
              "string.uppercase":
                "{{#label}} must only contain uppercase characters",
            },
          })),
            (b.addressOptions = function (v) {
              if (
                !v ||
                (a(
                  v.minDomainSegments === void 0 ||
                    (Number.isSafeInteger(v.minDomainSegments) &&
                      v.minDomainSegments > 0),
                  "minDomainSegments must be a positive integer"
                ),
                a(
                  v.maxDomainSegments === void 0 ||
                    (Number.isSafeInteger(v.maxDomainSegments) &&
                      v.maxDomainSegments > 0),
                  "maxDomainSegments must be a positive integer"
                ),
                v.tlds === !1)
              )
                return v;
              if (v.tlds === !0 || v.tlds === void 0)
                return (
                  a(b.tlds, "Built-in TLD list disabled"),
                  Object.assign({}, v, b.tlds)
                );
              a(
                typeof v.tlds == "object",
                "tlds must be true, false, or an object"
              );
              const w = v.tlds.deny;
              if (w)
                return (
                  Array.isArray(w) &&
                    (v = Object.assign({}, v, { tlds: { deny: new Set(w) } })),
                  a(
                    v.tlds.deny instanceof Set,
                    "tlds.deny must be an array, Set, or boolean"
                  ),
                  a(
                    !v.tlds.allow,
                    "Cannot specify both tlds.allow and tlds.deny lists"
                  ),
                  b.validateTlds(v.tlds.deny, "tlds.deny"),
                  v
                );
              const x = v.tlds.allow;
              return x
                ? x === !0
                  ? (a(b.tlds, "Built-in TLD list disabled"),
                    Object.assign({}, v, b.tlds))
                  : (Array.isArray(x) &&
                      (v = Object.assign({}, v, {
                        tlds: { allow: new Set(x) },
                      })),
                    a(
                      v.tlds.allow instanceof Set,
                      "tlds.allow must be an array, Set, or boolean"
                    ),
                    b.validateTlds(v.tlds.allow, "tlds.allow"),
                    v)
                : v;
            }),
            (b.validateTlds = function (v, w) {
              for (const x of v)
                a(
                  l.isValid(x, { minDomainSegments: 1, maxDomainSegments: 1 }),
                  `${w} must contain valid top level domain names`
                );
            }),
            (b.isoDate = function (v) {
              if (!g.isIsoDate(v)) return null;
              /.*T.*[+-]\d\d$/.test(v) && (v += "00");
              const w = new Date(v);
              return isNaN(w.getTime()) ? null : w.toISOString();
            }),
            (b.length = function (v, w, x, S, R) {
              return (
                a(!R || !1, "Invalid encoding:", R),
                v.$_addRule({
                  name: w,
                  method: "length",
                  args: { limit: x, encoding: R },
                  operator: S,
                })
              );
            });
        },
        8826: (i, s, o) => {
          const a = o(375),
            l = o(8068),
            c = {};
          (c.Map = class extends Map {
            slice() {
              return new c.Map(this);
            }
          }),
            (i.exports = l.extend({
              type: "symbol",
              terms: { map: { init: new c.Map() } },
              coerce: {
                method(u, d) {
                  let { schema: f, error: h } = d;
                  const p = f.$_terms.map.get(u);
                  return (
                    p && (u = p),
                    f._flags.only && typeof u != "symbol"
                      ? {
                          value: u,
                          errors: h("symbol.map", { map: f.$_terms.map }),
                        }
                      : { value: u }
                  );
                },
              },
              validate(u, d) {
                let { error: f } = d;
                if (typeof u != "symbol")
                  return { value: u, errors: f("symbol.base") };
              },
              rules: {
                map: {
                  method(u) {
                    u &&
                      !u[Symbol.iterator] &&
                      typeof u == "object" &&
                      (u = Object.entries(u)),
                      a(
                        u && u[Symbol.iterator],
                        "Iterable must be an iterable or object"
                      );
                    const d = this.clone(),
                      f = [];
                    for (const h of u) {
                      a(h && h[Symbol.iterator], "Entry must be an iterable");
                      const [p, g] = h;
                      a(
                        typeof p != "object" &&
                          typeof p != "function" &&
                          typeof p != "symbol",
                        "Key must not be of type object, function, or Symbol"
                      ),
                        a(typeof g == "symbol", "Value must be a Symbol"),
                        d.$_terms.map.set(p, g),
                        f.push(g);
                    }
                    return d.valid(...f);
                  },
                },
              },
              manifest: { build: (u, d) => (d.map && (u = u.map(d.map)), u) },
              messages: {
                "symbol.base": "{{#label}} must be a symbol",
                "symbol.map": "{{#label}} must be one of {{#map}}",
              },
            }));
        },
        8863: (i, s, o) => {
          const a = o(375),
            l = o(8571),
            c = o(738),
            u = o(9621),
            d = o(8160),
            f = o(6354),
            h = o(493),
            p = { result: Symbol("result") };
          (s.entry = function (g, b, v) {
            let w = d.defaults;
            v &&
              (a(
                v.warnings === void 0,
                "Cannot override warnings preference in synchronous validation"
              ),
              a(
                v.artifacts === void 0,
                "Cannot override artifacts preference in synchronous validation"
              ),
              (w = d.preferences(d.defaults, v)));
            const x = p.entry(g, b, w);
            a(
              !x.mainstay.externals.length,
              "Schema with external rules must use validateAsync()"
            );
            const S = { value: x.value };
            return (
              x.error && (S.error = x.error),
              x.mainstay.warnings.length &&
                (S.warning = f.details(x.mainstay.warnings)),
              x.mainstay.debug && (S.debug = x.mainstay.debug),
              x.mainstay.artifacts && (S.artifacts = x.mainstay.artifacts),
              S
            );
          }),
            (s.entryAsync = async function (g, b, v) {
              let w = d.defaults;
              v && (w = d.preferences(d.defaults, v));
              const x = p.entry(g, b, w),
                S = x.mainstay;
              if (x.error)
                throw (S.debug && (x.error.debug = S.debug), x.error);
              if (S.externals.length) {
                let O = x.value;
                const B = [];
                for (const C of S.externals) {
                  const I = C.state.path,
                    P = C.schema.type === "link" ? S.links.get(C.schema) : null;
                  let M,
                    k,
                    T = O;
                  const _ = I.length ? [O] : [],
                    A = I.length ? u(g, I) : g;
                  if (I.length) {
                    M = I[I.length - 1];
                    let N = O;
                    for (const L of I.slice(0, -1)) (N = N[L]), _.unshift(N);
                    (k = _[0]), (T = k[M]);
                  }
                  try {
                    const N = (F, D) =>
                        (P || C.schema).$_createError(F, T, D, C.state, w),
                      L = await C.method(T, {
                        schema: C.schema,
                        linked: P,
                        state: C.state,
                        prefs: v,
                        original: A,
                        error: N,
                        errorsArray: p.errorsArray,
                        warn: (F, D) =>
                          S.warnings.push(
                            (P || C.schema).$_createError(F, T, D, C.state, w)
                          ),
                        message: (F, D) =>
                          (P || C.schema).$_createError(
                            "external",
                            T,
                            D,
                            C.state,
                            w,
                            { messages: F }
                          ),
                      });
                    if (L === void 0 || L === T) continue;
                    if (L instanceof f.Report) {
                      if (
                        (S.tracer.log(
                          C.schema,
                          C.state,
                          "rule",
                          "external",
                          "error"
                        ),
                        B.push(L),
                        w.abortEarly)
                      )
                        break;
                      continue;
                    }
                    if (Array.isArray(L) && L[d.symbols.errors]) {
                      if (
                        (S.tracer.log(
                          C.schema,
                          C.state,
                          "rule",
                          "external",
                          "error"
                        ),
                        B.push(...L),
                        w.abortEarly)
                      )
                        break;
                      continue;
                    }
                    k
                      ? (S.tracer.value(C.state, "rule", T, L, "external"),
                        (k[M] = L))
                      : (S.tracer.value(C.state, "rule", O, L, "external"),
                        (O = L));
                  } catch (N) {
                    throw (w.errors.label && (N.message += ` (${C.label})`), N);
                  }
                }
                if (((x.value = O), B.length))
                  throw (
                    ((x.error = f.process(B, g, w)),
                    S.debug && (x.error.debug = S.debug),
                    x.error)
                  );
              }
              if (!w.warnings && !w.debug && !w.artifacts) return x.value;
              const R = { value: x.value };
              return (
                S.warnings.length && (R.warning = f.details(S.warnings)),
                S.debug && (R.debug = S.debug),
                S.artifacts && (R.artifacts = S.artifacts),
                R
              );
            }),
            (p.Mainstay = class {
              constructor(g, b, v) {
                (this.externals = []),
                  (this.warnings = []),
                  (this.tracer = g),
                  (this.debug = b),
                  (this.links = v),
                  (this.shadow = null),
                  (this.artifacts = null),
                  (this._snapshots = []);
              }
              snapshot() {
                this._snapshots.push({
                  externals: this.externals.slice(),
                  warnings: this.warnings.slice(),
                });
              }
              restore() {
                const g = this._snapshots.pop();
                (this.externals = g.externals), (this.warnings = g.warnings);
              }
            }),
            (p.entry = function (g, b, v) {
              const { tracer: w, cleanup: x } = p.tracer(b, v),
                S = v.debug ? [] : null,
                R = b._ids._schemaChain ? new Map() : null,
                O = new p.Mainstay(w, S, R),
                B = b._ids._schemaChain ? [{ schema: b }] : null,
                C = new h([], [], { mainstay: O, schemas: B }),
                I = s.validate(g, b, C, v);
              x && b.$_root.untrace();
              const P = f.process(I.errors, g, v);
              return { value: I.value, error: P, mainstay: O };
            }),
            (p.tracer = function (g, b) {
              return g.$_root._tracer
                ? { tracer: g.$_root._tracer._register(g) }
                : b.debug
                ? (a(g.$_root.trace, "Debug mode not supported"),
                  { tracer: g.$_root.trace()._register(g), cleanup: !0 })
                : { tracer: p.ignore };
            }),
            (s.validate = function (g, b, v, w) {
              let x =
                arguments.length > 4 && arguments[4] !== void 0
                  ? arguments[4]
                  : {};
              if (
                (b.$_terms.whens && (b = b._generate(g, v, w).schema),
                b._preferences && (w = p.prefs(b, w)),
                b._cache && w.cache)
              ) {
                const P = b._cache.get(g);
                if ((v.mainstay.tracer.debug(v, "validate", "cached", !!P), P))
                  return P;
              }
              const S = (P, M, k) => b.$_createError(P, g, M, k || v, w),
                R = {
                  original: g,
                  prefs: w,
                  schema: b,
                  state: v,
                  error: S,
                  errorsArray: p.errorsArray,
                  warn: (P, M, k) => v.mainstay.warnings.push(S(P, M, k)),
                  message: (P, M) =>
                    b.$_createError("custom", g, M, v, w, { messages: P }),
                };
              v.mainstay.tracer.entry(b, v);
              const O = b._definition;
              if (O.prepare && g !== void 0 && w.convert) {
                const P = O.prepare(g, R);
                if (P) {
                  if (
                    (v.mainstay.tracer.value(v, "prepare", g, P.value),
                    P.errors)
                  )
                    return p.finalize(P.value, [].concat(P.errors), R);
                  g = P.value;
                }
              }
              if (
                O.coerce &&
                g !== void 0 &&
                w.convert &&
                (!O.coerce.from || O.coerce.from.includes(typeof g))
              ) {
                const P = O.coerce.method(g, R);
                if (P) {
                  if (
                    (v.mainstay.tracer.value(v, "coerced", g, P.value),
                    P.errors)
                  )
                    return p.finalize(P.value, [].concat(P.errors), R);
                  g = P.value;
                }
              }
              const B = b._flags.empty;
              B &&
                B.$_match(p.trim(g, b), v.nest(B), d.defaults) &&
                (v.mainstay.tracer.value(v, "empty", g, void 0), (g = void 0));
              const C =
                x.presence ||
                b._flags.presence ||
                (b._flags._endedSwitch ? null : w.presence);
              if (g === void 0) {
                if (C === "forbidden") return p.finalize(g, null, R);
                if (C === "required")
                  return p.finalize(
                    g,
                    [b.$_createError("any.required", g, null, v, w)],
                    R
                  );
                if (C === "optional") {
                  if (b._flags.default !== d.symbols.deepDefault)
                    return p.finalize(g, null, R);
                  v.mainstay.tracer.value(v, "default", g, {}), (g = {});
                }
              } else if (C === "forbidden")
                return p.finalize(
                  g,
                  [b.$_createError("any.unknown", g, null, v, w)],
                  R
                );
              const I = [];
              if (b._valids) {
                const P = b._valids.get(g, v, w, b._flags.insensitive);
                if (P)
                  return (
                    w.convert &&
                      (v.mainstay.tracer.value(v, "valids", g, P.value),
                      (g = P.value)),
                    v.mainstay.tracer.filter(b, v, "valid", P),
                    p.finalize(g, null, R)
                  );
                if (b._flags.only) {
                  const M = b.$_createError(
                    "any.only",
                    g,
                    { valids: b._valids.values({ display: !0 }) },
                    v,
                    w
                  );
                  if (w.abortEarly) return p.finalize(g, [M], R);
                  I.push(M);
                }
              }
              if (b._invalids) {
                const P = b._invalids.get(g, v, w, b._flags.insensitive);
                if (P) {
                  v.mainstay.tracer.filter(b, v, "invalid", P);
                  const M = b.$_createError(
                    "any.invalid",
                    g,
                    { invalids: b._invalids.values({ display: !0 }) },
                    v,
                    w
                  );
                  if (w.abortEarly) return p.finalize(g, [M], R);
                  I.push(M);
                }
              }
              if (O.validate) {
                const P = O.validate(g, R);
                if (
                  P &&
                  (v.mainstay.tracer.value(v, "base", g, P.value),
                  (g = P.value),
                  P.errors)
                ) {
                  if (!Array.isArray(P.errors))
                    return I.push(P.errors), p.finalize(g, I, R);
                  if (P.errors.length)
                    return I.push(...P.errors), p.finalize(g, I, R);
                }
              }
              return b._rules.length ? p.rules(g, I, R) : p.finalize(g, I, R);
            }),
            (p.rules = function (g, b, v) {
              const { schema: w, state: x, prefs: S } = v;
              for (const R of w._rules) {
                const O = w._definition.rules[R.method];
                if (O.convert && S.convert) {
                  x.mainstay.tracer.log(w, x, "rule", R.name, "full");
                  continue;
                }
                let B,
                  C = R.args;
                if (R._resolve.length) {
                  C = Object.assign({}, C);
                  for (const P of R._resolve) {
                    const M = O.argsByName.get(P),
                      k = C[P].resolve(g, x, S),
                      T = M.normalize ? M.normalize(k) : k,
                      _ = d.validateArg(T, null, M);
                    if (_) {
                      B = w.$_createError(
                        "any.ref",
                        k,
                        { arg: P, ref: C[P], reason: _ },
                        x,
                        S
                      );
                      break;
                    }
                    C[P] = T;
                  }
                }
                B = B || O.validate(g, v, C, R);
                const I = p.rule(B, R);
                if (I.errors) {
                  if (
                    (x.mainstay.tracer.log(w, x, "rule", R.name, "error"),
                    R.warn)
                  ) {
                    x.mainstay.warnings.push(...I.errors);
                    continue;
                  }
                  if (S.abortEarly) return p.finalize(g, I.errors, v);
                  b.push(...I.errors);
                } else
                  x.mainstay.tracer.log(w, x, "rule", R.name, "pass"),
                    x.mainstay.tracer.value(x, "rule", g, I.value, R.name),
                    (g = I.value);
              }
              return p.finalize(g, b, v);
            }),
            (p.rule = function (g, b) {
              return g instanceof f.Report
                ? (p.error(g, b), { errors: [g], value: null })
                : Array.isArray(g) && g[d.symbols.errors]
                ? (g.forEach((v) => p.error(v, b)), { errors: g, value: null })
                : { errors: null, value: g };
            }),
            (p.error = function (g, b) {
              return b.message && g._setTemplate(b.message), g;
            }),
            (p.finalize = function (g, b, v) {
              b = b || [];
              const { schema: w, state: x, prefs: S } = v;
              if (b.length) {
                const O = p.default("failover", void 0, b, v);
                O !== void 0 &&
                  (x.mainstay.tracer.value(x, "failover", g, O),
                  (g = O),
                  (b = []));
              }
              if (b.length && w._flags.error)
                if (typeof w._flags.error == "function") {
                  (b = w._flags.error(b)), Array.isArray(b) || (b = [b]);
                  for (const O of b)
                    a(
                      O instanceof Error || O instanceof f.Report,
                      "error() must return an Error object"
                    );
                } else b = [w._flags.error];
              if (g === void 0) {
                const O = p.default("default", g, b, v);
                x.mainstay.tracer.value(x, "default", g, O), (g = O);
              }
              if (w._flags.cast && g !== void 0) {
                const O = w._definition.cast[w._flags.cast];
                if (O.from(g)) {
                  const B = O.to(g, v);
                  x.mainstay.tracer.value(x, "cast", g, B, w._flags.cast),
                    (g = B);
                }
              }
              if (w.$_terms.externals && S.externals && S._externals !== !1)
                for (const { method: O } of w.$_terms.externals)
                  x.mainstay.externals.push({
                    method: O,
                    schema: w,
                    state: x,
                    label: f.label(w._flags, x, S),
                  });
              const R = { value: g, errors: b.length ? b : null };
              return (
                w._flags.result &&
                  ((R.value =
                    w._flags.result === "strip" ? void 0 : v.original),
                  x.mainstay.tracer.value(x, w._flags.result, g, R.value),
                  x.shadow(g, w._flags.result)),
                w._cache &&
                  S.cache !== !1 &&
                  !w._refs.length &&
                  w._cache.set(v.original, R),
                g === void 0 ||
                  R.errors ||
                  w._flags.artifact === void 0 ||
                  ((x.mainstay.artifacts = x.mainstay.artifacts || new Map()),
                  x.mainstay.artifacts.has(w._flags.artifact) ||
                    x.mainstay.artifacts.set(w._flags.artifact, []),
                  x.mainstay.artifacts.get(w._flags.artifact).push(x.path)),
                R
              );
            }),
            (p.prefs = function (g, b) {
              const v = b === d.defaults;
              return v && g._preferences[d.symbols.prefs]
                ? g._preferences[d.symbols.prefs]
                : ((b = d.preferences(b, g._preferences)),
                  v && (g._preferences[d.symbols.prefs] = b),
                  b);
            }),
            (p.default = function (g, b, v, w) {
              const { schema: x, state: S, prefs: R } = w,
                O = x._flags[g];
              if (R.noDefaults || O === void 0) return b;
              if ((S.mainstay.tracer.log(x, S, "rule", g, "full"), !O))
                return O;
              if (typeof O == "function") {
                const B = O.length ? [l(S.ancestors[0]), w] : [];
                try {
                  return O(...B);
                } catch (C) {
                  return void v.push(
                    x.$_createError(`any.${g}`, null, { error: C }, S, R)
                  );
                }
              }
              return typeof O != "object"
                ? O
                : O[d.symbols.literal]
                ? O.literal
                : d.isResolvable(O)
                ? O.resolve(b, S, R)
                : l(O);
            }),
            (p.trim = function (g, b) {
              if (typeof g != "string") return g;
              const v = b.$_getRule("trim");
              return v && v.args.enabled ? g.trim() : g;
            }),
            (p.ignore = {
              active: !1,
              debug: c,
              entry: c,
              filter: c,
              log: c,
              resolve: c,
              value: c,
            }),
            (p.errorsArray = function () {
              const g = [];
              return (g[d.symbols.errors] = !0), g;
            });
        },
        2036: (i, s, o) => {
          const a = o(375),
            l = o(9474),
            c = o(8160),
            u = {};
          (i.exports = u.Values =
            class {
              constructor(d, f) {
                (this._values = new Set(d)),
                  (this._refs = new Set(f)),
                  (this._lowercase = u.lowercases(d)),
                  (this._override = !1);
              }
              get length() {
                return this._values.size + this._refs.size;
              }
              add(d, f) {
                c.isResolvable(d)
                  ? this._refs.has(d) || (this._refs.add(d), f && f.register(d))
                  : this.has(d, null, null, !1) ||
                    (this._values.add(d),
                    typeof d == "string" &&
                      this._lowercase.set(d.toLowerCase(), d));
              }
              static merge(d, f, h) {
                if (((d = d || new u.Values()), f)) {
                  if (f._override) return f.clone();
                  for (const p of [...f._values, ...f._refs]) d.add(p);
                }
                if (h) for (const p of [...h._values, ...h._refs]) d.remove(p);
                return d.length ? d : null;
              }
              remove(d) {
                c.isResolvable(d)
                  ? this._refs.delete(d)
                  : (this._values.delete(d),
                    typeof d == "string" &&
                      this._lowercase.delete(d.toLowerCase()));
              }
              has(d, f, h, p) {
                return !!this.get(d, f, h, p);
              }
              get(d, f, h, p) {
                if (!this.length) return !1;
                if (this._values.has(d)) return { value: d };
                if (typeof d == "string" && d && p) {
                  const g = this._lowercase.get(d.toLowerCase());
                  if (g) return { value: g };
                }
                if (!this._refs.size && typeof d != "object") return !1;
                if (typeof d == "object") {
                  for (const g of this._values)
                    if (l(g, d)) return { value: g };
                }
                if (f)
                  for (const g of this._refs) {
                    const b = g.resolve(d, f, h, null, { in: !0 });
                    if (b === void 0) continue;
                    const v =
                      g.in && typeof b == "object"
                        ? Array.isArray(b)
                          ? b
                          : Object.keys(b)
                        : [b];
                    for (const w of v)
                      if (typeof w == typeof d) {
                        if (p && d && typeof d == "string") {
                          if (w.toLowerCase() === d.toLowerCase())
                            return { value: w, ref: g };
                        } else if (l(w, d)) return { value: w, ref: g };
                      }
                  }
                return !1;
              }
              override() {
                this._override = !0;
              }
              values(d) {
                if (d && d.display) {
                  const f = [];
                  for (const h of [...this._values, ...this._refs])
                    h !== void 0 && f.push(h);
                  return f;
                }
                return Array.from([...this._values, ...this._refs]);
              }
              clone() {
                const d = new u.Values(this._values, this._refs);
                return (d._override = this._override), d;
              }
              concat(d) {
                a(!d._override, "Cannot concat override set of values");
                const f = new u.Values(
                  [...this._values, ...d._values],
                  [...this._refs, ...d._refs]
                );
                return (f._override = this._override), f;
              }
              describe() {
                const d = [];
                this._override && d.push({ override: !0 });
                for (const f of this._values.values())
                  d.push(f && typeof f == "object" ? { value: f } : f);
                for (const f of this._refs.values()) d.push(f.describe());
                return d;
              }
            }),
            (u.Values.prototype[c.symbols.values] = !0),
            (u.Values.prototype.slice = u.Values.prototype.clone),
            (u.lowercases = function (d) {
              const f = new Map();
              if (d)
                for (const h of d)
                  typeof h == "string" && f.set(h.toLowerCase(), h);
              return f;
            });
        },
        978: (i, s, o) => {
          const a = o(375),
            l = o(8571),
            c = o(1687),
            u = o(9621),
            d = {};
          (i.exports = function (f, h) {
            let p =
              arguments.length > 2 && arguments[2] !== void 0
                ? arguments[2]
                : {};
            if (
              (a(
                f && typeof f == "object",
                "Invalid defaults value: must be an object"
              ),
              a(
                !h || h === !0 || typeof h == "object",
                "Invalid source value: must be true, falsy or an object"
              ),
              a(typeof p == "object", "Invalid options: must be an object"),
              !h)
            )
              return null;
            if (p.shallow) return d.applyToDefaultsWithShallow(f, h, p);
            const g = l(f);
            if (h === !0) return g;
            const b = p.nullOverride !== void 0 && p.nullOverride;
            return c(g, h, { nullOverride: b, mergeArrays: !1 });
          }),
            (d.applyToDefaultsWithShallow = function (f, h, p) {
              const g = p.shallow;
              a(Array.isArray(g), "Invalid keys");
              const b = new Map(),
                v = h === !0 ? null : new Set();
              for (let S of g) {
                S = Array.isArray(S) ? S : S.split(".");
                const R = u(f, S);
                R && typeof R == "object"
                  ? b.set(R, (v && u(h, S)) || R)
                  : v && v.add(S);
              }
              const w = l(f, {}, b);
              if (!v) return w;
              for (const S of v) d.reachCopy(w, h, S);
              const x = p.nullOverride !== void 0 && p.nullOverride;
              return c(w, h, { nullOverride: x, mergeArrays: !1 });
            }),
            (d.reachCopy = function (f, h, p) {
              for (const v of p) {
                if (!(v in h)) return;
                const w = h[v];
                if (typeof w != "object" || w === null) return;
                h = w;
              }
              const g = h;
              let b = f;
              for (let v = 0; v < p.length - 1; ++v) {
                const w = p[v];
                typeof b[w] != "object" && (b[w] = {}), (b = b[w]);
              }
              b[p[p.length - 1]] = g;
            });
        },
        375: (i, s, o) => {
          const a = o(7916);
          i.exports = function (l) {
            if (!l) {
              for (
                var c = arguments.length,
                  u = new Array(c > 1 ? c - 1 : 0),
                  d = 1;
                d < c;
                d++
              )
                u[d - 1] = arguments[d];
              throw u.length === 1 && u[0] instanceof Error ? u[0] : new a(u);
            }
          };
        },
        8571: (i, s, o) => {
          const a = o(9621),
            l = o(4277),
            c = o(7043),
            u = {
              needsProtoHack: new Set([l.set, l.map, l.weakSet, l.weakMap]),
            };
          (i.exports = u.clone =
            function (d) {
              let f =
                  arguments.length > 1 && arguments[1] !== void 0
                    ? arguments[1]
                    : {},
                h =
                  arguments.length > 2 && arguments[2] !== void 0
                    ? arguments[2]
                    : null;
              if (typeof d != "object" || d === null) return d;
              let p = u.clone,
                g = h;
              if (f.shallow) {
                if (f.shallow !== !0) return u.cloneWithShallow(d, f);
                p = (x) => x;
              } else if (g) {
                const x = g.get(d);
                if (x) return x;
              } else g = new Map();
              const b = l.getInternalProto(d);
              if (b === l.buffer) return !1;
              if (b === l.date) return new Date(d.getTime());
              if (b === l.regex) return new RegExp(d);
              const v = u.base(d, b, f);
              if (v === d) return d;
              if ((g && g.set(d, v), b === l.set))
                for (const x of d) v.add(p(x, f, g));
              else if (b === l.map)
                for (const [x, S] of d) v.set(x, p(S, f, g));
              const w = c.keys(d, f);
              for (const x of w) {
                if (x === "__proto__") continue;
                if (b === l.array && x === "length") {
                  v.length = d.length;
                  continue;
                }
                const S = Object.getOwnPropertyDescriptor(d, x);
                S
                  ? S.get || S.set
                    ? Object.defineProperty(v, x, S)
                    : S.enumerable
                    ? (v[x] = p(d[x], f, g))
                    : Object.defineProperty(v, x, {
                        enumerable: !1,
                        writable: !0,
                        configurable: !0,
                        value: p(d[x], f, g),
                      })
                  : Object.defineProperty(v, x, {
                      enumerable: !0,
                      writable: !0,
                      configurable: !0,
                      value: p(d[x], f, g),
                    });
              }
              return v;
            }),
            (u.cloneWithShallow = function (d, f) {
              const h = f.shallow;
              (f = Object.assign({}, f)).shallow = !1;
              const p = new Map();
              for (const g of h) {
                const b = a(d, g);
                (typeof b != "object" && typeof b != "function") || p.set(b, b);
              }
              return u.clone(d, f, p);
            }),
            (u.base = function (d, f, h) {
              if (h.prototype === !1)
                return u.needsProtoHack.has(f)
                  ? new f.constructor()
                  : f === l.array
                  ? []
                  : {};
              const p = Object.getPrototypeOf(d);
              if (p && p.isImmutable) return d;
              if (f === l.array) {
                const g = [];
                return p !== f && Object.setPrototypeOf(g, p), g;
              }
              if (u.needsProtoHack.has(f)) {
                const g = new p.constructor();
                return p !== f && Object.setPrototypeOf(g, p), g;
              }
              return Object.create(p);
            });
        },
        9474: (i, s, o) => {
          const a = o(4277),
            l = { mismatched: null };
          (i.exports = function (c, u, d) {
            return (
              (d = Object.assign({ prototype: !0 }, d)),
              !!l.isDeepEqual(c, u, d, [])
            );
          }),
            (l.isDeepEqual = function (c, u, d, f) {
              if (c === u) return c !== 0 || 1 / c == 1 / u;
              const h = typeof c;
              if (h !== typeof u || c === null || u === null) return !1;
              if (h === "function") {
                if (!d.deepFunction || c.toString() !== u.toString()) return !1;
              } else if (h !== "object") return c != c && u != u;
              const p = l.getSharedType(c, u, !!d.prototype);
              switch (p) {
                case a.buffer:
                  return !1;
                case a.promise:
                  return c === u;
                case a.regex:
                  return c.toString() === u.toString();
                case l.mismatched:
                  return !1;
              }
              for (let g = f.length - 1; g >= 0; --g)
                if (f[g].isSame(c, u)) return !0;
              f.push(new l.SeenEntry(c, u));
              try {
                return !!l.isDeepEqualObj(p, c, u, d, f);
              } finally {
                f.pop();
              }
            }),
            (l.getSharedType = function (c, u, d) {
              if (d)
                return Object.getPrototypeOf(c) !== Object.getPrototypeOf(u)
                  ? l.mismatched
                  : a.getInternalProto(c);
              const f = a.getInternalProto(c);
              return f !== a.getInternalProto(u) ? l.mismatched : f;
            }),
            (l.valueOf = function (c) {
              const u = c.valueOf;
              if (u === void 0) return c;
              try {
                return u.call(c);
              } catch (d) {
                return d;
              }
            }),
            (l.hasOwnEnumerableProperty = function (c, u) {
              return Object.prototype.propertyIsEnumerable.call(c, u);
            }),
            (l.isSetSimpleEqual = function (c, u) {
              for (const d of Set.prototype.values.call(c))
                if (!Set.prototype.has.call(u, d)) return !1;
              return !0;
            }),
            (l.isDeepEqualObj = function (c, u, d, f, h) {
              const {
                  isDeepEqual: p,
                  valueOf: g,
                  hasOwnEnumerableProperty: b,
                } = l,
                { keys: v, getOwnPropertySymbols: w } = Object;
              if (c === a.array) {
                if (!f.part) {
                  if (u.length !== d.length) return !1;
                  for (let B = 0; B < u.length; ++B)
                    if (!p(u[B], d[B], f, h)) return !1;
                  return !0;
                }
                for (const B of u)
                  for (const C of d) if (p(B, C, f, h)) return !0;
              } else if (c === a.set) {
                if (u.size !== d.size) return !1;
                if (!l.isSetSimpleEqual(u, d)) {
                  const B = new Set(Set.prototype.values.call(d));
                  for (const C of Set.prototype.values.call(u)) {
                    if (B.delete(C)) continue;
                    let I = !1;
                    for (const P of B)
                      if (p(C, P, f, h)) {
                        B.delete(P), (I = !0);
                        break;
                      }
                    if (!I) return !1;
                  }
                }
              } else if (c === a.map) {
                if (u.size !== d.size) return !1;
                for (const [B, C] of Map.prototype.entries.call(u))
                  if (
                    (C === void 0 && !Map.prototype.has.call(d, B)) ||
                    !p(C, Map.prototype.get.call(d, B), f, h)
                  )
                    return !1;
              } else if (
                c === a.error &&
                (u.name !== d.name || u.message !== d.message)
              )
                return !1;
              const x = g(u),
                S = g(d);
              if ((u !== x || d !== S) && !p(x, S, f, h)) return !1;
              const R = v(u);
              if (!f.part && R.length !== v(d).length && !f.skip) return !1;
              let O = 0;
              for (const B of R)
                if (f.skip && f.skip.includes(B)) d[B] === void 0 && ++O;
                else if (!b(d, B) || !p(u[B], d[B], f, h)) return !1;
              if (!f.part && R.length - O !== v(d).length) return !1;
              if (f.symbols !== !1) {
                const B = w(u),
                  C = new Set(w(d));
                for (const I of B) {
                  if (!f.skip || !f.skip.includes(I)) {
                    if (b(u, I)) {
                      if (!b(d, I) || !p(u[I], d[I], f, h)) return !1;
                    } else if (b(d, I)) return !1;
                  }
                  C.delete(I);
                }
                for (const I of C) if (b(d, I)) return !1;
              }
              return !0;
            }),
            (l.SeenEntry = class {
              constructor(c, u) {
                (this.obj = c), (this.ref = u);
              }
              isSame(c, u) {
                return this.obj === c && this.ref === u;
              }
            });
        },
        7916: (i, s, o) => {
          const a = o(8761);
          i.exports = class extends Error {
            constructor(l) {
              super(
                l
                  .filter((c) => c !== "")
                  .map((c) =>
                    typeof c == "string"
                      ? c
                      : c instanceof Error
                      ? c.message
                      : a(c)
                  )
                  .join(" ") || "Unknown error"
              ),
                typeof Error.captureStackTrace == "function" &&
                  Error.captureStackTrace(this, s.assert);
            }
          };
        },
        5277: (i) => {
          const s = {};
          (i.exports = function (o) {
            if (!o) return "";
            let a = "";
            for (let l = 0; l < o.length; ++l) {
              const c = o.charCodeAt(l);
              s.isSafe(c) ? (a += o[l]) : (a += s.escapeHtmlChar(c));
            }
            return a;
          }),
            (s.escapeHtmlChar = function (o) {
              return (
                s.namedHtml.get(o) ||
                (o >= 256
                  ? "&#" + o + ";"
                  : `&#x${o.toString(16).padStart(2, "0")};`)
              );
            }),
            (s.isSafe = function (o) {
              return s.safeCharCodes.has(o);
            }),
            (s.namedHtml = new Map([
              [38, "&amp;"],
              [60, "&lt;"],
              [62, "&gt;"],
              [34, "&quot;"],
              [160, "&nbsp;"],
              [162, "&cent;"],
              [163, "&pound;"],
              [164, "&curren;"],
              [169, "&copy;"],
              [174, "&reg;"],
            ])),
            (s.safeCharCodes = (function () {
              const o = new Set();
              for (let a = 32; a < 123; ++a)
                (a >= 97 ||
                  (a >= 65 && a <= 90) ||
                  (a >= 48 && a <= 57) ||
                  a === 32 ||
                  a === 46 ||
                  a === 44 ||
                  a === 45 ||
                  a === 58 ||
                  a === 95) &&
                  o.add(a);
              return o;
            })());
        },
        6064: (i) => {
          i.exports = function (s) {
            return s.replace(
              /[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g,
              "\\$&"
            );
          };
        },
        738: (i) => {
          i.exports = function () {};
        },
        1687: (i, s, o) => {
          const a = o(375),
            l = o(8571),
            c = o(7043),
            u = {};
          i.exports = u.merge = function (d, f, h) {
            if (
              (a(
                d && typeof d == "object",
                "Invalid target value: must be an object"
              ),
              a(
                f == null || typeof f == "object",
                "Invalid source value: must be null, undefined, or an object"
              ),
              !f)
            )
              return d;
            if (
              ((h = Object.assign({ nullOverride: !0, mergeArrays: !0 }, h)),
              Array.isArray(f))
            ) {
              a(Array.isArray(d), "Cannot merge array onto an object"),
                h.mergeArrays || (d.length = 0);
              for (let g = 0; g < f.length; ++g)
                d.push(l(f[g], { symbols: h.symbols }));
              return d;
            }
            const p = c.keys(f, h);
            for (let g = 0; g < p.length; ++g) {
              const b = p[g];
              if (
                b === "__proto__" ||
                !Object.prototype.propertyIsEnumerable.call(f, b)
              )
                continue;
              const v = f[b];
              if (v && typeof v == "object") {
                if (d[b] === v) continue;
                !d[b] ||
                typeof d[b] != "object" ||
                Array.isArray(d[b]) !== Array.isArray(v) ||
                v instanceof Date ||
                v instanceof RegExp
                  ? (d[b] = l(v, { symbols: h.symbols }))
                  : u.merge(d[b], v, h);
              } else (v != null || h.nullOverride) && (d[b] = v);
            }
            return d;
          };
        },
        9621: (i, s, o) => {
          const a = o(375),
            l = {};
          (i.exports = function (c, u, d) {
            if (u === !1 || u == null) return c;
            typeof (d = d || {}) == "string" && (d = { separator: d });
            const f = Array.isArray(u);
            a(
              !f || !d.separator,
              "Separator option is not valid for array-based chain"
            );
            const h = f ? u : u.split(d.separator || ".");
            let p = c;
            for (let g = 0; g < h.length; ++g) {
              let b = h[g];
              const v = d.iterables && l.iterables(p);
              if (Array.isArray(p) || v === "set") {
                const w = Number(b);
                Number.isInteger(w) && (b = w < 0 ? p.length + w : w);
              }
              if (
                !p ||
                (typeof p == "function" && d.functions === !1) ||
                (!v && p[b] === void 0)
              ) {
                a(
                  !d.strict || g + 1 === h.length,
                  "Missing segment",
                  b,
                  "in reach path ",
                  u
                ),
                  a(
                    typeof p == "object" ||
                      d.functions === !0 ||
                      typeof p != "function",
                    "Invalid segment",
                    b,
                    "in reach path ",
                    u
                  ),
                  (p = d.default);
                break;
              }
              p = v ? (v === "set" ? [...p][b] : p.get(b)) : p[b];
            }
            return p;
          }),
            (l.iterables = function (c) {
              return c instanceof Set
                ? "set"
                : c instanceof Map
                ? "map"
                : void 0;
            });
        },
        8761: (i) => {
          i.exports = function () {
            try {
              return JSON.stringify(...arguments);
            } catch (s) {
              return "[Cannot display object: " + s.message + "]";
            }
          };
        },
        4277: (i, s) => {
          const o = {};
          (s = i.exports =
            {
              array: Array.prototype,
              buffer: !1,
              date: Date.prototype,
              error: Error.prototype,
              generic: Object.prototype,
              map: Map.prototype,
              promise: Promise.prototype,
              regex: RegExp.prototype,
              set: Set.prototype,
              weakMap: WeakMap.prototype,
              weakSet: WeakSet.prototype,
            }),
            (o.typeMap = new Map([
              ["[object Error]", s.error],
              ["[object Map]", s.map],
              ["[object Promise]", s.promise],
              ["[object Set]", s.set],
              ["[object WeakMap]", s.weakMap],
              ["[object WeakSet]", s.weakSet],
            ])),
            (s.getInternalProto = function (a) {
              if (Array.isArray(a)) return s.array;
              if (a instanceof Date) return s.date;
              if (a instanceof RegExp) return s.regex;
              if (a instanceof Error) return s.error;
              const l = Object.prototype.toString.call(a);
              return o.typeMap.get(l) || s.generic;
            });
        },
        7043: (i, s) => {
          s.keys = function (o) {
            return (arguments.length > 1 && arguments[1] !== void 0
              ? arguments[1]
              : {}
            ).symbols !== !1
              ? Reflect.ownKeys(o)
              : Object.getOwnPropertyNames(o);
          };
        },
        3652: (i, s, o) => {
          const a = o(375),
            l = {};
          (s.Sorter = class {
            constructor() {
              (this._items = []), (this.nodes = []);
            }
            add(c, u) {
              const d = [].concat((u = u || {}).before || []),
                f = [].concat(u.after || []),
                h = u.group || "?",
                p = u.sort || 0;
              a(!d.includes(h), `Item cannot come before itself: ${h}`),
                a(
                  !d.includes("?"),
                  "Item cannot come before unassociated items"
                ),
                a(!f.includes(h), `Item cannot come after itself: ${h}`),
                a(
                  !f.includes("?"),
                  "Item cannot come after unassociated items"
                ),
                Array.isArray(c) || (c = [c]);
              for (const g of c) {
                const b = {
                  seq: this._items.length,
                  sort: p,
                  before: d,
                  after: f,
                  group: h,
                  node: g,
                };
                this._items.push(b);
              }
              if (!u.manual) {
                const g = this._sort();
                a(
                  g,
                  "item",
                  h !== "?" ? `added into group ${h}` : "",
                  "created a dependencies error"
                );
              }
              return this.nodes;
            }
            merge(c) {
              Array.isArray(c) || (c = [c]);
              for (const d of c)
                if (d)
                  for (const f of d._items)
                    this._items.push(Object.assign({}, f));
              this._items.sort(l.mergeSort);
              for (let d = 0; d < this._items.length; ++d)
                this._items[d].seq = d;
              const u = this._sort();
              return a(u, "merge created a dependencies error"), this.nodes;
            }
            sort() {
              const c = this._sort();
              return a(c, "sort created a dependencies error"), this.nodes;
            }
            _sort() {
              const c = {},
                u = Object.create(null),
                d = Object.create(null);
              for (const b of this._items) {
                const v = b.seq,
                  w = b.group;
                (d[w] = d[w] || []), d[w].push(v), (c[v] = b.before);
                for (const x of b.after) (u[x] = u[x] || []), u[x].push(v);
              }
              for (const b in c) {
                const v = [];
                for (const w in c[b]) {
                  const x = c[b][w];
                  (d[x] = d[x] || []), v.push(...d[x]);
                }
                c[b] = v;
              }
              for (const b in u)
                if (d[b]) for (const v of d[b]) c[v].push(...u[b]);
              const f = {};
              for (const b in c) {
                const v = c[b];
                for (const w of v) (f[w] = f[w] || []), f[w].push(b);
              }
              const h = {},
                p = [];
              for (let b = 0; b < this._items.length; ++b) {
                let v = b;
                if (f[b]) {
                  v = null;
                  for (let w = 0; w < this._items.length; ++w) {
                    if (h[w] === !0) continue;
                    f[w] || (f[w] = []);
                    const x = f[w].length;
                    let S = 0;
                    for (let R = 0; R < x; ++R) h[f[w][R]] && ++S;
                    if (S === x) {
                      v = w;
                      break;
                    }
                  }
                }
                v !== null && ((h[v] = !0), p.push(v));
              }
              if (p.length !== this._items.length) return !1;
              const g = {};
              for (const b of this._items) g[b.seq] = b;
              (this._items = []), (this.nodes = []);
              for (const b of p) {
                const v = g[b];
                this.nodes.push(v.node), this._items.push(v);
              }
              return !0;
            }
          }),
            (l.mergeSort = (c, u) =>
              c.sort === u.sort ? 0 : c.sort < u.sort ? -1 : 1);
        },
        5380: (i, s, o) => {
          const a = o(443),
            l = o(2178),
            c = {
              minDomainSegments: 2,
              nonAsciiRx: /[^\x00-\x7f]/,
              domainControlRx: /[\x00-\x20@\:\/\\#!\$&\'\(\)\*\+,;=\?]/,
              tldSegmentRx: /^[a-zA-Z](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,
              domainSegmentRx: /^[a-zA-Z0-9](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,
              URL: a.URL || URL,
            };
          (s.analyze = function (u) {
            let d =
              arguments.length > 1 && arguments[1] !== void 0
                ? arguments[1]
                : {};
            if (!u) return l.code("DOMAIN_NON_EMPTY_STRING");
            if (typeof u != "string")
              throw new Error("Invalid input: domain must be a string");
            if (u.length > 256) return l.code("DOMAIN_TOO_LONG");
            if (c.nonAsciiRx.test(u)) {
              if (d.allowUnicode === !1)
                return l.code("DOMAIN_INVALID_UNICODE_CHARS");
              u = u.normalize("NFC");
            }
            if (c.domainControlRx.test(u))
              return l.code("DOMAIN_INVALID_CHARS");
            (u = c.punycode(u)),
              d.allowFullyQualified &&
                u[u.length - 1] === "." &&
                (u = u.slice(0, -1));
            const f = d.minDomainSegments || c.minDomainSegments,
              h = u.split(".");
            if (h.length < f) return l.code("DOMAIN_SEGMENTS_COUNT");
            if (d.maxDomainSegments && h.length > d.maxDomainSegments)
              return l.code("DOMAIN_SEGMENTS_COUNT_MAX");
            const p = d.tlds;
            if (p) {
              const g = h[h.length - 1].toLowerCase();
              if ((p.deny && p.deny.has(g)) || (p.allow && !p.allow.has(g)))
                return l.code("DOMAIN_FORBIDDEN_TLDS");
            }
            for (let g = 0; g < h.length; ++g) {
              const b = h[g];
              if (!b.length) return l.code("DOMAIN_EMPTY_SEGMENT");
              if (b.length > 63) return l.code("DOMAIN_LONG_SEGMENT");
              if (g < h.length - 1) {
                if (!c.domainSegmentRx.test(b))
                  return l.code("DOMAIN_INVALID_CHARS");
              } else if (!c.tldSegmentRx.test(b))
                return l.code("DOMAIN_INVALID_TLDS_CHARS");
            }
            return null;
          }),
            (s.isValid = function (u, d) {
              return !s.analyze(u, d);
            }),
            (c.punycode = function (u) {
              u.includes("%") && (u = u.replace(/%/g, "%25"));
              try {
                return new c.URL(`http://${u}`).host;
              } catch {
                return u;
              }
            });
        },
        1745: (i, s, o) => {
          const a = o(9848),
            l = o(5380),
            c = o(2178),
            u = {
              nonAsciiRx: /[^\x00-\x7f]/,
              encoder: new (a.TextEncoder || TextEncoder)(),
            };
          (s.analyze = function (d, f) {
            return u.email(d, f);
          }),
            (s.isValid = function (d, f) {
              return !u.email(d, f);
            }),
            (u.email = function (d) {
              let f =
                arguments.length > 1 && arguments[1] !== void 0
                  ? arguments[1]
                  : {};
              if (typeof d != "string")
                throw new Error("Invalid input: email must be a string");
              if (!d) return c.code("EMPTY_STRING");
              const h = !u.nonAsciiRx.test(d);
              if (!h) {
                if (f.allowUnicode === !1) return c.code("FORBIDDEN_UNICODE");
                d = d.normalize("NFC");
              }
              const p = d.split("@");
              if (p.length !== 2)
                return p.length > 2
                  ? c.code("MULTIPLE_AT_CHAR")
                  : c.code("MISSING_AT_CHAR");
              const [g, b] = p;
              if (!g) return c.code("EMPTY_LOCAL");
              if (!f.ignoreLength) {
                if (d.length > 254) return c.code("ADDRESS_TOO_LONG");
                if (u.encoder.encode(g).length > 64)
                  return c.code("LOCAL_TOO_LONG");
              }
              return u.local(g, h) || l.analyze(b, f);
            }),
            (u.local = function (d, f) {
              const h = d.split(".");
              for (const p of h) {
                if (!p.length) return c.code("EMPTY_LOCAL_SEGMENT");
                if (f) {
                  if (!u.atextRx.test(p)) return c.code("INVALID_LOCAL_CHARS");
                } else
                  for (const g of p) {
                    if (u.atextRx.test(g)) continue;
                    const b = u.binary(g);
                    if (!u.atomRx.test(b)) return c.code("INVALID_LOCAL_CHARS");
                  }
              }
            }),
            (u.binary = function (d) {
              return Array.from(u.encoder.encode(d))
                .map((f) => String.fromCharCode(f))
                .join("");
            }),
            (u.atextRx = /^[\w!#\$%&'\*\+\-/=\?\^`\{\|\}~]+$/),
            (u.atomRx = new RegExp(
              [
                "(?:[\\xc2-\\xdf][\\x80-\\xbf])",
                "(?:\\xe0[\\xa0-\\xbf][\\x80-\\xbf])|(?:[\\xe1-\\xec][\\x80-\\xbf]{2})|(?:\\xed[\\x80-\\x9f][\\x80-\\xbf])|(?:[\\xee-\\xef][\\x80-\\xbf]{2})",
                "(?:\\xf0[\\x90-\\xbf][\\x80-\\xbf]{2})|(?:[\\xf1-\\xf3][\\x80-\\xbf]{3})|(?:\\xf4[\\x80-\\x8f][\\x80-\\xbf]{2})",
              ].join("|")
            ));
        },
        2178: (i, s) => {
          (s.codes = {
            EMPTY_STRING: "Address must be a non-empty string",
            FORBIDDEN_UNICODE: "Address contains forbidden Unicode characters",
            MULTIPLE_AT_CHAR:
              "Address cannot contain more than one @ character",
            MISSING_AT_CHAR: "Address must contain one @ character",
            EMPTY_LOCAL: "Address local part cannot be empty",
            ADDRESS_TOO_LONG: "Address too long",
            LOCAL_TOO_LONG: "Address local part too long",
            EMPTY_LOCAL_SEGMENT:
              "Address local part contains empty dot-separated segment",
            INVALID_LOCAL_CHARS:
              "Address local part contains invalid character",
            DOMAIN_NON_EMPTY_STRING: "Domain must be a non-empty string",
            DOMAIN_TOO_LONG: "Domain too long",
            DOMAIN_INVALID_UNICODE_CHARS:
              "Domain contains forbidden Unicode characters",
            DOMAIN_INVALID_CHARS: "Domain contains invalid character",
            DOMAIN_INVALID_TLDS_CHARS: "Domain contains invalid tld character",
            DOMAIN_SEGMENTS_COUNT:
              "Domain lacks the minimum required number of segments",
            DOMAIN_SEGMENTS_COUNT_MAX: "Domain contains too many segments",
            DOMAIN_FORBIDDEN_TLDS: "Domain uses forbidden TLD",
            DOMAIN_EMPTY_SEGMENT: "Domain contains empty dot-separated segment",
            DOMAIN_LONG_SEGMENT:
              "Domain contains dot-separated segment that is too long",
          }),
            (s.code = function (o) {
              return { code: o, error: s.codes[o] };
            });
        },
        9959: (i, s, o) => {
          const a = o(375),
            l = o(5752);
          s.regex = function () {
            let c =
              arguments.length > 0 && arguments[0] !== void 0
                ? arguments[0]
                : {};
            a(
              c.cidr === void 0 || typeof c.cidr == "string",
              "options.cidr must be a string"
            );
            const u = c.cidr ? c.cidr.toLowerCase() : "optional";
            a(
              ["required", "optional", "forbidden"].includes(u),
              "options.cidr must be one of required, optional, forbidden"
            ),
              a(
                c.version === void 0 ||
                  typeof c.version == "string" ||
                  Array.isArray(c.version),
                "options.version must be a string or an array of string"
              );
            let d = c.version || ["ipv4", "ipv6", "ipvfuture"];
            Array.isArray(d) || (d = [d]),
              a(
                d.length >= 1,
                "options.version must have at least 1 version specified"
              );
            for (let p = 0; p < d.length; ++p)
              a(
                typeof d[p] == "string",
                "options.version must only contain strings"
              ),
                (d[p] = d[p].toLowerCase()),
                a(
                  ["ipv4", "ipv6", "ipvfuture"].includes(d[p]),
                  "options.version contains unknown version " +
                    d[p] +
                    " - must be one of ipv4, ipv6, ipvfuture"
                );
            d = Array.from(new Set(d));
            const f = `(?:${d
                .map((p) => {
                  if (u === "forbidden") return l.ip[p];
                  const g = `\\/${p === "ipv4" ? l.ip.v4Cidr : l.ip.v6Cidr}`;
                  return u === "required"
                    ? `${l.ip[p]}${g}`
                    : `${l.ip[p]}(?:${g})?`;
                })
                .join("|")})`,
              h = new RegExp(`^${f}$`);
            return { cidr: u, versions: d, regex: h, raw: f };
          };
        },
        5752: (i, s, o) => {
          const a = o(375),
            l = o(6064),
            c = {
              generate: function () {
                const u = {},
                  d = "\\dA-Fa-f",
                  f = "[" + d + "]",
                  h = "\\w-\\.~",
                  p = "!\\$&'\\(\\)\\*\\+,;=",
                  g = "%" + d,
                  b = h + g + p + ":@",
                  v = "[" + b + "]",
                  w = "(?:0{0,2}\\d|0?[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";
                u.ipv4address = "(?:" + w + "\\.){3}" + w;
                const x = f + "{1,4}",
                  S = "(?:" + x + ":" + x + "|" + u.ipv4address + ")",
                  R = "(?:" + x + ":){6}" + S,
                  O = "::(?:" + x + ":){5}" + S,
                  B = "(?:" + x + ")?::(?:" + x + ":){4}" + S,
                  C =
                    "(?:(?:" + x + ":){0,1}" + x + ")?::(?:" + x + ":){3}" + S,
                  I =
                    "(?:(?:" + x + ":){0,2}" + x + ")?::(?:" + x + ":){2}" + S,
                  P = "(?:(?:" + x + ":){0,3}" + x + ")?::" + x + ":" + S,
                  M = "(?:(?:" + x + ":){0,4}" + x + ")?::" + S,
                  k = "(?:(?:" + x + ":){0,5}" + x + ")?::" + x,
                  T = "(?:(?:" + x + ":){0,6}" + x + ")?::";
                (u.ipv4Cidr = "(?:\\d|[1-2]\\d|3[0-2])"),
                  (u.ipv6Cidr = "(?:0{0,2}\\d|0?[1-9]\\d|1[01]\\d|12[0-8])"),
                  (u.ipv6address =
                    "(?:" +
                    R +
                    "|" +
                    O +
                    "|" +
                    B +
                    "|" +
                    C +
                    "|" +
                    I +
                    "|" +
                    P +
                    "|" +
                    M +
                    "|" +
                    k +
                    "|" +
                    T +
                    ")"),
                  (u.ipvFuture = "v" + f + "+\\.[" + h + p + ":]+"),
                  (u.scheme = "[a-zA-Z][a-zA-Z\\d+-\\.]*"),
                  (u.schemeRegex = new RegExp(u.scheme));
                const _ = "[" + h + g + p + ":]*",
                  A = "[" + h + g + p + "]{1,255}",
                  N =
                    "(?:\\[(?:" +
                    u.ipv6address +
                    "|" +
                    u.ipvFuture +
                    ")\\]|" +
                    u.ipv4address +
                    "|" +
                    A +
                    ")",
                  L = "(?:" + _ + "@)?" + N + "(?::\\d*)?",
                  F = "(?:" + _ + "@)?(" + N + ")(?::\\d*)?",
                  D = v + "*",
                  j = v + "+",
                  z = "(?:\\/" + D + ")*",
                  $ = "\\/(?:" + j + z + ")?",
                  K = j + z,
                  re = "[" + h + g + p + "@]+" + z,
                  G = "(?:\\/\\/\\/" + D + z + ")";
                return (
                  (u.hierPart =
                    "(?:(?:\\/\\/" +
                    L +
                    z +
                    ")|" +
                    $ +
                    "|" +
                    K +
                    "|" +
                    G +
                    ")"),
                  (u.hierPartCapture =
                    "(?:(?:\\/\\/" + F + z + ")|" + $ + "|" + K + ")"),
                  (u.relativeRef =
                    "(?:(?:\\/\\/" + L + z + ")|" + $ + "|" + re + "|)"),
                  (u.relativeRefCapture =
                    "(?:(?:\\/\\/" + F + z + ")|" + $ + "|" + re + "|)"),
                  (u.query = "[" + b + "\\/\\?]*(?=#|$)"),
                  (u.queryWithSquareBrackets =
                    "[" + b + "\\[\\]\\/\\?]*(?=#|$)"),
                  (u.fragment = "[" + b + "\\/\\?]*"),
                  u
                );
              },
            };
          (c.rfc3986 = c.generate()),
            (s.ip = {
              v4Cidr: c.rfc3986.ipv4Cidr,
              v6Cidr: c.rfc3986.ipv6Cidr,
              ipv4: c.rfc3986.ipv4address,
              ipv6: c.rfc3986.ipv6address,
              ipvfuture: c.rfc3986.ipvFuture,
            }),
            (c.createRegex = function (u) {
              const d = c.rfc3986,
                f =
                  "(?:\\?" +
                  (u.allowQuerySquareBrackets
                    ? d.queryWithSquareBrackets
                    : d.query) +
                  ")?(?:#" +
                  d.fragment +
                  ")?",
                h = u.domain ? d.relativeRefCapture : d.relativeRef;
              if (u.relativeOnly) return c.wrap(h + f);
              let p = "";
              if (u.scheme) {
                a(
                  u.scheme instanceof RegExp ||
                    typeof u.scheme == "string" ||
                    Array.isArray(u.scheme),
                  "scheme must be a RegExp, String, or Array"
                );
                const v = [].concat(u.scheme);
                a(
                  v.length >= 1,
                  "scheme must have at least 1 scheme specified"
                );
                const w = [];
                for (let x = 0; x < v.length; ++x) {
                  const S = v[x];
                  a(
                    S instanceof RegExp || typeof S == "string",
                    "scheme at position " + x + " must be a RegExp or String"
                  ),
                    S instanceof RegExp
                      ? w.push(S.source.toString())
                      : (a(
                          d.schemeRegex.test(S),
                          "scheme at position " + x + " must be a valid scheme"
                        ),
                        w.push(l(S)));
                }
                p = w.join("|");
              }
              const g =
                  "(?:" +
                  (p ? "(?:" + p + ")" : d.scheme) +
                  ":" +
                  (u.domain ? d.hierPartCapture : d.hierPart) +
                  ")",
                b = u.allowRelative ? "(?:" + g + "|" + h + ")" : g;
              return c.wrap(b + f, p);
            }),
            (c.wrap = function (u, d) {
              return {
                raw: (u = `(?=.)(?!https?:/(?:$|[^/]))(?!https?:///)(?!https?:[^/])${u}`),
                regex: new RegExp(`^${u}$`),
                scheme: d,
              };
            }),
            (c.uriRegex = c.createRegex({})),
            (s.regex = function () {
              let u =
                arguments.length > 0 && arguments[0] !== void 0
                  ? arguments[0]
                  : {};
              return u.scheme ||
                u.allowRelative ||
                u.relativeOnly ||
                u.allowQuerySquareBrackets ||
                u.domain
                ? c.createRegex(u)
                : c.uriRegex;
            });
        },
        1447: (i, s) => {
          const o = {
            operators: [
              "!",
              "^",
              "*",
              "/",
              "%",
              "+",
              "-",
              "<",
              "<=",
              ">",
              ">=",
              "==",
              "!=",
              "&&",
              "||",
              "??",
            ],
            operatorCharacters: [
              "!",
              "^",
              "*",
              "/",
              "%",
              "+",
              "-",
              "<",
              "=",
              ">",
              "&",
              "|",
              "?",
            ],
            operatorsOrder: [
              ["^"],
              ["*", "/", "%"],
              ["+", "-"],
              ["<", "<=", ">", ">="],
              ["==", "!="],
              ["&&"],
              ["||", "??"],
            ],
            operatorsPrefix: ["!", "n"],
            literals: { '"': '"', "`": "`", "'": "'", "[": "]" },
            numberRx: /^(?:[0-9]*(\.[0-9]*)?){1}$/,
            tokenRx: /^[\w\$\#\.\@\:\{\}]+$/,
            symbol: Symbol("formula"),
            settings: Symbol("settings"),
          };
          (s.Parser = class {
            constructor(a) {
              let l =
                arguments.length > 1 && arguments[1] !== void 0
                  ? arguments[1]
                  : {};
              if (!l[o.settings] && l.constants)
                for (const c in l.constants) {
                  const u = l.constants[c];
                  if (
                    u !== null &&
                    !["boolean", "number", "string"].includes(typeof u)
                  )
                    throw new Error(
                      `Formula constant ${c} contains invalid ${typeof u} value type`
                    );
                }
              (this.settings = l[o.settings]
                ? l
                : Object.assign(
                    { [o.settings]: !0, constants: {}, functions: {} },
                    l
                  )),
                (this.single = null),
                (this._parts = null),
                this._parse(a);
            }
            _parse(a) {
              let l = [],
                c = "",
                u = 0,
                d = !1;
              const f = (p) => {
                if (u) throw new Error("Formula missing closing parenthesis");
                const g = l.length ? l[l.length - 1] : null;
                if (d || c || p) {
                  if (g && g.type === "reference" && p === ")")
                    return (
                      (g.type = "function"),
                      (g.value = this._subFormula(c, g.value)),
                      void (c = "")
                    );
                  if (p === ")") {
                    const b = new s.Parser(c, this.settings);
                    l.push({ type: "segment", value: b });
                  } else if (d) {
                    if (d === "]")
                      return (
                        l.push({ type: "reference", value: c }), void (c = "")
                      );
                    l.push({ type: "literal", value: c });
                  } else if (o.operatorCharacters.includes(c))
                    g &&
                    g.type === "operator" &&
                    o.operators.includes(g.value + c)
                      ? (g.value += c)
                      : l.push({ type: "operator", value: c });
                  else if (c.match(o.numberRx))
                    l.push({ type: "constant", value: parseFloat(c) });
                  else if (this.settings.constants[c] !== void 0)
                    l.push({
                      type: "constant",
                      value: this.settings.constants[c],
                    });
                  else {
                    if (!c.match(o.tokenRx))
                      throw new Error(`Formula contains invalid token: ${c}`);
                    l.push({ type: "reference", value: c });
                  }
                  c = "";
                }
              };
              for (const p of a)
                d
                  ? p === d
                    ? (f(), (d = !1))
                    : (c += p)
                  : u
                  ? p === "("
                    ? ((c += p), ++u)
                    : p === ")"
                    ? (--u, u ? (c += p) : f(p))
                    : (c += p)
                  : p in o.literals
                  ? (d = o.literals[p])
                  : p === "("
                  ? (f(), ++u)
                  : o.operatorCharacters.includes(p)
                  ? (f(), (c = p), f())
                  : p !== " "
                  ? (c += p)
                  : f();
              f(),
                (l = l.map((p, g) =>
                  p.type !== "operator" ||
                  p.value !== "-" ||
                  (g && l[g - 1].type !== "operator")
                    ? p
                    : { type: "operator", value: "n" }
                ));
              let h = !1;
              for (const p of l) {
                if (p.type === "operator") {
                  if (o.operatorsPrefix.includes(p.value)) continue;
                  if (!h)
                    throw new Error(
                      "Formula contains an operator in invalid position"
                    );
                  if (!o.operators.includes(p.value))
                    throw new Error(
                      `Formula contains an unknown operator ${p.value}`
                    );
                } else if (h)
                  throw new Error("Formula missing expected operator");
                h = !h;
              }
              if (!h)
                throw new Error("Formula contains invalid trailing operator");
              l.length === 1 &&
                ["reference", "literal", "constant"].includes(l[0].type) &&
                (this.single = {
                  type: l[0].type === "reference" ? "reference" : "value",
                  value: l[0].value,
                }),
                (this._parts = l.map((p) => {
                  if (p.type === "operator")
                    return o.operatorsPrefix.includes(p.value) ? p : p.value;
                  if (p.type !== "reference") return p.value;
                  if (
                    this.settings.tokenRx &&
                    !this.settings.tokenRx.test(p.value)
                  )
                    throw new Error(
                      `Formula contains invalid reference ${p.value}`
                    );
                  return this.settings.reference
                    ? this.settings.reference(p.value)
                    : o.reference(p.value);
                }));
            }
            _subFormula(a, l) {
              const c = this.settings.functions[l];
              if (typeof c != "function")
                throw new Error(`Formula contains unknown function ${l}`);
              let u = [];
              if (a) {
                let d = "",
                  f = 0,
                  h = !1;
                const p = () => {
                  if (!d)
                    throw new Error(
                      `Formula contains function ${l} with invalid arguments ${a}`
                    );
                  u.push(d), (d = "");
                };
                for (let g = 0; g < a.length; ++g) {
                  const b = a[g];
                  h
                    ? ((d += b), b === h && (h = !1))
                    : b in o.literals && !f
                    ? ((d += b), (h = o.literals[b]))
                    : b !== "," || f
                    ? ((d += b), b === "(" ? ++f : b === ")" && --f)
                    : p();
                }
                p();
              }
              return (
                (u = u.map((d) => new s.Parser(d, this.settings))),
                function (d) {
                  const f = [];
                  for (const h of u) f.push(h.evaluate(d));
                  return c.call(d, ...f);
                }
              );
            }
            evaluate(a) {
              const l = this._parts.slice();
              for (let c = l.length - 2; c >= 0; --c) {
                const u = l[c];
                if (u && u.type === "operator") {
                  const d = l[c + 1];
                  l.splice(c + 1, 1);
                  const f = o.evaluate(d, a);
                  l[c] = o.single(u.value, f);
                }
              }
              return (
                o.operatorsOrder.forEach((c) => {
                  for (let u = 1; u < l.length - 1; )
                    if (c.includes(l[u])) {
                      const d = l[u],
                        f = o.evaluate(l[u - 1], a),
                        h = o.evaluate(l[u + 1], a);
                      l.splice(u, 2);
                      const p = o.calculate(d, f, h);
                      l[u - 1] = p === 0 ? 0 : p;
                    } else u += 2;
                }),
                o.evaluate(l[0], a)
              );
            }
          }),
            (s.Parser.prototype[o.symbol] = !0),
            (o.reference = function (a) {
              return function (l) {
                return l && l[a] !== void 0 ? l[a] : null;
              };
            }),
            (o.evaluate = function (a, l) {
              return a === null
                ? null
                : typeof a == "function"
                ? a(l)
                : a[o.symbol]
                ? a.evaluate(l)
                : a;
            }),
            (o.single = function (a, l) {
              if (a === "!") return !l;
              const c = -l;
              return c === 0 ? 0 : c;
            }),
            (o.calculate = function (a, l, c) {
              if (a === "??") return o.exists(l) ? l : c;
              if (typeof l == "string" || typeof c == "string") {
                if (a === "+")
                  return (l = o.exists(l) ? l : "") + (o.exists(c) ? c : "");
              } else
                switch (a) {
                  case "^":
                    return Math.pow(l, c);
                  case "*":
                    return l * c;
                  case "/":
                    return l / c;
                  case "%":
                    return l % c;
                  case "+":
                    return l + c;
                  case "-":
                    return l - c;
                }
              switch (a) {
                case "<":
                  return l < c;
                case "<=":
                  return l <= c;
                case ">":
                  return l > c;
                case ">=":
                  return l >= c;
                case "==":
                  return l === c;
                case "!=":
                  return l !== c;
                case "&&":
                  return l && c;
                case "||":
                  return l || c;
              }
              return null;
            }),
            (o.exists = function (a) {
              return a != null;
            });
        },
        9926: () => {},
        5688: () => {},
        9708: () => {},
        1152: () => {},
        443: () => {},
        9848: () => {},
        5934: (i) => {
          i.exports = { version: "17.9.1" };
        },
      }),
      (r = {}),
      (function i(s) {
        var o = r[s];
        if (o !== void 0) return o.exports;
        var a = (r[s] = { exports: {} });
        return n[s](a, a.exports, i), a.exports;
      })(5107)
    );
    var n, r;
  });
})(MJ);
var K8e = MJ.exports;
const fe = Gi(K8e);
class p$ extends Error {
  constructor(t) {
    super(t.message),
      (this.message = t.message),
      (this.code = t.code),
      (this.data = t.data);
  }
}
const hi = (e, t) => {
    let n;
    e.request ? (n = e.request.bind(e)) : e.sendAsync && (n = Y8e(e));
    const r = async ({ method: i, params: s }) => {
      const o = i;
      if (t && t[o] === null)
        throw new p$({
          code: 4200,
          message: `The Provider does not support the requested method: ${i}`,
        });
      if (t && t[o]) return t[o]({ baseRequest: n, params: s });
      if (n) return n({ method: i, params: s });
      throw new p$({
        code: 4200,
        message: `The Provider does not support the requested method: ${i}`,
      });
    };
    return (e.request = r), e;
  },
  Y8e =
    (e) =>
    ({ method: t, params: n }) =>
      new Promise((r, i) => {
        e.sendAsync(
          { id: 0, jsonrpc: "2.0", method: t, params: n },
          (s, { result: o }) => {
            s ? i(JSON.parse(s)) : r(o ?? null);
          }
        );
      });
function E5(e, { strict: t = !0 } = {}) {
  return !e || typeof e != "string"
    ? !1
    : t
    ? /^0x[0-9a-fA-F]*$/.test(e)
    : e.startsWith("0x");
}
function m$(e) {
  return E5(e, { strict: !1 }) ? Math.ceil((e.length - 2) / 2) : e.length;
}
const Z8e = "2.12.0",
  Kut = (e) => e,
  Yut = (e) => e,
  Q8e = () => `viem@${Z8e}`;
class Tu extends Error {
  constructor(t, n = {}) {
    var s;
    super(),
      Object.defineProperty(this, "details", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "docsPath", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "metaMessages", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "shortMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "ViemError",
      }),
      Object.defineProperty(this, "version", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: Q8e(),
      });
    const r =
        n.cause instanceof Tu
          ? n.cause.details
          : (s = n.cause) != null && s.message
          ? n.cause.message
          : n.details,
      i = (n.cause instanceof Tu && n.cause.docsPath) || n.docsPath;
    (this.message = [
      t || "An error occurred.",
      "",
      ...(n.metaMessages ? [...n.metaMessages, ""] : []),
      ...(i
        ? [`Docs: https://viem.sh${i}${n.docsSlug ? `#${n.docsSlug}` : ""}`]
        : []),
      ...(r ? [`Details: ${r}`] : []),
      `Version: ${this.version}`,
    ].join(`
`)),
      n.cause && (this.cause = n.cause),
      (this.details = r),
      (this.docsPath = i),
      (this.metaMessages = n.metaMessages),
      (this.shortMessage = t);
  }
  walk(t) {
    return IJ(this, t);
  }
}
function IJ(e, t) {
  return t != null && t(e)
    ? e
    : e && typeof e == "object" && "cause" in e
    ? IJ(e.cause, t)
    : t
    ? null
    : e;
}
class Zut extends Tu {
  constructor({ offset: t, position: n, size: r }) {
    super(
      `Slice ${
        n === "start" ? "starting" : "ending"
      } at offset "${t}" is out-of-bounds (size: ${r}).`
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "SliceOffsetOutOfBoundsError",
      });
  }
}
class NJ extends Tu {
  constructor({ size: t, targetSize: n, type: r }) {
    super(
      `${r.charAt(0).toUpperCase()}${r
        .slice(1)
        .toLowerCase()} size (${t}) exceeds padding size (${n}).`
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "SizeExceedsPaddingSizeError",
      });
  }
}
class Qut extends Tu {
  constructor({ size: t, targetSize: n, type: r }) {
    super(
      `${r.charAt(0).toUpperCase()}${r
        .slice(1)
        .toLowerCase()} is expected to be ${n} ${r} long, but is ${t} ${r} long.`
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "InvalidBytesLengthError",
      });
  }
}
function wv(e, { dir: t, size: n = 32 } = {}) {
  return typeof e == "string"
    ? X8e(e, { dir: t, size: n })
    : J8e(e, { dir: t, size: n });
}
function X8e(e, { dir: t, size: n = 32 } = {}) {
  if (n === null) return e;
  const r = e.replace("0x", "");
  if (r.length > n * 2)
    throw new NJ({ size: Math.ceil(r.length / 2), targetSize: n, type: "hex" });
  return `0x${r[t === "right" ? "padEnd" : "padStart"](n * 2, "0")}`;
}
function J8e(e, { dir: t, size: n = 32 } = {}) {
  if (n === null) return e;
  if (e.length > n)
    throw new NJ({ size: e.length, targetSize: n, type: "bytes" });
  const r = new Uint8Array(n);
  for (let i = 0; i < n; i++) {
    const s = t === "right";
    r[s ? i : n - i - 1] = e[s ? i : e.length - i - 1];
  }
  return r;
}
class eEe extends Tu {
  constructor({ max: t, min: n, signed: r, size: i, value: s }) {
    super(
      `Number "${s}" is not in safe ${
        i ? `${i * 8}-bit ${r ? "signed" : "unsigned"} ` : ""
      }integer range ${t ? `(${n} to ${t})` : `(above ${n})`}`
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "IntegerOutOfRangeError",
      });
  }
}
class Xut extends Tu {
  constructor(t) {
    super(
      `Bytes value "${t}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "InvalidBytesBooleanError",
      });
  }
}
class tEe extends Tu {
  constructor(t) {
    super(
      `Hex value "${t}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "InvalidHexBooleanError",
      });
  }
}
class nEe extends Tu {
  constructor({ givenSize: t, maxSize: n }) {
    super(`Size cannot exceed ${n} bytes. Given size: ${t} bytes.`),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "SizeOverflowError",
      });
  }
}
function $4(e, { dir: t = "left" } = {}) {
  let n = typeof e == "string" ? e.replace("0x", "") : e,
    r = 0;
  for (
    let i = 0;
    i < n.length - 1 &&
    n[t === "left" ? i : n.length - i - 1].toString() === "0";
    i++
  )
    r++;
  return (
    (n = t === "left" ? n.slice(r) : n.slice(0, n.length - r)),
    typeof e == "string"
      ? (n.length === 1 && t === "right" && (n = `${n}0`),
        `0x${n.length % 2 === 1 ? `0${n}` : n}`)
      : n
  );
}
function p0(e, { size: t }) {
  if (m$(e) > t) throw new nEe({ givenSize: m$(e), maxSize: t });
}
function ZT(e, t) {
  const n = typeof t == "string" ? { to: t } : t,
    r = n.to;
  return r === "number"
    ? iEe(e, n)
    : r === "bigint"
    ? lO(e, n)
    : r === "string"
    ? sEe(e, n)
    : r === "boolean"
    ? rEe(e, n)
    : P8(e, n);
}
function lO(e, t = {}) {
  const { signed: n } = t;
  t.size && p0(e, { size: t.size });
  const r = BigInt(e);
  if (!n) return r;
  const i = (e.length - 2) / 2,
    s = (1n << (BigInt(i) * 8n - 1n)) - 1n;
  return r <= s ? r : r - BigInt(`0x${"f".padStart(i * 2, "f")}`) - 1n;
}
function rEe(e, t = {}) {
  let n = e;
  if ((t.size && (p0(n, { size: t.size }), (n = $4(n))), $4(n) === "0x00"))
    return !1;
  if ($4(n) === "0x01") return !0;
  throw new tEe(n);
}
function iEe(e, t = {}) {
  return Number(lO(e, t));
}
function sEe(e, t = {}) {
  let n = P8(e);
  return (
    t.size && (p0(n, { size: t.size }), (n = $4(n, { dir: "right" }))),
    new TextDecoder().decode(n)
  );
}
const oEe = Array.from({ length: 256 }, (e, t) =>
  t.toString(16).padStart(2, "0")
);
function g$(e, t = {}) {
  return typeof e == "number" || typeof e == "bigint"
    ? cO(e, t)
    : typeof e == "string"
    ? cEe(e, t)
    : typeof e == "boolean"
    ? aEe(e, t)
    : RJ(e, t);
}
function aEe(e, t = {}) {
  const n = `0x${Number(e)}`;
  return typeof t.size == "number"
    ? (p0(n, { size: t.size }), wv(n, { size: t.size }))
    : n;
}
function RJ(e, t = {}) {
  let n = "";
  for (let i = 0; i < e.length; i++) n += oEe[e[i]];
  const r = `0x${n}`;
  return typeof t.size == "number"
    ? (p0(r, { size: t.size }), wv(r, { dir: "right", size: t.size }))
    : r;
}
function cO(e, t = {}) {
  const { signed: n, size: r } = t,
    i = BigInt(e);
  let s;
  r
    ? n
      ? (s = (1n << (BigInt(r) * 8n - 1n)) - 1n)
      : (s = 2n ** (BigInt(r) * 8n) - 1n)
    : typeof e == "number" && (s = BigInt(Number.MAX_SAFE_INTEGER));
  const o = typeof s == "bigint" && n ? -s - 1n : 0;
  if ((s && i > s) || i < o) {
    const l = typeof e == "bigint" ? "n" : "";
    throw new eEe({
      max: s ? `${s}${l}` : void 0,
      min: `${o}${l}`,
      signed: n,
      size: r,
      value: `${e}${l}`,
    });
  }
  const a = `0x${(n && i < 0 ? (1n << BigInt(r * 8)) + BigInt(i) : i).toString(
    16
  )}`;
  return r ? wv(a, { size: r }) : a;
}
const lEe = new TextEncoder();
function cEe(e, t = {}) {
  const n = lEe.encode(e);
  return RJ(n, t);
}
const uEe = new TextEncoder();
function Jut(e, t = {}) {
  return typeof e == "number" || typeof e == "bigint"
    ? fEe(e, t)
    : typeof e == "boolean"
    ? dEe(e, t)
    : E5(e)
    ? P8(e, t)
    : hEe(e, t);
}
function dEe(e, t = {}) {
  const n = new Uint8Array(1);
  return (
    (n[0] = Number(e)),
    typeof t.size == "number"
      ? (p0(n, { size: t.size }), wv(n, { size: t.size }))
      : n
  );
}
const yf = { zero: 48, nine: 57, A: 65, F: 70, a: 97, f: 102 };
function y$(e) {
  if (e >= yf.zero && e <= yf.nine) return e - yf.zero;
  if (e >= yf.A && e <= yf.F) return e - (yf.A - 10);
  if (e >= yf.a && e <= yf.f) return e - (yf.a - 10);
}
function P8(e, t = {}) {
  let n = e;
  t.size &&
    (p0(n, { size: t.size }), (n = wv(n, { dir: "right", size: t.size })));
  let r = n.slice(2);
  r.length % 2 && (r = `0${r}`);
  const i = r.length / 2,
    s = new Uint8Array(i);
  for (let o = 0, a = 0; o < i; o++) {
    const l = y$(r.charCodeAt(a++)),
      c = y$(r.charCodeAt(a++));
    if (l === void 0 || c === void 0)
      throw new Tu(
        `Invalid byte sequence ("${r[a - 2]}${r[a - 1]}" in "${r}").`
      );
    s[o] = l * 16 + c;
  }
  return s;
}
function fEe(e, t) {
  const n = cO(e, t);
  return P8(n);
}
function hEe(e, t = {}) {
  const n = uEe.encode(e);
  return typeof t.size == "number"
    ? (p0(n, { size: t.size }), wv(n, { dir: "right", size: t.size }))
    : n;
}
const pEe = { gwei: 9, wei: 18 },
  edt = { ether: -9, wei: 9 };
function mEe(e, t) {
  let n = e.toString();
  const r = n.startsWith("-");
  r && (n = n.slice(1)), (n = n.padStart(t, "0"));
  let [i, s] = [n.slice(0, n.length - t), n.slice(n.length - t)];
  return (
    (s = s.replace(/(0+)$/, "")),
    `${r ? "-" : ""}${i || "0"}${s ? `.${s}` : ""}`
  );
}
function OJ(e, t = "wei") {
  return mEe(e, pEe[t]);
}
const PJ = (e) => PJ(),
  gEe = (e) => {
    const t = lO(e);
    return OJ(t);
  },
  yEe = (e) => {
    if (!e) return e;
    const t = ZT(e, "bigint");
    return OJ(t);
  },
  tdt = (e) => cO(e),
  vEe = async (e) => {
    const t = await At(
        () => import("./index-0e7SkSfJ.js"),
        __vite__mapDeps([0, 1])
      ),
      {
        id: n,
        label: r,
        token: i,
        publicRpcUrl: s,
        blockExplorerUrl: o,
        rpcUrl: a,
      } = e;
    switch (n) {
      case "0x89": {
        const { polygon: l } = t;
        return l;
      }
      case "0xa": {
        const { optimism: l } = t;
        return l;
      }
      case "0xa4b1": {
        const { arbitrum: l } = t;
        return l;
      }
      case "0x144": {
        const { zkSync: l } = t;
        return l;
      }
      case "0x38": {
        const { bsc: l } = t;
        return l;
      }
      case "0x1": {
        const { mainnet: l } = t;
        return l;
      }
      case "0xaa36a7": {
        const { sepolia: l } = t;
        return l;
      }
      case "0xfa": {
        const { fantom: l } = t;
        return l;
      }
      case "0xa86a": {
        const { avalanche: l } = t;
        return l;
      }
      case "0xa4ec": {
        const { celo: l } = t;
        return l;
      }
      case "0x2105": {
        const { base: l } = t;
        return l;
      }
      case "0x14a33": {
        const { baseGoerli: l } = t;
        return l;
      }
      case "0x64": {
        const { gnosis: l } = t;
        return l;
      }
      case "0x63564C40": {
        const { harmonyOne: l } = t;
        return l;
      }
      case "0x27bc86aa": {
        const { degen: l } = t;
        return l;
      }
      default: {
        const { extractChain: l, defineChain: c } = await At(async () => {
            const { extractChain: d, defineChain: f } = await import(
              "./index-DcXKPjle.js"
            );
            return { extractChain: d, defineChain: f };
          }, __vite__mapDeps([2, 1])),
          u = l({ chains: Object.values(t), id: ZT(n, "number") });
        return (
          u ||
          c({
            id: ZT(n, "number"),
            name: r ?? "",
            nativeCurrency: { decimals: 18, name: i ?? "", symbol: i ?? "" },
            rpcUrls: { default: { http: [a ?? "", s ?? ""] } },
            blockExplorers: { default: { name: "Explorer", url: o ?? "" } },
          })
        );
      }
    }
  };
var Fp;
(function (e) {
  (e[(e.ACCOUNT_ACCESS_REJECTED = 4001)] = "ACCOUNT_ACCESS_REJECTED"),
    (e[(e.ACCOUNT_ACCESS_ALREADY_REQUESTED = -32002)] =
      "ACCOUNT_ACCESS_ALREADY_REQUESTED"),
    (e[(e.UNAUTHORIZED = 4100)] = "UNAUTHORIZED"),
    (e[(e.INVALID_PARAMS = -32602)] = "INVALID_PARAMS"),
    (e[(e.UNSUPPORTED_METHOD = 4200)] = "UNSUPPORTED_METHOD"),
    (e[(e.DISCONNECTED = 4900)] = "DISCONNECTED"),
    (e[(e.CHAIN_DISCONNECTED = 4901)] = "CHAIN_DISCONNECTED"),
    (e[(e.CHAIN_NOT_ADDED = 4902)] = "CHAIN_NOT_ADDED"),
    (e[(e.DOES_NOT_EXIST = -32601)] = "DOES_NOT_EXIST"),
    (e[(e.UNRECOGNIZED_CHAIN_ID = -32603)] = "UNRECOGNIZED_CHAIN_ID");
})(Fp || (Fp = {}));
function Eo(e, t) {
  const n = e.validate(t);
  return n.error ? n : null;
}
const uO = fe
    .alternatives()
    .try(fe.string().pattern(/^0x[0-9a-fA-F]+$/), fe.number().positive()),
  dO = fe.string().valid("evm"),
  wEe = fe.object({
    address: fe.string().required(),
    icon: fe.string().optional(),
  }),
  bEe = fe.object({
    namespace: dO,
    id: uO.required(),
    rpcUrl: fe.string(),
    label: fe.string(),
    token: fe.string(),
    secondaryTokens: fe.array().max(5).items(wEe).optional(),
    icon: fe.string(),
    color: fe.string(),
    publicRpcUrl: fe.string(),
    protectedRpcUrl: fe.string(),
    blockExplorerUrl: fe.string(),
  });
var A5 = { exports: {} };
A5.exports;
(function (e, t) {
  var n = 200,
    r = "Expected a function",
    i = "__lodash_hash_undefined__",
    s = 1,
    o = 2,
    a = 1 / 0,
    l = 9007199254740991,
    c = "[object Arguments]",
    u = "[object Array]",
    d = "[object Boolean]",
    f = "[object Date]",
    h = "[object Error]",
    p = "[object Function]",
    g = "[object GeneratorFunction]",
    b = "[object Map]",
    v = "[object Number]",
    w = "[object Object]",
    x = "[object Promise]",
    S = "[object RegExp]",
    R = "[object Set]",
    O = "[object String]",
    B = "[object Symbol]",
    C = "[object WeakMap]",
    I = "[object ArrayBuffer]",
    P = "[object DataView]",
    M = "[object Float32Array]",
    k = "[object Float64Array]",
    T = "[object Int8Array]",
    _ = "[object Int16Array]",
    A = "[object Int32Array]",
    N = "[object Uint8Array]",
    L = "[object Uint8ClampedArray]",
    F = "[object Uint16Array]",
    D = "[object Uint32Array]",
    j = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    z = /^\w*$/,
    $ = /^\./,
    K =
      /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
    re = /[\\^$.*+?()[\]{}|]/g,
    G = /\\(\\)?/g,
    ne = /^\[object .+?Constructor\]$/,
    ae = /^(?:0|[1-9]\d*)$/,
    le = {};
  (le[M] = le[k] = le[T] = le[_] = le[A] = le[N] = le[L] = le[F] = le[D] = !0),
    (le[c] =
      le[u] =
      le[I] =
      le[d] =
      le[P] =
      le[f] =
      le[h] =
      le[p] =
      le[b] =
      le[v] =
      le[w] =
      le[S] =
      le[R] =
      le[O] =
      le[C] =
        !1);
  var ge = typeof Bn == "object" && Bn && Bn.Object === Object && Bn,
    Oe = typeof self == "object" && self && self.Object === Object && self,
    _e = ge || Oe || Function("return this")(),
    Ee = t && !t.nodeType && t,
    He = Ee && !0 && e && !e.nodeType && e,
    je = He && He.exports === Ee,
    Be = je && ge.process,
    rn = (function () {
      try {
        return Be && Be.binding("util");
      } catch {}
    })(),
    Wt = rn && rn.isTypedArray;
  function Mt(W, Z, se, ye) {
    for (var Je = -1, De = W ? W.length : 0; ++Je < De; ) {
      var Ze = W[Je];
      Z(ye, Ze, se(Ze), W);
    }
    return ye;
  }
  function an(W, Z) {
    for (var se = -1, ye = W ? W.length : 0; ++se < ye; )
      if (Z(W[se], se, W)) return !0;
    return !1;
  }
  function kt(W) {
    return function (Z) {
      return Z == null ? void 0 : Z[W];
    };
  }
  function Qe(W, Z) {
    for (var se = -1, ye = Array(W); ++se < W; ) ye[se] = Z(se);
    return ye;
  }
  function Vt(W) {
    return function (Z) {
      return W(Z);
    };
  }
  function Rt(W, Z) {
    return W == null ? void 0 : W[Z];
  }
  function mt(W) {
    var Z = !1;
    if (W != null && typeof W.toString != "function")
      try {
        Z = !!(W + "");
      } catch {}
    return Z;
  }
  function Pt(W) {
    var Z = -1,
      se = Array(W.size);
    return (
      W.forEach(function (ye, Je) {
        se[++Z] = [Je, ye];
      }),
      se
    );
  }
  function wn(W, Z) {
    return function (se) {
      return W(Z(se));
    };
  }
  function xt(W) {
    var Z = -1,
      se = Array(W.size);
    return (
      W.forEach(function (ye) {
        se[++Z] = ye;
      }),
      se
    );
  }
  var Tt = Array.prototype,
    _n = Function.prototype,
    Q = Object.prototype,
    H = _e["__core-js_shared__"],
    q = (function () {
      var W = /[^.]+$/.exec((H && H.keys && H.keys.IE_PROTO) || "");
      return W ? "Symbol(src)_1." + W : "";
    })(),
    ee = _n.toString,
    ce = Q.hasOwnProperty,
    pe = Q.toString,
    we = RegExp(
      "^" +
        ee
          .call(ce)
          .replace(re, "\\$&")
          .replace(
            /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
            "$1.*?"
          ) +
        "$"
    ),
    ht = _e.Symbol,
    vt = _e.Uint8Array,
    ct = Q.propertyIsEnumerable,
    Lt = Tt.splice,
    wt = wn(Object.keys, Object),
    Ht = Os(_e, "DataView"),
    mn = Os(_e, "Map"),
    jn = Os(_e, "Promise"),
    Gt = Os(_e, "Set"),
    Cn = Os(_e, "WeakMap"),
    cn = Os(Object, "create"),
    Yt = me(Ht),
    ln = me(mn),
    oe = me(jn),
    de = me(Gt),
    be = me(Cn),
    Me = ht ? ht.prototype : void 0,
    Fe = Me ? Me.valueOf : void 0,
    it = Me ? Me.toString : void 0;
  function ft(W) {
    var Z = -1,
      se = W ? W.length : 0;
    for (this.clear(); ++Z < se; ) {
      var ye = W[Z];
      this.set(ye[0], ye[1]);
    }
  }
  function ze() {
    this.__data__ = cn ? cn(null) : {};
  }
  function nt(W) {
    return this.has(W) && delete this.__data__[W];
  }
  function Xe(W) {
    var Z = this.__data__;
    if (cn) {
      var se = Z[W];
      return se === i ? void 0 : se;
    }
    return ce.call(Z, W) ? Z[W] : void 0;
  }
  function Ve(W) {
    var Z = this.__data__;
    return cn ? Z[W] !== void 0 : ce.call(Z, W);
  }
  function bt(W, Z) {
    var se = this.__data__;
    return (se[W] = cn && Z === void 0 ? i : Z), this;
  }
  (ft.prototype.clear = ze),
    (ft.prototype.delete = nt),
    (ft.prototype.get = Xe),
    (ft.prototype.has = Ve),
    (ft.prototype.set = bt);
  function gt(W) {
    var Z = -1,
      se = W ? W.length : 0;
    for (this.clear(); ++Z < se; ) {
      var ye = W[Z];
      this.set(ye[0], ye[1]);
    }
  }
  function un() {
    this.__data__ = [];
  }
  function Rn(W) {
    var Z = this.__data__,
      se = Hc(Z, W);
    if (se < 0) return !1;
    var ye = Z.length - 1;
    return se == ye ? Z.pop() : Lt.call(Z, se, 1), !0;
  }
  function bn(W) {
    var Z = this.__data__,
      se = Hc(Z, W);
    return se < 0 ? void 0 : Z[se][1];
  }
  function Sn(W) {
    return Hc(this.__data__, W) > -1;
  }
  function Si(W, Z) {
    var se = this.__data__,
      ye = Hc(se, W);
    return ye < 0 ? se.push([W, Z]) : (se[ye][1] = Z), this;
  }
  (gt.prototype.clear = un),
    (gt.prototype.delete = Rn),
    (gt.prototype.get = bn),
    (gt.prototype.has = Sn),
    (gt.prototype.set = Si);
  function vr(W) {
    var Z = -1,
      se = W ? W.length : 0;
    for (this.clear(); ++Z < se; ) {
      var ye = W[Z];
      this.set(ye[0], ye[1]);
    }
  }
  function pi() {
    this.__data__ = { hash: new ft(), map: new (mn || gt)(), string: new ft() };
  }
  function ii(W) {
    return qc(this, W).delete(W);
  }
  function Ki(W) {
    return qc(this, W).get(W);
  }
  function si(W) {
    return qc(this, W).has(W);
  }
  function Ti(W, Z) {
    return qc(this, W).set(W, Z), this;
  }
  (vr.prototype.clear = pi),
    (vr.prototype.delete = ii),
    (vr.prototype.get = Ki),
    (vr.prototype.has = si),
    (vr.prototype.set = Ti);
  function Yi(W) {
    var Z = -1,
      se = W ? W.length : 0;
    for (this.__data__ = new vr(); ++Z < se; ) this.add(W[Z]);
  }
  function Es(W) {
    return this.__data__.set(W, i), this;
  }
  function In(W) {
    return this.__data__.has(W);
  }
  (Yi.prototype.add = Yi.prototype.push = Es), (Yi.prototype.has = In);
  function On(W) {
    this.__data__ = new gt(W);
  }
  function Ei() {
    this.__data__ = new gt();
  }
  function As(W) {
    return this.__data__.delete(W);
  }
  function wr(W) {
    return this.__data__.get(W);
  }
  function Mi(W) {
    return this.__data__.has(W);
  }
  function ha(W, Z) {
    var se = this.__data__;
    if (se instanceof gt) {
      var ye = se.__data__;
      if (!mn || ye.length < n - 1) return ye.push([W, Z]), this;
      se = this.__data__ = new vr(ye);
    }
    return se.set(W, Z), this;
  }
  (On.prototype.clear = Ei),
    (On.prototype.delete = As),
    (On.prototype.get = wr),
    (On.prototype.has = Mi),
    (On.prototype.set = ha);
  function ju(W, Z) {
    var se = cr(W) || qn(W) ? Qe(W.length, String) : [],
      ye = se.length,
      Je = !!ye;
    for (var De in W)
      ce.call(W, De) && !(Je && (De == "length" || Kc(De, ye))) && se.push(De);
    return se;
  }
  function Hc(W, Z) {
    for (var se = W.length; se--; ) if (Wn(W[se][0], Z)) return se;
    return -1;
  }
  function Yd(W, Z, se, ye) {
    return (
      _0(W, function (Je, De, Ze) {
        Z(ye, Je, se(Je), Ze);
      }),
      ye
    );
  }
  var _0 = Vc(fl),
    Ih = Fu();
  function fl(W, Z) {
    return W && Ih(W, Z, rf);
  }
  function hl(W, Z) {
    Z = Yc(Z, W) ? [Z] : Jd(Z);
    for (var se = 0, ye = Z.length; W != null && se < ye; ) W = W[ie(Z[se++])];
    return se && se == ye ? W : void 0;
  }
  function Zd(W) {
    return pe.call(W);
  }
  function Nh(W, Z) {
    return W != null && Z in Object(W);
  }
  function Ql(W, Z, se, ye, Je) {
    return W === Z
      ? !0
      : W == null || Z == null || (!Gs(W) && !Bi(Z))
      ? W !== W && Z !== Z
      : Du(W, Z, Ql, se, ye, Je);
  }
  function Du(W, Z, se, ye, Je, De) {
    var Ze = cr(W),
      yn = cr(Z),
      fn = u,
      ur = u;
    Ze || ((fn = Ps(W)), (fn = fn == c ? w : fn)),
      yn || ((ur = Ps(Z)), (ur = ur == c ? w : ur));
    var Kn = fn == w && !mt(W),
      dr = ur == w && !mt(Z),
      br = fn == ur;
    if (br && !Kn)
      return (
        De || (De = new On()),
        Ze || nf(W) ? Uu(W, Z, se, ye, Je, De) : tf(W, Z, fn, se, ye, Je, De)
      );
    if (!(Je & o)) {
      var Ai = Kn && ce.call(W, "__wrapped__"),
        mi = dr && ce.call(Z, "__wrapped__");
      if (Ai || mi) {
        var vs = Ai ? W.value() : W,
          Ni = mi ? Z.value() : Z;
        return De || (De = new On()), se(vs, Ni, ye, Je, De);
      }
    }
    return br ? (De || (De = new On()), Gc(W, Z, se, ye, Je, De)) : !1;
  }
  function S0(W, Z, se, ye) {
    var Je = se.length,
      De = Je;
    if (W == null) return !De;
    for (W = Object(W); Je--; ) {
      var Ze = se[Je];
      if (Ze[2] ? Ze[1] !== W[Ze[0]] : !(Ze[0] in W)) return !1;
    }
    for (; ++Je < De; ) {
      Ze = se[Je];
      var yn = Ze[0],
        fn = W[yn],
        ur = Ze[1];
      if (Ze[2]) {
        if (fn === void 0 && !(yn in W)) return !1;
      } else {
        var Kn = new On(),
          dr;
        if (!(dr === void 0 ? Ql(ur, fn, ye, s | o, Kn) : dr)) return !1;
      }
    }
    return !0;
  }
  function Rh(W) {
    if (!Gs(W) || jh(W)) return !1;
    var Z = Ii(W) || mt(W) ? we : ne;
    return Z.test(me(W));
  }
  function Qd(W) {
    return Bi(W) && Di(W.length) && !!le[pe.call(W)];
  }
  function Bu(W) {
    return typeof W == "function"
      ? W
      : W == null
      ? Co
      : typeof W == "object"
      ? cr(W)
        ? Ph(W[0], W[1])
        : Oh(W)
      : qv(W);
  }
  function Xl(W) {
    if (!Dh(W)) return wt(W);
    var Z = [];
    for (var se in Object(W))
      ce.call(W, se) && se != "constructor" && Z.push(se);
    return Z;
  }
  function Oh(W) {
    var Z = ja(W);
    return Z.length == 1 && Z[0][2]
      ? Rr(Z[0][0], Z[0][1])
      : function (se) {
          return se === W || S0(se, W, Z);
        };
  }
  function Ph(W, Z) {
    return Yc(W) && Dr(Z)
      ? Rr(ie(W), Z)
      : function (se) {
          var ye = k1(se, W);
          return ye === void 0 && ye === Z
            ? Bh(se, W)
            : Ql(Z, ye, void 0, s | o);
        };
  }
  function Xd(W) {
    return function (Z) {
      return hl(Z, W);
    };
  }
  function Lh(W) {
    if (typeof W == "string") return W;
    if (Jl(W)) return it ? it.call(W) : "";
    var Z = W + "";
    return Z == "0" && 1 / W == -a ? "-0" : Z;
  }
  function Jd(W) {
    return cr(W) ? W : $u(W);
  }
  function ef(W, Z) {
    return function (se, ye) {
      var Je = cr(se) ? Mt : Yd,
        De = Z ? Z() : {};
      return Je(se, W, Bu(ye), De);
    };
  }
  function Vc(W, Z) {
    return function (se, ye) {
      if (se == null) return se;
      if (!dn(se)) return W(se, ye);
      for (
        var Je = se.length, De = -1, Ze = Object(se);
        ++De < Je && ye(Ze[De], De, Ze) !== !1;

      );
      return se;
    };
  }
  function Fu(W) {
    return function (Z, se, ye) {
      for (var Je = -1, De = Object(Z), Ze = ye(Z), yn = Ze.length; yn--; ) {
        var fn = Ze[++Je];
        if (se(De[fn], fn, De) === !1) break;
      }
      return Z;
    };
  }
  function Uu(W, Z, se, ye, Je, De) {
    var Ze = Je & o,
      yn = W.length,
      fn = Z.length;
    if (yn != fn && !(Ze && fn > yn)) return !1;
    var ur = De.get(W);
    if (ur && De.get(Z)) return ur == Z;
    var Kn = -1,
      dr = !0,
      br = Je & s ? new Yi() : void 0;
    for (De.set(W, Z), De.set(Z, W); ++Kn < yn; ) {
      var Ai = W[Kn],
        mi = Z[Kn];
      if (ye) var vs = Ze ? ye(mi, Ai, Kn, Z, W, De) : ye(Ai, mi, Kn, W, Z, De);
      if (vs !== void 0) {
        if (vs) continue;
        dr = !1;
        break;
      }
      if (br) {
        if (
          !an(Z, function (Ni, ko) {
            if (!br.has(ko) && (Ai === Ni || se(Ai, Ni, ye, Je, De)))
              return br.add(ko);
          })
        ) {
          dr = !1;
          break;
        }
      } else if (!(Ai === mi || se(Ai, mi, ye, Je, De))) {
        dr = !1;
        break;
      }
    }
    return De.delete(W), De.delete(Z), dr;
  }
  function tf(W, Z, se, ye, Je, De, Ze) {
    switch (se) {
      case P:
        if (W.byteLength != Z.byteLength || W.byteOffset != Z.byteOffset)
          return !1;
        (W = W.buffer), (Z = Z.buffer);
      case I:
        return !(W.byteLength != Z.byteLength || !ye(new vt(W), new vt(Z)));
      case d:
      case f:
      case v:
        return Wn(+W, +Z);
      case h:
        return W.name == Z.name && W.message == Z.message;
      case S:
      case O:
        return W == Z + "";
      case b:
        var yn = Pt;
      case R:
        var fn = De & o;
        if ((yn || (yn = xt), W.size != Z.size && !fn)) return !1;
        var ur = Ze.get(W);
        if (ur) return ur == Z;
        (De |= s), Ze.set(W, Z);
        var Kn = Uu(yn(W), yn(Z), ye, Je, De, Ze);
        return Ze.delete(W), Kn;
      case B:
        if (Fe) return Fe.call(W) == Fe.call(Z);
    }
    return !1;
  }
  function Gc(W, Z, se, ye, Je, De) {
    var Ze = Je & o,
      yn = rf(W),
      fn = yn.length,
      ur = rf(Z),
      Kn = ur.length;
    if (fn != Kn && !Ze) return !1;
    for (var dr = fn; dr--; ) {
      var br = yn[dr];
      if (!(Ze ? br in Z : ce.call(Z, br))) return !1;
    }
    var Ai = De.get(W);
    if (Ai && De.get(Z)) return Ai == Z;
    var mi = !0;
    De.set(W, Z), De.set(Z, W);
    for (var vs = Ze; ++dr < fn; ) {
      br = yn[dr];
      var Ni = W[br],
        ko = Z[br];
      if (ye) var Fh = Ze ? ye(ko, Ni, br, Z, W, De) : ye(Ni, ko, br, W, Z, De);
      if (!(Fh === void 0 ? Ni === ko || se(Ni, ko, ye, Je, De) : Fh)) {
        mi = !1;
        break;
      }
      vs || (vs = br == "constructor");
    }
    if (mi && !vs) {
      var ec = W.constructor,
        pl = Z.constructor;
      ec != pl &&
        "constructor" in W &&
        "constructor" in Z &&
        !(
          typeof ec == "function" &&
          ec instanceof ec &&
          typeof pl == "function" &&
          pl instanceof pl
        ) &&
        (mi = !1);
    }
    return De.delete(W), De.delete(Z), mi;
  }
  function qc(W, Z) {
    var se = W.__data__;
    return E0(Z) ? se[typeof Z == "string" ? "string" : "hash"] : se.map;
  }
  function ja(W) {
    for (var Z = rf(W), se = Z.length; se--; ) {
      var ye = Z[se],
        Je = W[ye];
      Z[se] = [ye, Je, Dr(Je)];
    }
    return Z;
  }
  function Os(W, Z) {
    var se = Rt(W, Z);
    return Rh(se) ? se : void 0;
  }
  var Ps = Zd;
  ((Ht && Ps(new Ht(new ArrayBuffer(1))) != P) ||
    (mn && Ps(new mn()) != b) ||
    (jn && Ps(jn.resolve()) != x) ||
    (Gt && Ps(new Gt()) != R) ||
    (Cn && Ps(new Cn()) != C)) &&
    (Ps = function (W) {
      var Z = pe.call(W),
        se = Z == w ? W.constructor : void 0,
        ye = se ? me(se) : void 0;
      if (ye)
        switch (ye) {
          case Yt:
            return P;
          case ln:
            return b;
          case oe:
            return x;
          case de:
            return R;
          case be:
            return C;
        }
      return Z;
    });
  function Da(W, Z, se) {
    Z = Yc(Z, W) ? [Z] : Jd(Z);
    for (var ye, Je = -1, Ze = Z.length; ++Je < Ze; ) {
      var De = ie(Z[Je]);
      if (!(ye = W != null && se(W, De))) break;
      W = W[De];
    }
    if (ye) return ye;
    var Ze = W ? W.length : 0;
    return !!Ze && Di(Ze) && Kc(De, Ze) && (cr(W) || qn(W));
  }
  function Kc(W, Z) {
    return (
      (Z = Z ?? l),
      !!Z &&
        (typeof W == "number" || ae.test(W)) &&
        W > -1 &&
        W % 1 == 0 &&
        W < Z
    );
  }
  function Yc(W, Z) {
    if (cr(W)) return !1;
    var se = typeof W;
    return se == "number" ||
      se == "symbol" ||
      se == "boolean" ||
      W == null ||
      Jl(W)
      ? !0
      : z.test(W) || !j.test(W) || (Z != null && W in Object(Z));
  }
  function E0(W) {
    var Z = typeof W;
    return Z == "string" || Z == "number" || Z == "symbol" || Z == "boolean"
      ? W !== "__proto__"
      : W === null;
  }
  function jh(W) {
    return !!q && q in W;
  }
  function Dh(W) {
    var Z = W && W.constructor,
      se = (typeof Z == "function" && Z.prototype) || Q;
    return W === se;
  }
  function Dr(W) {
    return W === W && !Gs(W);
  }
  function Rr(W, Z) {
    return function (se) {
      return se == null ? !1 : se[W] === Z && (Z !== void 0 || W in Object(se));
    };
  }
  var $u = jt(function (W) {
    W = C1(W);
    var Z = [];
    return (
      $.test(W) && Z.push(""),
      W.replace(K, function (se, ye, Je, De) {
        Z.push(Je ? De.replace(G, "$1") : ye || se);
      }),
      Z
    );
  });
  function ie(W) {
    if (typeof W == "string" || Jl(W)) return W;
    var Z = W + "";
    return Z == "0" && 1 / W == -a ? "-0" : Z;
  }
  function me(W) {
    if (W != null) {
      try {
        return ee.call(W);
      } catch {}
      try {
        return W + "";
      } catch {}
    }
    return "";
  }
  var Ie = ef(
    function (W, Z, se) {
      W[se ? 0 : 1].push(Z);
    },
    function () {
      return [[], []];
    }
  );
  function jt(W, Z) {
    if (typeof W != "function" || (Z && typeof Z != "function"))
      throw new TypeError(r);
    var se = function () {
      var ye = arguments,
        Je = Z ? Z.apply(this, ye) : ye[0],
        De = se.cache;
      if (De.has(Je)) return De.get(Je);
      var Ze = W.apply(this, ye);
      return (se.cache = De.set(Je, Ze)), Ze;
    };
    return (se.cache = new (jt.Cache || vr)()), se;
  }
  jt.Cache = vr;
  function Wn(W, Z) {
    return W === Z || (W !== W && Z !== Z);
  }
  function qn(W) {
    return (
      Br(W) &&
      ce.call(W, "callee") &&
      (!ct.call(W, "callee") || pe.call(W) == c)
    );
  }
  var cr = Array.isArray;
  function dn(W) {
    return W != null && Di(W.length) && !Ii(W);
  }
  function Br(W) {
    return Bi(W) && dn(W);
  }
  function Ii(W) {
    var Z = Gs(W) ? pe.call(W) : "";
    return Z == p || Z == g;
  }
  function Di(W) {
    return typeof W == "number" && W > -1 && W % 1 == 0 && W <= l;
  }
  function Gs(W) {
    var Z = typeof W;
    return !!W && (Z == "object" || Z == "function");
  }
  function Bi(W) {
    return !!W && typeof W == "object";
  }
  function Jl(W) {
    return typeof W == "symbol" || (Bi(W) && pe.call(W) == B);
  }
  var nf = Wt ? Vt(Wt) : Qd;
  function C1(W) {
    return W == null ? "" : Lh(W);
  }
  function k1(W, Z, se) {
    var ye = W == null ? void 0 : hl(W, Z);
    return ye === void 0 ? se : ye;
  }
  function Bh(W, Z) {
    return W != null && Da(W, Z, Nh);
  }
  function rf(W) {
    return dn(W) ? ju(W) : Xl(W);
  }
  function Co(W) {
    return W;
  }
  function qv(W) {
    return Yc(W) ? kt(ie(W)) : Xd(W);
  }
  e.exports = Ie;
})(A5, A5.exports);
var xEe = A5.exports;
const _Ee = Gi(xEe);
var C5 = { exports: {} };
C5.exports;
(function (e, t) {
  var n = 200,
    r = "__lodash_hash_undefined__",
    i = 800,
    s = 16,
    o = 9007199254740991,
    a = "[object Arguments]",
    l = "[object Array]",
    c = "[object AsyncFunction]",
    u = "[object Boolean]",
    d = "[object Date]",
    f = "[object Error]",
    h = "[object Function]",
    p = "[object GeneratorFunction]",
    g = "[object Map]",
    b = "[object Number]",
    v = "[object Null]",
    w = "[object Object]",
    x = "[object Proxy]",
    S = "[object RegExp]",
    R = "[object Set]",
    O = "[object String]",
    B = "[object Undefined]",
    C = "[object WeakMap]",
    I = "[object ArrayBuffer]",
    P = "[object DataView]",
    M = "[object Float32Array]",
    k = "[object Float64Array]",
    T = "[object Int8Array]",
    _ = "[object Int16Array]",
    A = "[object Int32Array]",
    N = "[object Uint8Array]",
    L = "[object Uint8ClampedArray]",
    F = "[object Uint16Array]",
    D = "[object Uint32Array]",
    j = /[\\^$.*+?()[\]{}|]/g,
    z = /^\[object .+?Constructor\]$/,
    $ = /^(?:0|[1-9]\d*)$/,
    K = {};
  (K[M] = K[k] = K[T] = K[_] = K[A] = K[N] = K[L] = K[F] = K[D] = !0),
    (K[a] =
      K[l] =
      K[I] =
      K[u] =
      K[P] =
      K[d] =
      K[f] =
      K[h] =
      K[g] =
      K[b] =
      K[w] =
      K[S] =
      K[R] =
      K[O] =
      K[C] =
        !1);
  var re = typeof Bn == "object" && Bn && Bn.Object === Object && Bn,
    G = typeof self == "object" && self && self.Object === Object && self,
    ne = re || G || Function("return this")(),
    ae = t && !t.nodeType && t,
    le = ae && !0 && e && !e.nodeType && e,
    ge = le && le.exports === ae,
    Oe = ge && re.process,
    _e = (function () {
      try {
        var ie = le && le.require && le.require("util").types;
        return ie || (Oe && Oe.binding && Oe.binding("util"));
      } catch {}
    })(),
    Ee = _e && _e.isTypedArray;
  function He(ie, me, Ie) {
    switch (Ie.length) {
      case 0:
        return ie.call(me);
      case 1:
        return ie.call(me, Ie[0]);
      case 2:
        return ie.call(me, Ie[0], Ie[1]);
      case 3:
        return ie.call(me, Ie[0], Ie[1], Ie[2]);
    }
    return ie.apply(me, Ie);
  }
  function je(ie, me) {
    for (var Ie = -1, jt = Array(ie); ++Ie < ie; ) jt[Ie] = me(Ie);
    return jt;
  }
  function Be(ie) {
    return function (me) {
      return ie(me);
    };
  }
  function rn(ie, me) {
    return ie == null ? void 0 : ie[me];
  }
  function Wt(ie, me) {
    return function (Ie) {
      return ie(me(Ie));
    };
  }
  var Mt = Array.prototype,
    an = Function.prototype,
    kt = Object.prototype,
    Qe = ne["__core-js_shared__"],
    Vt = an.toString,
    Rt = kt.hasOwnProperty,
    mt = (function () {
      var ie = /[^.]+$/.exec((Qe && Qe.keys && Qe.keys.IE_PROTO) || "");
      return ie ? "Symbol(src)_1." + ie : "";
    })(),
    Pt = kt.toString,
    wn = Vt.call(Object),
    xt = RegExp(
      "^" +
        Vt.call(Rt)
          .replace(j, "\\$&")
          .replace(
            /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
            "$1.*?"
          ) +
        "$"
    ),
    Tt = ge ? ne.Buffer : void 0,
    _n = ne.Symbol,
    Q = ne.Uint8Array;
  Tt && Tt.allocUnsafe;
  var H = Wt(Object.getPrototypeOf, Object),
    q = Object.create,
    ee = kt.propertyIsEnumerable,
    ce = Mt.splice,
    pe = _n ? _n.toStringTag : void 0,
    we = (function () {
      try {
        var ie = Zd(Object, "defineProperty");
        return ie({}, "", {}), ie;
      } catch {}
    })(),
    ht = Tt ? Tt.isBuffer : void 0,
    vt = Math.max,
    ct = Date.now,
    Lt = Zd(ne, "Map"),
    wt = Zd(Object, "create"),
    Ht = (function () {
      function ie() {}
      return function (me) {
        if (!Ps(me)) return {};
        if (q) return q(me);
        ie.prototype = me;
        var Ie = new ie();
        return (ie.prototype = void 0), Ie;
      };
    })();
  function mn(ie) {
    var me = -1,
      Ie = ie == null ? 0 : ie.length;
    for (this.clear(); ++me < Ie; ) {
      var jt = ie[me];
      this.set(jt[0], jt[1]);
    }
  }
  function jn() {
    (this.__data__ = wt ? wt(null) : {}), (this.size = 0);
  }
  function Gt(ie) {
    var me = this.has(ie) && delete this.__data__[ie];
    return (this.size -= me ? 1 : 0), me;
  }
  function Cn(ie) {
    var me = this.__data__;
    if (wt) {
      var Ie = me[ie];
      return Ie === r ? void 0 : Ie;
    }
    return Rt.call(me, ie) ? me[ie] : void 0;
  }
  function cn(ie) {
    var me = this.__data__;
    return wt ? me[ie] !== void 0 : Rt.call(me, ie);
  }
  function Yt(ie, me) {
    var Ie = this.__data__;
    return (
      (this.size += this.has(ie) ? 0 : 1),
      (Ie[ie] = wt && me === void 0 ? r : me),
      this
    );
  }
  (mn.prototype.clear = jn),
    (mn.prototype.delete = Gt),
    (mn.prototype.get = Cn),
    (mn.prototype.has = cn),
    (mn.prototype.set = Yt);
  function ln(ie) {
    var me = -1,
      Ie = ie == null ? 0 : ie.length;
    for (this.clear(); ++me < Ie; ) {
      var jt = ie[me];
      this.set(jt[0], jt[1]);
    }
  }
  function oe() {
    (this.__data__ = []), (this.size = 0);
  }
  function de(ie) {
    var me = this.__data__,
      Ie = ii(me, ie);
    if (Ie < 0) return !1;
    var jt = me.length - 1;
    return Ie == jt ? me.pop() : ce.call(me, Ie, 1), --this.size, !0;
  }
  function be(ie) {
    var me = this.__data__,
      Ie = ii(me, ie);
    return Ie < 0 ? void 0 : me[Ie][1];
  }
  function Me(ie) {
    return ii(this.__data__, ie) > -1;
  }
  function Fe(ie, me) {
    var Ie = this.__data__,
      jt = ii(Ie, ie);
    return jt < 0 ? (++this.size, Ie.push([ie, me])) : (Ie[jt][1] = me), this;
  }
  (ln.prototype.clear = oe),
    (ln.prototype.delete = de),
    (ln.prototype.get = be),
    (ln.prototype.has = Me),
    (ln.prototype.set = Fe);
  function it(ie) {
    var me = -1,
      Ie = ie == null ? 0 : ie.length;
    for (this.clear(); ++me < Ie; ) {
      var jt = ie[me];
      this.set(jt[0], jt[1]);
    }
  }
  function ft() {
    (this.size = 0),
      (this.__data__ = {
        hash: new mn(),
        map: new (Lt || ln)(),
        string: new mn(),
      });
  }
  function ze(ie) {
    var me = hl(this, ie).delete(ie);
    return (this.size -= me ? 1 : 0), me;
  }
  function nt(ie) {
    return hl(this, ie).get(ie);
  }
  function Xe(ie) {
    return hl(this, ie).has(ie);
  }
  function Ve(ie, me) {
    var Ie = hl(this, ie),
      jt = Ie.size;
    return Ie.set(ie, me), (this.size += Ie.size == jt ? 0 : 1), this;
  }
  (it.prototype.clear = ft),
    (it.prototype.delete = ze),
    (it.prototype.get = nt),
    (it.prototype.has = Xe),
    (it.prototype.set = Ve);
  function bt(ie) {
    var me = (this.__data__ = new ln(ie));
    this.size = me.size;
  }
  function gt() {
    (this.__data__ = new ln()), (this.size = 0);
  }
  function un(ie) {
    var me = this.__data__,
      Ie = me.delete(ie);
    return (this.size = me.size), Ie;
  }
  function Rn(ie) {
    return this.__data__.get(ie);
  }
  function bn(ie) {
    return this.__data__.has(ie);
  }
  function Sn(ie, me) {
    var Ie = this.__data__;
    if (Ie instanceof ln) {
      var jt = Ie.__data__;
      if (!Lt || jt.length < n - 1)
        return jt.push([ie, me]), (this.size = ++Ie.size), this;
      Ie = this.__data__ = new it(jt);
    }
    return Ie.set(ie, me), (this.size = Ie.size), this;
  }
  (bt.prototype.clear = gt),
    (bt.prototype.delete = un),
    (bt.prototype.get = Rn),
    (bt.prototype.has = bn),
    (bt.prototype.set = Sn);
  function Si(ie, me) {
    var Ie = Uu(ie),
      jt = !Ie && Fu(ie),
      Wn = !Ie && !jt && qc(ie),
      qn = !Ie && !jt && !Wn && Yc(ie),
      cr = Ie || jt || Wn || qn,
      dn = cr ? je(ie.length, String) : [],
      Br = dn.length;
    for (var Ii in ie)
      (cr &&
        (Ii == "length" ||
          (Wn && (Ii == "offset" || Ii == "parent")) ||
          (qn &&
            (Ii == "buffer" || Ii == "byteLength" || Ii == "byteOffset")) ||
          Du(Ii, Br))) ||
        dn.push(Ii);
    return dn;
  }
  function vr(ie, me, Ie) {
    ((Ie !== void 0 && !Vc(ie[me], Ie)) || (Ie === void 0 && !(me in ie))) &&
      Ki(ie, me, Ie);
  }
  function pi(ie, me, Ie) {
    var jt = ie[me];
    (!(Rt.call(ie, me) && Vc(jt, Ie)) || (Ie === void 0 && !(me in ie))) &&
      Ki(ie, me, Ie);
  }
  function ii(ie, me) {
    for (var Ie = ie.length; Ie--; ) if (Vc(ie[Ie][0], me)) return Ie;
    return -1;
  }
  function Ki(ie, me, Ie) {
    me == "__proto__" && we
      ? we(ie, me, {
          configurable: !0,
          enumerable: !0,
          value: Ie,
          writable: !0,
        })
      : (ie[me] = Ie);
  }
  var si = fl();
  function Ti(ie) {
    return ie == null
      ? ie === void 0
        ? B
        : v
      : pe && pe in Object(ie)
      ? Nh(ie)
      : Oh(ie);
  }
  function Yi(ie) {
    return Da(ie) && Ti(ie) == a;
  }
  function Es(ie) {
    if (!Ps(ie) || Qd(ie)) return !1;
    var me = ja(ie) ? xt : z;
    return me.test(ef(ie));
  }
  function In(ie) {
    return Da(ie) && Os(ie.length) && !!K[Ti(ie)];
  }
  function On(ie) {
    if (!Ps(ie)) return Xl(ie);
    var me = Bu(ie),
      Ie = [];
    for (var jt in ie)
      (jt == "constructor" && (me || !Rt.call(ie, jt))) || Ie.push(jt);
    return Ie;
  }
  function Ei(ie, me, Ie, jt, Wn) {
    ie !== me &&
      si(
        me,
        function (qn, cr) {
          if ((Wn || (Wn = new bt()), Ps(qn))) As(ie, me, cr, Ie, Ei, jt, Wn);
          else {
            var dn = jt ? jt(Xd(ie, cr), qn, cr + "", ie, me, Wn) : void 0;
            dn === void 0 && (dn = qn), vr(ie, cr, dn);
          }
        },
        jh
      );
  }
  function As(ie, me, Ie, jt, Wn, qn, cr) {
    var dn = Xd(ie, Ie),
      Br = Xd(me, Ie),
      Ii = cr.get(Br);
    if (Ii) {
      vr(ie, Ie, Ii);
      return;
    }
    var Di = qn ? qn(dn, Br, Ie + "", ie, me, cr) : void 0,
      Gs = Di === void 0;
    if (Gs) {
      var Bi = Uu(Br),
        Jl = !Bi && qc(Br),
        nf = !Bi && !Jl && Yc(Br);
      (Di = Br),
        Bi || Jl || nf
          ? Uu(dn)
            ? (Di = dn)
            : Gc(dn)
            ? (Di = Yd(dn))
            : Jl
            ? ((Gs = !1), (Di = ha(Br)))
            : nf
            ? ((Gs = !1), (Di = Hc(Br)))
            : (Di = [])
          : Kc(Br) || Fu(Br)
          ? ((Di = dn),
            Fu(dn) ? (Di = E0(dn)) : (!Ps(dn) || ja(dn)) && (Di = Ql(Br)))
          : (Gs = !1);
    }
    Gs && (cr.set(Br, Di), Wn(Di, Br, jt, qn, cr), cr.delete(Br)),
      vr(ie, Ie, Di);
  }
  function wr(ie, me) {
    return Lh(Ph(ie, me, Rr), ie + "");
  }
  var Mi = we
    ? function (ie, me) {
        return we(ie, "toString", {
          configurable: !0,
          enumerable: !1,
          value: Dr(me),
          writable: !0,
        });
      }
    : Rr;
  function ha(ie, me) {
    return ie.slice();
  }
  function ju(ie) {
    var me = new ie.constructor(ie.byteLength);
    return new Q(me).set(new Q(ie)), me;
  }
  function Hc(ie, me) {
    var Ie = ju(ie.buffer);
    return new ie.constructor(Ie, ie.byteOffset, ie.length);
  }
  function Yd(ie, me) {
    var Ie = -1,
      jt = ie.length;
    for (me || (me = Array(jt)); ++Ie < jt; ) me[Ie] = ie[Ie];
    return me;
  }
  function _0(ie, me, Ie, jt) {
    var Wn = !Ie;
    Ie || (Ie = {});
    for (var qn = -1, cr = me.length; ++qn < cr; ) {
      var dn = me[qn],
        Br = void 0;
      Br === void 0 && (Br = ie[dn]), Wn ? Ki(Ie, dn, Br) : pi(Ie, dn, Br);
    }
    return Ie;
  }
  function Ih(ie) {
    return wr(function (me, Ie) {
      var jt = -1,
        Wn = Ie.length,
        qn = Wn > 1 ? Ie[Wn - 1] : void 0,
        cr = Wn > 2 ? Ie[2] : void 0;
      for (
        qn = ie.length > 3 && typeof qn == "function" ? (Wn--, qn) : void 0,
          cr && S0(Ie[0], Ie[1], cr) && ((qn = Wn < 3 ? void 0 : qn), (Wn = 1)),
          me = Object(me);
        ++jt < Wn;

      ) {
        var dn = Ie[jt];
        dn && ie(me, dn, jt, qn);
      }
      return me;
    });
  }
  function fl(ie) {
    return function (me, Ie, jt) {
      for (var Wn = -1, qn = Object(me), cr = jt(me), dn = cr.length; dn--; ) {
        var Br = cr[++Wn];
        if (Ie(qn[Br], Br, qn) === !1) break;
      }
      return me;
    };
  }
  function hl(ie, me) {
    var Ie = ie.__data__;
    return Rh(me) ? Ie[typeof me == "string" ? "string" : "hash"] : Ie.map;
  }
  function Zd(ie, me) {
    var Ie = rn(ie, me);
    return Es(Ie) ? Ie : void 0;
  }
  function Nh(ie) {
    var me = Rt.call(ie, pe),
      Ie = ie[pe];
    try {
      ie[pe] = void 0;
      var jt = !0;
    } catch {}
    var Wn = Pt.call(ie);
    return jt && (me ? (ie[pe] = Ie) : delete ie[pe]), Wn;
  }
  function Ql(ie) {
    return typeof ie.constructor == "function" && !Bu(ie) ? Ht(H(ie)) : {};
  }
  function Du(ie, me) {
    var Ie = typeof ie;
    return (
      (me = me ?? o),
      !!me &&
        (Ie == "number" || (Ie != "symbol" && $.test(ie))) &&
        ie > -1 &&
        ie % 1 == 0 &&
        ie < me
    );
  }
  function S0(ie, me, Ie) {
    if (!Ps(Ie)) return !1;
    var jt = typeof me;
    return (
      jt == "number" ? tf(Ie) && Du(me, Ie.length) : jt == "string" && me in Ie
    )
      ? Vc(Ie[me], ie)
      : !1;
  }
  function Rh(ie) {
    var me = typeof ie;
    return me == "string" || me == "number" || me == "symbol" || me == "boolean"
      ? ie !== "__proto__"
      : ie === null;
  }
  function Qd(ie) {
    return !!mt && mt in ie;
  }
  function Bu(ie) {
    var me = ie && ie.constructor,
      Ie = (typeof me == "function" && me.prototype) || kt;
    return ie === Ie;
  }
  function Xl(ie) {
    var me = [];
    if (ie != null) for (var Ie in Object(ie)) me.push(Ie);
    return me;
  }
  function Oh(ie) {
    return Pt.call(ie);
  }
  function Ph(ie, me, Ie) {
    return (
      (me = vt(me === void 0 ? ie.length - 1 : me, 0)),
      function () {
        for (
          var jt = arguments,
            Wn = -1,
            qn = vt(jt.length - me, 0),
            cr = Array(qn);
          ++Wn < qn;

        )
          cr[Wn] = jt[me + Wn];
        Wn = -1;
        for (var dn = Array(me + 1); ++Wn < me; ) dn[Wn] = jt[Wn];
        return (dn[me] = Ie(cr)), He(ie, this, dn);
      }
    );
  }
  function Xd(ie, me) {
    if (
      !(me === "constructor" && typeof ie[me] == "function") &&
      me != "__proto__"
    )
      return ie[me];
  }
  var Lh = Jd(Mi);
  function Jd(ie) {
    var me = 0,
      Ie = 0;
    return function () {
      var jt = ct(),
        Wn = s - (jt - Ie);
      if (((Ie = jt), Wn > 0)) {
        if (++me >= i) return arguments[0];
      } else me = 0;
      return ie.apply(void 0, arguments);
    };
  }
  function ef(ie) {
    if (ie != null) {
      try {
        return Vt.call(ie);
      } catch {}
      try {
        return ie + "";
      } catch {}
    }
    return "";
  }
  function Vc(ie, me) {
    return ie === me || (ie !== ie && me !== me);
  }
  var Fu = Yi(
      (function () {
        return arguments;
      })()
    )
      ? Yi
      : function (ie) {
          return Da(ie) && Rt.call(ie, "callee") && !ee.call(ie, "callee");
        },
    Uu = Array.isArray;
  function tf(ie) {
    return ie != null && Os(ie.length) && !ja(ie);
  }
  function Gc(ie) {
    return Da(ie) && tf(ie);
  }
  var qc = ht || $u;
  function ja(ie) {
    if (!Ps(ie)) return !1;
    var me = Ti(ie);
    return me == h || me == p || me == c || me == x;
  }
  function Os(ie) {
    return typeof ie == "number" && ie > -1 && ie % 1 == 0 && ie <= o;
  }
  function Ps(ie) {
    var me = typeof ie;
    return ie != null && (me == "object" || me == "function");
  }
  function Da(ie) {
    return ie != null && typeof ie == "object";
  }
  function Kc(ie) {
    if (!Da(ie) || Ti(ie) != w) return !1;
    var me = H(ie);
    if (me === null) return !0;
    var Ie = Rt.call(me, "constructor") && me.constructor;
    return typeof Ie == "function" && Ie instanceof Ie && Vt.call(Ie) == wn;
  }
  var Yc = Ee ? Be(Ee) : In;
  function E0(ie) {
    return _0(ie, jh(ie));
  }
  function jh(ie) {
    return tf(ie) ? Si(ie) : On(ie);
  }
  var Dh = Ih(function (ie, me, Ie) {
    Ei(ie, me, Ie);
  });
  function Dr(ie) {
    return function () {
      return ie;
    };
  }
  function Rr(ie) {
    return ie;
  }
  function $u() {
    return !1;
  }
  e.exports = Dh;
})(C5, C5.exports);
var SEe = C5.exports;
const EEe = Gi(SEe);
function k5(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) &&
      t.indexOf(r) < 0 &&
      (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(e, r[i]) &&
        (n[r[i]] = e[r[i]]);
  return n;
}
var LJ = `<svg width="56" height="56" viewBox="0 0 56 56" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect width="56" height="56" rx="8" fill="#262A3D"/>
<g clip-path="url(#clip0_15747_103507)">
<path d="M20.6176 35.9801L16.0142 27.9949H25.2218L29.826 35.9801H20.6176Z" fill="#262A3D"/>
<path d="M20.6176 35.9801L16.0142 27.9949H25.2218L29.826 35.9801H20.6176Z" fill="white"/>
<path d="M25.2218 27.9947H16.0142L20.6176 20.0095H29.826L25.2218 27.9947Z" fill="url(#paint0_linear_15747_103507)"/>
<path d="M34.4302 27.9948L29.826 20.0096H20.6176L16.0142 12.0244H34.4302L43.6379 27.9948H34.4302Z" fill="#262A3D"/>
<path d="M34.4302 27.9948L29.826 20.0096H20.6176L16.0142 12.0244H34.4302L43.6379 27.9948H34.4302Z" fill="white"/>
<path d="M34.4302 43.9652H16.0142L20.6176 35.9801H29.826L34.4302 27.9949H43.6379L34.4302 43.9652Z" fill="url(#paint1_linear_15747_103507)"/>
</g>
<defs>
<linearGradient id="paint0_linear_15747_103507" x1="16.0142" y1="24.0021" x2="29.826" y2="24.0021" gradientUnits="userSpaceOnUse">
<stop stop-color="#55CCFE"/>
<stop offset="1" stop-color="#5E93EF"/>
</linearGradient>
<linearGradient id="paint1_linear_15747_103507" x1="76.5102" y1="5214.05" x2="10391.8" y2="5214.05" gradientUnits="userSpaceOnUse">
<stop stop-color="#55CCFE"/>
<stop offset="1" stop-color="#5E93EF"/>
</linearGradient>
<clipPath id="clip0_15747_103507">
<rect width="27.6667" height="32" fill="white" transform="translate(16 12)"/>
</clipPath>
</defs>
</svg>
`,
  AEe = `
<svg width="152" height="16" viewBox="0 0 152 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M4.03641 6.252C3.23241 6.252 2.41641 6.636 2.04441 7.272V6.396H1.00041V14.724H2.04441V11.124C2.41641 11.784 3.20841 12.144 4.04841 12.144C5.58441 12.144 6.84441 10.98 6.84441 9.204C6.84441 7.44 5.57241 6.252 4.03641 6.252ZM3.94041 11.16C3.02841 11.16 2.04441 10.428 2.04441 9.216C2.04441 8.016 2.94441 7.236 3.94041 7.236C4.97241 7.236 5.78841 8.1 5.78841 9.216C5.78841 10.344 4.97241 11.16 3.94041 11.16ZM10.8452 12.144C12.4412 12.144 13.7852 10.968 13.7852 9.192C13.7852 7.416 12.4412 6.252 10.8452 6.252C9.24919 6.252 7.91719 7.416 7.91719 9.192C7.91719 10.968 9.24919 12.144 10.8452 12.144ZM10.8452 11.16C9.82519 11.16 8.97319 10.356 8.97319 9.192C8.97319 8.04 9.82519 7.236 10.8452 7.236C11.8772 7.236 12.7412 8.04 12.7412 9.192C12.7412 10.356 11.8772 11.16 10.8452 11.16ZM22.2729 6.396L20.8449 10.38L19.4049 6.396H18.3849L16.9569 10.38L15.5289 6.396H14.4009L16.5369 12H17.4009L18.8889 7.836L20.4369 12H21.3129L23.4009 6.396H22.2729ZM29.6948 9.18C29.6948 7.404 28.5068 6.252 26.9108 6.252C25.3148 6.252 24.0308 7.404 24.0308 9.18C24.0308 10.956 25.3148 12.144 26.9108 12.144C27.9908 12.144 28.9988 11.616 29.4788 10.644L28.5788 10.284C28.2548 10.848 27.6308 11.16 26.9468 11.16C25.9868 11.16 25.2668 10.644 25.1108 9.648H29.6708C29.6828 9.492 29.6948 9.336 29.6948 9.18ZM25.1228 8.748C25.2908 7.74 25.9628 7.236 26.9108 7.236C27.8348 7.236 28.5188 7.788 28.6508 8.748H25.1228ZM33.7456 6.252C33.0016 6.252 32.4616 6.684 32.1736 7.668V6.396H31.1176V12H32.1736V9.948C32.1736 8.472 32.6176 7.26 33.7336 7.26C33.9496 7.26 34.2496 7.308 34.5496 7.452L34.7176 6.468C34.5496 6.36 34.1416 6.252 33.7456 6.252ZM40.8627 9.18C40.8627 7.404 39.6747 6.252 38.0787 6.252C36.4827 6.252 35.1987 7.404 35.1987 9.18C35.1987 10.956 36.4827 12.144 38.0787 12.144C39.1587 12.144 40.1667 11.616 40.6467 10.644L39.7467 10.284C39.4227 10.848 38.7987 11.16 38.1147 11.16C37.1547 11.16 36.4347 10.644 36.2787 9.648H40.8387C40.8507 9.492 40.8627 9.336 40.8627 9.18ZM36.2907 8.748C36.4587 7.74 37.1307 7.236 38.0787 7.236C39.0027 7.236 39.6867 7.788 39.8187 8.748H36.2907ZM46.7136 3.348V7.272C46.3416 6.612 45.5496 6.252 44.7096 6.252C43.1736 6.252 41.9136 7.416 41.9136 9.192C41.9136 10.956 43.1856 12.144 44.7216 12.144C45.5256 12.144 46.3416 11.76 46.7136 11.124V12H47.7576V3.348H46.7136ZM44.8056 11.16C43.7856 11.16 42.9696 10.296 42.9696 9.18C42.9696 8.052 43.7856 7.236 44.8056 7.236C45.7296 7.236 46.7136 7.968 46.7136 9.18C46.7136 10.38 45.8136 11.16 44.8056 11.16ZM55.6695 6.252C54.8295 6.252 54.0375 6.612 53.6655 7.272V3.348H52.6215V12H53.6655V11.124C54.0375 11.76 54.8535 12.144 55.6575 12.144C57.1935 12.144 58.4655 10.956 58.4655 9.192C58.4655 7.416 57.2055 6.252 55.6695 6.252ZM55.5615 11.16C54.5655 11.16 53.6655 10.38 53.6655 9.18C53.6655 7.968 54.6495 7.236 55.5615 7.236C56.5935 7.236 57.4095 8.052 57.4095 9.18C57.4095 10.296 56.5935 11.16 55.5615 11.16ZM63.6097 6.396L61.8937 10.524L60.2017 6.396H59.0737L61.3297 11.832L60.1537 14.724H61.2577L64.7377 6.396H63.6097Z" fill="var(--w3o-text-color, #707481)"/>
<g clip-path="url(#clip0_13558_103869)">
<path d="M143.502 11.0888L141.863 8.24889H145.142L146.782 11.0888H143.502Z" fill="currentColor"/>
<path d="M145.142 8.24887H141.863L143.502 5.40895H146.782L145.142 8.24887Z" fill="url(#paint0_linear_13558_103869)"/>
<path d="M148.421 8.24888L146.782 5.40896H143.502L141.863 2.56903H148.421L151.701 8.24888H148.421Z" fill="currentColor"/>
<path d="M148.421 13.9287H141.863L143.502 11.0888H146.782L148.421 8.24889H151.701L148.421 13.9287Z" fill="url(#paint1_linear_13558_103869)"/>
<path d="M76.4774 8.89232C76.4774 10.9327 74.9716 12.5077 73.1366 12.5077C72.1369 12.5077 71.4106 12.1378 70.9181 11.508V12.316H69.1513V2.71994L70.9181 2.17606V6.27771C71.4106 5.64894 72.1369 5.27797 73.1366 5.27797C74.9716 5.27797 76.4774 6.85198 76.4774 8.89232ZM74.7106 8.89232C74.7106 7.73959 73.9037 6.96201 72.8076 6.96201C71.7114 6.96201 70.9213 7.74273 70.9213 8.89232C70.9213 10.0419 71.7292 10.8237 72.8076 10.8237C73.8859 10.8237 74.7106 10.043 74.7106 8.89232Z" fill="currentColor"/>
<path d="M77.2718 2.71994L79.0376 2.17606V12.316H77.2718V2.71994Z" fill="currentColor"/>
<path d="M79.8183 8.89232C79.8171 8.17544 80.0286 7.47431 80.4261 6.87774C80.8236 6.28117 81.3893 5.816 82.0514 5.54113C82.7135 5.26627 83.4422 5.19408 84.1454 5.33371C84.8485 5.47333 85.4944 5.8185 86.0013 6.32549C86.5081 6.83247 86.8531 7.47847 86.9925 8.18166C87.1319 8.88486 87.0595 9.61361 86.7845 10.2756C86.5094 10.9376 86.0441 11.5031 85.4474 11.9005C84.8507 12.2978 84.1495 12.5092 83.4326 12.5077C82.9565 12.5128 82.4842 12.4227 82.0433 12.2428C81.6024 12.0629 81.2019 11.7967 80.8653 11.46C80.5286 11.1232 80.2626 10.7227 80.0828 10.2817C79.903 9.84083 79.8131 9.36845 79.8183 8.89232ZM85.2948 8.89232C85.2948 7.78359 84.4869 7.00602 83.4326 7.00602C82.3784 7.00602 81.5841 7.78674 81.5841 8.89232C81.5841 9.9979 82.392 10.7786 83.4326 10.7786C84.4733 10.7786 85.2948 10.0021 85.2948 8.89232Z" fill="currentColor"/>
<path d="M87.7313 8.89233C87.7313 6.85198 89.2645 5.27797 91.3457 5.27797C92.6881 5.27797 93.8513 5.98952 94.413 7.04375L92.8935 7.93451C92.6189 7.37281 92.03 7.01651 91.3321 7.01651C90.2778 7.01651 89.4971 7.79723 89.4971 8.89233C89.4971 9.98743 90.2778 10.7545 91.3321 10.7545C92.0447 10.7545 92.6326 10.4129 92.904 9.8512L94.4371 10.7273C94.1281 11.2741 93.6779 11.7279 93.1335 12.0413C92.5891 12.3547 91.9706 12.5161 91.3425 12.5088C89.2645 12.5077 87.7313 10.9327 87.7313 8.89233Z" fill="currentColor"/>
<path d="M99.5123 12.316L97.0203 9.20776V12.316H95.2534V2.71994L97.0203 2.17606V8.48153L99.374 5.46974H101.482L98.7316 8.85145L101.566 12.316H99.5123Z" fill="currentColor"/>
<path d="M108.623 8.11161V12.316H106.856V8.33377C106.856 7.40215 106.296 6.92324 105.501 6.92324C104.639 6.92324 103.994 7.4294 103.994 8.62091V12.316H102.229V5.46974H103.994V6.23579C104.405 5.6196 105.118 5.27797 106.035 5.27797C107.486 5.27797 108.623 6.29657 108.623 8.11161Z" fill="currentColor"/>
<path d="M116.74 5.46974V12.316H114.975V11.508C114.481 12.1242 113.742 12.5077 112.743 12.5077C110.921 12.5077 109.415 10.9358 109.415 8.89233C109.415 6.84884 110.921 5.27797 112.743 5.27797C113.742 5.27797 114.481 5.66152 114.975 6.27771V5.46974H116.74ZM114.975 8.89233C114.975 7.73959 114.167 6.96201 113.071 6.96201C111.974 6.96201 111.184 7.74273 111.184 8.89233C111.184 10.0419 111.992 10.8237 113.071 10.8237C114.149 10.8237 114.975 10.043 114.975 8.89233Z" fill="currentColor"/>
<path d="M121.344 7.16742V5.46975H119.796V3.45665L118.027 4.00053V10.0157C118.027 11.8643 118.866 12.5895 121.342 12.3212V10.7137C120.329 10.7692 119.794 10.7545 119.794 10.0157V7.16742H121.344Z" fill="currentColor"/>
<path d="M122.582 5.46974H124.347V12.316H122.582V5.46974Z" fill="currentColor"/>
<path d="M132.293 5.46974L129.691 12.316H127.678L125.077 5.46974H127.021L128.678 10.262L130.348 5.46974H132.293Z" fill="currentColor"/>
<path d="M136.073 10.9075C136.757 10.9075 137.305 10.6204 137.607 10.2232L139.03 11.0448C138.387 11.9754 137.36 12.5119 136.046 12.5119C133.74 12.5119 132.294 10.94 132.294 8.89652C132.294 6.85303 133.761 5.28217 135.908 5.28217C137.935 5.28217 139.373 6.88447 139.373 8.89652C139.37 9.13886 139.346 9.38049 139.301 9.61856H134.143C134.389 10.5219 135.142 10.9075 136.073 10.9075ZM137.607 8.25099C137.387 7.26487 136.648 6.8677 135.908 6.8677C134.965 6.8677 134.321 7.37491 134.114 8.25099H137.607Z" fill="currentColor"/>
</g>
<defs>
<linearGradient id="paint0_linear_13558_103869" x1="141.863" y1="6.82891" x2="146.782" y2="6.82891" gradientUnits="userSpaceOnUse">
<stop stop-color="#55CCFE"/>
<stop offset="1" stop-color="#5E93EF"/>
</linearGradient>
<linearGradient id="paint1_linear_13558_103869" x1="6973.93" y1="500.862" x2="7897.53" y2="500.862" gradientUnits="userSpaceOnUse">
<stop stop-color="#55CCFE"/>
<stop offset="1" stop-color="#5E93EF"/>
</linearGradient>
<clipPath id="clip0_13558_103869">
<rect width="82.8232" height="12" fill="white" transform="translate(69.0884 2)"/>
</clipPath>
</defs>
</svg>
`,
  v$ = `
  <svg height="100%" viewBox="0 0 10 14" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M4.99902 0.12619V5.20805L9.58065 7.12736L4.99902 0.12619Z" fill="white" fill-opacity="0.602"/>
    <path d="M4.99923 0.12619L0.416992 7.12736L4.99923 5.20805V0.12619Z" fill="white"/>
    <path d="M4.99902 10.4207V13.8737L9.58371 7.92728L4.99902 10.4207Z" fill="white" fill-opacity="0.602"/>
    <path d="M4.99923 13.8737V10.4201L0.416992 7.92728L4.99923 13.8737Z" fill="white"/>
    <path d="M4.99902 9.62134L9.58065 7.12739L4.99902 5.20923V9.62134Z" fill="white" fill-opacity="0.2"/>
    <path d="M0.416992 7.12739L4.99923 9.62134V5.20923L0.416992 7.12739Z" fill="white" fill-opacity="0.602"/>
  </svg>
`,
  w$ = `
  <svg width="100%" viewBox="0 0 14 13" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M10.5091 4.05856C10.2585 3.91901 9.9362 3.91901 9.64974 4.05856L7.64453 5.20986L6.28385 5.94251L4.31445 7.09382C4.0638 7.23337 3.74154 7.23337 3.45508 7.09382L1.91536 6.18673C1.66471 6.04718 1.48568 5.76807 1.48568 5.45408V3.70968C1.48568 3.43057 1.62891 3.15147 1.91536 2.97703L3.45508 2.10483C3.70573 1.96527 4.02799 1.96527 4.31445 2.10483L5.85417 3.01192C6.10482 3.15147 6.28385 3.43057 6.28385 3.74457V4.89587L7.64453 4.12833V2.94214C7.64453 2.66304 7.5013 2.38393 7.21484 2.20949L4.35026 0.569752C4.09961 0.4302 3.77734 0.4302 3.49089 0.569752L0.554687 2.24438C0.268229 2.38393 0.125 2.66304 0.125 2.94214V6.22162C0.125 6.50072 0.268229 6.77983 0.554687 6.95427L3.45508 8.59401C3.70573 8.73356 4.02799 8.73356 4.31445 8.59401L6.28385 7.47759L7.64453 6.71005L9.61393 5.59363C9.86458 5.45408 10.1868 5.45408 10.4733 5.59363L12.013 6.46583C12.2637 6.60539 12.4427 6.88449 12.4427 7.19848V8.94289C12.4427 9.22199 12.2995 9.50109 12.013 9.67553L10.5091 10.5477C10.2585 10.6873 9.9362 10.6873 9.64974 10.5477L8.11002 9.67553C7.85937 9.53598 7.68034 9.25688 7.68034 8.94289V7.82647L6.31966 8.59401V9.74531C6.31966 10.0244 6.46289 10.3035 6.74935 10.478L9.64974 12.1177C9.90039 12.2572 10.2227 12.2572 10.5091 12.1177L13.4095 10.478C13.6602 10.3384 13.8392 10.0593 13.8392 9.74531V6.43095C13.8392 6.15184 13.696 5.87274 13.4095 5.6983L10.5091 4.05856Z" fill="white"/>
  </svg>
`,
  CEe = `
  <svg width="100%" height="100%" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M4.32975 5.90275L7 3.2325L9.67163 5.90413L11.2254 4.35038L7 0.125L2.776 4.349L4.32975 5.90275ZM0.125 7L1.67875 5.44625L3.2325 7L1.67875 8.55375L0.125 7ZM4.32975 8.09725L7 10.7675L9.67163 8.09587L11.2254 9.64894L7 13.875L2.776 9.651L2.77394 9.64894L4.32975 8.09725ZM10.7675 7L12.3212 5.44625L13.875 7L12.3212 8.55375L10.7675 7ZM8.57575 6.99863H8.57713V7L7 8.57713L5.42494 7.00275L5.42219 7L5.42494 6.99794L5.70062 6.72156L5.83469 6.5875L7 5.42288L8.57644 6.99931L8.57575 6.99863Z" fill="white"/>
  </svg>
`,
  kEe = `
  <svg height="100%" viewBox="0 0 12 14" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M5.26613 0.133876C5.46683 0.0457135 5.68592 0 5.90775 0C6.12958 0 6.34867 0.0457135 6.54938 0.133876L10.2679 1.9598C10.3617 1.99893 10.4437 2.05898 10.5068 2.13465C10.5699 2.21033 10.6121 2.29932 10.6298 2.3938H10.6335V11.5637C10.6245 11.6667 10.5857 11.7654 10.5213 11.8495C10.457 11.9336 10.3694 11.9998 10.2679 12.0411L6.54938 13.8656C6.34867 13.9538 6.12958 13.9995 5.90775 13.9995C5.68592 13.9995 5.46683 13.9538 5.26613 13.8656L1.54762 12.0397C1.44724 11.9979 1.36095 11.9313 1.29799 11.8472C1.23504 11.7631 1.19779 11.6646 1.19025 11.5623C1.19025 11.5465 1.19025 11.5332 1.19025 11.522V2.39205C1.20579 2.29767 1.24673 2.20852 1.30923 2.13292C1.37173 2.05733 1.45375 1.99776 1.54762 1.9598L5.26613 0.133876ZM10.0478 7.50898L6.54938 9.22396C6.34872 9.31229 6.12961 9.35809 5.90775 9.35809C5.68589 9.35809 5.46678 9.31229 5.26613 9.22396L1.77525 7.51283V11.5455L5.26613 13.2493C5.43937 13.3471 5.62982 13.4154 5.82863 13.4512L5.9085 13.4558C6.12668 13.4357 6.3373 13.3704 6.525 13.2647L10.05 11.5301V7.50898H10.0478ZM0.585375 11.3642C0.568078 11.6186 0.612957 11.8734 0.716625 12.1093C0.805331 12.2602 0.936232 12.3857 1.09538 12.4726L1.10662 12.4796C1.1505 12.5069 1.1985 12.5356 1.25663 12.5692L1.32563 12.6081L1.53675 12.7267L1.23375 13.1922L0.9975 13.0592L0.95775 13.0365C0.889125 12.9973 0.8325 12.9637 0.779625 12.9315C0.214875 12.5769 0.004125 12.1912 0 11.3887V11.3642H0.585H0.585375ZM5.61412 5.05096C5.58845 5.05933 5.5634 5.06926 5.53912 5.08071L1.82137 6.90524L1.81013 6.91119H1.80675L1.81275 6.91469L1.82137 6.91889L5.53988 8.74341C5.56405 8.75505 5.58912 8.76499 5.61487 8.77316L5.61412 5.05096ZM6.201 5.05096V8.77456C6.22675 8.76639 6.25182 8.75645 6.276 8.74481L9.9945 6.92029L10.0057 6.91434H10.0091L10.0031 6.91154L9.9945 6.90699L6.276 5.08246C6.25182 5.07083 6.22675 5.06088 6.201 5.05271V5.05096ZM10.0478 3.04479L6.71025 4.68137L10.0478 6.31795V3.04304V3.04479ZM1.77525 3.04864V6.3141L5.103 4.68137L1.77525 3.04864ZM6.27525 0.61617C6.15894 0.569406 6.03364 0.545286 5.907 0.545286C5.78036 0.545286 5.65506 0.569406 5.53875 0.61617L1.821 2.4393L1.80975 2.4449L1.80638 2.44665L1.81238 2.4498L1.821 2.45365L5.5395 4.27817C5.65571 4.32526 5.78106 4.34956 5.90775 4.34956C6.03444 4.34956 6.15979 4.32526 6.276 4.27817L9.9945 2.45365L10.0057 2.4498L10.0091 2.44805L10.0031 2.4449L9.9945 2.4407L6.27525 0.61617ZM10.5968 0.816717L10.833 0.949365L10.875 0.970015C10.9432 1.00921 10.9999 1.04316 11.0528 1.07501C11.6179 1.42851 11.8282 1.81455 11.8328 2.61709V2.64159H11.2459C11.2632 2.38703 11.2183 2.13212 11.1146 1.8961C11.0258 1.74528 10.8948 1.61983 10.7355 1.53316L10.7242 1.52616C10.6807 1.49851 10.6327 1.47016 10.5743 1.43656L10.5056 1.39981L10.2945 1.28151L10.5975 0.816017L10.5968 0.816717Z" fill="white"/>
  </svg>
`,
  b$ = `
  <svg width="100%" viewBox="0 0 17 10" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M3.33611 9.25254C2.38341 9.25254 1.60287 9.02834 0.99442 8.58002C0.393974 8.1237 0.09375 7.47526 0.09375 6.63462C0.09375 6.45849 0.113782 6.2423 0.153782 5.9861C0.257909 5.40972 0.406006 4.71718 0.598133 3.9086C1.14252 1.707 2.54757 0.606201 4.81323 0.606201C5.42967 0.606201 5.98206 0.710266 6.47044 0.918394C6.95882 1.11852 7.34308 1.42278 7.62327 1.8311C7.90346 2.23135 8.04362 2.71174 8.04362 3.27212C8.04362 3.44025 8.02359 3.65241 7.98352 3.9086C7.86346 4.62111 7.71933 5.31366 7.55121 5.9861C7.27101 7.08294 6.78666 7.90354 6.09815 8.44793C5.40964 8.98431 4.489 9.25254 3.33611 9.25254ZM3.50424 7.52326C3.95262 7.52326 4.33284 7.39116 4.6451 7.12697C4.96535 6.86278 5.19351 6.45849 5.32958 5.9141C5.51371 5.16153 5.65387 4.50502 5.74993 3.94463C5.78193 3.7765 5.79793 3.60441 5.79793 3.42822C5.79793 2.6997 5.41764 2.33542 4.65713 2.33542C4.20875 2.33542 3.82449 2.46751 3.50424 2.7317C3.19205 2.99596 2.96786 3.40025 2.83179 3.94463C2.68766 4.48102 2.54354 5.13753 2.39947 5.9141C2.36741 6.07417 2.35141 6.2423 2.35141 6.41842C2.35141 7.155 2.73573 7.52326 3.50424 7.52326Z" fill="white"/>
    <path d="M8.59569 9.13247C8.50762 9.13247 8.43953 9.10443 8.39153 9.04837C8.35146 8.98431 8.33949 8.9123 8.35549 8.83224L10.0127 1.02648C10.0287 0.938417 10.0727 0.866353 10.1448 0.810289C10.2169 0.754289 10.2929 0.726257 10.373 0.726257H13.5673C14.456 0.726257 15.1685 0.910385 15.7049 1.27864C16.2493 1.64696 16.5215 2.17931 16.5215 2.87582C16.5215 3.07595 16.4975 3.28415 16.4495 3.50027C16.2493 4.42098 15.845 5.10149 15.2366 5.54181C14.6361 5.98213 13.8115 6.20229 12.7627 6.20229H11.1415L10.5892 8.83224C10.5731 8.92031 10.5291 8.99231 10.4571 9.04837C10.385 9.10443 10.3089 9.13247 10.2289 9.13247H8.59569ZM12.8468 4.54507C13.183 4.54507 13.4752 4.45298 13.7234 4.26885C13.9796 4.08472 14.1478 3.82053 14.2278 3.47627C14.2518 3.34015 14.2639 3.22008 14.2639 3.11602C14.2639 2.88383 14.1958 2.7077 14.0597 2.58763C13.9236 2.45951 13.6914 2.3955 13.3632 2.3955H11.9221L11.4658 4.54507H12.8468Z" fill="white"/>
  </svg>
`,
  TEe = `
  <svg width="100%" viewBox="0 0 20 19" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M19.8682 0.489349H0.110352V18.4468H19.8682V0.489349Z" fill="white"/>
  </svg>
`,
  MEe = `
<?xml version="1.0" encoding="utf-8"?>
<!-- Generator: Adobe Illustrator 26.3.1, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<svg version="1.1" id="Symbol" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 viewBox="0 0 384 383" style="enable-background:new 0 0 384 383;" xml:space="preserve">
<style type="text/css">
	.st0{fill:#FCFF52;}
</style>
<path class="st0" d="M383.5,0H0.5v383h383V249.3h-63.6C298,298.1,248.7,332,192.3,332c-77.8,0-140.8-63.6-140.8-140.8
	C51.4,114,114.5,51,192.3,51c57.5,0,106.8,35,128.7,84.9h62.5V0z"/>
</svg>
`,
  IEe = `
  <svg width="100%" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M32 16C32 7.16344 24.8366 0 16 0C7.16344 0 0 7.16344 0 16C0 24.8366 7.16344 32 16 32C24.8366 32 32 24.8366 32 16Z" fill="#04795B"/>
    <path d="M11.6529 17.4492C12.2831 17.4492 12.8648 17.2392 13.3334 16.8758L9.4877 13.0316C9.12413 13.4919 8.9141 14.0734 8.9141 14.7114C8.906 16.2216 10.134 17.4492 11.6529 17.4492Z" fill="#EFEFEF"/>
    <path d="M23.0931 14.7033C23.0931 14.0734 22.8831 13.4919 22.5195 13.0234L18.6738 16.8677C19.1343 17.2311 19.716 17.4411 20.3543 17.4411C21.8651 17.4492 23.0931 16.2216 23.0931 14.7033Z" fill="#EFEFEF"/>
    <path d="M25.0322 10.528L23.3275 12.2321C23.8931 12.9105 24.2324 13.7666 24.2324 14.7195C24.2324 16.8597 22.4954 18.5961 20.3544 18.5961C19.4092 18.5961 18.5447 18.2569 17.866 17.6915L15.9998 19.5571L14.1335 17.6915C13.4549 18.2569 12.5985 18.5961 11.6451 18.5961C9.50416 18.5961 7.7672 16.8597 7.7672 14.7195C7.7672 13.7746 8.10651 12.9105 8.67206 12.2321L7.79947 11.3599L6.96736 10.528C5.99787 12.1271 5.44043 13.9927 5.44043 15.9956C5.44043 21.8265 10.1667 26.543 15.9917 26.543C21.8167 26.543 26.543 21.8185 26.543 15.9956C26.5591 13.9846 26.0017 12.119 25.0322 10.528Z" fill="#EFEFEF"/>
    <path d="M23.6338 8.71084C21.7191 6.6999 19.0045 5.44 15.9991 5.44C12.9937 5.44 10.2872 6.6999 8.36435 8.71084C8.10584 8.98545 7.85539 9.27617 7.62109 9.575L15.991 17.9419L24.361 9.56695C24.1509 9.27617 23.9005 8.97734 23.6338 8.71084ZM15.9991 6.81297C18.4713 6.81297 20.7658 7.76593 22.4866 9.50231L15.9991 15.9874L9.5116 9.50231C11.2405 7.76593 13.5269 6.81297 15.9991 6.81297Z" fill="#EFEFEF"/>
  </svg>
`,
  NEe = `
  <svg width="100%" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M12.5484 1.04102e-06C11.6346 -0.000708404 10.7578 0.361217 10.1105 1.00633C9.46322 1.65145 9.09835 2.52703 9.096 3.44089V7.256C8.74045 7.28 8.37689 7.29511 8 7.29511C7.62311 7.29511 7.26133 7.31022 6.904 7.33156V3.44089C6.88946 2.53496 6.51938 1.67105 5.87358 1.03553C5.22779 0.400017 4.35805 0.0438409 3.452 0.0438409C2.54595 0.0438409 1.67621 0.400017 1.03042 1.03553C0.384623 1.67105 0.0145378 2.53496 0 3.44089V12.5591C0.0145378 13.465 0.384623 14.329 1.03042 14.9645C1.67621 15.6 2.54595 15.9562 3.452 15.9562C4.35805 15.9562 5.22779 15.6 5.87358 14.9645C6.51938 14.329 6.88946 13.465 6.904 12.5591V8.744C7.25956 8.72 7.62311 8.70489 8 8.70489C8.37689 8.70489 8.73867 8.68978 9.096 8.66845V12.5591C9.11054 13.465 9.48062 14.329 10.1264 14.9645C10.7722 15.6 11.6419 15.9562 12.548 15.9562C13.4541 15.9562 14.3238 15.6 14.9696 14.9645C15.6154 14.329 15.9855 13.465 16 12.5591V3.44089C15.9976 2.52719 15.6329 1.65173 14.9858 1.00665C14.3387 0.361557 13.4622 -0.000472854 12.5484 1.04102e-06ZM3.45156 1.40978C3.99089 1.40954 4.50828 1.62326 4.89023 2.00404C5.27218 2.38482 5.48748 2.90156 5.48889 3.44089V7.48089C4.47892 7.62724 3.49264 7.90609 2.55556 8.31023C2.14954 8.48842 1.76733 8.71655 1.41778 8.98934V3.44089C1.41919 2.90218 1.634 2.38597 2.01518 2.00529C2.39636 1.62462 2.91284 1.41048 3.45156 1.40978ZM5.48889 12.5591C5.48889 13.0994 5.27424 13.6177 4.89217 13.9997C4.51009 14.3818 3.99189 14.5964 3.45156 14.5964C2.91122 14.5964 2.39302 14.3818 2.01094 13.9997C1.62887 13.6177 1.41422 13.0994 1.41422 12.5591V11.6444C1.41422 10.8364 2.05422 10.0711 3.12711 9.59467C3.88309 9.26852 4.6763 9.03656 5.48889 8.904V12.5591ZM12.5484 14.5902C12.0091 14.5905 11.4917 14.3767 11.1098 13.996C10.7278 13.6152 10.5125 13.0984 10.5111 12.5591V8.51911C11.5211 8.37276 12.5074 8.09392 13.4444 7.68978C13.8505 7.51159 14.2327 7.28345 14.5822 7.01067V12.5591C14.5808 13.0978 14.366 13.614 13.9848 13.9947C13.6036 14.3754 13.0872 14.5895 12.5484 14.5902ZM12.8729 6.4C12.1169 6.72615 11.3237 6.95811 10.5111 7.09067V3.44089C10.5111 2.90056 10.7258 2.38235 11.1078 2.00028C11.4899 1.6182 12.0081 1.40356 12.5484 1.40356C13.0888 1.40356 13.607 1.6182 13.9891 2.00028C14.3711 2.38235 14.5858 2.90056 14.5858 3.44089V4.35556C14.5858 5.16 13.9458 5.92534 12.8729 6.4Z" fill="url(#paint0_linear_10254_2422)"/>
    <defs>
      <linearGradient id="paint0_linear_10254_2422" x1="1.01333" y1="14.7674" x2="14.8954" y2="0.847434" gradientUnits="userSpaceOnUse">
        <stop stop-color="#00AEE9"/>
        <stop offset="1" stop-color="#69FABD"/>
      </linearGradient>
    </defs>
  </svg>
`,
  x$ = `
  <svg height="100%" viewBox="0 0 22 25" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M13.7827 11.3172L15.5966 8.23933L20.4858 15.8545L20.4881 17.3159L20.4722 7.25942C20.4606 7.0136 20.3301 6.7887 20.1218 6.6561L11.3194 1.5928C11.1135 1.49162 10.8523 1.49269 10.6468 1.59594C10.6191 1.60989 10.593 1.62499 10.568 1.64147L10.5374 1.66079L1.99318 6.6121L1.95999 6.62712C1.91737 6.64674 1.8743 6.67165 1.83382 6.70063C1.67186 6.81683 1.56424 6.98861 1.52944 7.18131C1.52423 7.21052 1.52039 7.24026 1.51855 7.27023L1.53197 15.4653L6.08607 8.40666C6.65942 7.47067 7.90869 7.1692 9.06835 7.1856L10.4295 7.22155L2.40986 20.0827L3.3552 20.627L11.4709 7.23458L15.0581 7.22155L6.96327 20.9519L10.3366 22.8921L10.7396 23.1239C10.9101 23.1932 11.111 23.1967 11.283 23.1347L20.2091 17.9618L18.5026 18.9507L13.7827 11.3172ZM14.4747 21.2849L11.0677 15.9375L13.1474 12.4083L17.622 19.461L14.4747 21.2849Z" fill="#2D374B"/>
    <path d="M11.0684 15.9375L14.4754 21.2849L17.6228 19.4609L13.1482 12.4083L11.0684 15.9375Z" fill="#28A0F0"/>
    <path d="M20.4887 17.3159L20.4864 15.8545L15.5972 8.23932L13.7832 11.3172L18.5031 18.9507L20.2097 17.9618C20.3771 17.8259 20.4783 17.6264 20.489 17.4111L20.4887 17.3159Z" fill="#28A0F0"/>
    <path d="M7.71943e-05 18.694L2.41 20.0826L10.4296 7.22152L9.0685 7.18557C7.90883 7.16916 6.65964 7.47063 6.08621 8.40662L1.53211 15.4652L0 17.8193V18.694H7.71943e-05Z" fill="white"/>
    <path d="M15.0582 7.22156L11.4712 7.23459L3.35547 20.627L6.19211 22.2603L6.96354 20.9519L15.0582 7.22156Z" fill="white"/>
    <path d="M21.9999 7.20306C21.97 6.45287 21.5638 5.76608 20.9275 5.36626L12.0097 0.237888C11.3803 -0.079066 10.594 -0.0794494 9.96363 0.237658C9.88913 0.275218 1.2912 5.26171 1.2912 5.26171C1.17223 5.31874 1.05764 5.38673 0.949789 5.46384C0.381801 5.87094 0.0355663 6.50346 0 7.19846V17.8194L1.53211 15.4653L1.5187 7.27029C1.52054 7.24032 1.52429 7.21088 1.52958 7.18175C1.56415 6.9889 1.67185 6.81689 1.83397 6.70069C1.87444 6.67171 10.6192 1.60995 10.647 1.596C10.8526 1.49275 11.1137 1.49168 11.3195 1.59286L20.122 6.65616C20.3302 6.78876 20.4608 7.01366 20.4723 7.25948V17.4111C20.4617 17.6265 20.3766 17.8259 20.2092 17.9619L18.5026 18.9508L17.6221 19.461L14.4748 21.285L11.283 23.1347C11.1111 23.1968 10.9101 23.1933 10.7397 23.124L6.96334 20.952L6.19191 22.2603L9.58559 24.2142C9.6978 24.278 9.79784 24.3345 9.87985 24.3807C10.0069 24.452 10.0935 24.4996 10.1241 24.5144C10.3653 24.6315 10.7123 24.6997 11.025 24.6997C11.3118 24.6997 11.5913 24.647 11.8559 24.5434L21.1266 19.1745C21.6587 18.7623 21.9717 18.1406 21.9999 17.467V7.20306Z" fill="#96BEDC"/>
  </svg>
`,
  _$ = `
<svg height="100%" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_1607_202)">
<mask id="mask0_1607_202" style="mask-type:luminance" maskUnits="userSpaceOnUse" x="0" y="0" width="32" height="32">
<path d="M32 0H0V32H32V0Z" fill="white"/>
</mask>
<g mask="url(#mask0_1607_202)">
<path d="M16 32C19.1645 32 22.258 31.0616 24.8892 29.3036C27.5204 27.5454 29.571 25.0466 30.782 22.123C31.993 19.1993 32.31 15.9823 31.6926 12.8786C31.0752 9.77486 29.5514 6.92394 27.3138 4.6863C25.076 2.44866 22.2252 0.924806 19.1214 0.307442C16.0177 -0.30992 12.8007 0.0069325 9.87706 1.21793C6.95344 2.42894 4.45458 4.4797 2.69648 7.11088C0.938384 9.74206 0 12.8355 0 16C0 20.2434 1.68571 24.3132 4.6863 27.3138C7.68688 30.3142 11.7565 32 16 32Z" fill="#0052FF"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M15.9624 27.2676C22.1852 27.2676 27.23 22.223 27.23 16C27.23 9.7771 22.1852 4.73242 15.9624 4.73242C10.0588 4.73242 5.21566 9.2726 4.7341 15.0518H21.4546V16.928H4.73242C5.20432 22.7168 10.0519 27.2676 15.9624 27.2676Z" fill="white"/>
</g>
</g>
<defs>
<clipPath id="clip0_1607_202">
<rect width="32" height="32" fill="white"/>
</clipPath>
</defs>
</svg>
`,
  REe = `
<svg width="100%" height="100%" viewBox="0 0 12 20" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M0 0L0.0100002 6L4 10L0.0100002 14.01L0 20H12V14L8 10L12 6.01V0H0ZM10 14.5V18H2V14.5L6 10.5L10 14.5Z" fill="#929BED"/>
</svg>
`,
  bb = `
  <svg width="100%" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M11.07 12.85C11.84 11.46 13.32 10.64 14.18 9.41C15.09 8.12 14.58 5.71 12 5.71C10.31 5.71 9.48 6.99 9.13 8.05L6.54 6.96C7.25 4.83 9.18 3 11.99 3C14.34 3 15.95 4.07 16.77 5.41C17.47 6.56 17.88 8.71 16.8 10.31C15.6 12.08 14.45 12.62 13.83 13.76C13.58 14.22 13.48 14.52 13.48 16H10.59C10.58 15.22 10.46 13.95 11.07 12.85ZM14 20C14 21.1 13.1 22 12 22C10.9 22 10 21.1 10 20C10 18.9 10.9 18 12 18C13.1 18 14 18.9 14 20Z" fill="currentColor"/>
  </svg>
`,
  OEe = `
<svg width="14" height="11" viewBox="0 0 14 11" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M4.48076 8.10881L1.33076 4.95881L0.280762 6.00881L4.48076 10.2088L13.4808 1.20881L12.4308 0.158813L4.48076 8.10881Z" fill="#A4F4C6"/>
</svg>
`,
  PEe = `<svg width="16" height="13" viewBox="0 0 16 13" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M0.666992 13.0002H15.3337L8.00033 0.333496L0.666992 13.0002ZM8.66699 11.0002H7.33366V9.66683H8.66699V11.0002ZM8.66699 8.3335H7.33366V5.66683H8.66699V8.3335Z" fill="#FFB3B3"/>
</svg>
`,
  L8 = `
  <svg width="100%" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M12 2C6.48 2 2 6.48 2 12C2 17.52 6.48 22 12 22C17.52 22 22 17.52 22 12C22 6.48 17.52 2 12 2ZM13 17H11V11H13V17ZM13 9H11V7H13V9Z" fill="currentColor"/>
  </svg>
`,
  jJ = `
  <svg width="100%" viewBox="0 0 18 18" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M6.74999 12.15L3.59999 9L2.54999 10.05L6.74999 14.25L15.75 5.25L14.7 4.2L6.74999 12.15Z" fill="currentColor"/>
  </svg>
`,
  LEe = `
  <svg width="100%" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
    <path d="M6 2L6.01 8L10 12L6.01 16.01L6 22H18V16L14 12L18 8.01V2H6ZM16 16.5V20H8V16.5L12 12.5L16 16.5Z" fill="currenColor"/>
  </svg>
`,
  jEe = `
<?xml version="1.0" encoding="UTF-8"?>
<svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 477 477">
  <defs>
    <style>.cls-1{fill:#a36dfe;}.cls-2{fill:#4b2895;}</style>
  </defs>
  <circle class="cls-1" cx="238.5" cy="238.5" r="238.5"/>
  <g>
    <path class="cls-2" d="M237.85,113.99c29.25,1.32,54.97,2.45,80.69,3.69,3.95,.19,7.92,.72,11.82,1.43,9.23,1.69,15.34,8.72,14.78,18.2-1.33,22.33-3.22,44.63-4.79,66.95-.81,11.47-1.49,22.96-2.12,34.44-.29,5.24-2.03,8.14-7.74,10.18-37.84,13.52-76.98,15.46-116.47,13.42-23.24-1.2-45.99-5.86-68.06-13.68-4.71-1.67-6.72-3.91-7.03-8.72-1.31-20.46-2.83-40.9-4.25-61.35-.94-13.55-2.1-27.1-2.7-40.66-.49-11.15,6.17-18.37,17.2-19.01,30.7-1.78,61.4-3.39,88.69-4.88Z"/><path class="cls-2" d="M238.34,363.01c-31.19-1.24-61.52-5.51-90.12-18.31-20.8-9.31-38.13-23.01-48.65-43.63-3.63-7.1-5.68-15.3-6.91-23.24-1.17-7.59,1.95-14.47,8.76-18.93,6.74-4.42,13.4-3.5,20.12,.38,14.24,8.24,14.6,8.18,14.39,24.44-.09,7.1,3.71,11.23,8.41,15.24,12.51,10.67,26.94,17.78,42.7,21.94,38.88,10.26,77.66,10.06,115.42-4.42,11.31-4.33,21.33-12.17,31.67-18.82,5.27-3.39,7.7-8.7,6.88-15.19-1.34-10.7,2.19-17.99,12.86-22.48,7.8-3.29,14.95-6.25,22.38-.72,7.42,5.53,9.4,13.33,7.88,22.37-4.05,24.14-19.06,40.5-38.25,53.68-18.5,12.7-39.59,19.06-61.42,22.61-15.24,2.48-30.72,3.44-46.1,5.09Z"/>
  </g>
</svg>
`,
  DEe = `<svg width="178" height="177" viewBox="0 0 178 177" fill="none" xmlns="http://www.w3.org/2000/svg">
<circle cx="89.0198" cy="88.4095" r="88.305" fill="#06061B"/>
<path d="M68.0815 75.158C67.5149 74.5153 66.8174 74.1932 65.9874 74.1932H49.0126C48.8618 74.1932 48.7384 74.1459 48.6455 74.0512C48.5511 73.9581 48.5039 73.8528 48.5039 73.7398V62.3958C48.5039 62.2828 48.5511 62.179 48.6455 62.0844C48.7384 61.9897 48.8618 61.9424 49.0126 61.9424H66.9499C71.4761 61.9424 75.381 63.7773 78.6629 67.4442L83.0201 72.7185L74.5327 82.9848L68.0815 75.158ZM99.4299 67.3877C102.712 63.7575 106.635 61.9424 111.199 61.9424H129.08C129.231 61.9424 129.344 61.9805 129.42 62.0553C129.495 62.1317 129.533 62.2446 129.533 62.3958V73.7398C129.533 73.8528 129.495 73.9581 129.42 74.0512C129.344 74.1459 129.231 74.1932 129.08 74.1932H112.105C111.275 74.1932 110.578 74.5153 110.011 75.158L97.5064 90.2452L110.068 105.445C110.634 106.051 111.312 106.354 112.105 106.354H129.08C129.231 106.354 129.344 106.401 129.42 106.496C129.495 106.59 129.533 106.714 129.533 106.864V118.208C129.533 118.321 129.495 118.426 129.42 118.519C129.344 118.614 129.231 118.661 129.08 118.661H111.199C106.635 118.661 102.73 116.828 99.4863 113.159L89.0754 100.568L78.6629 113.159C75.381 116.828 71.4578 118.661 66.8936 118.661H49.0126C48.8618 118.661 48.7476 118.614 48.673 118.519C48.5968 118.424 48.5603 118.302 48.5603 118.15V106.806C48.5603 106.693 48.5968 106.589 48.673 106.494C48.7476 106.399 48.8618 106.352 49.0126 106.352H65.9874C66.7793 106.352 67.4768 106.032 68.0815 105.387L80.3595 90.5276L99.4299 67.3877Z" fill="#00D1FF"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M1.62306 101.122C1.02459 96.9706 0.714844 92.7262 0.714844 88.4095C0.714844 85.5803 0.84789 82.7823 1.10807 80.0212L11.5198 67.3877C14.8017 63.7575 18.7248 61.9424 23.2891 61.9424H41.1701C41.3209 61.9424 41.4336 61.9805 41.5097 62.0553C41.5844 62.1317 41.6224 62.2446 41.6224 62.3958V73.7398C41.6224 73.8528 41.5844 73.9581 41.5097 74.0512C41.4336 74.1459 41.3209 74.1932 41.1701 74.1932H24.1953C23.3653 74.1932 22.6678 74.5153 22.1012 75.158L9.59627 90.2452L22.1576 105.445C22.7241 106.051 23.4018 106.354 24.1953 106.354H41.1701C41.3209 106.354 41.4336 106.401 41.5097 106.496C41.5844 106.59 41.6224 106.714 41.6224 106.864V118.208C41.6224 118.321 41.5844 118.426 41.5097 118.519C41.4336 118.614 41.3209 118.661 41.1701 118.661H23.2891C18.7248 118.661 14.82 116.828 11.5761 113.159L1.62306 101.122Z" fill="#00D1FF"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M176.393 101.284C177.007 97.0816 177.325 92.7827 177.325 88.4095C177.325 85.5791 177.192 82.7799 176.931 80.0176L168.27 90.5276L155.992 105.387C155.387 106.032 154.689 106.352 153.898 106.352H136.923C136.772 106.352 136.658 106.399 136.583 106.494C136.507 106.589 136.47 106.693 136.47 106.806V118.15C136.47 118.302 136.507 118.424 136.583 118.519C136.658 118.614 136.772 118.661 136.923 118.661H154.804C159.368 118.661 163.291 116.828 166.573 113.159L176.393 101.284ZM153.898 74.1932C154.728 74.1932 155.425 74.5153 155.992 75.158L162.443 82.9848L170.93 72.7185L166.573 67.4442C163.291 63.7773 159.386 61.9424 154.86 61.9424H136.923C136.772 61.9424 136.649 61.9897 136.556 62.0844C136.461 62.179 136.414 62.2828 136.414 62.3958V73.7398C136.414 73.8528 136.461 73.9581 136.556 74.0512C136.649 74.1459 136.772 74.1932 136.923 74.1932H153.898Z" fill="#00D1FF"/>
</svg>`;
function BEe() {
  if (typeof window < "u") {
    const e = J5e.getParser(window.navigator.userAgent),
      t = e.getOS(),
      n = e.getBrowser(),
      { type: r } = e.getPlatform();
    return { type: r, os: t, browser: n };
  } else return { type: null, os: null, browser: null };
}
const FEe = (e) => e != null;
function fO(e) {
  return e.includes("<svg");
}
function ndt(e) {
  return `${e.slice(0, 6)}…${e.slice(-4)}`;
}
function rdt(e) {
  return e.length > 11 ? `${e.slice(0, 4)}…${e.slice(-6)}` : e;
}
async function idt(e) {
  try {
    return await navigator.clipboard.writeText(e);
  } catch (t) {
    console.error("Failed to copy: ", t);
  }
}
const DJ = (e) => (typeof e == "number" ? `0x${e.toString(16)}` : e);
function UEe(e) {
  return e.map((t) => {
    var { id: n } = t,
      r = k5(t, ["id"]);
    const i = DJ(n);
    return Object.assign({ id: i }, r);
  });
}
function sdt(e) {
  return `0x${(e * 1e9).toString(16)}`;
}
const odt = {
  "0x1": "Ethereum",
  "0xaa36a7": "Sepolia",
  "0x38": "Binance",
  "0x89": "Polygon",
  "0xfa": "Fantom",
  "0xa": "OP Mainnet",
  "0x45": "OP Kovan",
  "0xa86a": "Avalanche",
  "0xa4ec": "Celo",
  "0x2105": "Base",
  "0x14a33": "Base Goerli",
  "0x64": "Gnosis",
  "0x63564C40": "Harmony One",
  "0xa4b1": "Arbitrum One",
  "0xa4ba": "Arbitrum Nova",
  "0x27bc86aa": "Degen",
  "0x890": "SNAX",
};
function T5(e) {
  switch (e) {
    case "0x1":
    case "0x89":
    case "0xa":
    case "0xa4b1":
    case "0x144":
      return "0x1";
    case "0x5":
      return e;
    case "0xaa36a7":
      return e;
    default:
      return null;
  }
}
const $Ee = async (e) => {
    switch (e) {
      case "0x89":
      case "0xa":
      case "0xa4b1":
      case "0x144":
      case "0x1": {
        const { mainnet: t } = await At(async () => {
          const { mainnet: n } = await import("./index-40a497ea-B-e4dja1.js");
          return { mainnet: n };
        }, __vite__mapDeps([3, 4]));
        return t;
      }
      case "0xaa36a7": {
        const { sepolia: t } = await At(async () => {
          const { sepolia: n } = await import("./index-40a497ea-B-e4dja1.js");
          return { sepolia: n };
        }, __vite__mapDeps([3, 4]));
        return t;
      }
      default:
        return null;
    }
  },
  adt = {
    main: "0x1",
    sepolia: "0xaa36a7",
    xdai: "0x64",
    "bsc-main": "0x38",
    "matic-main": "0x89",
    "fantom-main": "0xfa",
    "matic-mumbai": "0x80001",
    degen: "0x27bc86aa",
    SNAX: "0x890",
  },
  zEe = {
    "0x1": { icon: v$, color: "#627EEA" },
    "0xaa36a7": { icon: v$, color: "#627EEA" },
    "0x38": { icon: CEe, color: "#F3BA2F" },
    "0x89": { icon: w$, color: "#8247E5" },
    "0xfa": { icon: kEe, color: "#1969FF" },
    "0xa": { icon: b$, color: "#FF0420" },
    "0x45": { icon: b$, color: "#FF0420" },
    "0xa86a": { icon: TEe, color: "#E84142" },
    "0xa4ec": { icon: MEe, color: "#FBCC5C" },
    "0x64": { icon: IEe, color: "#04795B" },
    "0x63564C40": { icon: NEe, color: "#ffffff" },
    "0xa4b1": { icon: x$, color: "#33394B" },
    "0xa4ba": { icon: x$, color: "#33394B" },
    "0x2105": { icon: _$, color: "#0259F9" },
    "0x14a33": { icon: _$, color: "#0259F9" },
    "0x80001": { icon: w$, color: "#8247E5" },
    "0x27bc86aa": { icon: jEe, color: "#a36dfe" },
    "0x890": { icon: DEe, color: "#00D1FF" },
  },
  ldt = { icon: bb, color: "#33394B" };
function cdt(e) {
  return e ? zEe[e.toLowerCase()] : void 0;
}
function udt(e, t) {
  return !!t.find(({ id: n, namespace: r }) => n === e.id && r === e.namespace);
}
const ddt = {
    pending: {
      backgroundColor: "var(--onboard-primary-700, var(--primary-700))",
      borderColor: "#6370E5",
      eventIcon: REe,
    },
    success: {
      backgroundColor: "#052E17",
      borderColor: "var(--onboard-success-300, var(--success-300))",
      eventIcon: OEe,
    },
    error: {
      backgroundColor: "#FDB1B11A",
      borderColor: "var(--onboard-danger-300, var(--danger-300))",
      eventIcon: PEe,
    },
    hint: {
      backgroundColor: "var(--onboard-gray-500, var(--gray-500))",
      borderColor: "var(--onboard-gray-500, var(--gray-500))",
      iconColor: "var(--onboard-gray-100, var(--gray-100))",
      eventIcon: L8,
    },
  },
  WEe = (e) => new Promise((t) => setTimeout(t, e));
function j8(e) {
  try {
    return localStorage.getItem(e);
  } catch {
    return null;
  }
}
function D8(e, t) {
  try {
    localStorage.setItem(e, t);
  } catch {
    return;
  }
}
function BJ(e) {
  try {
    localStorage.removeItem(e);
  } catch {
    return;
  }
}
let Sa = {
  svelteInstance: null,
  device: BEe(),
  initialWalletInit: [],
  gas: void 0,
  containerElements: { accountCenter: void 0, connectModal: void 0 },
  unstoppableResolution: void 0,
  wagmi: void 0,
};
function S$(e) {
  Sa = Object.assign(Object.assign({}, Sa), e);
}
const dp = {
    wallets: [],
    walletModules: [],
    chains: [],
    accountCenter: {
      enabled: !0,
      position: "bottomRight",
      expanded: !1,
      minimal: !0,
    },
    notify: {
      enabled: !0,
      position: "topRight",
      replacement: { gasPriceProbability: { speedup: 80, cancel: 95 } },
    },
    notifications: [],
    locale: "",
    connect: { showSidebar: !0, disableClose: !1 },
    appMetadata: null,
    wagmiConfig: null,
  },
  xd = {
    TERMS_AGREEMENT: "onboard.js:agreement",
    LAST_CONNECTED_WALLET: "onboard.js:last_connected_wallet",
  },
  zs = 768,
  fdt = "https://rpc.blocknative.com/boost",
  hdt =
    "https://docs.blocknative.com/blocknative-mev-protection/transaction-boost",
  FJ = "add_chains",
  UJ = "update_chains",
  $J = "reset_store",
  zJ = "add_wallet",
  WJ = "update_wallet",
  HJ = "remove_wallet",
  VJ = "update_account",
  GJ = "update_account_center",
  qJ = "update_connect_modal",
  KJ = "set_wallet_modules",
  YJ = "set_locale",
  ZJ = "update_notify",
  QJ = "add_notification",
  XJ = "remove_notification",
  JJ = "update_balance",
  eee = "update_app_metadata",
  tee = "update_wagmi_config";
function HEe(e, t) {
  const { type: n, payload: r } = t;
  switch (n) {
    case FJ:
      return Object.assign(Object.assign({}, e), {
        chains: [...e.chains, ...r],
      });
    case UJ: {
      const i = r,
        s = e.chains,
        o = s.findIndex((a) => a.id === i.id);
      return (s[o] = i), Object.assign(Object.assign({}, e), { chains: s });
    }
    case zJ: {
      const i = r,
        s = e.wallets.find(({ label: o }) => o === i.label);
      return Object.assign(Object.assign({}, e), {
        wallets: [s || r, ...e.wallets.filter(({ label: o }) => o !== i.label)],
      });
    }
    case WJ: {
      const i = r,
        { id: s } = i,
        o = k5(i, ["id"]),
        a = e.wallets.map((l) =>
          l.label === s ? Object.assign(Object.assign({}, l), o) : l
        );
      return Object.assign(Object.assign({}, e), { wallets: a });
    }
    case HJ: {
      const i = r;
      return Object.assign(Object.assign({}, e), {
        wallets: e.wallets.filter(({ label: s }) => s !== i.id),
      });
    }
    case VJ: {
      const i = r,
        { id: s, address: o } = i,
        a = k5(i, ["id", "address"]),
        l = e.wallets.map(
          (c) => (
            c.label === s &&
              (c.accounts = c.accounts.map((u) =>
                u.address === o ? Object.assign(Object.assign({}, u), a) : u
              )),
            c
          )
        );
      return Object.assign(Object.assign({}, e), { wallets: l });
    }
    case JJ: {
      const i = r;
      return Object.assign(Object.assign({}, e), { wallets: i });
    }
    case qJ: {
      const i = r;
      return Object.assign(Object.assign({}, e), {
        connect: Object.assign(Object.assign({}, e.connect), i),
      });
    }
    case GJ: {
      const i = r;
      return Object.assign(Object.assign({}, e), {
        accountCenter: Object.assign(Object.assign({}, e.accountCenter), i),
      });
    }
    case ZJ: {
      const i = r;
      return Object.assign(Object.assign({}, e), {
        notify: Object.assign(Object.assign({}, e.notify), i),
      });
    }
    case QJ: {
      const i = r,
        s = [...e.notifications],
        o = s.findIndex(({ id: a }) => a === i.id);
      return (
        o !== -1 ? (s[o] = i) : s.unshift(i),
        Object.assign(Object.assign({}, e), { notifications: s })
      );
    }
    case XJ: {
      const i = r;
      return Object.assign(Object.assign({}, e), {
        notifications: e.notifications.filter((s) => s.id !== i),
      });
    }
    case KJ:
      return Object.assign(Object.assign({}, e), { walletModules: r });
    case YJ:
      return w1.set(r), Object.assign(Object.assign({}, e), { locale: r });
    case eee: {
      const i = r;
      return Object.assign(Object.assign({}, e), {
        appMetadata: Object.assign(
          Object.assign(Object.assign({}, e.appMetadata), i),
          { name: i.name || "" }
        ),
      });
    }
    case tee: {
      const i = r;
      return Object.assign(Object.assign({}, e), { wagmiConfig: i });
    }
    case $J:
      return dp;
    default:
      throw new Error(`Unknown type: ${n} in appStore reducer`);
  }
}
const B8 = new jx(dp),
  M5 = new xh();
M5.subscribe(B8);
function Ho(e) {
  const t = B8.getValue();
  M5.next(HEe(t, e));
}
function VEe(e) {
  if (!e) return M5.asObservable();
  if (!Object.keys(B8.getValue()).includes(String(e)))
    throw new Error(`key: ${e} does not exist on this store`);
  return M5.asObservable().pipe(q5e(e), rO(e), Oy(FEe));
}
function GEe() {
  return B8.getValue();
}
const Pn = { select: VEe, get: GEe };
function rt() {}
const Ux = (e) => e;
function qEe(e, t) {
  for (const n in t) e[n] = t[n];
  return e;
}
function KEe(e) {
  return (
    !!e &&
    (typeof e == "object" || typeof e == "function") &&
    typeof e.then == "function"
  );
}
function nee(e) {
  return e();
}
function E$() {
  return Object.create(null);
}
function Hd(e) {
  e.forEach(nee);
}
function m0(e) {
  return typeof e == "function";
}
function oo(e, t) {
  return e != e
    ? t == t
    : e !== t || (e && typeof e == "object") || typeof e == "function";
}
let L_;
function By(e, t) {
  return L_ || (L_ = document.createElement("a")), (L_.href = t), e === L_.href;
}
function YEe(e) {
  return Object.keys(e).length === 0;
}
function ZEe(e, ...t) {
  if (e == null) return rt;
  const n = e.subscribe(...t);
  return n.unsubscribe ? () => n.unsubscribe() : n;
}
function is(e, t, n) {
  e.$$.on_destroy.push(ZEe(t, n));
}
function hO(e, t, n, r) {
  if (e) {
    const i = ree(e, t, n, r);
    return e[0](i);
  }
}
function ree(e, t, n, r) {
  return e[1] && r ? qEe(n.ctx.slice(), e[1](r(t))) : n.ctx;
}
function pO(e, t, n, r) {
  if (e[2] && r) {
    const i = e[2](r(n));
    if (t.dirty === void 0) return i;
    if (typeof i == "object") {
      const s = [],
        o = Math.max(t.dirty.length, i.length);
      for (let a = 0; a < o; a += 1) s[a] = t.dirty[a] | i[a];
      return s;
    }
    return t.dirty | i;
  }
  return t.dirty;
}
function mO(e, t, n, r, i, s) {
  if (i) {
    const o = ree(t, n, r, s);
    e.p(o, i);
  }
}
function gO(e) {
  if (e.ctx.length > 32) {
    const t = [],
      n = e.ctx.length / 32;
    for (let r = 0; r < n; r++) t[r] = -1;
    return t;
  }
  return -1;
}
function A$(e) {
  return e ?? "";
}
function C$(e) {
  const t = typeof e == "string" && e.match(/^\s*(-?[\d.]+)([^\s]*)\s*$/);
  return t ? [parseFloat(t[1]), t[2] || "px"] : [e, "px"];
}
const iee = typeof window < "u";
let F8 = iee ? () => window.performance.now() : () => Date.now(),
  yO = iee ? (e) => requestAnimationFrame(e) : rt;
const ey = new Set();
function see(e) {
  ey.forEach((t) => {
    t.c(e) || (ey.delete(t), t.f());
  }),
    ey.size !== 0 && yO(see);
}
function U8(e) {
  let t;
  return (
    ey.size === 0 && yO(see),
    {
      promise: new Promise((n) => {
        ey.add((t = { c: e, f: n }));
      }),
      abort() {
        ey.delete(t);
      },
    }
  );
}
function Te(e, t) {
  e.appendChild(t);
}
function ao(e, t, n) {
  const r = vO(e);
  if (!r.getElementById(t)) {
    const i = We("style");
    (i.id = t), (i.textContent = n), oee(r, i);
  }
}
function vO(e) {
  if (!e) return document;
  const t = e.getRootNode ? e.getRootNode() : e.ownerDocument;
  return t && t.host ? t : e.ownerDocument;
}
function QEe(e) {
  const t = We("style");
  return oee(vO(e), t), t.sheet;
}
function oee(e, t) {
  return Te(e.head || e, t), t.sheet;
}
function at(e, t, n) {
  e.insertBefore(t, n || null);
}
function st(e) {
  e.parentNode && e.parentNode.removeChild(e);
}
function aee(e, t) {
  for (let n = 0; n < e.length; n += 1) e[n] && e[n].d(t);
}
function We(e) {
  return document.createElement(e);
}
function XEe(e) {
  return document.createElementNS("http://www.w3.org/2000/svg", e);
}
function hr(e) {
  return document.createTextNode(e);
}
function qt() {
  return hr(" ");
}
function xi() {
  return hr("");
}
function ll(e, t, n, r) {
  return e.addEventListener(t, n, r), () => e.removeEventListener(t, n, r);
}
function JEe(e) {
  return function (t) {
    return t.stopPropagation(), e.call(this, t);
  };
}
function Se(e, t, n) {
  n == null
    ? e.removeAttribute(t)
    : e.getAttribute(t) !== n && e.setAttribute(t, n);
}
function e9e(e) {
  return Array.from(e.childNodes);
}
function zr(e, t) {
  (t = "" + t), e.data !== t && (e.data = t);
}
function ig(e, t, n, r) {
  n == null ? e.style.removeProperty(t) : e.style.setProperty(t, n, "");
}
function pdt(e, t, n) {
  for (let r = 0; r < e.options.length; r += 1) {
    const i = e.options[r];
    if (i.__value === t) {
      i.selected = !0;
      return;
    }
  }
  e.selectedIndex = -1;
}
function Ft(e, t, n) {
  e.classList[n ? "add" : "remove"](t);
}
function t9e(e, t, { bubbles: n = !1, cancelable: r = !1 } = {}) {
  const i = document.createEvent("CustomEvent");
  return i.initCustomEvent(e, n, r, t), i;
}
class bv {
  constructor(t = !1) {
    (this.is_svg = !1), (this.is_svg = t), (this.e = this.n = null);
  }
  c(t) {
    this.h(t);
  }
  m(t, n, r = null) {
    this.e ||
      (this.is_svg
        ? (this.e = XEe(n.nodeName))
        : (this.e = We(n.nodeType === 11 ? "TEMPLATE" : n.nodeName)),
      (this.t = n.tagName !== "TEMPLATE" ? n : n.content),
      this.c(t)),
      this.i(r);
  }
  h(t) {
    (this.e.innerHTML = t),
      (this.n = Array.from(
        this.e.nodeName === "TEMPLATE"
          ? this.e.content.childNodes
          : this.e.childNodes
      ));
  }
  i(t) {
    for (let n = 0; n < this.n.length; n += 1) at(this.t, this.n[n], t);
  }
  p(t) {
    this.d(), this.h(t), this.i(this.a);
  }
  d() {
    this.n.forEach(st);
  }
}
function Od(e, t) {
  return new e(t);
}
const I5 = new Map();
let N5 = 0;
function n9e(e) {
  let t = 5381,
    n = e.length;
  for (; n--; ) t = ((t << 5) - t) ^ e.charCodeAt(n);
  return t >>> 0;
}
function r9e(e, t) {
  const n = { stylesheet: QEe(t), rules: {} };
  return I5.set(e, n), n;
}
function xb(e, t, n, r, i, s, o, a = 0) {
  const l = 16.666 / r;
  let c = `{
`;
  for (let b = 0; b <= 1; b += l) {
    const v = t + (n - t) * s(b);
    c +=
      b * 100 +
      `%{${o(v, 1 - v)}}
`;
  }
  const u =
      c +
      `100% {${o(n, 1 - n)}}
}`,
    d = `__svelte_${n9e(u)}_${a}`,
    f = vO(e),
    { stylesheet: h, rules: p } = I5.get(f) || r9e(f, e);
  p[d] ||
    ((p[d] = !0), h.insertRule(`@keyframes ${d} ${u}`, h.cssRules.length));
  const g = e.style.animation || "";
  return (
    (e.style.animation = `${
      g ? `${g}, ` : ""
    }${d} ${r}ms linear ${i}ms 1 both`),
    (N5 += 1),
    d
  );
}
function _b(e, t) {
  const n = (e.style.animation || "").split(", "),
    r = n.filter(
      t ? (s) => s.indexOf(t) < 0 : (s) => s.indexOf("__svelte") === -1
    ),
    i = n.length - r.length;
  i && ((e.style.animation = r.join(", ")), (N5 -= i), N5 || i9e());
}
function i9e() {
  yO(() => {
    N5 ||
      (I5.forEach((e) => {
        const { ownerNode: t } = e.stylesheet;
        t && st(t);
      }),
      I5.clear());
  });
}
function mdt(e, t, n, r) {
  if (!t) return rt;
  const i = e.getBoundingClientRect();
  if (
    t.left === i.left &&
    t.right === i.right &&
    t.top === i.top &&
    t.bottom === i.bottom
  )
    return rt;
  const {
    delay: s = 0,
    duration: o = 300,
    easing: a = Ux,
    start: l = F8() + s,
    end: c = l + o,
    tick: u = rt,
    css: d,
  } = n(e, { from: t, to: i }, r);
  let f = !0,
    h = !1,
    p;
  function g() {
    d && (p = xb(e, 0, 1, o, s, a, d)), s || (h = !0);
  }
  function b() {
    d && _b(e, p), (f = !1);
  }
  return (
    U8((v) => {
      if ((!h && v >= l && (h = !0), h && v >= c && (u(1, 0), b()), !f))
        return !1;
      if (h) {
        const w = v - l,
          x = 0 + 1 * a(w / o);
        u(x, 1 - x);
      }
      return !0;
    }),
    g(),
    u(0, 1),
    b
  );
}
function gdt(e) {
  const t = getComputedStyle(e);
  if (t.position !== "absolute" && t.position !== "fixed") {
    const { width: n, height: r } = t,
      i = e.getBoundingClientRect();
    (e.style.position = "absolute"),
      (e.style.width = n),
      (e.style.height = r),
      s9e(e, i);
  }
}
function s9e(e, t) {
  const n = e.getBoundingClientRect();
  if (t.left !== n.left || t.top !== n.top) {
    const r = getComputedStyle(e),
      i = r.transform === "none" ? "" : r.transform;
    e.style.transform = `${i} translate(${t.left - n.left}px, ${
      t.top - n.top
    }px)`;
  }
}
let Sb;
function $f(e) {
  Sb = e;
}
function wO() {
  if (!Sb) throw new Error("Function called outside component initialization");
  return Sb;
}
function o9e(e) {
  wO().$$.on_mount.push(e);
}
function lee(e) {
  wO().$$.on_destroy.push(e);
}
function a9e(e, t) {
  const n = e.$$.callbacks[t.type];
  n && n.slice().forEach((r) => r.call(this, t));
}
const sg = [],
  R5 = [];
let ty = [];
const QT = [],
  l9e = Promise.resolve();
let XT = !1;
function c9e() {
  XT || ((XT = !0), l9e.then(bO));
}
function Na(e) {
  ty.push(e);
}
function u9e(e) {
  QT.push(e);
}
const SC = new Set();
let V1 = 0;
function bO() {
  if (V1 !== 0) return;
  const e = Sb;
  do {
    try {
      for (; V1 < sg.length; ) {
        const t = sg[V1];
        V1++, $f(t), d9e(t.$$);
      }
    } catch (t) {
      throw ((sg.length = 0), (V1 = 0), t);
    }
    for ($f(null), sg.length = 0, V1 = 0; R5.length; ) R5.pop()();
    for (let t = 0; t < ty.length; t += 1) {
      const n = ty[t];
      SC.has(n) || (SC.add(n), n());
    }
    ty.length = 0;
  } while (sg.length);
  for (; QT.length; ) QT.pop()();
  (XT = !1), SC.clear(), $f(e);
}
function d9e(e) {
  if (e.fragment !== null) {
    e.update(), Hd(e.before_update);
    const t = e.dirty;
    (e.dirty = [-1]),
      e.fragment && e.fragment.p(e.ctx, t),
      e.after_update.forEach(Na);
  }
}
function f9e(e) {
  const t = [],
    n = [];
  ty.forEach((r) => (e.indexOf(r) === -1 ? t.push(r) : n.push(r))),
    n.forEach((r) => r()),
    (ty = t);
}
let A2;
function xO() {
  return (
    A2 ||
      ((A2 = Promise.resolve()),
      A2.then(() => {
        A2 = null;
      })),
    A2
  );
}
function Tm(e, t, n) {
  e.dispatchEvent(t9e(`${t ? "intro" : "outro"}${n}`));
}
const z4 = new Set();
let pd;
function zi() {
  pd = { r: 0, c: [], p: pd };
}
function Wi() {
  pd.r || Hd(pd.c), (pd = pd.p);
}
function Ke(e, t) {
  e && e.i && (z4.delete(e), e.i(t));
}
function ot(e, t, n, r) {
  if (e && e.o) {
    if (z4.has(e)) return;
    z4.add(e),
      pd.c.push(() => {
        z4.delete(e), r && (n && e.d(1), r());
      }),
      e.o(t);
  } else r && r();
}
const _O = { duration: 0 };
function SO(e, t, n) {
  const r = { direction: "in" };
  let i = t(e, n, r),
    s = !1,
    o,
    a,
    l = 0;
  function c() {
    o && _b(e, o);
  }
  function u() {
    const {
      delay: f = 0,
      duration: h = 300,
      easing: p = Ux,
      tick: g = rt,
      css: b,
    } = i || _O;
    b && (o = xb(e, 0, 1, h, f, p, b, l++)), g(0, 1);
    const v = F8() + f,
      w = v + h;
    a && a.abort(),
      (s = !0),
      Na(() => Tm(e, !0, "start")),
      (a = U8((x) => {
        if (s) {
          if (x >= w) return g(1, 0), Tm(e, !0, "end"), c(), (s = !1);
          if (x >= v) {
            const S = p((x - v) / h);
            g(S, 1 - S);
          }
        }
        return s;
      }));
  }
  let d = !1;
  return {
    start() {
      d || ((d = !0), _b(e), m0(i) ? ((i = i(r)), xO().then(u)) : u());
    },
    invalidate() {
      d = !1;
    },
    end() {
      s && (c(), (s = !1));
    },
  };
}
function ydt(e, t, n) {
  const r = { direction: "out" };
  let i = t(e, n, r),
    s = !0,
    o;
  const a = pd;
  a.r += 1;
  function l() {
    const {
      delay: c = 0,
      duration: u = 300,
      easing: d = Ux,
      tick: f = rt,
      css: h,
    } = i || _O;
    h && (o = xb(e, 1, 0, u, c, d, h));
    const p = F8() + c,
      g = p + u;
    Na(() => Tm(e, !1, "start")),
      U8((b) => {
        if (s) {
          if (b >= g) return f(0, 1), Tm(e, !1, "end"), --a.r || Hd(a.c), !1;
          if (b >= p) {
            const v = d((b - p) / u);
            f(1 - v, v);
          }
        }
        return s;
      });
  }
  return (
    m0(i)
      ? xO().then(() => {
          (i = i(r)), l();
        })
      : l(),
    {
      end(c) {
        c && i.tick && i.tick(1, 0), s && (o && _b(e, o), (s = !1));
      },
    }
  );
}
function k$(e, t, n, r) {
  const i = { direction: "both" };
  let s = t(e, n, i),
    o = r ? 0 : 1,
    a = null,
    l = null,
    c = null;
  function u() {
    c && _b(e, c);
  }
  function d(h, p) {
    const g = h.b - o;
    return (
      (p *= Math.abs(g)),
      {
        a: o,
        b: h.b,
        d: g,
        duration: p,
        start: h.start,
        end: h.start + p,
        group: h.group,
      }
    );
  }
  function f(h) {
    const {
        delay: p = 0,
        duration: g = 300,
        easing: b = Ux,
        tick: v = rt,
        css: w,
      } = s || _O,
      x = { start: F8() + p, b: h };
    h || ((x.group = pd), (pd.r += 1)),
      a || l
        ? (l = x)
        : (w && (u(), (c = xb(e, o, h, g, p, b, w))),
          h && v(0, 1),
          (a = d(x, g)),
          Na(() => Tm(e, h, "start")),
          U8((S) => {
            if (
              (l &&
                S > l.start &&
                ((a = d(l, g)),
                (l = null),
                Tm(e, a.b, "start"),
                w && (u(), (c = xb(e, o, a.b, a.duration, 0, b, s.css)))),
              a)
            ) {
              if (S >= a.end)
                v((o = a.b), 1 - o),
                  Tm(e, a.b, "end"),
                  l || (a.b ? u() : --a.group.r || Hd(a.group.c)),
                  (a = null);
              else if (S >= a.start) {
                const R = S - a.start;
                (o = a.a + a.d * b(R / a.duration)), v(o, 1 - o);
              }
            }
            return !!(a || l);
          }));
  }
  return {
    run(h) {
      m0(s)
        ? xO().then(() => {
            (s = s(i)), f(h);
          })
        : f(h);
    },
    end() {
      u(), (a = l = null);
    },
  };
}
function Qm(e, t) {
  const n = (t.token = {});
  function r(i, s, o, a) {
    if (t.token !== n) return;
    t.resolved = a;
    let l = t.ctx;
    o !== void 0 && ((l = l.slice()), (l[o] = a));
    const c = i && (t.current = i)(l);
    let u = !1;
    t.block &&
      (t.blocks
        ? t.blocks.forEach((d, f) => {
            f !== s &&
              d &&
              (zi(),
              ot(d, 1, 1, () => {
                t.blocks[f] === d && (t.blocks[f] = null);
              }),
              Wi());
          })
        : t.block.d(1),
      c.c(),
      Ke(c, 1),
      c.m(t.mount(), t.anchor),
      (u = !0)),
      (t.block = c),
      t.blocks && (t.blocks[s] = c),
      u && bO();
  }
  if (KEe(e)) {
    const i = wO();
    if (
      (e.then(
        (s) => {
          $f(i), r(t.then, 1, t.value, s), $f(null);
        },
        (s) => {
          if (($f(i), r(t.catch, 2, t.error, s), $f(null), !t.hasCatch))
            throw s;
        }
      ),
      t.current !== t.pending)
    )
      return r(t.pending, 0), !0;
  } else {
    if (t.current !== t.then) return r(t.then, 1, t.value, e), !0;
    t.resolved = e;
  }
}
function xv(e, t, n) {
  const r = t.slice(),
    { resolved: i } = e;
  e.current === e.then && (r[e.value] = i),
    e.current === e.catch && (r[e.error] = i),
    e.block.p(r, n);
}
function vdt(e, t) {
  e.d(1), t.delete(e.key);
}
function h9e(e, t) {
  ot(e, 1, 1, () => {
    t.delete(e.key);
  });
}
function wdt(e, t) {
  e.f(), h9e(e, t);
}
function bdt(e, t, n, r, i, s, o, a, l, c, u, d) {
  let f = e.length,
    h = s.length,
    p = f;
  const g = {};
  for (; p--; ) g[e[p].key] = p;
  const b = [],
    v = new Map(),
    w = new Map(),
    x = [];
  for (p = h; p--; ) {
    const B = d(i, s, p),
      C = n(B);
    let I = o.get(C);
    I ? x.push(() => I.p(B, t)) : ((I = c(C, B)), I.c()),
      v.set(C, (b[p] = I)),
      C in g && w.set(C, Math.abs(p - g[C]));
  }
  const S = new Set(),
    R = new Set();
  function O(B) {
    Ke(B, 1), B.m(a, u), o.set(B.key, B), (u = B.first), h--;
  }
  for (; f && h; ) {
    const B = b[h - 1],
      C = e[f - 1],
      I = B.key,
      P = C.key;
    B === C
      ? ((u = B.first), f--, h--)
      : v.has(P)
      ? !o.has(I) || S.has(I)
        ? O(B)
        : R.has(P)
        ? f--
        : w.get(I) > w.get(P)
        ? (R.add(I), O(B))
        : (S.add(P), f--)
      : (l(C, o), f--);
  }
  for (; f--; ) {
    const B = e[f];
    v.has(B.key) || l(B, o);
  }
  for (; h; ) O(b[h - 1]);
  return Hd(x), b;
}
function p9e(e, t, n) {
  const r = e.$$.props[t];
  r !== void 0 && ((e.$$.bound[r] = n), n(e.$$.ctx[r]));
}
function pr(e) {
  e && e.c();
}
function or(e, t, n, r) {
  const { fragment: i, after_update: s } = e.$$;
  i && i.m(t, n),
    r ||
      Na(() => {
        const o = e.$$.on_mount.map(nee).filter(m0);
        e.$$.on_destroy ? e.$$.on_destroy.push(...o) : Hd(o),
          (e.$$.on_mount = []);
      }),
    s.forEach(Na);
}
function ar(e, t) {
  const n = e.$$;
  n.fragment !== null &&
    (f9e(n.after_update),
    Hd(n.on_destroy),
    n.fragment && n.fragment.d(t),
    (n.on_destroy = n.fragment = null),
    (n.ctx = []));
}
function m9e(e, t) {
  e.$$.dirty[0] === -1 && (sg.push(e), c9e(), e.$$.dirty.fill(0)),
    (e.$$.dirty[(t / 31) | 0] |= 1 << t % 31);
}
function lo(e, t, n, r, i, s, o, a = [-1]) {
  const l = Sb;
  $f(e);
  const c = (e.$$ = {
    fragment: null,
    ctx: [],
    props: s,
    update: rt,
    not_equal: i,
    bound: E$(),
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(t.context || (l ? l.$$.context : [])),
    callbacks: E$(),
    dirty: a,
    skip_bound: !1,
    root: t.target || l.$$.root,
  });
  o && o(c.root);
  let u = !1;
  if (
    ((c.ctx = n
      ? n(e, t.props || {}, (d, f, ...h) => {
          const p = h.length ? h[0] : f;
          return (
            c.ctx &&
              i(c.ctx[d], (c.ctx[d] = p)) &&
              (!c.skip_bound && c.bound[d] && c.bound[d](p), u && m9e(e, d)),
            f
          );
        })
      : []),
    c.update(),
    (u = !0),
    Hd(c.before_update),
    (c.fragment = r ? r(c.ctx) : !1),
    t.target)
  ) {
    if (t.hydrate) {
      const d = e9e(t.target);
      c.fragment && c.fragment.l(d), d.forEach(st);
    } else c.fragment && c.fragment.c();
    t.intro && Ke(e.$$.fragment),
      or(e, t.target, t.anchor, t.customElement),
      bO();
  }
  $f(l);
}
class co {
  $destroy() {
    ar(this, 1), (this.$destroy = rt);
  }
  $on(t, n) {
    if (!m0(n)) return rt;
    const r = this.$$.callbacks[t] || (this.$$.callbacks[t] = []);
    return (
      r.push(n),
      () => {
        const i = r.indexOf(n);
        i !== -1 && r.splice(i, 1);
      }
    );
  }
  $set(t) {
    this.$$set &&
      !YEe(t) &&
      ((this.$$.skip_bound = !0), this.$$set(t), (this.$$.skip_bound = !1));
  }
}
const EO = new xh(),
  AO = new xh(),
  du = new jx({ inProgress: !1, actionRequired: "" }),
  Fy = new jx(null),
  CO = Pn.select("wallets").pipe(Rd(1));
EO.pipe(rJ(CO), rO("1")).subscribe((e) => {
  e.forEach(({ label: t }) => {
    AO.next(t);
  }),
    oAe();
});
const T$ = new jx([]);
function xdt(e) {
  const t = T$.getValue();
  T$.next(t.filter((n) => n.hash !== e));
}
const M$ = F5e(() => {
    const e = new xh();
    return (
      lee(() => {
        e.next();
      }),
      e.asObservable().pipe(nO(1))
    );
  }),
  Ag = {
    default: {
      "--w3o-background-color": "unset",
      "--w3o-foreground-color": "unset",
      "--w3o-text-color": "unset",
      "--w3o-border-color": "unset",
      "--w3o-action-color": "unset",
      "--w3o-border-radius": "unset",
      "--w3o-font-family": "inherit",
    },
    light: {
      "--w3o-background-color": "#ffffff",
      "--w3o-foreground-color": "#EFF1FC",
      "--w3o-text-color": "#1a1d26",
      "--w3o-border-color": "#d0d4f7",
      "--w3o-action-color": "#6370E5",
      "--w3o-border-radius": "16px",
      "--w3o-font-family": "inherit",
    },
    dark: {
      "--w3o-background-color": "#1A1D26",
      "--w3o-foreground-color": "#242835",
      "--w3o-text-color": "#EFF1FC",
      "--w3o-border-color": "#33394B",
      "--w3o-action-color": "#929bed",
      "--w3o-border-radius": "16px",
      "--w3o-font-family": "inherit",
    },
  },
  g9e = (e) => (typeof e == "string" && e === "system" ? v9e() : y9e(e)),
  y9e = (e) => {
    if (typeof e == "string" && e in Ag) return Ag[e];
    if (typeof e == "object") return e;
  },
  Q2 = (e) => {
    Object.keys(e).forEach((t) => {
      document.documentElement.style.setProperty(t, e[t] || null);
    });
  },
  v9e = () => {
    const e = window.matchMedia("(prefers-color-scheme: dark)");
    e.matches ? Q2(Ag.dark) : Q2(Ag.light),
      UT(e, "change")
        .pipe(yb(EO))
        .subscribe((t) => {
          t.matches ? Q2(Ag.dark) : Q2(Ag.light);
        });
  },
  EC = fe.object().unknown(),
  w9e = fe.object({ namespace: dO.required(), id: uO.required() }),
  b9e = fe
    .any()
    .allow(
      fe.object({
        name: fe.string().required(),
        avatar: fe.string(),
        contentHash: fe.any().allow(fe.string(), null),
        getText: fe.function().arity(1).required(),
      }),
      null
    ),
  x9e = fe.any().allow(fe.object({ name: fe.string().required() }), null),
  _9e = fe.any().allow(fe.object({ eth: fe.number() }).unknown(), null),
  S9e = fe
    .any()
    .allow(
      fe.object({ balance: fe.string().required(), icon: fe.string() }),
      null
    ),
  E9e = fe.object({
    address: fe.string().required(),
    ens: b9e,
    uns: x9e,
    balance: _9e,
    secondaryTokens: S9e,
  }),
  A9e = fe
    .array()
    .items(bEe)
    .unique((e, t) => e.id === t.id)
    .error((e) =>
      e[0].code === "array.unique"
        ? new Error(
            `There is a duplicate Chain ID in your Onboard Chains array: ${e}`
          )
        : new Error(`${e}`)
    ),
  C9e = fe.array().items(E9e),
  cee = fe
    .object({
      label: fe.string(),
      icon: fe.string(),
      provider: EC,
      instance: EC,
      accounts: C9e,
      chains: fe.array().items(w9e),
      wagmiConnector: EC,
    })
    .required()
    .error(new Error("wallet must be defined")),
  k9e = fe.array().items(cee),
  uee = fe.object({
    name: fe.string().required(),
    url: fe.string().uri().required(),
  }),
  dee = fe.object({
    version: fe.string().required(),
    termsUrl: fe.string().uri(),
    privacyUrl: fe.string().uri(),
  }),
  T9e = fe.object({
    name: fe.string().required(),
    description: fe.string().required(),
    icon: fe.string(),
    logo: fe.string(),
    gettingStartedGuide: fe.string(),
    email: fe.string(),
    appUrl: fe.string(),
    explore: fe.string(),
    recommendedInjectedWallets: fe.array().items(uee),
    agreement: dee,
  }),
  M9e = fe.object({
    name: fe.string(),
    description: fe.string(),
    icon: fe.string(),
    logo: fe.string(),
    gettingStartedGuide: fe.string(),
    email: fe.string(),
    appUrl: fe.string(),
    explore: fe.string(),
    recommendedInjectedWallets: fe.array().items(uee),
    agreement: dee,
  });
fe.object({
  label: fe.string().required(),
  getInfo: fe.function().arity(1).required(),
  getInterface: fe.function().arity(1).required(),
});
const fee = fe.array().items(fe.function()).required(),
  I9e = fe.string(),
  kO = fe.string().valid("topRight", "bottomRight", "bottomLeft", "topLeft"),
  I$ = [70, 80, 90, 95, 99],
  O5 = fe.object({
    transactionHandler: fe.function().optional(),
    enabled: fe.boolean(),
    position: kO,
    replacement: fe.object({
      gasPriceProbability: fe.object({
        speedup: fe.number().valid(...I$),
        cancel: fe.number().valid(...I$),
      }),
    }),
  }),
  hee = fe.object({ desktop: O5, mobile: O5 }),
  N$ = fe.object({
    enabled: fe.boolean(),
    position: kO,
    minimal: fe.boolean(),
    containerElement: fe.string(),
    hideTransactionProtectionBtn: fe.boolean(),
    transactionProtectionInfoLink: fe.string(),
  }),
  N9e = fe.object({
    enabled: fe.boolean(),
    position: kO,
    expanded: fe.boolean(),
    minimal: fe.boolean(),
    hideTransactionProtectionBtn: fe.boolean(),
    transactionProtectionInfoLink: fe.string(),
    containerElement: fe.string(),
  }),
  pee = fe.object({
    showSidebar: fe.boolean(),
    disableClose: fe.boolean(),
    autoConnectLastWallet: fe.boolean(),
    autoConnectAllPreviousWallet: fe.boolean(),
    iDontHaveAWalletLink: fe.string(),
    wheresMyWalletLink: fe.string(),
    removeWhereIsMyWalletWarning: fe.boolean(),
    removeIDontHaveAWalletInfoLink: fe.boolean(),
    disableUDResolution: fe.boolean(),
  }),
  R9e = fe.object({ accountCenter: fe.string(), connectModal: fe.string() }),
  O9e = fe.object({
    "--w3o-background-color": fe.string(),
    "--w3o-font-family": fe.string(),
    "--w3o-foreground-color": fe.string(),
    "--w3o-text-color": fe.string(),
    "--w3o-border-color": fe.string(),
    "--w3o-action-color": fe.string(),
    "--w3o-border-radius": fe.string(),
  }),
  P9e = fe.string().valid("default", "dark", "light", "system"),
  mee = fe.alternatives().try(O9e, P9e),
  L9e = fe.object({
    wallets: fee,
    chains: A9e.required(),
    appMetadata: T9e,
    i18n: fe.object().unknown(),
    apiKey: fe.string(),
    accountCenter: fe.object({
      desktop: N$,
      mobile: N$,
      hideTransactionProtectionBtn: fe.boolean(),
      transactionProtectionInfoLink: fe.string(),
    }),
    notify: [hee, O5],
    gas: fe.object({
      get: fe.function().required(),
      stream: fe.function().required(),
    }),
    wagmi: fe.function(),
    connect: pee,
    containerElements: R9e,
    transactionPreview: fe.any(),
    theme: mee,
    disableFontDownload: fe.boolean(),
    unstoppableResolution: fe.function(),
  }),
  j9e = fe.object({
    autoSelect: fe
      .alternatives()
      .try(
        fe.object({
          label: fe.string().required(),
          disableModals: fe.boolean(),
        }),
        fe.string()
      ),
  }),
  D9e = fe.object({ label: fe.string().required() }).required(),
  B9e = fe.object({
    address: fe.string().required(),
    icon: fe.string().optional(),
  }),
  F9e = fe.object({
    chainId: uO.required(),
    chainNamespace: dO,
    wallet: fe.string(),
    rpcUrl: fe.string(),
    label: fe.string(),
    token: fe.string(),
    protectedRpcUrl: fe.string(),
    secondaryTokens: fe.array().max(5).items(B9e).optional(),
  }),
  U9e = fe.object({
    key: fe.string().required(),
    type: fe.string().allow("pending", "error", "success", "hint"),
    eventCode: fe.string(),
    message: fe.string().required(),
    id: fe.string().required(),
    autoDismiss: fe.number(),
    onClick: fe.function(),
    link: fe.string(),
  });
fe.object({
  sendTransaction: fe.function(),
  estimateGas: fe.function(),
  gasPrice: fe.function(),
  balance: fe.alternatives(fe.string(), fe.number()),
  txDetails: fe.object({
    value: fe.alternatives(fe.string(), fe.number()),
    to: fe.string(),
    from: fe.string(),
  }),
  txApproveReminderTimeout: fe.number(),
});
const $9e = fe.object({
  key: fe.string(),
  type: fe.string().allow("pending", "error", "success", "hint"),
  eventCode: fe.string(),
  message: fe.string(),
  id: fe.string(),
  autoDismiss: fe.number(),
  onClick: fe.function(),
  link: fe.string(),
});
fe.object({
  id: fe.string().required(),
  key: fe.string().required(),
  type: fe.string().allow("pending", "error", "success", "hint").required(),
  eventCode: fe.string().required(),
  message: fe.string().required(),
  autoDismiss: fe.number().required(),
  network: fe.string().required(),
  startTime: fe.number(),
  onClick: fe.function(),
  link: fe.string(),
});
function TO(e) {
  return Eo(cee, e);
}
function z9e(e) {
  return Eo(L9e, e);
}
function W9e(e) {
  return Eo(j9e, e);
}
function H9e(e) {
  return Eo(D9e, e);
}
function gee(e, t) {
  return Eo(
    fe
      .string()
      .required()
      .label(t || "value"),
    e
  );
}
function yee(e) {
  return Eo(F9e, e);
}
function V9e(e) {
  return Eo(N9e, e);
}
function G9e(e) {
  return Eo(pee, e);
}
function q9e(e) {
  return Eo(fee, e);
}
function K9e(e) {
  return Eo(I9e, e);
}
function vee(e) {
  return Eo(O5, e);
}
function Y9e(e) {
  return Eo(hee, e);
}
function Z9e(e) {
  return Eo(U9e, e);
}
function R$(e) {
  return Eo($9e, e);
}
function Q9e(e) {
  return Eo(k9e, e);
}
function X9e(e) {
  return Eo(mee, e);
}
function J9e(e) {
  return Eo(M9e, e);
}
function eAe(e) {
  const t = {
    type: FJ,
    payload: e.map((n) => {
      var { namespace: r = "evm", id: i, rpcUrl: s } = n,
        o = k5(n, ["namespace", "id", "rpcUrl"]);
      return Object.assign(Object.assign({}, o), {
        namespace: r,
        id: i.toLowerCase(),
        rpcUrl: s ? s.trim() : null,
      });
    }),
  };
  Ho(t);
}
function wee(e) {
  const { label: t, token: n, rpcUrl: r, id: i, namespace: s } = e,
    o = yee({ label: t, token: n, rpcUrl: r, chainId: i, chainNamespace: s });
  if (o) throw o;
  Ho({ type: UJ, payload: e });
}
function JT(e) {
  const t = TO(e);
  if (t) throw (console.error(t), t);
  Ho({ type: zJ, payload: e });
}
function Ew(e, t) {
  const n = TO(t);
  if (n) throw (console.error(n), n);
  const r = { type: WJ, payload: Object.assign({ id: e }, t) };
  Ho(r);
}
function tAe(e) {
  const t = gee(e, "wallet id");
  if (t) throw t;
  Ho({ type: HJ, payload: { id: e } });
}
function nAe(e, t) {
  const n = TO(e) || (t && gee(t, "address"));
  if (n) throw n;
  if (t) {
    const r = e.accounts.find((i) => i.address === t);
    r &&
      (e.accounts = [
        r,
        ...e.accounts.filter(({ address: i }) => i !== r.address),
      ]);
  }
  dAe(e), JT(e);
}
function X2(e, t, n) {
  const r = { type: VJ, payload: Object.assign({ id: e, address: t }, n) };
  Ho(r);
}
function bee(e) {
  const t = V9e(e);
  if (t) throw t;
  Ho({ type: GJ, payload: e });
}
function rAe(e) {
  const t = G9e(e);
  if (t) throw t;
  Ho({ type: qJ, payload: e });
}
function W4(e) {
  const t = vee(e);
  if (t) throw t;
  Ho({ type: ZJ, payload: e });
}
function AC(e) {
  const t = Z9e(e);
  if (t) throw t;
  Ho({ type: QJ, payload: e });
}
function iAe(e) {
  const t = R$(e);
  if (t) throw t;
  const n = `customNotification-${q8e()}`,
    r = Object.assign(Object.assign({}, e), { id: n, key: n });
  AC(r);
  const i = () => {
      r.id && sAe(r.id);
    },
    s = (o) => {
      const a = R$(e);
      if (a) throw a;
      const l = Object.assign(Object.assign({}, o), { id: r.id, key: r.key });
      return AC(l), { dismiss: i, update: s };
    };
  return AC(r), { dismiss: i, update: s };
}
function sAe(e) {
  if (typeof e != "string")
    throw new Error("Notification id must be of type string");
  Ho({ type: XJ, payload: e });
}
function oAe() {
  Ho({ type: $J });
}
function xee(e) {
  const t = q9e(e);
  if (t) throw t;
  const n = cAe(e),
    r = uAe(n);
  Ho({ type: KJ, payload: r });
}
function aAe(e) {
  const t = K9e(e);
  if (t) throw t;
  Ho({ type: YJ, payload: e });
}
function lAe(e) {
  const t = Q9e(e);
  if (t) throw t;
  Ho({ type: JJ, payload: e });
}
function cAe(e) {
  const { device: t } = Sa;
  return t
    ? e.reduce((n, r) => {
        const i = r({ device: t });
        return i && n.push(...(Array.isArray(i) ? i : [i])), n;
      }, [])
    : [];
}
function uAe(e) {
  return e.filter(
    (t, n) => t && e.findIndex((r) => r && r.label === t.label) === n
  );
}
function _ee(e) {
  const t = X9e(e);
  if (t) throw t;
  const n = g9e(e);
  n && Q2(n);
}
function See(e) {
  const t = J9e(e);
  if (t) throw t;
  Ho({ type: eee, payload: e });
}
function Eee(e) {
  Ho({ type: tee, payload: e });
}
function dAe(e) {
  const { wagmi: t } = Sa;
  if (t)
    try {
      const { label: n } = e,
        { wagmiConnect: r, getWagmiConnector: i } = t,
        s = Pn.get().wagmiConfig,
        o = i(n);
      r(s, { connector: o }).then(() => {
        Ew(n, { wagmiConnector: o });
      });
    } catch (n) {
      console.error(
        `Error updating Wagmi connector on primary wallet switch ${n}`
      );
    }
}
async function fAe(e) {
  if (e) {
    const i = W9e(e);
    if (i) throw i;
  }
  const { chains: t } = Pn.get();
  if (!t.length)
    throw new Error(
      "At least one chain must be set before attempting to connect a wallet"
    );
  let { autoSelect: n } = e || {};
  n || (n = { label: "", disableModals: !1 }),
    n && (typeof n == "string" || n.label) && (await WEe(50)),
    Pn.get().walletModules.length || xee(Sa.initialWalletInit),
    du.next({
      autoSelect: typeof n == "string" ? { label: n, disableModals: !1 } : n,
      inProgress: !0,
    });
  const r = du.pipe(
    Oy(({ inProgress: i, actionRequired: s }) => i === !1 && !s),
    rJ(CO),
    rO(1)
  );
  return gb(r);
}
async function MO(e) {
  const t = H9e(e);
  if (t) throw t;
  const { label: n } = e,
    { wagmi: r } = Sa;
  if (r) {
    const s = await r.wagmiDisconnectWallet(n);
    s && Eee(s);
  }
  AO.next(n), tAe(n);
  const i = j8(xd.LAST_CONNECTED_WALLET);
  if (i)
    try {
      const s = JSON.parse(i);
      Array.isArray(s) &&
        s.indexOf(n) >= 0 &&
        D8(xd.LAST_CONNECTED_WALLET, JSON.stringify(s.filter((o) => o !== n))),
        typeof s == "string" && s === n && BJ(xd.LAST_CONNECTED_WALLET);
    } catch (s) {
      console.error(
        `There was an error disconnecting the last connected wallet from localStorage - Error: ${s}`
      );
    }
  return Pn.get().wallets;
}
async function hAe(e) {
  const { wallets: t, chains: n } = Pn.get(),
    r = await Promise.all(
      t.map(async (i) => {
        const s = n.find(({ id: a }) => a === i.chains[0].id);
        if (!s) return;
        const o = await Promise.all(
          i.accounts.map(async (a) => {
            const l = await P5(a.address, s);
            if (
              !e ||
              e.some((c) => c.toLowerCase() === a.address.toLowerCase())
            ) {
              const c = await L5(a.address, s);
              return Object.assign(Object.assign({}, a), {
                balance: c,
                secondaryTokens: l,
              });
            }
            return Object.assign(Object.assign({}, a), { secondaryTokens: l });
          })
        );
        return Object.assign(Object.assign({}, i), { accounts: o });
      })
    );
  lAe(r);
}
const P5 = async (e, t) => {
    if (!t) return [];
    const n = t.rpcUrl;
    return !t.secondaryTokens || !t.secondaryTokens.length || !n
      ? []
      : await Promise.all(
          t.secondaryTokens.map(async (i) => {
            try {
              const { createPublicClient: s, http: o } = await At(async () => {
                  const { createPublicClient: p, http: g } = await import(
                    "./index-DcXKPjle.js"
                  );
                  return { createPublicClient: p, http: g };
                }, __vite__mapDeps([2, 1])),
                a = await vEe(t),
                l = s({
                  chain: a,
                  transport: o(
                    t.providerConnectionInfo && t.providerConnectionInfo.url
                      ? t.providerConnectionInfo.url
                      : n
                  ),
                }),
                c = {
                  abi: [
                    {
                      inputs: [{ name: "owner", type: "address" }],
                      name: "balanceOf",
                      outputs: [{ name: "", type: "uint256" }],
                      stateMutability: "view",
                      type: "function",
                    },
                    {
                      inputs: [],
                      name: "symbol",
                      outputs: [{ name: "", type: "string" }],
                      stateMutability: "view",
                      type: "function",
                    },
                  ],
                  address: i.address,
                },
                u =
                  l.readContract(
                    Object.assign(Object.assign({}, c), {
                      functionName: "balanceOf",
                      args: [e],
                    })
                  ) || "",
                d =
                  l.readContract(
                    Object.assign(Object.assign({}, c), {
                      functionName: "symbol",
                      args: [],
                    })
                  ) || "",
                [f, h] = await Promise.all([u, d]);
              return { name: h, balance: yEe(f.toString()), icon: i.icon };
            } catch (s) {
              console.error(`There was an error fetching balance and/or symbol 
          for token contract: ${i.address} - ${s}`);
            }
          })
        );
  },
  CC = {};
async function pAe(e) {
  if (!e) return null;
  if (!CC[e.rpcUrl]) {
    const t = await $Ee(e.id);
    if (!t) return null;
    const { createPublicClient: n, http: r } = await At(async () => {
        const { createPublicClient: s, http: o } = await import(
          "./index-DcXKPjle.js"
        );
        return { createPublicClient: s, http: o };
      }, __vite__mapDeps([2, 1])),
      i = n({ chain: t, transport: r() });
    CC[e.rpcUrl] = i;
  }
  return CC[e.rpcUrl];
}
function Aee(e) {
  const t = { method: "eth_requestAccounts" };
  return e.request(t);
}
function _dt(e) {
  const t = { method: "eth_selectAccounts" };
  return e.request(t);
}
function Cee(e) {
  return e.request({ method: "eth_chainId" });
}
function kee(e) {
  const { provider: t, disconnected$: n } = e;
  return tJ(
    (s) => {
      t.on("accountsChanged", s);
    },
    (s) => {
      t.removeListener("accountsChanged", s);
    }
  ).pipe(yb(n));
}
function mAe(e) {
  const { provider: t, disconnected$: n } = e;
  return tJ(
    (s) => {
      t.on("chainChanged", s);
    },
    (s) => {
      t.removeListener("chainChanged", s);
    }
  ).pipe(yb(n));
}
function gAe(e, t) {
  const n = AO.pipe(
      Oy((s) => s === t),
      nO(1)
    ),
    r = kee({ provider: e, disconnected$: n }).pipe($T());
  r.subscribe(async ([s]) => {
    try {
      await vAe(t);
    } catch (d) {
      console.warn(
        "Web3Onboard: Error whilst trying to sync connected accounts:",
        d
      );
    }
    if (!s) {
      MO({ label: t });
      return;
    }
    const { wallets: o } = Pn.get(),
      a = o.find((d) => d.label === t),
      l = a ? a.accounts : [],
      [[c], u] = _Ee(l, (d) => d.address === s);
    Ew(t, {
      accounts: [
        c || { address: s, ens: null, uns: null, balance: null },
        ...u,
      ],
    });
  }),
    r
      .pipe(
        XU(async ([s]) => {
          if (!s) return;
          const { wallets: o, chains: a } = Pn.get(),
            l = o.find((x) => x.label === t);
          if (!l) return;
          const { chains: c, accounts: u } = l,
            [d] = c,
            f = a.find(({ namespace: x, id: S }) => x === "evm" && S === d.id);
          if (!f) return;
          const h = L5(s, f),
            p = P5(s, f),
            g = u.find((x) => x.address === s),
            b = a.find(({ id: x }) => x === T5(d.id)),
            v =
              g && g.ens
                ? Promise.resolve(g.ens)
                : b
                ? eM(s, b)
                : Promise.resolve(null),
            w =
              g && g.uns
                ? Promise.resolve(g.uns)
                : b
                ? tM(s, b)
                : Promise.resolve(null);
          return Promise.all([Promise.resolve(s), h, v, w, p]);
        })
      )
      .subscribe((s) => {
        if (!s) return;
        const [o, a, l, c, u] = s;
        X2(t, o, { balance: a, ens: l, uns: c, secondaryTokens: u });
      });
  const i = mAe({ provider: e, disconnected$: n }).pipe($T());
  i.subscribe(async (s) => {
    const { wallets: o } = Pn.get(),
      a = o.find((f) => f.label === t);
    if (!a) return;
    const { chains: l, accounts: c } = a,
      [u] = l;
    if ((E5(s) || (s = g$(s)), s === u.id)) return;
    const d = c.map(({ address: f }) => ({
      address: f,
      ens: null,
      uns: null,
      balance: null,
    }));
    Ew(t, { chains: [{ namespace: "evm", id: s }], accounts: d });
  }),
    i
      .pipe(
        XU(async (s) => {
          const { wallets: o, chains: a } = Pn.get(),
            l = o.find((d) => d.label === t),
            c = (l == null ? void 0 : l.accounts) || [];
          E5(s) || (s = g$(s));
          const u = a.find(({ namespace: d, id: f }) => d === "evm" && f === s);
          return u
            ? Promise.all(
                c.map(async ({ address: d }) => {
                  const f = L5(d, u),
                    h = P5(d, u),
                    p = a.find(({ id: R }) => R === T5(s)),
                    g = p ? eM(d, p) : Promise.resolve(null),
                    b = p ? tM(d, p) : Promise.resolve(null),
                    [v, w, x, S] = await Promise.all([f, g, b, h]);
                  return {
                    address: d,
                    balance: v,
                    ens: w,
                    uns: x,
                    secondaryTokens: S,
                  };
                })
              )
            : Promise.resolve(null);
        })
      )
      .subscribe((s) => {
        s && Ew(t, { accounts: s });
      }),
    n.subscribe(() => {
      e.disconnect && e.disconnect();
    });
}
async function eM(e, t) {
  if (!t) return null;
  const n = await pAe(t);
  if (!n) return null;
  try {
    const r = await n.getEnsName({ address: e });
    let i = null;
    if (r) {
      const { labelhash: s, normalize: o } = await At(async () => {
          const { labelhash: f, normalize: h } = await import(
            "./index-021f6a62-BcF70HI7.js"
          ).then((p) => p.y);
          return { labelhash: f, normalize: h };
        }, []).then(function (f) {
          return f.i;
        }),
        a = o(r),
        l = await n.getEnsResolver({ name: a }),
        c = await n.getEnsAvatar({ name: a }),
        u = s(a);
      i = {
        name: r,
        avatar: c,
        contentHash: u,
        ensResolver: l,
        getText: async (f) => await n.getEnsText({ name: r, key: f }),
      };
    }
    return i;
  } catch (r) {
    return console.error(r), null;
  }
}
async function tM(e, t) {
  const { unstoppableResolution: n } = Sa;
  if (!n || !PJ() || !t) return null;
  try {
    return await n(e);
  } catch (r) {
    return console.error(r), null;
  }
}
async function L5(e, t) {
  if (!t) return null;
  const { wallets: n } = Pn.get();
  try {
    const r = n.find((o) => !!o.provider);
    if (!r) return null;
    const s = await r.provider.request({
      method: "eth_getBalance",
      params: [e, "latest"],
    });
    return s ? { [t.token || "eth"]: gEe(s) } : null;
  } catch (r) {
    return console.error(r), null;
  }
}
function $8(e, t) {
  return e.request({
    method: "wallet_switchEthereumChain",
    params: [{ chainId: t }],
  });
}
function Tee(e, t) {
  return e.request({
    method: "wallet_addEthereumChain",
    params: [
      {
        chainId: t.id,
        chainName: t.label,
        nativeCurrency: { name: t.label, symbol: t.token, decimals: 18 },
        rpcUrls: [t.publicRpcUrl || t.rpcUrl],
        blockExplorerUrls: t.blockExplorerUrl ? [t.blockExplorerUrl] : null,
      },
    ],
  });
}
function Sdt(e, t, n) {
  return e.request({
    method: "wallet_addEthereumChain",
    params: [
      {
        chainId: t.id,
        chainName: t.label,
        nativeCurrency: { name: t.label, symbol: t.token, decimals: 18 },
        rpcUrls: [n],
        blockExplorerUrls: t.blockExplorerUrl ? [t.blockExplorerUrl] : void 0,
      },
    ],
  });
}
async function yAe(e) {
  try {
    const t = await e.request({ method: "wallet_getPermissions" });
    return Array.isArray(t) ? t : [];
  } catch {
    return [];
  }
}
async function vAe(e) {
  const t = Pn.get().wallets.find((i) => i.label === e);
  if (!t) return;
  const r = (await yAe(t.provider)).find(
    ({ parentCapability: i }) => i === "eth_accounts"
  );
  if (r) {
    const { value: i } = r.caveats.find(
      ({ type: s }) => s === "restrictReturnedAccounts"
    ) || { value: null };
    if (i) {
      const s = t.accounts.filter(({ address: o }) => i.includes(o));
      Ew(t.label, Object.assign(Object.assign({}, t), { accounts: s }));
    }
  }
}
const wAe = async (e, t) => {
    try {
      const { id: n } = t;
      return await Tee(e, t), await $8(e, n), n;
    } catch {
      return;
    }
  },
  bAe = () => ({
    addOrSwitchChain: wAe,
    getChainId: Cee,
    requestAccounts: Aee,
    switchChain: $8,
  });
async function xAe(e) {
  const t = yee(e);
  if (t) throw t;
  const { wallets: n, chains: r } = Pn.get(),
    {
      chainId: i,
      chainNamespace: s = "evm",
      wallet: o,
      rpcUrl: a,
      label: l,
      token: c,
    } = e,
    u = DJ(i),
    d = r.find(
      ({ namespace: p, id: g }) =>
        p === s && g.toLowerCase() === u.toLowerCase()
    );
  if (!d)
    throw new Error(
      `Chain with chainId: ${i} and chainNamespace: ${s} has not been set and must be added when Onboard is initialized.`
    );
  const f = o ? n.find(({ label: p }) => p === o) : n[0];
  if (!f)
    throw new Error(
      o
        ? `Wallet with label ${o} is not connected`
        : "A wallet must be connected before a chain can be set"
    );
  const [h] = f.chains;
  if (h.namespace === s && h.id === u) return !0;
  try {
    return await $8(f.provider, u), !0;
  } catch (p) {
    const { code: g } = p,
      b = Fy.pipe(
        Oy((v) => v === null),
        Dx(() => !1)
      );
    if (g === Fp.CHAIN_NOT_ADDED || g === Fp.UNRECOGNIZED_CHAIN_ID)
      return (
        (a || l || c) &&
          (a && (d.rpcUrl = a), l && (d.label = l), c && (d.token = c), wee(d)),
        _Ae(f, d, b, u)
      );
    if (g === Fp.UNSUPPORTED_METHOD) return Fy.next({ chain: d }), gb(b);
  }
  return !1;
}
const _Ae = async (e, t, n, r) => {
  try {
    return await Tee(e.provider, t), await $8(e.provider, r), !0;
  } catch (i) {
    const { code: s } = i;
    return s === Fp.ACCOUNT_ACCESS_REJECTED
      ? !1
      : (Fy.next({ chain: t }), gb(n));
  }
};
var SAe = {
    selectingWallet: {
      header: "Available Wallets",
      sidebar: {
        heading: "",
        subheading: "Connect your wallet",
        paragraph:
          "Connecting your wallet is like “logging in” to Web3. Select your wallet from the options to get started.",
        IDontHaveAWallet: "I don't have a wallet",
      },
      recommendedWalletsPart1: "{app} only supports",
      recommendedWalletsPart2:
        "on this platform. Please use or install one of the supported wallets to continue",
      installWallet:
        "You do not have any wallets installed that {app} supports, please use a supported wallet",
      agreement: {
        agree: "I agree to the",
        terms: "Terms & Conditions",
        and: "and",
        privacy: "Privacy Policy",
      },
      whyDontISeeMyWallet: "Why don't I see my wallet?",
      learnMore: "Click here to learn more",
    },
    connectingWallet: {
      header:
        "{connectionRejected, select, false {Connecting to {wallet}...} other {Connection Rejected}}",
      sidebar: {
        subheading: "Approve Connection",
        paragraph:
          "Please approve the connection in your wallet and authorize access to continue.",
      },
      mainText: "Connecting...",
      paragraph:
        "Make sure to select all accounts that you want to grant access to.",
      previousConnection:
        "{wallet} already has a pending connection request, please open the {wallet} app to login and connect.",
      rejectedText: "Connection Rejected!",
      rejectedCTA: "Click here to try again",
      primaryButton: "Back to wallets",
    },
    connectedWallet: {
      header: "Connection Successful",
      sidebar: {
        subheading: "Connection Successful!",
        paragraph: "Your wallet is now connected to {app}",
      },
      mainText: "Connected",
    },
  },
  EAe = {
    actionRequired: {
      heading: "Action required in {wallet}",
      paragraph: "Please switch the active account in your wallet.",
      linkText: "Learn more.",
      buttonText: "Okay",
    },
    switchChain: {
      heading: "Switch Chain",
      paragraph1:
        "{app} requires that you switch your wallet to the {nextNetworkName} network to continue.",
      paragraph2:
        "*Some wallets may not support changing networks. If you can not change networks in your wallet you may consider switching to a different wallet.",
    },
    confirmDisconnectAll: {
      heading: "Disconnect all Wallets",
      description:
        "Are you sure that you would like to disconnect all your wallets?",
      confirm: "Confirm",
      cancel: "Cancel",
    },
    confirmTransactionProtection: {
      heading: "Enable Transaction Protection",
      description:
        "Protect RPC endpoints hide your transaction from front-running and sandwich bots.",
      link: "Learn more",
      enable: "Enable",
      dismiss: "Dismiss",
    },
  },
  AAe = {
    connectAnotherWallet: "Connect another Wallet",
    disconnectAllWallets: "Disconnect all Wallets",
    currentNetwork: "Current Network",
    enableTransactionProtection: "Enable Transaction Protection",
    appInfo: "App Info",
    learnMore: "Learn More",
    gettingStartedGuide: "Getting Started Guide",
    smartContracts: "Smart Contract(s)",
    explore: "Explore",
    poweredBy: "powered by",
    addAccount: "Add Account",
    setPrimaryAccount: "Set Primary Account",
    disconnectWallet: "Disconnect Wallet",
    copyAddress: "Copy Wallet address",
  },
  CAe = {
    transaction: {
      txRequest: "Your transaction is waiting for you to confirm",
      nsfFail: "You have insufficient funds for this transaction",
      txUnderpriced:
        "The gas price for your transaction is too low, try a higher gas price",
      txRepeat: "This could be a repeat transaction",
      txAwaitingApproval:
        "You have a previous transaction waiting for you to confirm",
      txConfirmReminder: "Please confirm your transaction to continue",
      txSendFail: "You rejected the transaction",
      txSent: "Your transaction has been sent to the network",
      txStallPending:
        "Your transaction has stalled before it was sent, please try again",
      txStuck: "Your transaction is stuck due to a nonce gap",
      txPool: "Your transaction has started",
      txStallConfirmed:
        "Your transaction has stalled and hasn't been confirmed",
      txSpeedUp: "Your transaction has been sped up",
      txCancel: "Your transaction is being canceled",
      txFailed: "Your transaction has failed",
      txConfirmed: "Your transaction has succeeded",
      txError: "Oops something went wrong, please try again",
      txReplaceError:
        "There was an error replacing your transaction, please try again",
    },
    watched: {
      txPool:
        "Your account is {verb} {formattedValue} {asset} {preposition} {counterpartyShortened}",
      txSpeedUp:
        "Transaction for {formattedValue} {asset} {preposition} {counterpartyShortened} has been sped up",
      txCancel:
        "Transaction for {formattedValue} {asset} {preposition} {counterpartyShortened} has been canceled",
      txConfirmed:
        "Your account successfully {verb} {formattedValue} {asset} {preposition} {counterpartyShortened}",
      txFailed:
        "Your account failed to {verb} {formattedValue} {asset} {preposition} {counterpartyShortened}",
      txStuck: "Your transaction is stuck due to a nonce gap",
    },
    time: { minutes: "min", seconds: "sec" },
  },
  sr = { connect: SAe, modals: EAe, accountCenter: AAe, notify: CAe };
function kAe(e) {
  if (e) {
    const { en: t } = e,
      n = EEe(sr, t || {});
    F4("en", n),
      Object.keys(e)
        .filter((i) => i !== "en")
        .forEach((i) => {
          const s = e[i];
          s && F4(i, s);
        });
  } else F4("en", sr);
  E8e({ fallbackLocale: "en", initialLocale: O8e() });
}
var TAe = `
  <svg width="100%" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M19 6.41L17.59 5L12 10.59L6.41 5L5 6.41L10.59 12L5 17.59L6.41 19L12 13.41L17.59 19L19 17.59L13.41 12L19 6.41Z" fill="currentColor"/>
  </svg>
`;
function MAe(e) {
  ao(
    e,
    "svelte-1ubf722",
    ".close-button.svelte-1ubf722.svelte-1ubf722{position:relative;overflow:hidden;display:flex;align-items:center;justify-content:center;height:2rem;width:2rem;border-radius:2rem;cursor:pointer;color:var(--onboard-close-button-color, inherit)}.close-button.svelte-1ubf722.svelte-1ubf722:hover::before{opacity:0.2}.close-button.svelte-1ubf722:hover .svg-box.svelte-1ubf722{opacity:1}.close-button.svelte-1ubf722.svelte-1ubf722::before{content:'';position:absolute;height:inherit;width:inherit;opacity:0.1;background:currentColor;transition:300ms ease-in-out opacity}.svg-box.svelte-1ubf722.svelte-1ubf722{position:absolute;height:1.5rem;width:1.5rem;opacity:0.6;transition:300ms ease-in-out opacity}"
  );
}
function IAe(e) {
  let t, n;
  return {
    c() {
      (t = We("div")),
        (n = We("div")),
        Se(n, "class", "svg-box svelte-1ubf722"),
        Se(t, "class", "close-button svelte-1ubf722");
    },
    m(r, i) {
      at(r, t, i), Te(t, n), (n.innerHTML = TAe);
    },
    p: rt,
    i: rt,
    o: rt,
    d(r) {
      r && st(t);
    },
  };
}
let Mee = class extends co {
  constructor(t) {
    super(), lo(this, t, null, IAe, oo, {}, MAe);
  }
};
function Iee(e) {
  const t = e - 1;
  return t * t * t + 1;
}
function Adt(e) {
  return Math.pow(e - 1, 3) * (1 - e) + 1;
}
function j5(e, { delay: t = 0, duration: n = 400, easing: r = Ux } = {}) {
  const i = +getComputedStyle(e).opacity;
  return { delay: t, duration: n, easing: r, css: (s) => `opacity: ${s * i}` };
}
function Cdt(
  e,
  {
    delay: t = 0,
    duration: n = 400,
    easing: r = Iee,
    x: i = 0,
    y: s = 0,
    opacity: o = 0,
  } = {}
) {
  const a = getComputedStyle(e),
    l = +a.opacity,
    c = a.transform === "none" ? "" : a.transform,
    u = l * (1 - o),
    [d, f] = C$(i),
    [h, p] = C$(s);
  return {
    delay: t,
    duration: n,
    easing: r,
    css: (g, b) => `
			transform: ${c} translate(${(1 - g) * d}${f}, ${(1 - g) * h}${p});
			opacity: ${l - u * b}`,
  };
}
function NAe(
  e,
  { delay: t = 0, duration: n = 400, easing: r = Iee, axis: i = "y" } = {}
) {
  const s = getComputedStyle(e),
    o = +s.opacity,
    a = i === "y" ? "height" : "width",
    l = parseFloat(s[a]),
    c = i === "y" ? ["top", "bottom"] : ["left", "right"],
    u = c.map((v) => `${v[0].toUpperCase()}${v.slice(1)}`),
    d = parseFloat(s[`padding${u[0]}`]),
    f = parseFloat(s[`padding${u[1]}`]),
    h = parseFloat(s[`margin${u[0]}`]),
    p = parseFloat(s[`margin${u[1]}`]),
    g = parseFloat(s[`border${u[0]}Width`]),
    b = parseFloat(s[`border${u[1]}Width`]);
  return {
    delay: t,
    duration: n,
    easing: r,
    css: (v) =>
      `overflow: hidden;opacity: ${Math.min(v * 20, 1) * o};${a}: ${
        v * l
      }px;padding-${c[0]}: ${v * d}px;padding-${c[1]}: ${v * f}px;margin-${
        c[0]
      }: ${v * h}px;margin-${c[1]}: ${v * p}px;border-${c[0]}-width: ${
        v * g
      }px;border-${c[1]}-width: ${v * b}px;`,
  };
}
function RAe(e) {
  ao(
    e,
    "svelte-7ee2g7",
    `section.svelte-7ee2g7{top:0;left:0;pointer-events:none;z-index:var(--onboard-modal-z-index, var(--modal-z-index))}.background.svelte-7ee2g7{background:var(--onboard-modal-backdrop, var(--modal-backdrop));pointer-events:all}.full-screen-background.svelte-7ee2g7{width:100vw;height:100vh;height:100dvh}.max-height.svelte-7ee2g7{max-height:calc(100vh - 2rem)}.modal-position.svelte-7ee2g7{top:var(--onboard-modal-top, var(--modal-top));bottom:var(--onboard-modal-bottom, var(--modal-bottom));left:var(--onboard-modal-left, var(--modal-left));right:var(--onboard-modal-right, var(--modal-right))}.modal-overflow.svelte-7ee2g7{overflow:hidden}.modal-styling.svelte-7ee2g7{--border-radius:var(
      --onboard-modal-border-radius,
      var(--w3o-border-radius, 1rem)
    );border-radius:var(--border-radius) var(--border-radius) 0 0;box-shadow:var(--onboard-modal-box-shadow, var(--box-shadow-0));max-width:100vw}.modal.svelte-7ee2g7{overflow-y:auto;background:var(--onboard-modal-background, white);color:var(--onboard-modal-color, initial)}.width-100.svelte-7ee2g7{width:100%}.modal-container-mobile.svelte-7ee2g7{bottom:0}@media all and (min-width: 768px){.modal-styling.svelte-7ee2g7{border-radius:var(--border-radius)}.modal-container-mobile.svelte-7ee2g7{bottom:unset;margin:1rem}.width-100.svelte-7ee2g7{width:unset}}`
  );
}
function OAe(e) {
  let t, n, r, i, s, o, a, l, c, u;
  const d = e[3].default,
    f = hO(d, e, e[2], null);
  return {
    c() {
      (t = We("section")),
        (n = We("div")),
        (r = We("div")),
        (i = We("div")),
        (s = We("div")),
        (o = We("div")),
        f && f.c(),
        Se(o, "class", "modal relative svelte-7ee2g7"),
        Se(
          s,
          "class",
          "modal-overflow modal-styling relative flex justify-center svelte-7ee2g7"
        ),
        Se(s, "style", `${e[1] ? "max-width: 100%;" : ""}`),
        Se(i, "class", "flex relative max-height svelte-7ee2g7"),
        Ft(i, "width-100", e[1]),
        Se(
          r,
          "class",
          "modal-container-mobile modal-position flex svelte-7ee2g7"
        ),
        Ft(r, "absolute", !e[1]),
        Ft(r, "width-100", e[1]),
        Se(
          n,
          "class",
          "background flex items-center justify-center relative svelte-7ee2g7"
        ),
        Ft(n, "full-screen-background", !e[1]),
        Se(t, "class", "svelte-7ee2g7"),
        Ft(t, "fixed", !e[1]);
    },
    m(h, p) {
      at(h, t, p),
        Te(t, n),
        Te(n, r),
        Te(r, i),
        Te(i, s),
        Te(s, o),
        f && f.m(o, null),
        (l = !0),
        c ||
          ((u = [
            ll(i, "click", JEe(e[4])),
            ll(n, "click", function () {
              m0(e[0]) && e[0].apply(this, arguments);
            }),
          ]),
          (c = !0));
    },
    p(h, [p]) {
      (e = h),
        f &&
          f.p &&
          (!l || p & 4) &&
          mO(f, d, e, e[2], l ? pO(d, e[2], p, null) : gO(e[2]), null);
    },
    i(h) {
      l ||
        (Ke(f, h),
        Na(() => {
          l && (a || (a = k$(t, j5, {}, !0)), a.run(1));
        }),
        (l = !0));
    },
    o(h) {
      ot(f, h), a || (a = k$(t, j5, {}, !1)), a.run(0), (l = !1);
    },
    d(h) {
      h && st(t), f && f.d(h), h && a && a.end(), (c = !1), Hd(u);
    },
  };
}
function PAe(e, t, n) {
  let { $$slots: r = {}, $$scope: i } = t;
  const s = !!Sa.containerElements.connectModal,
    o = document.documentElement;
  o9e(() => {
    s || ((o.style.position = "sticky"), (o.style.overflow = "hidden"));
  }),
    lee(() => {
      s || ((o.style.position = ""), o.style.removeProperty("overflow"));
    });
  let { close: a } = t;
  function l(c) {
    a9e.call(this, e, c);
  }
  return (
    (e.$$set = (c) => {
      "close" in c && n(0, (a = c.close)),
        "$$scope" in c && n(2, (i = c.$$scope));
    }),
    [a, s, i, r, l]
  );
}
let IO = class extends co {
  constructor(t) {
    super(), lo(this, t, PAe, OAe, oo, { close: 0 }, RAe);
  }
};
function LAe(e) {
  ao(
    e,
    "svelte-tz7ru1",
    ".container.svelte-tz7ru1{padding:var(--onboard-spacing-4, var(--spacing-4));font-size:var(--onboard-font-size-6, var(--font-size-6));line-height:24px}input.svelte-tz7ru1{height:1rem;width:1rem;margin-right:0.5rem}"
  );
}
function jAe(e) {
  let t,
    n,
    r,
    i,
    s,
    o = e[1]("connect.selectingWallet.agreement.agree") + "",
    a,
    l,
    c = " ",
    u,
    d,
    f,
    h,
    p,
    g = e[3] && DAe(e),
    b = e[4] && BAe(e);
  return {
    c() {
      (t = We("div")),
        (n = We("label")),
        (r = We("input")),
        (i = qt()),
        (s = We("span")),
        (a = hr(o)),
        (l = qt()),
        (u = hr(c)),
        (d = qt()),
        g && g.c(),
        (f = qt()),
        b && b.c(),
        Se(r, "class", " svelte-tz7ru1"),
        Se(r, "type", "checkbox"),
        Se(n, "class", "flex"),
        Se(t, "class", "container flex items-center svelte-tz7ru1");
    },
    m(v, w) {
      at(v, t, w),
        Te(t, n),
        Te(n, r),
        (r.checked = e[0]),
        Te(n, i),
        Te(n, s),
        Te(s, a),
        Te(s, l),
        Te(s, u),
        Te(s, d),
        g && g.m(s, null),
        Te(s, f),
        b && b.m(s, null),
        h || ((p = ll(r, "change", e[6])), (h = !0));
    },
    p(v, w) {
      w & 1 && (r.checked = v[0]),
        w & 2 &&
          o !== (o = v[1]("connect.selectingWallet.agreement.agree") + "") &&
          zr(a, o),
        v[3] && g.p(v, w),
        v[4] && b.p(v, w);
    },
    d(v) {
      v && st(t), g && g.d(), b && b.d(), (h = !1), p();
    },
  };
}
function DAe(e) {
  let t,
    n = e[1]("connect.selectingWallet.agreement.terms") + "",
    r,
    i = e[4] ? " " + e[1]("connect.selectingWallet.agreement.and") + " " : ".",
    s;
  return {
    c() {
      (t = We("a")),
        (r = hr(n)),
        (s = hr(i)),
        Se(t, "href", e[3]),
        Se(t, "target", "_blank");
    },
    m(o, a) {
      at(o, t, a), Te(t, r), at(o, s, a);
    },
    p(o, a) {
      a & 2 &&
        n !== (n = o[1]("connect.selectingWallet.agreement.terms") + "") &&
        zr(r, n),
        a & 2 &&
          i !==
            (i = o[4]
              ? " " + o[1]("connect.selectingWallet.agreement.and") + " "
              : ".") &&
          zr(s, i);
    },
    d(o) {
      o && st(t), o && st(s);
    },
  };
}
function BAe(e) {
  let t,
    n = e[1]("connect.selectingWallet.agreement.privacy") + "",
    r,
    i;
  return {
    c() {
      (t = We("a")),
        (r = hr(n)),
        (i = hr(".")),
        Se(t, "href", e[4]),
        Se(t, "target", "_blank");
    },
    m(s, o) {
      at(s, t, o), Te(t, r), at(s, i, o);
    },
    p(s, o) {
      o & 2 &&
        n !== (n = s[1]("connect.selectingWallet.agreement.privacy") + "") &&
        zr(r, n);
    },
    d(s) {
      s && st(t), s && st(i);
    },
  };
}
function FAe(e) {
  let t,
    n = e[5] && jAe(e);
  return {
    c() {
      n && n.c(), (t = xi());
    },
    m(r, i) {
      n && n.m(r, i), at(r, t, i);
    },
    p(r, [i]) {
      r[5] && n.p(r, i);
    },
    i: rt,
    o: rt,
    d(r) {
      n && n.d(r), r && st(t);
    },
  };
}
function UAe(e, t, n) {
  let r, i;
  is(e, _h, (b) => n(1, (i = b)));
  let { agreed: s } = t;
  const {
      terms: o,
      privacy: a,
      version: l,
    } = JSON.parse(j8(xd.TERMS_AGREEMENT) || "{}"),
    c = { termsUrl: "", privacyUrl: "", version: "" },
    u = Pn.select("appMetadata").pipe(bd(Pn.get().appMetadata), Rd(1));
  is(e, u, (b) => n(7, (r = b)));
  const { termsUrl: d, privacyUrl: f, version: h } = (r && r.agreement) || c,
    p = !!((d && !o) || (f && !a) || (h && h !== l));
  s = !p;
  function g() {
    (s = this.checked), n(0, s);
  }
  return (
    (e.$$set = (b) => {
      "agreed" in b && n(0, (s = b.agreed));
    }),
    (e.$$.update = () => {
      e.$$.dirty & 1 &&
        (s
          ? D8(
              xd.TERMS_AGREEMENT,
              JSON.stringify({ version: h, terms: !!d, privacy: !!f })
            )
          : s === !1 && BJ(xd.TERMS_AGREEMENT));
    }),
    [s, i, u, d, f, p, g]
  );
}
class $Ae extends co {
  constructor(t) {
    super(), lo(this, t, UAe, FAe, oo, { agreed: 0 }, LAe);
  }
}
function zAe(e) {
  ao(
    e,
    "svelte-2btye1",
    ".icon.svelte-2btye1{color:var(--onboard-white, var(--white));border-radius:50px;bottom:-0.25rem;right:-0.25rem}.yellow.svelte-2btye1{background:var(--onboard-warning-500, var(--warning-500))}"
  );
}
function WAe(e) {
  let t, n, r;
  return {
    c() {
      (t = We("div")),
        Se(
          t,
          "class",
          (n = A$(`${e[2]} icon flex absolute`) + " svelte-2btye1")
        ),
        Se(
          t,
          "style",
          (r = `width: ${e[0]}px; height: ${e[0]}px; padding: ${e[0] / 6}px;`)
        ),
        Ft(t, "yellow", e[1] === "yellow");
    },
    m(i, s) {
      at(i, t, s), (t.innerHTML = LEe);
    },
    p(i, [s]) {
      s & 4 &&
        n !== (n = A$(`${i[2]} icon flex absolute`) + " svelte-2btye1") &&
        Se(t, "class", n),
        s & 1 &&
          r !==
            (r = `width: ${i[0]}px; height: ${i[0]}px; padding: ${
              i[0] / 6
            }px;`) &&
          Se(t, "style", r),
        s & 6 && Ft(t, "yellow", i[1] === "yellow");
    },
    i: rt,
    o: rt,
    d(i) {
      i && st(t);
    },
  };
}
function HAe(e, t, n) {
  let { size: r } = t,
    { color: i = "yellow" } = t,
    { class: s = "test" } = t;
  return (
    (e.$$set = (o) => {
      "size" in o && n(0, (r = o.size)),
        "color" in o && n(1, (i = o.color)),
        "class" in o && n(2, (s = o.class));
    }),
    [r, i, s]
  );
}
class VAe extends co {
  constructor(t) {
    super(), lo(this, t, HAe, WAe, oo, { size: 0, color: 1, class: 2 }, zAe);
  }
}
function GAe(e) {
  ao(
    e,
    "svelte-1bikw7k",
    ".icon.svelte-1bikw7k{color:var(--onboard-white, var(--white));border-radius:50px}.green.svelte-1bikw7k{background:var(--onboard-success-600, var(--success-600))}.blue.svelte-1bikw7k{background:var(--onboard-primary-1, var(--primary-1))}"
  );
}
function qAe(e) {
  let t, n;
  return {
    c() {
      (t = We("div")),
        Se(t, "class", "icon flex svelte-1bikw7k"),
        Se(
          t,
          "style",
          (n = `width: ${e[0]}px; height: ${e[0]}px; padding: ${e[0] / 5}px;`)
        ),
        Ft(t, "green", e[1] === "green"),
        Ft(t, "blue", e[1] === "blue");
    },
    m(r, i) {
      at(r, t, i), (t.innerHTML = jJ);
    },
    p(r, [i]) {
      i & 1 &&
        n !==
          (n = `width: ${r[0]}px; height: ${r[0]}px; padding: ${
            r[0] / 5
          }px;`) &&
        Se(t, "style", n),
        i & 2 && Ft(t, "green", r[1] === "green"),
        i & 2 && Ft(t, "blue", r[1] === "blue");
    },
    i: rt,
    o: rt,
    d(r) {
      r && st(t);
    },
  };
}
function KAe(e, t, n) {
  let { size: r } = t,
    { color: i = "green" } = t;
  return (
    (e.$$set = (s) => {
      "size" in s && n(0, (r = s.size)), "color" in s && n(1, (i = s.color));
    }),
    [r, i]
  );
}
class Nee extends co {
  constructor(t) {
    super(), lo(this, t, KAe, qAe, oo, { size: 0, color: 1 }, GAe);
  }
}
function YAe(e) {
  ao(
    e,
    "svelte-1le5672",
    ".loading-container.svelte-1le5672.svelte-1le5672{font-family:inherit;font-size:inherit;color:inherit}span.svelte-1le5672.svelte-1le5672{font-family:inherit;font-size:0.889em;margin-top:1rem}.loading.svelte-1le5672.svelte-1le5672{display:inline-block}.loading.svelte-1le5672 div.svelte-1le5672{font-size:inherit;display:block;position:absolute;border:3px solid;border-radius:50%;animation:svelte-1le5672-bn-loading 1.2s cubic-bezier(0.5, 0, 0.5, 1) infinite;border-color:currentColor transparent transparent transparent}.loading.svelte-1le5672 .loading-first.svelte-1le5672{animation-delay:-0.45s}.loading.svelte-1le5672 .loading-second.svelte-1le5672{animation-delay:-0.3s}.loading.svelte-1le5672 .loading-third.svelte-1le5672{animation-delay:-0.15s}@keyframes svelte-1le5672-bn-loading{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}"
  );
}
function O$(e) {
  let t, n;
  return {
    c() {
      (t = We("span")), (n = hr(e[0])), Se(t, "class", "svelte-1le5672");
    },
    m(r, i) {
      at(r, t, i), Te(t, n);
    },
    p(r, i) {
      i & 1 && zr(n, r[0]);
    },
    d(r) {
      r && st(t);
    },
  };
}
function ZAe(e) {
  let t,
    n,
    r,
    i,
    s,
    o,
    a,
    l,
    c,
    u,
    d,
    f,
    h = e[0] && O$(e);
  return {
    c() {
      (t = We("div")),
        (n = We("div")),
        (r = We("div")),
        (s = qt()),
        (o = We("div")),
        (l = qt()),
        (c = We("div")),
        (f = qt()),
        h && h.c(),
        Se(r, "class", "loading-first svelte-1le5672"),
        Se(r, "style", (i = `height: ${e[1]}; width: ${e[1]};`)),
        Se(o, "class", "loading-second svelte-1le5672"),
        Se(o, "style", (a = `height: ${e[1]}; width: ${e[1]};`)),
        Se(c, "class", "loading-third svelte-1le5672"),
        Se(c, "style", (u = `height: ${e[1]}; width: ${e[1]};`)),
        Se(n, "class", "loading relative svelte-1le5672"),
        Se(n, "style", (d = `height: ${e[1]}; width: ${e[1]};`)),
        Se(
          t,
          "class",
          "loading-container flex flex-column justify-center items-center absolute svelte-1le5672"
        );
    },
    m(p, g) {
      at(p, t, g),
        Te(t, n),
        Te(n, r),
        Te(n, s),
        Te(n, o),
        Te(n, l),
        Te(n, c),
        Te(t, f),
        h && h.m(t, null);
    },
    p(p, [g]) {
      g & 2 &&
        i !== (i = `height: ${p[1]}; width: ${p[1]};`) &&
        Se(r, "style", i),
        g & 2 &&
          a !== (a = `height: ${p[1]}; width: ${p[1]};`) &&
          Se(o, "style", a),
        g & 2 &&
          u !== (u = `height: ${p[1]}; width: ${p[1]};`) &&
          Se(c, "style", u),
        g & 2 &&
          d !== (d = `height: ${p[1]}; width: ${p[1]};`) &&
          Se(n, "style", d),
        p[0]
          ? h
            ? h.p(p, g)
            : ((h = O$(p)), h.c(), h.m(t, null))
          : h && (h.d(1), (h = null));
    },
    i: rt,
    o: rt,
    d(p) {
      p && st(t), h && h.d();
    },
  };
}
function QAe(e, t, n) {
  let { description: r = "" } = t,
    { size: i = "2rem" } = t;
  return (
    (e.$$set = (s) => {
      "description" in s && n(0, (r = s.description)),
        "size" in s && n(1, (i = s.size));
    }),
    [r, i]
  );
}
class XAe extends co {
  constructor(t) {
    super(), lo(this, t, QAe, ZAe, oo, { description: 0, size: 1 }, YAe);
  }
}
function JAe(e) {
  ao(
    e,
    "svelte-i129jl",
    `.icon.svelte-i129jl{height:100%}.border-custom.svelte-i129jl{border:1px solid var(--border-color)}.border-yellow.svelte-i129jl{border:1px solid var(--onboard-warning-500, var(--warning-500))}.border-gray.svelte-i129jl{border:1px solid var(--onboard-gray-400, var(--gray-400))}.border-green.svelte-i129jl{border:1px solid var(--onboard-success-500, var(--success-500))}.border-dark-green.svelte-i129jl{border:1px solid var(--onboard-success-700, var(--success-700))}.border-blue.svelte-i129jl{border:1px solid
      var(
        --onboard-wallet-app-icon-border-color,
        var(--onboard-primary-300, var(--primary-300))
      )}.border-dark-blue.svelte-i129jl{border:1px solid
      var(
        --onboard-wallet-app-icon-border-color,
        var(--onboard-primary-600, var(--primary-600))
      )}.border-transparent.svelte-i129jl{border:1px solid transparent}.border-black.svelte-i129jl{border:1px solid var(--onboard-gray-600, var(--gray-600))}.background-gray.svelte-i129jl{background:var(
      --onboard-wallet-app-icon-background-gray,
      var(--onboard-gray-500, var(--gray-500))
    )}.background-light-gray.svelte-i129jl{background:var(
      --onboard-wallet-app-icon-background-light-gray,
      var(--onboard-gray-100, var(--gray-100))
    )}.background-light-blue.svelte-i129jl{background:var(
      --onboard-wallet-app-icon-background-light-blue,
      var(--onboard-primary-100, var(--primary-100))
    )}.background-green.svelte-i129jl{background:var(
      --onboard-wallet-app-icon-background-green,
      var(--onboard-success-100, var(--success-100))
    )}.background-white.svelte-i129jl{background:var(
      --onboard-wallet-app-icon-background-white,
      var(--onboard-white, var(--white))
    )}.background-transparent.svelte-i129jl{background:var(
      --onboard-wallet-app-icon-background-transparent,
      transparent
    )}@keyframes svelte-i129jl-pulse{from{opacity:0}to{opacity:1}}.placeholder-icon.svelte-i129jl{width:100%;height:100%;background:var(--onboard-gray-100, var(--gray-100));border-radius:32px;animation:svelte-i129jl-pulse infinite 750ms alternate ease-in-out}.spinner-container.svelte-i129jl{color:var(--onboard-primary-300, var(--primary-300))}img.svelte-i129jl{max-width:100%;height:auto}.pending-status-icon{z-index:1;fill:white;box-shadow:0px 2px 12px 0px rgba(0, 0, 0, 0.1)}.status-icon-container.svelte-i129jl{right:-0.25rem;bottom:-0.25rem;position:absolute}`
  );
}
const eCe = (e) => ({}),
  P$ = (e) => ({});
function tCe(e) {
  let t,
    n,
    r,
    i = {
      ctx: e,
      current: null,
      token: null,
      hasCatch: !1,
      pending: aCe,
      then: iCe,
      catch: rCe,
      value: 13,
      blocks: [, , ,],
    };
  return (
    Qm((n = e[1]), i),
    {
      c() {
        (t = xi()), i.block.c();
      },
      m(s, o) {
        at(s, t, o),
          i.block.m(s, (i.anchor = o)),
          (i.mount = () => t.parentNode),
          (i.anchor = t),
          (r = !0);
      },
      p(s, o) {
        (e = s),
          (i.ctx = e),
          (o & 2 && n !== (n = e[1]) && Qm(n, i)) || xv(i, e, o);
      },
      i(s) {
        r || (Ke(i.block), (r = !0));
      },
      o(s) {
        for (let o = 0; o < 3; o += 1) {
          const a = i.blocks[o];
          ot(a);
        }
        r = !1;
      },
      d(s) {
        s && st(t), i.block.d(s), (i.token = null), (i = null);
      },
    }
  );
}
function nCe(e) {
  let t, n, r;
  return (
    (n = new XAe({ props: { size: "2rem" } })),
    {
      c() {
        (t = We("div")),
          pr(n.$$.fragment),
          Se(t, "class", "spinner-container svelte-i129jl");
      },
      m(i, s) {
        at(i, t, s), or(n, t, null), (r = !0);
      },
      p: rt,
      i(i) {
        r || (Ke(n.$$.fragment, i), (r = !0));
      },
      o(i) {
        ot(n.$$.fragment, i), (r = !1);
      },
      d(i) {
        i && st(t), ar(n);
      },
    }
  );
}
function rCe(e) {
  return { c: rt, m: rt, p: rt, i: rt, o: rt, d: rt };
}
function iCe(e) {
  let t, n, r, i, s, o;
  function a(d, f) {
    return f & 2 && (n = null), n == null && (n = !!fO(d[13])), n ? oCe : sCe;
  }
  let l = a(e, -1),
    c = l(e),
    u = e[2] && e[9] <= zs && L$();
  return {
    c() {
      (t = We("div")),
        c.c(),
        (i = qt()),
        u && u.c(),
        (s = xi()),
        Se(t, "class", "icon flex justify-center items-center svelte-i129jl");
    },
    m(d, f) {
      at(d, t, f),
        c.m(t, null),
        at(d, i, f),
        u && u.m(d, f),
        at(d, s, f),
        (o = !0);
    },
    p(d, f) {
      l === (l = a(d, f)) && c
        ? c.p(d, f)
        : (c.d(1), (c = l(d)), c && (c.c(), c.m(t, null))),
        d[2] && d[9] <= zs
          ? u
            ? f & 516 && Ke(u, 1)
            : ((u = L$()), u.c(), Ke(u, 1), u.m(s.parentNode, s))
          : u &&
            (zi(),
            ot(u, 1, 1, () => {
              u = null;
            }),
            Wi());
    },
    i(d) {
      o ||
        (d &&
          (r ||
            Na(() => {
              (r = SO(t, j5, {})), r.start();
            })),
        Ke(u),
        (o = !0));
    },
    o(d) {
      ot(u), (o = !1);
    },
    d(d) {
      d && st(t), c.d(), d && st(i), u && u.d(d), d && st(s);
    },
  };
}
function sCe(e) {
  let t, n;
  return {
    c() {
      (t = We("img")),
        By(t.src, (n = e[13])) || Se(t, "src", n),
        Se(t, "alt", "logo"),
        Se(t, "class", "svelte-i129jl");
    },
    m(r, i) {
      at(r, t, i);
    },
    p(r, i) {
      i & 2 && !By(t.src, (n = r[13])) && Se(t, "src", n);
    },
    d(r) {
      r && st(t);
    },
  };
}
function oCe(e) {
  let t,
    n = e[13] + "",
    r;
  return {
    c() {
      (t = new bv(!1)), (r = xi()), (t.a = r);
    },
    m(i, s) {
      t.m(n, i, s), at(i, r, s);
    },
    p(i, s) {
      s & 2 && n !== (n = i[13] + "") && t.p(n);
    },
    d(i) {
      i && st(r), i && t.d();
    },
  };
}
function L$(e) {
  let t, n, r;
  return (
    (n = new VAe({ props: { class: "pending-status-icon", size: 20 } })),
    {
      c() {
        (t = We("div")),
          pr(n.$$.fragment),
          Se(t, "class", "status-icon-container svelte-i129jl");
      },
      m(i, s) {
        at(i, t, s), or(n, t, null), (r = !0);
      },
      i(i) {
        r || (Ke(n.$$.fragment, i), (r = !0));
      },
      o(i) {
        ot(n.$$.fragment, i), (r = !1);
      },
      d(i) {
        i && st(t), ar(n);
      },
    }
  );
}
function aCe(e) {
  let t;
  return {
    c() {
      (t = We("div")), Se(t, "class", "placeholder-icon svelte-i129jl");
    },
    m(n, r) {
      at(n, t, r);
    },
    p: rt,
    i: rt,
    o: rt,
    d(n) {
      n && st(t);
    },
  };
}
function lCe(e) {
  let t, n, r, i, s, o, a, l;
  Na(e[12]);
  const c = [nCe, tCe],
    u = [];
  function d(p, g) {
    return p[2] && p[9] >= zs ? 0 : 1;
  }
  (n = d(e)), (r = u[n] = c[n](e));
  const f = e[11].status,
    h = hO(f, e, e[10], P$);
  return {
    c() {
      (t = We("div")),
        r.c(),
        (i = qt()),
        h && h.c(),
        Se(t, "class", "relative svelte-i129jl"),
        Se(
          t,
          "style",
          (s = `${
            e[6] === "custom" ? `background-color: ${e[7]}` : ""
          }; padding: ${e[3] - 1}px; width: ${e[0]}px; height: ${
            e[0]
          }px; border-radius: ${e[8]}px; color: ${e[4]};`)
        ),
        Ft(t, "border-custom", e[5] === "custom"),
        Ft(t, "border-yellow", e[5] === "yellow"),
        Ft(t, "border-gray", e[5] === "gray"),
        Ft(t, "border-green", e[5] === "green"),
        Ft(t, "border-dark-green", e[5] === "darkGreen"),
        Ft(t, "border-blue", e[5] === "blue"),
        Ft(t, "border-dark-blue", e[5] === "darkBlue"),
        Ft(t, "border-transparent", e[5] === "transparent"),
        Ft(t, "border-black", e[5] === "black"),
        Ft(t, "background-gray", e[6] === "gray"),
        Ft(t, "background-light-gray", e[6] === "lightGray"),
        Ft(t, "background-light-blue", e[6] === "lightBlue"),
        Ft(t, "background-green", e[6] === "green"),
        Ft(t, "background-white", e[6] === "white"),
        Ft(t, "background-transparent", e[6] === "transparent");
    },
    m(p, g) {
      at(p, t, g),
        u[n].m(t, null),
        Te(t, i),
        h && h.m(t, null),
        (o = !0),
        a || ((l = ll(window, "resize", e[12])), (a = !0));
    },
    p(p, [g]) {
      let b = n;
      (n = d(p)),
        n === b
          ? u[n].p(p, g)
          : (zi(),
            ot(u[b], 1, 1, () => {
              u[b] = null;
            }),
            Wi(),
            (r = u[n]),
            r ? r.p(p, g) : ((r = u[n] = c[n](p)), r.c()),
            Ke(r, 1),
            r.m(t, i)),
        h &&
          h.p &&
          (!o || g & 1024) &&
          mO(h, f, p, p[10], o ? pO(f, p[10], g, eCe) : gO(p[10]), P$),
        (!o ||
          (g & 473 &&
            s !==
              (s = `${
                p[6] === "custom" ? `background-color: ${p[7]}` : ""
              }; padding: ${p[3] - 1}px; width: ${p[0]}px; height: ${
                p[0]
              }px; border-radius: ${p[8]}px; color: ${p[4]};`))) &&
          Se(t, "style", s),
        (!o || g & 32) && Ft(t, "border-custom", p[5] === "custom"),
        (!o || g & 32) && Ft(t, "border-yellow", p[5] === "yellow"),
        (!o || g & 32) && Ft(t, "border-gray", p[5] === "gray"),
        (!o || g & 32) && Ft(t, "border-green", p[5] === "green"),
        (!o || g & 32) && Ft(t, "border-dark-green", p[5] === "darkGreen"),
        (!o || g & 32) && Ft(t, "border-blue", p[5] === "blue"),
        (!o || g & 32) && Ft(t, "border-dark-blue", p[5] === "darkBlue"),
        (!o || g & 32) && Ft(t, "border-transparent", p[5] === "transparent"),
        (!o || g & 32) && Ft(t, "border-black", p[5] === "black"),
        (!o || g & 64) && Ft(t, "background-gray", p[6] === "gray"),
        (!o || g & 64) && Ft(t, "background-light-gray", p[6] === "lightGray"),
        (!o || g & 64) && Ft(t, "background-light-blue", p[6] === "lightBlue"),
        (!o || g & 64) && Ft(t, "background-green", p[6] === "green"),
        (!o || g & 64) && Ft(t, "background-white", p[6] === "white"),
        (!o || g & 64) &&
          Ft(t, "background-transparent", p[6] === "transparent");
    },
    i(p) {
      o || (Ke(r), Ke(h, p), (o = !0));
    },
    o(p) {
      ot(r), ot(h, p), (o = !1);
    },
    d(p) {
      p && st(t), u[n].d(), h && h.d(p), (a = !1), l();
    },
  };
}
function cCe(e, t, n) {
  let { $$slots: r = {}, $$scope: i } = t,
    { size: s } = t,
    { icon: o } = t,
    { loading: a = !1 } = t,
    { padding: l = s / 6 } = t,
    { color: c = "black" } = t,
    { border: u = "transparent" } = t,
    { background: d = "transparent" } = t,
    { customBackgroundColor: f = "" } = t,
    { radius: h = 12 } = t,
    p;
  function g() {
    n(9, (p = window.innerWidth));
  }
  return (
    (e.$$set = (b) => {
      "size" in b && n(0, (s = b.size)),
        "icon" in b && n(1, (o = b.icon)),
        "loading" in b && n(2, (a = b.loading)),
        "padding" in b && n(3, (l = b.padding)),
        "color" in b && n(4, (c = b.color)),
        "border" in b && n(5, (u = b.border)),
        "background" in b && n(6, (d = b.background)),
        "customBackgroundColor" in b && n(7, (f = b.customBackgroundColor)),
        "radius" in b && n(8, (h = b.radius)),
        "$$scope" in b && n(10, (i = b.$$scope));
    }),
    [s, o, a, l, c, u, d, f, h, p, i, r, g]
  );
}
class Eb extends co {
  constructor(t) {
    super(),
      lo(
        this,
        t,
        cCe,
        lCe,
        oo,
        {
          size: 0,
          icon: 1,
          loading: 2,
          padding: 3,
          color: 4,
          border: 5,
          background: 6,
          customBackgroundColor: 7,
          radius: 8,
        },
        JAe
      );
  }
}
function uCe(e) {
  ao(
    e,
    "svelte-q2gson",
    ".container.svelte-q2gson{gap:1rem;padding:0.75rem;color:var(--onboard-warning-700, var(--warning-700));font-size:var(--onboard-font-size-7, var(--font-size-7));line-height:16px;border:1px solid var(--onboard-warning-400, var(--warning-400));background:var(--onboard-warning-100, var(--warning-100));border-radius:12px}.icon.svelte-q2gson{color:var(--onboard-warning-700, var(--warning-700));width:1rem;height:1rem;flex:0 0 auto}"
  );
}
function dCe(e) {
  let t, n, r, i, s, o;
  const a = e[1].default,
    l = hO(a, e, e[0], null);
  return {
    c() {
      (t = We("div")),
        (n = We("div")),
        l && l.c(),
        (r = qt()),
        (i = We("div")),
        Se(i, "class", "icon svelte-q2gson"),
        Se(t, "class", "container flex justify-between svelte-q2gson");
    },
    m(c, u) {
      at(c, t, u),
        Te(t, n),
        l && l.m(n, null),
        Te(t, r),
        Te(t, i),
        (i.innerHTML = L8),
        (o = !0);
    },
    p(c, [u]) {
      l &&
        l.p &&
        (!o || u & 1) &&
        mO(l, a, c, c[0], o ? pO(a, c[0], u, null) : gO(c[0]), null);
    },
    i(c) {
      o ||
        (Ke(l, c),
        c &&
          (s ||
            Na(() => {
              (s = SO(t, NAe, { delay: 50, duration: 500 })), s.start();
            })),
        (o = !0));
    },
    o(c) {
      ot(l, c), (o = !1);
    },
    d(c) {
      c && st(t), l && l.d(c);
    },
  };
}
function fCe(e, t, n) {
  let { $$slots: r = {}, $$scope: i } = t;
  return (
    (e.$$set = (s) => {
      "$$scope" in s && n(0, (i = s.$$scope));
    }),
    [i, r]
  );
}
class NO extends co {
  constructor(t) {
    super(), lo(this, t, fCe, dCe, oo, {}, uCe);
  }
}
function hCe(e) {
  ao(
    e,
    "svelte-1kfgpsl",
    `.container.svelte-1kfgpsl{padding:var(--onboard-spacing-4, var(--spacing-4));color:var(
      --onboard-connect-accent-text-color,
      var(--onboard-gray-700, var(--gray-700))
    )}.connecting-container.svelte-1kfgpsl{padding:var(--onboard-spacing-4, var(--spacing-4));border-radius:var(--onboard-border-radius-1, var(--border-radius-1));background:var(--onboard-success-100, var(--success-100));border:1px solid var(--onboard-success-600, var(--success-600));width:100%}.text.svelte-1kfgpsl{right:var(--onboard-spacing-5, var(--spacing-5))}.tick.svelte-1kfgpsl{color:var(--onboard-success-700, var(--success-700))}`
  );
}
function pCe(e) {
  let t,
    n,
    r,
    i,
    s,
    o,
    a,
    l,
    c,
    u,
    d,
    f,
    h,
    p =
      e[2]("connect.connectedWallet.mainText", {
        default: sr.connect.connectedWallet.mainText,
        values: { wallet: e[0].label },
      }) + "",
    g,
    b,
    v,
    w;
  return (
    (s = new Eb({
      props: {
        size: 40,
        padding: 8,
        background: e[1] && e[1].icon ? "lightBlue" : "lightGray",
        border: "darkGreen",
        icon: (e[1] && e[1].icon) || bb,
      },
    })),
    (l = new Nee({ props: { size: 17 } })),
    (d = new Eb({
      props: {
        size: 40,
        padding: 8,
        border: "darkGreen",
        background: "white",
        icon: e[0].icon,
      },
    })),
    {
      c() {
        (t = We("div")),
          (n = We("div")),
          (r = We("div")),
          (i = We("div")),
          pr(s.$$.fragment),
          (o = qt()),
          (a = We("div")),
          pr(l.$$.fragment),
          (c = qt()),
          (u = We("div")),
          pr(d.$$.fragment),
          (f = qt()),
          (h = We("div")),
          (g = hr(p)),
          (b = qt()),
          (v = We("div")),
          Se(a, "class", "relative"),
          ig(a, "right", "1rem"),
          ig(a, "top", "4px"),
          ig(a, "z-index", "1"),
          Se(u, "class", "relative"),
          ig(u, "right", "1.75rem"),
          Se(i, "class", "flex justify-center items-end relative"),
          Se(h, "class", "text relative svelte-1kfgpsl"),
          Se(r, "class", "flex items-center"),
          Se(v, "class", "tick flex items-center svelte-1kfgpsl"),
          ig(v, "width", "24px"),
          Se(
            n,
            "class",
            "connecting-container flex justify-between items-center svelte-1kfgpsl"
          ),
          Se(t, "class", "container svelte-1kfgpsl");
      },
      m(x, S) {
        at(x, t, S),
          Te(t, n),
          Te(n, r),
          Te(r, i),
          or(s, i, null),
          Te(i, o),
          Te(i, a),
          or(l, a, null),
          Te(i, c),
          Te(i, u),
          or(d, u, null),
          Te(r, f),
          Te(r, h),
          Te(h, g),
          Te(n, b),
          Te(n, v),
          (v.innerHTML = jJ),
          (w = !0);
      },
      p(x, [S]) {
        const R = {};
        S & 2 && (R.background = x[1] && x[1].icon ? "lightBlue" : "lightGray"),
          S & 2 && (R.icon = (x[1] && x[1].icon) || bb),
          s.$set(R);
        const O = {};
        S & 1 && (O.icon = x[0].icon),
          d.$set(O),
          (!w || S & 5) &&
            p !==
              (p =
                x[2]("connect.connectedWallet.mainText", {
                  default: sr.connect.connectedWallet.mainText,
                  values: { wallet: x[0].label },
                }) + "") &&
            zr(g, p);
      },
      i(x) {
        w ||
          (Ke(s.$$.fragment, x),
          Ke(l.$$.fragment, x),
          Ke(d.$$.fragment, x),
          (w = !0));
      },
      o(x) {
        ot(s.$$.fragment, x),
          ot(l.$$.fragment, x),
          ot(d.$$.fragment, x),
          (w = !1);
      },
      d(x) {
        x && st(t), ar(s), ar(l), ar(d);
      },
    }
  );
}
function mCe(e, t, n) {
  let r, i;
  is(e, _h, (a) => n(2, (i = a)));
  let { selectedWallet: s } = t;
  const o = Pn.select("appMetadata").pipe(bd(Pn.get().appMetadata), Rd(1));
  return (
    is(e, o, (a) => n(1, (r = a))),
    (e.$$set = (a) => {
      "selectedWallet" in a && n(0, (s = a.selectedWallet));
    }),
    [s, r, i, o]
  );
}
class gCe extends co {
  constructor(t) {
    super(), lo(this, t, mCe, pCe, oo, { selectedWallet: 0 }, hCe);
  }
}
function yCe(e) {
  ao(
    e,
    "svelte-j1ywa3",
    `.container.svelte-j1ywa3{padding:var(--onboard-spacing-4, var(--spacing-4))}.connecting-container.svelte-j1ywa3{width:100%;padding:var(--onboard-spacing-4, var(--spacing-4));transition:background-color 100ms ease-in-out,
      border-color 100ms ease-in-out;border-radius:24px;background:var(--onboard-primary-100, var(--primary-100));border:1px solid;border-color:var(--onboard-primary-300, var(--primary-300));color:var(--onboard-gray-600, var(--gray-600))}.connecting-container.warning.svelte-j1ywa3{background:var(--onboard-warning-100, var(--warning-100));border-color:var(--onboard-warning-400, var(--warning-400))}.text.svelte-j1ywa3{line-height:16px;margin-bottom:var(--onboard-spacing-5, var(--spacing-5))}.text.text-rejected.svelte-j1ywa3{line-height:24px;margin-bottom:0}.subtext.svelte-j1ywa3{font-size:var(--onboard-font-size-7, var(--font-size-7));line-height:16px}.rejected-cta.svelte-j1ywa3{color:var(--onboard-primary-500, var(--primary-500))}.onboard-button-primary.svelte-j1ywa3{bottom:var(--onboard-spacing-3, var(--spacing-3))}.ml.svelte-j1ywa3{margin-left:var(--onboard-spacing-4, var(--spacing-4))}@media all and (max-width: 520px){.connecting-container.svelte-j1ywa3{border-radius:var(--onboard-border-radius-4, var(--border-radius-4))}.container.svelte-j1ywa3{padding-bottom:0}.wallet-badges.svelte-j1ywa3{display:none}.connecting-wallet-info.svelte-j1ywa3{margin:0}.onboard-button-primary.svelte-j1ywa3{display:none}}`
  );
}
function vCe(e) {
  let t,
    n =
      e[7](
        `connect.connectingWallet.${e[5] ? "previousConnection" : "paragraph"}`,
        {
          default: sr.connect.connectingWallet.paragraph,
          values: { wallet: e[1].label },
        }
      ) + "",
    r;
  return {
    c() {
      (t = We("div")), (r = hr(n)), Se(t, "class", "subtext svelte-j1ywa3");
    },
    m(i, s) {
      at(i, t, s), Te(t, r);
    },
    p(i, s) {
      s & 162 &&
        n !==
          (n =
            i[7](
              `connect.connectingWallet.${
                i[5] ? "previousConnection" : "paragraph"
              }`,
              {
                default: sr.connect.connectingWallet.paragraph,
                values: { wallet: i[1].label },
              }
            ) + "") &&
        zr(r, n);
    },
    d(i) {
      i && st(t);
    },
  };
}
function wCe(e) {
  let t,
    n =
      e[7]("connect.connectingWallet.rejectedCTA", {
        default: sr.connect.connectingWallet.rejectedCTA,
        values: { wallet: e[1].label },
      }) + "",
    r,
    i,
    s;
  return {
    c() {
      (t = We("div")),
        (r = hr(n)),
        Se(t, "class", "rejected-cta pointer subtext svelte-j1ywa3");
    },
    m(o, a) {
      at(o, t, a),
        Te(t, r),
        i ||
          ((s = ll(t, "click", function () {
            m0(e[0]) && e[0].apply(this, arguments);
          })),
          (i = !0));
    },
    p(o, a) {
      (e = o),
        a & 130 &&
          n !==
            (n =
              e[7]("connect.connectingWallet.rejectedCTA", {
                default: sr.connect.connectingWallet.rejectedCTA,
                values: { wallet: e[1].label },
              }) + "") &&
          zr(r, n);
    },
    d(o) {
      o && st(t), (i = !1), s();
    },
  };
}
function bCe(e) {
  let t,
    n,
    r,
    i,
    s,
    o,
    a,
    l,
    c,
    u,
    d,
    f =
      e[7](`connect.connectingWallet.${e[4] ? "rejectedText" : "mainText"}`, {
        default: e[4]
          ? sr.connect.connectingWallet.rejectedText
          : sr.connect.connectingWallet.mainText,
        values: { wallet: e[1].label },
      }) + "",
    h,
    p,
    g,
    b,
    v =
      e[7]("connect.connectingWallet.primaryButton", {
        default: sr.connect.connectingWallet.primaryButton,
      }) + "",
    w,
    x,
    S,
    R;
  (s = new Eb({
    props: {
      size: 40,
      padding: 8,
      icon: (e[6] && e[6].icon) || bb,
      border: e[4] || e[5] ? "yellow" : "blue",
      background: "lightGray",
    },
  })),
    (l = new Eb({
      props: {
        size: 40,
        padding: 8,
        border: e[4] || e[5] ? "yellow" : "blue",
        background: "white",
        icon: e[1].icon,
      },
    }));
  function O(I, P) {
    return I[4] ? wCe : vCe;
  }
  let B = O(e),
    C = B(e);
  return {
    c() {
      (t = We("div")),
        (n = We("div")),
        (r = We("div")),
        (i = We("div")),
        pr(s.$$.fragment),
        (o = qt()),
        (a = We("div")),
        pr(l.$$.fragment),
        (c = qt()),
        (u = We("div")),
        (d = We("div")),
        (h = hr(f)),
        (p = qt()),
        C.c(),
        (g = qt()),
        (b = We("button")),
        (w = hr(v)),
        Se(a, "class", "relative"),
        ig(a, "right", "0.5rem"),
        Se(
          i,
          "class",
          "flex justify-center relative wallet-badges svelte-j1ywa3"
        ),
        Se(d, "class", "text svelte-j1ywa3"),
        Ft(d, "text-rejected", e[4]),
        Se(
          u,
          "class",
          "flex flex-column justify-center ml connecting-wallet-info svelte-j1ywa3"
        ),
        Se(r, "class", "flex"),
        Se(
          n,
          "class",
          "connecting-container flex justify-between items-center svelte-j1ywa3"
        ),
        Ft(n, "warning", e[4] || e[5]),
        Se(b, "class", "onboard-button-primary absolute svelte-j1ywa3"),
        Se(t, "class", "container flex flex-column items-center svelte-j1ywa3");
    },
    m(I, P) {
      at(I, t, P),
        Te(t, n),
        Te(n, r),
        Te(r, i),
        or(s, i, null),
        Te(i, o),
        Te(i, a),
        or(l, a, null),
        Te(r, c),
        Te(r, u),
        Te(u, d),
        Te(d, h),
        Te(u, p),
        C.m(u, null),
        Te(t, g),
        Te(t, b),
        Te(b, w),
        (x = !0),
        S || ((R = ll(b, "click", e[9])), (S = !0));
    },
    p(I, [P]) {
      const M = {};
      P & 64 && (M.icon = (I[6] && I[6].icon) || bb),
        P & 48 && (M.border = I[4] || I[5] ? "yellow" : "blue"),
        s.$set(M);
      const k = {};
      P & 48 && (k.border = I[4] || I[5] ? "yellow" : "blue"),
        P & 2 && (k.icon = I[1].icon),
        l.$set(k),
        (!x || P & 146) &&
          f !==
            (f =
              I[7](
                `connect.connectingWallet.${
                  I[4] ? "rejectedText" : "mainText"
                }`,
                {
                  default: I[4]
                    ? sr.connect.connectingWallet.rejectedText
                    : sr.connect.connectingWallet.mainText,
                  values: { wallet: I[1].label },
                }
              ) + "") &&
          zr(h, f),
        (!x || P & 16) && Ft(d, "text-rejected", I[4]),
        B === (B = O(I)) && C
          ? C.p(I, P)
          : (C.d(1), (C = B(I)), C && (C.c(), C.m(u, null))),
        (!x || P & 48) && Ft(n, "warning", I[4] || I[5]),
        (!x || P & 128) &&
          v !==
            (v =
              I[7]("connect.connectingWallet.primaryButton", {
                default: sr.connect.connectingWallet.primaryButton,
              }) + "") &&
          zr(w, v);
    },
    i(I) {
      x || (Ke(s.$$.fragment, I), Ke(l.$$.fragment, I), (x = !0));
    },
    o(I) {
      ot(s.$$.fragment, I), ot(l.$$.fragment, I), (x = !1);
    },
    d(I) {
      I && st(t), ar(s), ar(l), C.d(), (S = !1), R();
    },
  };
}
function xCe(e, t, n) {
  let r, i;
  is(e, _h, (h) => n(7, (i = h)));
  let { connectWallet: s } = t,
    { selectedWallet: o } = t,
    { deselectWallet: a } = t,
    { setStep: l } = t,
    { connectionRejected: c } = t,
    { previousConnectionRequest: u } = t;
  const d = Pn.select("appMetadata").pipe(bd(Pn.get().appMetadata), Rd(1));
  is(e, d, (h) => n(6, (r = h)));
  const f = () => {
    a(o.label), l("selectingWallet");
  };
  return (
    (e.$$set = (h) => {
      "connectWallet" in h && n(0, (s = h.connectWallet)),
        "selectedWallet" in h && n(1, (o = h.selectedWallet)),
        "deselectWallet" in h && n(2, (a = h.deselectWallet)),
        "setStep" in h && n(3, (l = h.setStep)),
        "connectionRejected" in h && n(4, (c = h.connectionRejected)),
        "previousConnectionRequest" in h &&
          n(5, (u = h.previousConnectionRequest));
    }),
    [s, o, a, l, c, u, r, i, d, f]
  );
}
class _Ce extends co {
  constructor(t) {
    super(),
      lo(
        this,
        t,
        xCe,
        bCe,
        oo,
        {
          connectWallet: 0,
          selectedWallet: 1,
          deselectWallet: 2,
          setStep: 3,
          connectionRejected: 4,
          previousConnectionRequest: 5,
        },
        yCe
      );
  }
}
function SCe(e) {
  ao(
    e,
    "svelte-1uy2ffh",
    ".outer-container.svelte-1uy2ffh{padding:var(--onboard-spacing-4, var(--spacing-4))}.link.svelte-1uy2ffh{font-size:var(--onboard-font-size-7, var(--font-size-7));line-height:16px;color:var(--onboard-primary-500, var(--primary-500));text-decoration:none}"
  );
}
function j$(e, t, n) {
  const r = e.slice();
  return (r[3] = t[n].name), (r[4] = t[n].url), (r[6] = n), r;
}
function ECe(e) {
  let t =
      e[1]("connect.selectingWallet.installWallet", {
        default: sr.connect.selectingWallet.installWallet,
        values: { app: e[0].name || "this app" },
      }) + "",
    n;
  return {
    c() {
      n = hr(t);
    },
    m(r, i) {
      at(r, n, i);
    },
    p(r, i) {
      i & 3 &&
        t !==
          (t =
            r[1]("connect.selectingWallet.installWallet", {
              default: sr.connect.selectingWallet.installWallet,
              values: { app: r[0].name || "this app" },
            }) + "") &&
        zr(n, t);
    },
    d(r) {
      r && st(n);
    },
  };
}
function ACe(e) {
  let t =
      e[1]("connect.selectingWallet.recommendedWalletsPart1", {
        default: sr.connect.selectingWallet.recommendedWalletsPart1,
        values: { app: e[0].name || "This app" },
      }) + "",
    n,
    r,
    i,
    s =
      e[1]("connect.selectingWallet.recommendedWalletsPart2", {
        default: sr.connect.selectingWallet.recommendedWalletsPart2,
      }) + "",
    o,
    a = e[0].recommendedInjectedWallets,
    l = [];
  for (let c = 0; c < a.length; c += 1) l[c] = D$(j$(e, a, c));
  return {
    c() {
      (n = hr(t)), (r = qt());
      for (let c = 0; c < l.length; c += 1) l[c].c();
      (i = qt()), (o = hr(s));
    },
    m(c, u) {
      at(c, n, u), at(c, r, u);
      for (let d = 0; d < l.length; d += 1) l[d] && l[d].m(c, u);
      at(c, i, u), at(c, o, u);
    },
    p(c, u) {
      if (
        (u & 3 &&
          t !==
            (t =
              c[1]("connect.selectingWallet.recommendedWalletsPart1", {
                default: sr.connect.selectingWallet.recommendedWalletsPart1,
                values: { app: c[0].name || "This app" },
              }) + "") &&
          zr(n, t),
        u & 1)
      ) {
        a = c[0].recommendedInjectedWallets;
        let d;
        for (d = 0; d < a.length; d += 1) {
          const f = j$(c, a, d);
          l[d]
            ? l[d].p(f, u)
            : ((l[d] = D$(f)), l[d].c(), l[d].m(i.parentNode, i));
        }
        for (; d < l.length; d += 1) l[d].d(1);
        l.length = a.length;
      }
      u & 2 &&
        s !==
          (s =
            c[1]("connect.selectingWallet.recommendedWalletsPart2", {
              default: sr.connect.selectingWallet.recommendedWalletsPart2,
            }) + "") &&
        zr(o, s);
    },
    d(c) {
      c && st(n), c && st(r), aee(l, c), c && st(i), c && st(o);
    },
  };
}
function D$(e) {
  let t,
    n = e[3] + "",
    r,
    i = e[6] < e[0].recommendedInjectedWallets.length - 1 ? ", " : "",
    s,
    o;
  return {
    c() {
      (t = We("a")),
        (r = hr(n)),
        (s = hr(i)),
        Se(t, "class", "link pointer svelte-1uy2ffh"),
        Se(t, "href", (o = e[4])),
        Se(t, "target", "_blank"),
        Se(t, "rel", "noreferrer noopener");
    },
    m(a, l) {
      at(a, t, l), Te(t, r), Te(t, s);
    },
    p(a, l) {
      l & 1 && n !== (n = a[3] + "") && zr(r, n),
        l & 1 &&
          i !==
            (i =
              a[6] < a[0].recommendedInjectedWallets.length - 1 ? ", " : "") &&
          zr(s, i),
        l & 1 && o !== (o = a[4]) && Se(t, "href", o);
    },
    d(a) {
      a && st(t);
    },
  };
}
function CCe(e) {
  let t;
  function n(s, o) {
    return s[0].recommendedInjectedWallets ? ACe : ECe;
  }
  let r = n(e),
    i = r(e);
  return {
    c() {
      i.c(), (t = xi());
    },
    m(s, o) {
      i.m(s, o), at(s, t, o);
    },
    p(s, o) {
      r === (r = n(s)) && i
        ? i.p(s, o)
        : (i.d(1), (i = r(s)), i && (i.c(), i.m(t.parentNode, t)));
    },
    d(s) {
      i.d(s), s && st(t);
    },
  };
}
function kCe(e) {
  let t, n, r;
  return (
    (n = new NO({
      props: { $$slots: { default: [CCe] }, $$scope: { ctx: e } },
    })),
    {
      c() {
        (t = We("div")),
          pr(n.$$.fragment),
          Se(t, "class", "outer-container svelte-1uy2ffh");
      },
      m(i, s) {
        at(i, t, s), or(n, t, null), (r = !0);
      },
      p(i, [s]) {
        const o = {};
        s & 131 && (o.$$scope = { dirty: s, ctx: i }), n.$set(o);
      },
      i(i) {
        r || (Ke(n.$$.fragment, i), (r = !0));
      },
      o(i) {
        ot(n.$$.fragment, i), (r = !1);
      },
      d(i) {
        i && st(t), ar(n);
      },
    }
  );
}
function TCe(e, t, n) {
  let r, i;
  is(e, _h, (o) => n(1, (i = o)));
  const s = Pn.select("appMetadata").pipe(bd(Pn.get().appMetadata), Rd(1));
  return is(e, s, (o) => n(0, (r = o))), [r, i, s];
}
class MCe extends co {
  constructor(t) {
    super(), lo(this, t, TCe, kCe, oo, {}, SCe);
  }
}
function ICe(e) {
  ao(
    e,
    "svelte-1ct6vh0",
    "button.svelte-1ct6vh0:disabled{opacity:0.5}button.wallet-button-styling.svelte-1ct6vh0{position:relative;align-items:flex-start;flex:1;padding:0;background:none;color:var(--onboard-wallet-button-color, inherit)}.wallet-button-container.svelte-1ct6vh0{display:flex}.wallet-button-container-inner.svelte-1ct6vh0{position:relative;display:flex;flex-flow:column;align-items:center;gap:0.5rem;padding:0.75rem;width:5rem}.name.svelte-1ct6vh0{font-size:var(--onboard-font-size-7, var(--font-size-7));line-height:1rem;text-overflow:ellipsis;max-width:5rem;max-height:2rem;overflow:hidden}.status-icon.svelte-1ct6vh0{position:absolute;top:3.5rem;left:3.5rem}@media screen and (min-width: 768px){button.wallet-button-styling.svelte-1ct6vh0{transition:background-color 250ms ease-in-out;background:var(--onboard-wallet-button-background, none);border:1px solid transparent;border-color:var(--onboard-wallet-button-border-color, var(--border-color));border-radius:var(--onboard-wallet-button-border-radius, var(--border-radius-1))}button.wallet-button-styling.svelte-1ct6vh0:hover{background:var(--onboard-wallet-button-background-hover, var(--foreground-color));color:var(--onboard-wallet-button-color-hover)}.wallet-button-container-inner.svelte-1ct6vh0{flex:1;flex-flow:row nowrap;gap:1rem;padding:1rem}button.connected.svelte-1ct6vh0{border-color:var(--onboard-success-500, var(--success-500))}.name.svelte-1ct6vh0{font-size:var(--onboard-font-size-5, var(--font-size-5));line-height:1.25rem;text-align:initial;max-width:inherit;max-height:3rem}.status-icon.svelte-1ct6vh0{top:0;bottom:0;left:auto;right:1rem;margin:auto;height:20px}}"
  );
}
function B$(e) {
  let t, n, r;
  return (
    (n = new Nee({ props: { size: 20 } })),
    {
      c() {
        (t = We("div")),
          pr(n.$$.fragment),
          Se(t, "class", "status-icon svelte-1ct6vh0");
      },
      m(i, s) {
        at(i, t, s), or(n, t, null), (r = !0);
      },
      i(i) {
        r || (Ke(n.$$.fragment, i), (r = !0));
      },
      o(i) {
        ot(n.$$.fragment, i), (r = !1);
      },
      d(i) {
        i && st(t), ar(n);
      },
    }
  );
}
function NCe(e) {
  let t, n, r, i, s, o, a, l, c, u, d, f;
  Na(e[7]),
    (i = new Eb({
      props: {
        size: e[6] >= zs ? 48 : 56,
        icon: e[0],
        loading: e[4],
        border: e[3] ? "green" : "custom",
        background: "transparent",
      },
    }));
  let h = e[3] && B$();
  return {
    c() {
      (t = We("div")),
        (n = We("button")),
        (r = We("div")),
        pr(i.$$.fragment),
        (s = qt()),
        (o = We("div")),
        (a = hr(e[1])),
        (l = qt()),
        h && h.c(),
        Se(o, "class", "name svelte-1ct6vh0"),
        Se(r, "class", "wallet-button-container-inner svelte-1ct6vh0"),
        Se(n, "class", "wallet-button-styling svelte-1ct6vh0"),
        (n.disabled = e[5]),
        Ft(n, "connected", e[3]),
        Se(t, "class", "wallet-button-container svelte-1ct6vh0");
    },
    m(p, g) {
      at(p, t, g),
        Te(t, n),
        Te(n, r),
        or(i, r, null),
        Te(r, s),
        Te(r, o),
        Te(o, a),
        Te(r, l),
        h && h.m(r, null),
        (u = !0),
        d ||
          ((f = [
            ll(window, "resize", e[7]),
            ll(n, "click", function () {
              m0(e[2]) && e[2].apply(this, arguments);
            }),
          ]),
          (d = !0));
    },
    p(p, [g]) {
      e = p;
      const b = {};
      g & 64 && (b.size = e[6] >= zs ? 48 : 56),
        g & 1 && (b.icon = e[0]),
        g & 16 && (b.loading = e[4]),
        g & 8 && (b.border = e[3] ? "green" : "custom"),
        i.$set(b),
        (!u || g & 2) && zr(a, e[1]),
        e[3]
          ? h
            ? g & 8 && Ke(h, 1)
            : ((h = B$()), h.c(), Ke(h, 1), h.m(r, null))
          : h &&
            (zi(),
            ot(h, 1, 1, () => {
              h = null;
            }),
            Wi()),
        (!u || g & 32) && (n.disabled = e[5]),
        (!u || g & 8) && Ft(n, "connected", e[3]);
    },
    i(p) {
      u ||
        (Ke(i.$$.fragment, p),
        Ke(h),
        p &&
          (c ||
            Na(() => {
              (c = SO(n, j5, {})), c.start();
            })),
        (u = !0));
    },
    o(p) {
      ot(i.$$.fragment, p), ot(h), (u = !1);
    },
    d(p) {
      p && st(t), ar(i), h && h.d(), (d = !1), Hd(f);
    },
  };
}
function RCe(e, t, n) {
  let { icon: r } = t,
    { label: i } = t,
    { onClick: s } = t,
    { connected: o } = t,
    { connecting: a } = t,
    { disabled: l } = t,
    c;
  function u() {
    n(6, (c = window.innerWidth));
  }
  return (
    (e.$$set = (d) => {
      "icon" in d && n(0, (r = d.icon)),
        "label" in d && n(1, (i = d.label)),
        "onClick" in d && n(2, (s = d.onClick)),
        "connected" in d && n(3, (o = d.connected)),
        "connecting" in d && n(4, (a = d.connecting)),
        "disabled" in d && n(5, (l = d.disabled));
    }),
    [r, i, s, o, a, l, c, u]
  );
}
class OCe extends co {
  constructor(t) {
    super(),
      lo(
        this,
        t,
        RCe,
        NCe,
        oo,
        {
          icon: 0,
          label: 1,
          onClick: 2,
          connected: 3,
          connecting: 4,
          disabled: 5,
        },
        ICe
      );
  }
}
function PCe(e) {
  ao(
    e,
    "svelte-kpc6js",
    ".wallets-container.svelte-kpc6js{display:flex;gap:0.5rem;overflow-x:scroll;overflow-y:hidden;padding:0.75rem 0.5rem;border-bottom:1px solid var(--border-color);-ms-overflow-style:none;scrollbar-width:none}.wallets-container.svelte-kpc6js::-webkit-scrollbar{display:none}.warning-container.svelte-kpc6js{margin:1rem 1rem 0}.notice-container.svelte-kpc6js{flex:0 0 100%;margin-top:0.75rem}@media all and (min-width: 768px){.wallets-container.svelte-kpc6js{display:grid;grid-template-columns:repeat(var(--onboard-wallet-columns, 2), 1fr);padding:1rem;border:none}.notice-container.svelte-kpc6js{grid-column:span 2;margin:0}}"
  );
}
function F$(e, t, n) {
  const r = e.slice();
  return (r[10] = t[n]), r;
}
function U$(e) {
  let t, n, r;
  return (
    (n = new NO({
      props: { $$slots: { default: [LCe] }, $$scope: { ctx: e } },
    })),
    {
      c() {
        (t = We("div")),
          pr(n.$$.fragment),
          Se(t, "class", "warning-container svelte-kpc6js");
      },
      m(i, s) {
        at(i, t, s), or(n, t, null), (r = !0);
      },
      p(i, s) {
        const o = {};
        s & 8200 && (o.$$scope = { dirty: s, ctx: i }), n.$set(o);
      },
      i(i) {
        r || (Ke(n.$$.fragment, i), (r = !0));
      },
      o(i) {
        ot(n.$$.fragment, i), (r = !1);
      },
      d(i) {
        i && st(t), ar(n);
      },
    }
  );
}
function LCe(e) {
  let t, n;
  return {
    c() {
      (t = new bv(!1)), (n = xi()), (t.a = n);
    },
    m(r, i) {
      t.m(e[3], r, i), at(r, n, i);
    },
    p(r, i) {
      i & 8 && t.p(r[3]);
    },
    d(r) {
      r && st(n), r && t.d();
    },
  };
}
function $$(e) {
  let t, n;
  function r() {
    return e[9](e[10]);
  }
  return (
    (t = new OCe({
      props: {
        connected: e[7](e[10].label),
        connecting: e[2] === e[10].label,
        label: e[10].label,
        icon: e[10].icon,
        onClick: r,
        disabled: e[4] <= zs && e[2] && e[2] !== e[10].label,
      },
    })),
    {
      c() {
        pr(t.$$.fragment);
      },
      m(i, s) {
        or(t, i, s), (n = !0);
      },
      p(i, s) {
        e = i;
        const o = {};
        s & 1 && (o.connected = e[7](e[10].label)),
          s & 5 && (o.connecting = e[2] === e[10].label),
          s & 1 && (o.label = e[10].label),
          s & 1 && (o.icon = e[10].icon),
          s & 3 && (o.onClick = r),
          s & 21 && (o.disabled = e[4] <= zs && e[2] && e[2] !== e[10].label),
          t.$set(o);
      },
      i(i) {
        n || (Ke(t.$$.fragment, i), (n = !0));
      },
      o(i) {
        ot(t.$$.fragment, i), (n = !1);
      },
      d(i) {
        ar(t, i);
      },
    }
  );
}
function jCe(e) {
  let t, n, r;
  return (
    (n = new NO({
      props: { $$slots: { default: [DCe] }, $$scope: { ctx: e } },
    })),
    {
      c() {
        (t = We("div")),
          pr(n.$$.fragment),
          Se(t, "class", "notice-container svelte-kpc6js");
      },
      m(i, s) {
        at(i, t, s), or(n, t, null), (r = !0);
      },
      p(i, s) {
        const o = {};
        s & 8224 && (o.$$scope = { dirty: s, ctx: i }), n.$set(o);
      },
      i(i) {
        r || (Ke(n.$$.fragment, i), (r = !0));
      },
      o(i) {
        ot(n.$$.fragment, i), (r = !1);
      },
      d(i) {
        i && st(t), ar(n);
      },
    }
  );
}
function DCe(e) {
  let t,
    n =
      e[5]("connect.selectingWallet.whyDontISeeMyWallet", {
        default: sr.connect.selectingWallet.whyDontISeeMyWallet,
      }) + "",
    r,
    i,
    s,
    o =
      e[5]("connect.selectingWallet.learnMore", {
        default: sr.connect.selectingWallet.learnMore,
      }) + "",
    a;
  return {
    c() {
      (t = We("div")),
        (r = hr(n)),
        (i = qt()),
        (s = We("a")),
        (a = hr(o)),
        Se(s, "class", "link pointer"),
        Se(s, "href", e[6].wheresMyWalletLink || FCe),
        Se(s, "target", "_blank"),
        Se(s, "rel", "noreferrer noopener");
    },
    m(l, c) {
      at(l, t, c), Te(t, r), at(l, i, c), at(l, s, c), Te(s, a);
    },
    p(l, c) {
      c & 32 &&
        n !==
          (n =
            l[5]("connect.selectingWallet.whyDontISeeMyWallet", {
              default: sr.connect.selectingWallet.whyDontISeeMyWallet,
            }) + "") &&
        zr(r, n),
        c & 32 &&
          o !==
            (o =
              l[5]("connect.selectingWallet.learnMore", {
                default: sr.connect.selectingWallet.learnMore,
              }) + "") &&
          zr(a, o);
    },
    d(l) {
      l && st(t), l && st(i), l && st(s);
    },
  };
}
function BCe(e) {
  let t, n, r, i, s, o, a;
  Na(e[8]);
  let l = e[3] && U$(e),
    c = e[0],
    u = [];
  for (let h = 0; h < c.length; h += 1) u[h] = $$(F$(e, c, h));
  const d = (h) =>
    ot(u[h], 1, 1, () => {
      u[h] = null;
    });
  let f = !e[6].removeWhereIsMyWalletWarning && jCe(e);
  return {
    c() {
      (t = We("div")), l && l.c(), (n = qt()), (r = We("div"));
      for (let h = 0; h < u.length; h += 1) u[h].c();
      (i = qt()),
        f && f.c(),
        Se(r, "class", "wallets-container svelte-kpc6js"),
        Se(t, "class", "outer-container");
    },
    m(h, p) {
      at(h, t, p), l && l.m(t, null), Te(t, n), Te(t, r);
      for (let g = 0; g < u.length; g += 1) u[g] && u[g].m(r, null);
      Te(r, i),
        f && f.m(r, null),
        (s = !0),
        o || ((a = ll(window, "resize", e[8])), (o = !0));
    },
    p(h, [p]) {
      if (
        (h[3]
          ? l
            ? (l.p(h, p), p & 8 && Ke(l, 1))
            : ((l = U$(h)), l.c(), Ke(l, 1), l.m(t, n))
          : l &&
            (zi(),
            ot(l, 1, 1, () => {
              l = null;
            }),
            Wi()),
        p & 151)
      ) {
        c = h[0];
        let g;
        for (g = 0; g < c.length; g += 1) {
          const b = F$(h, c, g);
          u[g]
            ? (u[g].p(b, p), Ke(u[g], 1))
            : ((u[g] = $$(b)), u[g].c(), Ke(u[g], 1), u[g].m(r, i));
        }
        for (zi(), g = c.length; g < u.length; g += 1) d(g);
        Wi();
      }
      h[6].removeWhereIsMyWalletWarning || f.p(h, p);
    },
    i(h) {
      if (!s) {
        Ke(l);
        for (let p = 0; p < c.length; p += 1) Ke(u[p]);
        Ke(f), (s = !0);
      }
    },
    o(h) {
      ot(l), (u = u.filter(Boolean));
      for (let p = 0; p < u.length; p += 1) ot(u[p]);
      ot(f), (s = !1);
    },
    d(h) {
      h && st(t), l && l.d(), aee(u, h), f && f.d(), (o = !1), a();
    },
  };
}
const FCe =
  "https://www.blocknative.com/blog/metamask-wont-connect-web3-wallet-troubleshooting";
function UCe(e, t, n) {
  let r;
  is(e, _h, (h) => n(5, (r = h)));
  let { wallets: i } = t,
    { selectWallet: s } = t,
    { connectingWalletLabel: o } = t,
    { connectingErrorMessage: a } = t,
    l;
  const { connect: c } = Pn.get();
  function u(h) {
    const { wallets: p } = Pn.get();
    return !!p.find((g) => g.label === h);
  }
  function d() {
    n(4, (l = window.innerWidth));
  }
  const f = (h) => s(h);
  return (
    (e.$$set = (h) => {
      "wallets" in h && n(0, (i = h.wallets)),
        "selectWallet" in h && n(1, (s = h.selectWallet)),
        "connectingWalletLabel" in h && n(2, (o = h.connectingWalletLabel)),
        "connectingErrorMessage" in h && n(3, (a = h.connectingErrorMessage));
    }),
    [i, s, o, a, l, r, c, u, d, f]
  );
}
class $Ce extends co {
  constructor(t) {
    super(),
      lo(
        this,
        t,
        UCe,
        BCe,
        oo,
        {
          wallets: 0,
          selectWallet: 1,
          connectingWalletLabel: 2,
          connectingErrorMessage: 3,
        },
        PCe
      );
  }
}
function zCe(e) {
  ao(
    e,
    "svelte-obaru3",
    `.sidebar.svelte-obaru3{--background-color:var(
      --onboard-connect-sidebar-background,
      var(--w3o-foreground-color, none)
    );--text-color:var(--onboard-connect-sidebar-color, inherit);--border-color:var(--onboard-connect-sidebar-border-color, inherit);display:flex;flex-flow:column;gap:1rem;padding:1rem;align-items:center}.inner-container.svelte-obaru3{display:flex;flex-flow:column;align-items:center;align-self:stretch;gap:0.5rem;padding:1.5rem;text-align:center;border:1px solid transparent;border-radius:12px;border-color:var(--border-color);background:var(--background-color);color:var(--text-color)}.icon-container.svelte-obaru3{display:flex;height:3.5rem;width:auto;min-width:3.5rem;max-width:100%}.heading.svelte-obaru3{font-size:var(--onboard-font-size-3, var(--font-size-3));margin:0 0 var(--onboard-spacing-5, var(--spacing-5)) 0}.subheading.svelte-obaru3{line-height:1rem}.description.svelte-obaru3{line-height:1.25rem;font-size:var(--onboard-font-size-6, var(--font-size-6))}img.svelte-obaru3{max-width:100%;height:auto}.indicators.svelte-obaru3{margin-top:auto}.indicator.svelte-obaru3{box-sizing:content-box;width:8px;height:8px;border-radius:8px;background:var(
      --onboard-connect-sidebar-progress-background,
      var(--onboard-gray-700, var(--gray-700))
    );transition:background 250ms ease-in-out}.indicator.on.svelte-obaru3{background:var(
      --onboard-connect-sidebar-progress-color,
      var(--action-color)
    );border:2px solid
      var(
        --onboard-connect-sidebar-progress-background,
        var(--onboard-gray-700, var(--gray-700))
      )}.join.svelte-obaru3{box-sizing:content-box;z-index:1;right:4px;height:2px;background:var(
      --onboard-connect-sidebar-progress-background,
      var(--onboard-gray-700, var(--gray-700))
    );transition:background 250ms ease-in-out}.join.active.svelte-obaru3{background:var(
      --onboard-connect-sidebar-progress-color,
      var(--action-color)
    )}.no-link.svelte-obaru3{display:flex;flex-direction:row;align-items:center;padding:0.25rem 0.5rem 0.25rem 0.75rem;gap:0.25rem;font-size:var(--onboard-font-size-6, var(--font-size-6))}.info-icon.svelte-obaru3{width:1.25rem;display:flex;align-items:center}@media all and (min-width: 768px){.sidebar.svelte-obaru3{max-width:280px;border-right:1px solid;border-color:var(--border-color);background:var(--background-color)}.inner-container.svelte-obaru3{border:none;text-align:initial;flex:1;align-items:flex-start;gap:1rem}.indicators.svelte-obaru3{margin-bottom:0.25rem}}`
  );
}
function z$(e) {
  let t,
    n,
    r = e[3](`connect.${e[0]}.sidebar.header`, { default: "" }),
    i;
  function s(c, u) {
    return c[2] && (c[2].logo || c[2].icon) ? HCe : WCe;
  }
  let o = s(e),
    a = o(e),
    l = r && W$(e);
  return {
    c() {
      (t = We("div")),
        a.c(),
        (n = qt()),
        l && l.c(),
        (i = xi()),
        Se(t, "class", "icon-container svelte-obaru3");
    },
    m(c, u) {
      at(c, t, u), a.m(t, null), at(c, n, u), l && l.m(c, u), at(c, i, u);
    },
    p(c, u) {
      o === (o = s(c)) && a
        ? a.p(c, u)
        : (a.d(1), (a = o(c)), a && (a.c(), a.m(t, null))),
        u & 9 && (r = c[3](`connect.${c[0]}.sidebar.header`, { default: "" })),
        r
          ? l
            ? l.p(c, u)
            : ((l = W$(c)), l.c(), l.m(i.parentNode, i))
          : l && (l.d(1), (l = null));
    },
    d(c) {
      c && st(t), a.d(), c && st(n), l && l.d(c), c && st(i);
    },
  };
}
function WCe(e) {
  let t, n;
  return {
    c() {
      (t = new bv(!1)), (n = xi()), (t.a = n);
    },
    m(r, i) {
      t.m(LJ, r, i), at(r, n, i);
    },
    p: rt,
    d(r) {
      r && st(n), r && t.d();
    },
  };
}
function HCe(e) {
  let t, n;
  function r(o, a) {
    return (
      a & 4 && (t = null),
      t == null && (t = !!fO(o[2].logo || o[2].icon)),
      t ? GCe : VCe
    );
  }
  let i = r(e, -1),
    s = i(e);
  return {
    c() {
      s.c(), (n = xi());
    },
    m(o, a) {
      s.m(o, a), at(o, n, a);
    },
    p(o, a) {
      i === (i = r(o, a)) && s
        ? s.p(o, a)
        : (s.d(1), (s = i(o)), s && (s.c(), s.m(n.parentNode, n)));
    },
    d(o) {
      s.d(o), o && st(n);
    },
  };
}
function VCe(e) {
  let t, n;
  return {
    c() {
      (t = We("img")),
        By(t.src, (n = e[2].logo || e[2].icon)) || Se(t, "src", n),
        Se(t, "alt", "logo"),
        Se(t, "class", "svelte-obaru3");
    },
    m(r, i) {
      at(r, t, i);
    },
    p(r, i) {
      i & 4 && !By(t.src, (n = r[2].logo || r[2].icon)) && Se(t, "src", n);
    },
    d(r) {
      r && st(t);
    },
  };
}
function GCe(e) {
  let t,
    n = (e[2].logo || e[2].icon) + "",
    r;
  return {
    c() {
      (t = new bv(!1)), (r = hr("​")), (t.a = r);
    },
    m(i, s) {
      t.m(n, i, s), at(i, r, s);
    },
    p(i, s) {
      s & 4 && n !== (n = (i[2].logo || i[2].icon) + "") && t.p(n);
    },
    d(i) {
      i && t.d(), i && st(r);
    },
  };
}
function W$(e) {
  let t,
    n = e[3](`connect.${e[0]}.sidebar.header`, { default: e[7] }) + "",
    r;
  return {
    c() {
      (t = We("div")), (r = hr(n)), Se(t, "class", "heading svelte-obaru3");
    },
    m(i, s) {
      at(i, t, s), Te(t, r);
    },
    p(i, s) {
      s & 9 &&
        n !==
          (n =
            i[3](`connect.${i[0]}.sidebar.header`, { default: i[7] }) + "") &&
        zr(r, n);
    },
    d(i) {
      i && st(t);
    },
  };
}
function qCe(e) {
  let t,
    n =
      e[3]("connect.selectingWallet.sidebar.IDontHaveAWallet", {
        default: sr.connect.selectingWallet.sidebar.IDontHaveAWallet,
      }) + "",
    r,
    i,
    s;
  return {
    c() {
      (t = We("a")),
        (r = hr(n)),
        (i = qt()),
        (s = We("div")),
        Se(s, "class", "info-icon svelte-obaru3"),
        Se(
          t,
          "href",
          e[4].iDontHaveAWalletLink ||
            "https://ethereum.org/en/wallets/find-wallet/#main-content"
        ),
        Se(t, "target", "_blank"),
        Se(t, "rel", "noreferrer noopener"),
        Se(t, "class", "no-link svelte-obaru3");
    },
    m(o, a) {
      at(o, t, a), Te(t, r), Te(t, i), Te(t, s), (s.innerHTML = L8);
    },
    p(o, a) {
      a & 8 &&
        n !==
          (n =
            o[3]("connect.selectingWallet.sidebar.IDontHaveAWallet", {
              default: sr.connect.selectingWallet.sidebar.IDontHaveAWallet,
            }) + "") &&
        zr(r, n);
    },
    d(o) {
      o && st(t);
    },
  };
}
function H$(e) {
  let t, n, r, i, s, o, a, l, c, u, d, f;
  return {
    c() {
      (t = We("div")),
        (n = We("div")),
        (r = qt()),
        (i = We("div")),
        (o = qt()),
        (a = We("div")),
        (l = qt()),
        (c = We("div")),
        (d = qt()),
        (f = We("div")),
        Se(n, "class", "indicator relative svelte-obaru3"),
        Ft(n, "on", !0),
        Se(i, "class", "join relative svelte-obaru3"),
        Se(
          i,
          "style",
          (s = `${
            e[0] !== "selectingWallet"
              ? "right: 4px; width: 52px;"
              : "right: 2px; width: 54px;"
          }`)
        ),
        Ft(i, "active", e[0] !== "selectingWallet"),
        Se(a, "class", "indicator relative svelte-obaru3"),
        Se(a, "style", "right: 8px;"),
        Ft(a, "on", e[0] !== "selectingWallet"),
        Se(c, "class", "join relative svelte-obaru3"),
        Se(
          c,
          "style",
          (u = `${
            e[0] === "connectedWallet"
              ? "right: 12px; width: 52px;"
              : "right: 10px; width: 54px;"
          }`)
        ),
        Ft(c, "active", e[0] === "connectedWallet"),
        Se(f, "style", "right: 16px;"),
        Se(f, "class", "indicator relative svelte-obaru3"),
        Ft(f, "on", e[0] === "connectedWallet"),
        Se(t, "class", "indicators flex items-center svelte-obaru3");
    },
    m(h, p) {
      at(h, t, p),
        Te(t, n),
        Te(t, r),
        Te(t, i),
        Te(t, o),
        Te(t, a),
        Te(t, l),
        Te(t, c),
        Te(t, d),
        Te(t, f);
    },
    p(h, p) {
      p & 1 &&
        s !==
          (s = `${
            h[0] !== "selectingWallet"
              ? "right: 4px; width: 52px;"
              : "right: 2px; width: 54px;"
          }`) &&
        Se(i, "style", s),
        p & 1 && Ft(i, "active", h[0] !== "selectingWallet"),
        p & 1 && Ft(a, "on", h[0] !== "selectingWallet"),
        p & 1 &&
          u !==
            (u = `${
              h[0] === "connectedWallet"
                ? "right: 12px; width: 52px;"
                : "right: 10px; width: 54px;"
            }`) &&
          Se(c, "style", u),
        p & 1 && Ft(c, "active", h[0] === "connectedWallet"),
        p & 1 && Ft(f, "on", h[0] === "connectedWallet");
    },
    d(h) {
      h && st(t);
    },
  };
}
function V$(e) {
  let t, n, r, i, s, o, a, l, c, u, d, f;
  return {
    c() {
      (t = We("div")),
        (n = We("div")),
        (r = qt()),
        (i = We("div")),
        (o = qt()),
        (a = We("div")),
        (l = qt()),
        (c = We("div")),
        (d = qt()),
        (f = We("div")),
        Se(n, "class", "indicator relative svelte-obaru3"),
        Ft(n, "on", !0),
        Se(i, "class", "join relative svelte-obaru3"),
        Se(
          i,
          "style",
          (s = `right: 2px; ${
            e[0] !== "selectingWallet" ? "width: 78px;" : "width: 82px;"
          }`)
        ),
        Ft(i, "active", e[0] !== "selectingWallet"),
        Se(a, "class", "indicator relative svelte-obaru3"),
        Se(a, "style", "right: 4px;"),
        Ft(a, "on", e[0] !== "selectingWallet"),
        Se(c, "class", "join relative svelte-obaru3"),
        Se(
          c,
          "style",
          (u = `right: 6px; ${
            e[0] === "connectedWallet" ? "width: 74px;" : "width: 81px;"
          }`)
        ),
        Ft(c, "active", e[0] === "connectedWallet"),
        Se(f, "style", "right: 8px;"),
        Se(f, "class", "indicator relative svelte-obaru3"),
        Ft(f, "on", e[0] === "connectedWallet"),
        Se(t, "class", "indicators flex items-center svelte-obaru3");
    },
    m(h, p) {
      at(h, t, p),
        Te(t, n),
        Te(t, r),
        Te(t, i),
        Te(t, o),
        Te(t, a),
        Te(t, l),
        Te(t, c),
        Te(t, d),
        Te(t, f);
    },
    p(h, p) {
      p & 1 &&
        s !==
          (s = `right: 2px; ${
            h[0] !== "selectingWallet" ? "width: 78px;" : "width: 82px;"
          }`) &&
        Se(i, "style", s),
        p & 1 && Ft(i, "active", h[0] !== "selectingWallet"),
        p & 1 && Ft(a, "on", h[0] !== "selectingWallet"),
        p & 1 &&
          u !==
            (u = `right: 6px; ${
              h[0] === "connectedWallet" ? "width: 74px;" : "width: 81px;"
            }`) &&
          Se(c, "style", u),
        p & 1 && Ft(c, "active", h[0] === "connectedWallet"),
        p & 1 && Ft(f, "on", h[0] === "connectedWallet");
    },
    d(h) {
      h && st(t);
    },
  };
}
function KCe(e) {
  let t,
    n,
    r,
    i,
    s = e[3](`connect.${e[0]}.sidebar.subheading`, { default: e[5] }) + "",
    o,
    a,
    l,
    c =
      e[3](`connect.${e[0]}.sidebar.paragraph`, {
        values: { app: (e[2] && e[2].name) || "This App" },
        default: e[6],
      }) + "",
    u,
    d,
    f,
    h,
    p,
    g,
    b,
    v;
  Na(e[9]);
  let w = e[1] >= zs && z$(e),
    x = !e[4].removeIDontHaveAWalletInfoLink && qCe(e),
    S = e[1] < zs && H$(e),
    R = e[1] >= zs && V$(e);
  return {
    c() {
      (t = We("div")),
        (n = We("div")),
        w && w.c(),
        (r = qt()),
        (i = We("div")),
        (o = hr(s)),
        (a = qt()),
        (l = We("div")),
        (u = hr(c)),
        (d = qt()),
        x && x.c(),
        (f = qt()),
        S && S.c(),
        (h = qt()),
        R && R.c(),
        (p = qt()),
        (g = We("div")),
        Se(i, "class", "subheading svelte-obaru3"),
        Se(l, "class", "description svelte-obaru3"),
        Se(n, "class", "inner-container svelte-obaru3"),
        Se(t, "class", "sidebar svelte-obaru3");
    },
    m(O, B) {
      at(O, t, B),
        Te(t, n),
        w && w.m(n, null),
        Te(n, r),
        Te(n, i),
        Te(i, o),
        Te(n, a),
        Te(n, l),
        Te(l, u),
        Te(n, d),
        x && x.m(n, null),
        Te(n, f),
        S && S.m(n, null),
        Te(t, h),
        R && R.m(t, null),
        Te(t, p),
        Te(t, g),
        (g.innerHTML = AEe),
        b || ((v = ll(window, "resize", e[9])), (b = !0));
    },
    p(O, [B]) {
      O[1] >= zs
        ? w
          ? w.p(O, B)
          : ((w = z$(O)), w.c(), w.m(n, r))
        : w && (w.d(1), (w = null)),
        B & 9 &&
          s !==
            (s =
              O[3](`connect.${O[0]}.sidebar.subheading`, { default: O[5] }) +
              "") &&
          zr(o, s),
        B & 13 &&
          c !==
            (c =
              O[3](`connect.${O[0]}.sidebar.paragraph`, {
                values: { app: (O[2] && O[2].name) || "This App" },
                default: O[6],
              }) + "") &&
          zr(u, c),
        O[4].removeIDontHaveAWalletInfoLink || x.p(O, B),
        O[1] < zs
          ? S
            ? S.p(O, B)
            : ((S = H$(O)), S.c(), S.m(n, null))
          : S && (S.d(1), (S = null)),
        O[1] >= zs
          ? R
            ? R.p(O, B)
            : ((R = V$(O)), R.c(), R.m(t, p))
          : R && (R.d(1), (R = null));
    },
    i: rt,
    o: rt,
    d(O) {
      O && st(t), w && w.d(), x && x.d(), S && S.d(), R && R.d(), (b = !1), v();
    },
  };
}
function YCe(e, t, n) {
  let r, i;
  is(e, _h, (p) => n(3, (i = p)));
  let { step: s } = t;
  const { connect: o } = Pn.get(),
    a = sr.connect[s].sidebar,
    { subheading: l, paragraph: c } = a,
    { heading: u } = a;
  let d;
  const f = Pn.select("appMetadata").pipe(bd(Pn.get().appMetadata), Rd(1));
  is(e, f, (p) => n(2, (r = p)));
  function h() {
    n(1, (d = window.innerWidth));
  }
  return (
    (e.$$set = (p) => {
      "step" in p && n(0, (s = p.step));
    }),
    [s, d, r, i, o, l, c, u, f, h]
  );
}
class ZCe extends co {
  constructor(t) {
    super(), lo(this, t, YCe, KCe, oo, { step: 0 }, zCe);
  }
}
function QCe(e) {
  ao(
    e,
    "svelte-1qwmck3",
    `.container.svelte-1qwmck3{--background-color:var(
      --onboard-main-scroll-container-background,
      var(--w3o-background-color)
    );--foreground-color:var(--w3o-foreground-color);--text-color:var(--onboard-connect-text-color, var(--w3o-text-color));--border-color:var(--w3o-border-color, var(--gray-200));--action-color:var(--w3o-action-color, var(--primary-500));font-family:var(--onboard-font-family-normal, var(--font-family-normal));font-size:var(--onboard-font-size-5, 1rem);background:var(--background-color);color:var(--text-color);border-color:var(--border-color);line-height:24px;overflow:hidden;position:relative;display:flex;height:min-content;flex-flow:column-reverse}.content.svelte-1qwmck3{width:var(--onboard-connect-content-width, 100%)}.header.svelte-1qwmck3{display:flex;padding:1rem;border-bottom:1px solid transparent;background:var(--onboard-connect-header-background);color:var(--onboard-connect-header-color);border-color:var(--border-color)}.header-heading.svelte-1qwmck3{line-height:1rem}.button-container.svelte-1qwmck3{right:0.5rem;top:0.5rem}.mobile-header.svelte-1qwmck3{display:flex;gap:0.5rem;height:4.5rem;padding:1rem;border-bottom:1px solid;border-color:var(--border-color)}.mobile-subheader.svelte-1qwmck3{opacity:0.6;font-size:0.875rem;font-weight:400;line-height:1rem;margin-top:0.25rem}.icon-container.svelte-1qwmck3{display:flex;flex:0 0 auto;height:2.5rem;width:2.5rem;min-width:2.5rem;justify-content:center;align-items:center}.disabled.svelte-1qwmck3{opacity:0.2;pointer-events:none;overflow:hidden}.icon-container svg{display:block;height:100%;width:auto}.w-full.svelte-1qwmck3{width:100%}.scroll-container.svelte-1qwmck3{overflow-y:auto;transition:opacity 250ms ease-in-out;scrollbar-width:none}.scroll-container.svelte-1qwmck3::-webkit-scrollbar{display:none}@media all and (min-width: 768px){.container.svelte-1qwmck3{margin:0;flex-flow:row;height:var(--onboard-connect-content-height, 440px)}.content.svelte-1qwmck3{width:var(--onboard-connect-content-width, 488px)}.mobile-subheader.svelte-1qwmck3{display:none}.icon-container.svelte-1qwmck3{display:none}}`
  );
}
function G$(e) {
  let t, n;
  return (
    (t = new IO({
      props: {
        close: !e[16].disableClose && e[20],
        $$slots: { default: [l7e] },
        $$scope: { ctx: e },
      },
    })),
    {
      c() {
        pr(t.$$.fragment);
      },
      m(r, i) {
        or(t, r, i), (n = !0);
      },
      p(r, i) {
        const s = {};
        (i[0] & 32766) | (i[1] & 32) && (s.$$scope = { dirty: i, ctx: r }),
          t.$set(s);
      },
      i(r) {
        n || (Ke(t.$$.fragment, r), (n = !0));
      },
      o(r) {
        ot(t.$$.fragment, r), (n = !1);
      },
      d(r) {
        ar(t, r);
      },
    }
  );
}
function XCe(e) {
  let t, n;
  return (
    (t = new ZCe({ props: { step: e[5] } })),
    {
      c() {
        pr(t.$$.fragment);
      },
      m(r, i) {
        or(t, r, i), (n = !0);
      },
      p(r, i) {
        const s = {};
        i[0] & 32 && (s.step = r[5]), t.$set(s);
      },
      i(r) {
        n || (Ke(t.$$.fragment, r), (n = !0));
      },
      o(r) {
        ot(t.$$.fragment, r), (n = !1);
      },
      d(r) {
        ar(t, r);
      },
    }
  );
}
function JCe(e) {
  let t,
    n,
    r =
      e[14](`connect.${e[5]}.header`, {
        default: sr.connect[e[5]].header,
        values: { connectionRejected: e[1], wallet: e[3] && e[3].label },
      }) + "",
    i,
    s,
    o = e[5] === "selectingWallet" ? `(${e[12]})` : "",
    a;
  return {
    c() {
      (t = We("div")),
        (n = We("div")),
        (i = hr(r)),
        (s = qt()),
        (a = hr(o)),
        Se(n, "class", "header-heading svelte-1qwmck3"),
        Se(t, "class", "header relative flex items-center svelte-1qwmck3");
    },
    m(l, c) {
      at(l, t, c), Te(t, n), Te(n, i), Te(n, s), Te(n, a);
    },
    p(l, c) {
      c[0] & 16426 &&
        r !==
          (r =
            l[14](`connect.${l[5]}.header`, {
              default: sr.connect[l[5]].header,
              values: { connectionRejected: l[1], wallet: l[3] && l[3].label },
            }) + "") &&
        zr(i, r),
        c[0] & 4128 &&
          o !== (o = l[5] === "selectingWallet" ? `(${l[12]})` : "") &&
          zr(a, o);
    },
    d(l) {
      l && st(t);
    },
  };
}
function e7e(e) {
  let t,
    n,
    r,
    i,
    s,
    o =
      e[14](
        e[5] === "connectingWallet" && e[3]
          ? `connect.${e[5]}.header`
          : `connect.${e[5]}.sidebar.subheading`,
        {
          default:
            e[5] === "connectingWallet" && e[3]
              ? sr.connect[e[5]].header
              : sr.connect[e[5]].sidebar.subheading,
          values: { connectionRejected: e[1], wallet: e[3] && e[3].label },
        }
      ) + "",
    a,
    l,
    c,
    u =
      e[5] === "selectingWallet"
        ? `${e[12]} available wallets`
        : "1 account selected",
    d;
  function f(g, b) {
    return g[13] && g[13].icon ? n7e : t7e;
  }
  let h = f(e),
    p = h(e);
  return {
    c() {
      (t = We("div")),
        (n = We("div")),
        p.c(),
        (r = qt()),
        (i = We("div")),
        (s = We("div")),
        (a = hr(o)),
        (l = qt()),
        (c = We("div")),
        (d = hr(u)),
        Se(n, "class", "icon-container svelte-1qwmck3"),
        Se(s, "class", "header-heading svelte-1qwmck3"),
        Se(c, "class", "mobile-subheader svelte-1qwmck3"),
        Se(i, "class", "flex flex-column justify-center w-full svelte-1qwmck3"),
        Se(t, "class", "mobile-header svelte-1qwmck3");
    },
    m(g, b) {
      at(g, t, b),
        Te(t, n),
        p.m(n, null),
        Te(t, r),
        Te(t, i),
        Te(i, s),
        Te(s, a),
        Te(i, l),
        Te(i, c),
        Te(c, d);
    },
    p(g, b) {
      h === (h = f(g)) && p
        ? p.p(g, b)
        : (p.d(1), (p = h(g)), p && (p.c(), p.m(n, null))),
        b[0] & 16426 &&
          o !==
            (o =
              g[14](
                g[5] === "connectingWallet" && g[3]
                  ? `connect.${g[5]}.header`
                  : `connect.${g[5]}.sidebar.subheading`,
                {
                  default:
                    g[5] === "connectingWallet" && g[3]
                      ? sr.connect[g[5]].header
                      : sr.connect[g[5]].sidebar.subheading,
                  values: {
                    connectionRejected: g[1],
                    wallet: g[3] && g[3].label,
                  },
                }
              ) + "") &&
          zr(a, o),
        b[0] & 4128 &&
          u !==
            (u =
              g[5] === "selectingWallet"
                ? `${g[12]} available wallets`
                : "1 account selected") &&
          zr(d, u);
    },
    d(g) {
      g && st(t), p.d();
    },
  };
}
function t7e(e) {
  let t, n;
  return {
    c() {
      (t = new bv(!1)), (n = xi()), (t.a = n);
    },
    m(r, i) {
      t.m(LJ, r, i), at(r, n, i);
    },
    p: rt,
    d(r) {
      r && st(n), r && t.d();
    },
  };
}
function n7e(e) {
  let t, n;
  function r(o, a) {
    return (
      a[0] & 8192 && (t = null),
      t == null && (t = !!fO(o[13].icon)),
      t ? i7e : r7e
    );
  }
  let i = r(e, [-1, -1]),
    s = i(e);
  return {
    c() {
      s.c(), (n = xi());
    },
    m(o, a) {
      s.m(o, a), at(o, n, a);
    },
    p(o, a) {
      i === (i = r(o, a)) && s
        ? s.p(o, a)
        : (s.d(1), (s = i(o)), s && (s.c(), s.m(n.parentNode, n)));
    },
    d(o) {
      s.d(o), o && st(n);
    },
  };
}
function r7e(e) {
  let t, n;
  return {
    c() {
      (t = We("img")),
        By(t.src, (n = e[13].icon)) || Se(t, "src", n),
        Se(t, "alt", "logo");
    },
    m(r, i) {
      at(r, t, i);
    },
    p(r, i) {
      i[0] & 8192 && !By(t.src, (n = r[13].icon)) && Se(t, "src", n);
    },
    d(r) {
      r && st(t);
    },
  };
}
function i7e(e) {
  let t,
    n = e[13].icon + "",
    r;
  return {
    c() {
      (t = new bv(!1)), (r = xi()), (t.a = r);
    },
    m(i, s) {
      t.m(n, i, s), at(i, r, s);
    },
    p(i, s) {
      s[0] & 8192 && n !== (n = i[13].icon + "") && t.p(n);
    },
    d(i) {
      i && st(r), i && t.d();
    },
  };
}
function s7e(e) {
  let t, n, r, i, s;
  return (
    (n = new Mee({})),
    {
      c() {
        (t = We("div")),
          pr(n.$$.fragment),
          Se(t, "class", "button-container absolute svelte-1qwmck3");
      },
      m(o, a) {
        at(o, t, a),
          or(n, t, null),
          (r = !0),
          i || ((s = ll(t, "click", e[20])), (i = !0));
      },
      p: rt,
      i(o) {
        r || (Ke(n.$$.fragment, o), (r = !0));
      },
      o(o) {
        ot(n.$$.fragment, o), (r = !1);
      },
      d(o) {
        o && st(t), ar(n), (i = !1), s();
      },
    }
  );
}
function q$(e) {
  let t, n, r, i;
  const s = [a7e, o7e],
    o = [];
  function a(l, c) {
    return l[2].length ? 0 : 1;
  }
  return (
    (t = a(e)),
    (n = o[t] = s[t](e)),
    {
      c() {
        n.c(), (r = xi());
      },
      m(l, c) {
        o[t].m(l, c), at(l, r, c), (i = !0);
      },
      p(l, c) {
        let u = t;
        (t = a(l)),
          t === u
            ? o[t].p(l, c)
            : (zi(),
              ot(o[u], 1, 1, () => {
                o[u] = null;
              }),
              Wi(),
              (n = o[t]),
              n ? n.p(l, c) : ((n = o[t] = s[t](l)), n.c()),
              Ke(n, 1),
              n.m(r.parentNode, r));
      },
      i(l) {
        i || (Ke(n), (i = !0));
      },
      o(l) {
        ot(n), (i = !1);
      },
      d(l) {
        o[t].d(l), l && st(r);
      },
    }
  );
}
function o7e(e) {
  let t, n;
  return (
    (t = new MCe({})),
    {
      c() {
        pr(t.$$.fragment);
      },
      m(r, i) {
        or(t, r, i), (n = !0);
      },
      p: rt,
      i(r) {
        n || (Ke(t.$$.fragment, r), (n = !0));
      },
      o(r) {
        ot(t.$$.fragment, r), (n = !1);
      },
      d(r) {
        ar(t, r);
      },
    }
  );
}
function a7e(e) {
  let t, n, r, i, s, o;
  function a(c) {
    e[24](c);
  }
  let l = {};
  return (
    e[7] !== void 0 && (l.agreed = e[7]),
    (t = new $Ae({ props: l })),
    R5.push(() => p9e(t, "agreed", a)),
    (s = new $Ce({
      props: {
        selectWallet: e[18],
        wallets: e[2],
        connectingWalletLabel: e[8],
        connectingErrorMessage: e[9],
      },
    })),
    {
      c() {
        pr(t.$$.fragment),
          (r = qt()),
          (i = We("div")),
          pr(s.$$.fragment),
          Se(i, "class", "svelte-1qwmck3"),
          Ft(i, "disabled", !e[7]);
      },
      m(c, u) {
        or(t, c, u), at(c, r, u), at(c, i, u), or(s, i, null), (o = !0);
      },
      p(c, u) {
        const d = {};
        !n && u[0] & 128 && ((n = !0), (d.agreed = c[7]), u9e(() => (n = !1))),
          t.$set(d);
        const f = {};
        u[0] & 4 && (f.wallets = c[2]),
          u[0] & 256 && (f.connectingWalletLabel = c[8]),
          u[0] & 512 && (f.connectingErrorMessage = c[9]),
          s.$set(f),
          (!o || u[0] & 128) && Ft(i, "disabled", !c[7]);
      },
      i(c) {
        o || (Ke(t.$$.fragment, c), Ke(s.$$.fragment, c), (o = !0));
      },
      o(c) {
        ot(t.$$.fragment, c), ot(s.$$.fragment, c), (o = !1);
      },
      d(c) {
        ar(t, c), c && st(r), c && st(i), ar(s);
      },
    }
  );
}
function K$(e) {
  let t, n;
  return (
    (t = new _Ce({
      props: {
        connectWallet: e[21],
        connectionRejected: e[1],
        previousConnectionRequest: e[6],
        setStep: e[22],
        deselectWallet: e[19],
        selectedWallet: e[3],
      },
    })),
    {
      c() {
        pr(t.$$.fragment);
      },
      m(r, i) {
        or(t, r, i), (n = !0);
      },
      p(r, i) {
        const s = {};
        i[0] & 2 && (s.connectionRejected = r[1]),
          i[0] & 64 && (s.previousConnectionRequest = r[6]),
          i[0] & 8 && (s.selectedWallet = r[3]),
          t.$set(s);
      },
      i(r) {
        n || (Ke(t.$$.fragment, r), (n = !0));
      },
      o(r) {
        ot(t.$$.fragment, r), (n = !1);
      },
      d(r) {
        ar(t, r);
      },
    }
  );
}
function Y$(e) {
  let t, n;
  return (
    (t = new gCe({ props: { selectedWallet: e[3] } })),
    {
      c() {
        pr(t.$$.fragment);
      },
      m(r, i) {
        or(t, r, i), (n = !0);
      },
      p(r, i) {
        const s = {};
        i[0] & 8 && (s.selectedWallet = r[3]), t.$set(s);
      },
      i(r) {
        n || (Ke(t.$$.fragment, r), (n = !0));
      },
      o(r) {
        ot(t.$$.fragment, r), (n = !1);
      },
      d(r) {
        ar(t, r);
      },
    }
  );
}
function l7e(e) {
  let t,
    n,
    r,
    i,
    s,
    o,
    a,
    l,
    c,
    u = e[16].showSidebar && XCe(e);
  function d(w, x) {
    return w[4] <= zs ? e7e : JCe;
  }
  let f = d(e),
    h = f(e),
    p = !e[16].disableClose && s7e(e),
    g = (e[5] === "selectingWallet" || e[4] <= zs) && q$(e),
    b = e[11] && K$(e),
    v = e[5] === "connectedWallet" && e[3] && e[4] >= zs && Y$(e);
  return {
    c() {
      (t = We("div")),
        u && u.c(),
        (n = qt()),
        (r = We("div")),
        h.c(),
        (i = qt()),
        p && p.c(),
        (s = qt()),
        (o = We("div")),
        g && g.c(),
        (a = qt()),
        b && b.c(),
        (l = qt()),
        v && v.c(),
        Se(o, "class", "scroll-container svelte-1qwmck3"),
        Se(r, "class", "content flex flex-column svelte-1qwmck3"),
        Se(t, "class", "container svelte-1qwmck3");
    },
    m(w, x) {
      at(w, t, x),
        u && u.m(t, null),
        Te(t, n),
        Te(t, r),
        h.m(r, null),
        Te(r, i),
        p && p.m(r, null),
        Te(r, s),
        Te(r, o),
        g && g.m(o, null),
        Te(o, a),
        b && b.m(o, null),
        Te(o, l),
        v && v.m(o, null),
        e[25](o),
        (c = !0);
    },
    p(w, x) {
      w[16].showSidebar && u.p(w, x),
        f === (f = d(w)) && h
          ? h.p(w, x)
          : (h.d(1), (h = f(w)), h && (h.c(), h.m(r, i))),
        w[16].disableClose || p.p(w, x),
        w[5] === "selectingWallet" || w[4] <= zs
          ? g
            ? (g.p(w, x), x[0] & 48 && Ke(g, 1))
            : ((g = q$(w)), g.c(), Ke(g, 1), g.m(o, a))
          : g &&
            (zi(),
            ot(g, 1, 1, () => {
              g = null;
            }),
            Wi()),
        w[11]
          ? b
            ? (b.p(w, x), x[0] & 2048 && Ke(b, 1))
            : ((b = K$(w)), b.c(), Ke(b, 1), b.m(o, l))
          : b &&
            (zi(),
            ot(b, 1, 1, () => {
              b = null;
            }),
            Wi()),
        w[5] === "connectedWallet" && w[3] && w[4] >= zs
          ? v
            ? (v.p(w, x), x[0] & 56 && Ke(v, 1))
            : ((v = Y$(w)), v.c(), Ke(v, 1), v.m(o, null))
          : v &&
            (zi(),
            ot(v, 1, 1, () => {
              v = null;
            }),
            Wi());
    },
    i(w) {
      c || (Ke(u), Ke(p), Ke(g), Ke(b), Ke(v), (c = !0));
    },
    o(w) {
      ot(u), ot(p), ot(g), ot(b), ot(v), (c = !1);
    },
    d(w) {
      w && st(t),
        u && u.d(),
        h.d(),
        p && p.d(),
        g && g.d(),
        b && b.d(),
        v && v.d(),
        e[25](null);
    },
  };
}
function c7e(e) {
  let t, n, r, i;
  Na(e[23]);
  let s = !e[0].disableModals && G$(e);
  return {
    c() {
      s && s.c(), (t = xi());
    },
    m(o, a) {
      s && s.m(o, a),
        at(o, t, a),
        (n = !0),
        r || ((i = ll(window, "resize", e[23])), (r = !0));
    },
    p(o, a) {
      o[0].disableModals
        ? s &&
          (zi(),
          ot(s, 1, 1, () => {
            s = null;
          }),
          Wi())
        : s
        ? (s.p(o, a), a[0] & 1 && Ke(s, 1))
        : ((s = G$(o)), s.c(), Ke(s, 1), s.m(t.parentNode, t));
    },
    i(o) {
      n || (Ke(s), (n = !0));
    },
    o(o) {
      ot(s), (n = !1);
    },
    d(o) {
      s && s.d(o), o && st(t), (r = !1), i();
    },
  };
}
function u7e(e, t, n) {
  let r, i, s, o, a;
  is(e, _h, (K) => n(14, (a = K)));
  let { autoSelect: l } = t;
  const c = Pn.select("appMetadata").pipe(bd(Pn.get().appMetadata), Rd(1));
  is(e, c, (K) => n(13, (s = K)));
  const { walletModules: u, connect: d, chains: f } = Pn.get(),
    h = new xh(),
    { unstoppableResolution: p, wagmi: g } = Sa;
  let b = !1,
    v = !1,
    w = [],
    x,
    S,
    R,
    O,
    B,
    C;
  const I = new jx("selectingWallet");
  is(e, I, (K) => n(5, (o = K))),
    du
      .pipe(
        nJ(
          (K, re) =>
            K.autoSelect &&
            re.autoSelect &&
            K.autoSelect.disableModals === re.autoSelect.disableModals
        ),
        Oy(({ autoSelect: K }) => K && K.disableModals === !1),
        yb(M$)
      )
      .subscribe(() => {
        x && N();
      });
  async function P({ label: K, icon: re, getInterface: G }) {
    n(8, (R = K));
    try {
      const ne = Pn.get().wallets.find((_e) => _e.label === K);
      if (ne) {
        JT(ne), setTimeout(() => F("connectedWallet"), 1), n(3, (x = ne));
        return;
      }
      const { chains: ae } = Pn.get(),
        { provider: le, instance: ge } = await G({
          chains: ae,
          EventEmitter: xR,
          appMetadata: s,
        }),
        Oe = await re;
      n(
        3,
        (x = {
          label: K,
          icon: Oe,
          provider: le,
          instance: ge,
          accounts: [],
          chains: [{ namespace: "evm", id: "0x1" }],
        })
      ),
        n(9, (O = "")),
        D(),
        setTimeout(() => F("connectingWallet"), 1);
    } catch (ne) {
      const { message: ae } = ne;
      n(9, (O = ae)), n(8, (R = "")), D();
    }
  }
  function M() {
    n(3, (x = null));
  }
  function k(K) {
    n(3, (x = Object.assign(Object.assign({}, x), K)));
  }
  async function T(K) {
    const { getIcon: re, getInterface: G, label: ne } = K,
      ae = re();
    P({ label: ne, icon: ae, getInterface: G });
  }
  async function _() {
    n(
      2,
      (w = u.map(({ getIcon: K, getInterface: re, label: G }) => ({
        label: G,
        icon: K(),
        getInterface: re,
      })))
    );
  }
  function A() {
    du.next({ inProgress: !1 });
  }
  async function N() {
    n(1, (b = !1));
    const { provider: K, label: re } = x;
    h.next();
    try {
      let G, ne;
      if (g) {
        const {
            buildWagmiConfig: ge,
            wagmiConnect: Oe,
            getWagmiConnector: _e,
          } = g,
          Ee = await ge(f, { label: re, provider: K });
        Eee(Ee), (ne = _e(re));
        const He = await Promise.race([
          Oe(Ee, { connector: ne }),
          gb(h.pipe(gC([]))),
        ]);
        if (!He || !("accounts" in He)) return;
        const [je] = He.accounts;
        G = je;
      } else {
        const [ge] = await Promise.race([Aee(K), gb(h.pipe(gC([])))]);
        if (!ge) return;
        G = ge;
      }
      if (
        Pn.get().connect.autoConnectLastWallet ||
        Pn.get().connect.autoConnectAllPreviousWallet
      ) {
        let ge = j8(xd.LAST_CONNECTED_WALLET);
        try {
          let Oe = JSON.parse(ge);
          if (Oe && Array.isArray(Oe)) {
            const _e = Oe;
            ge = [...new Set([re, ..._e])];
          }
        } catch (Oe) {
          if (Oe instanceof SyntaxError && ge && typeof ge == "string")
            ge = [ge];
          else throw new Error(Oe);
        }
        ge || (ge = [re]), D8(xd.LAST_CONNECTED_WALLET, JSON.stringify(ge));
      }
      const ae = await Cee(K),
        le = {
          accounts: [{ address: G, ens: null, uns: null, balance: null }],
          chains: [{ namespace: "evm", id: ae }],
          wagmiConnector: ne,
        };
      JT(Object.assign(Object.assign({}, x), le)),
        gAe(K, re),
        k(le),
        F("connectedWallet"),
        D();
    } catch (G) {
      const { code: ne } = G;
      if ((D(), ne === Fp.ACCOUNT_ACCESS_REJECTED)) {
        n(1, (b = !0)),
          l.disableModals
            ? du.next({ inProgress: !1 })
            : l.label && n(0, (l.label = ""), l);
        return;
      }
      if (ne === Fp.ACCOUNT_ACCESS_ALREADY_REQUESTED) {
        if ((n(6, (v = !0)), l.disableModals)) {
          du.next({ inProgress: !1 });
          return;
        }
        kee({
          provider: x.provider,
          disconnected$: du.pipe(
            Oy(({ inProgress: ae }) => !ae),
            gC("")
          ),
        })
          .pipe(nO(1))
          .subscribe(([ae]) => {
            ae && N();
          });
        return;
      }
    }
  }
  async function L() {
    const { accounts: K, chains: re } = x,
      G = Pn.get().chains,
      [ne] = re,
      ae = G.find(
        ({ namespace: He, id: je }) => He === ne.namespace && je === ne.id
      ),
      { address: le } = K[0];
    let { balance: ge, ens: Oe, uns: _e, secondaryTokens: Ee } = K[0];
    if (
      (ge === null &&
        L5(le, ae).then((He) => {
          X2(x.label, le, { balance: He });
        }),
      ae &&
        !Ee &&
        Array.isArray(ae.secondaryTokens) &&
        ae.secondaryTokens.length &&
        P5(le, ae).then((He) => {
          X2(x.label, le, { secondaryTokens: He });
        }),
      Oe === null && T5(ne.id))
    ) {
      const He = f.find(({ id: je }) => je === T5(ne.id));
      eM(le, He).then((je) => {
        X2(x.label, le, { ens: je });
      });
    }
    _e === null &&
      p &&
      tM(le, ae).then((He) => {
        X2(x.label, le, { uns: He });
      }),
      setTimeout(() => du.next({ inProgress: !1 }), 1500);
  }
  I.pipe(yb(M$)).subscribe((K) => {
    switch (K) {
      case "selectingWallet": {
        if (l.label) {
          const re = u.find(
            ({ label: G }) => G.toLowerCase() === l.label.toLowerCase()
          );
          re ? T(re) : l.disableModals && du.next({ inProgress: !1 });
        } else n(8, (R = "")), _();
        break;
      }
      case "connectingWallet": {
        N();
        break;
      }
      case "connectedWallet": {
        n(8, (R = "")), L();
        break;
      }
    }
  });
  function F(K) {
    h.next(), I.next(K);
  }
  function D() {
    C && C.scrollTo(0, 0);
  }
  function j() {
    n(4, (B = window.innerWidth));
  }
  function z(K) {
    (S = K), n(7, S);
  }
  function $(K) {
    R5[K ? "unshift" : "push"](() => {
      (C = K), n(10, C);
    });
  }
  return (
    (e.$$set = (K) => {
      "autoSelect" in K && n(0, (l = K.autoSelect));
    }),
    (e.$$.update = () => {
      e.$$.dirty[0] & 4 && n(12, (r = w.length - Pn.get().wallets.length)),
        e.$$.dirty[0] & 58 &&
          n(
            11,
            (i =
              (o === "connectingWallet" && x && B >= zs) ||
              (B <= zs && b && o === "connectingWallet" && x))
          );
    }),
    [
      l,
      b,
      w,
      x,
      B,
      o,
      v,
      S,
      R,
      O,
      C,
      i,
      r,
      s,
      a,
      c,
      d,
      I,
      P,
      M,
      A,
      N,
      F,
      j,
      z,
      $,
    ]
  );
}
class d7e extends co {
  constructor(t) {
    super(), lo(this, t, u7e, c7e, oo, { autoSelect: 0 }, QCe, [-1, -1]);
  }
}
function f7e(e) {
  ao(
    e,
    "svelte-12yam41",
    ".container.svelte-12yam41{padding:var(--onboard-spacing-4, var(--spacing-4));font-family:var(--onboard-font-family-normal, var(--font-family-normal));line-height:16px;font-size:var(--onboard-font-size-5, var(--font-size-5))}.close.svelte-12yam41{top:var(--onboard-spacing-5, var(--spacing-5));right:var(--onboard-spacing-5, var(--spacing-5));padding:0.5rem}h4.svelte-12yam41{font-size:var(--onboard-font-size-3, var(--font-size-3));margin:var(--onboard-spacing-4, var(--spacing-4)) 0}p.svelte-12yam41{margin:0 0 var(--onboard-spacing-4, var(--spacing-4)) 0;max-width:488px}"
  );
}
function h7e(e) {
  let t,
    n,
    r =
      e[0]("modals.switchChain.heading", {
        default: sr.modals.switchChain.heading,
      }) + "",
    i,
    s,
    o,
    a =
      e[0]("modals.switchChain.paragraph1", {
        default: sr.modals.switchChain.paragraph1,
        values: {
          app: (e[1] && e[1].name) || "This app",
          nextNetworkName: e[2],
        },
      }) + "",
    l,
    c,
    u,
    d =
      e[0]("modals.switchChain.paragraph2", {
        default: sr.modals.switchChain.paragraph2,
      }) + "",
    f,
    h,
    p,
    g,
    b,
    v,
    w;
  return (
    (g = new Mee({})),
    {
      c() {
        (t = We("div")),
          (n = We("h4")),
          (i = hr(r)),
          (s = qt()),
          (o = We("p")),
          (l = hr(a)),
          (c = qt()),
          (u = We("p")),
          (f = hr(d)),
          (h = qt()),
          (p = We("div")),
          pr(g.$$.fragment),
          Se(n, "class", "svelte-12yam41"),
          Se(o, "class", "svelte-12yam41"),
          Se(u, "class", "svelte-12yam41"),
          Se(p, "class", "close absolute svelte-12yam41"),
          Se(t, "class", "container relative svelte-12yam41");
      },
      m(x, S) {
        at(x, t, S),
          Te(t, n),
          Te(n, i),
          Te(t, s),
          Te(t, o),
          Te(o, l),
          Te(t, c),
          Te(t, u),
          Te(u, f),
          Te(t, h),
          Te(t, p),
          or(g, p, null),
          (b = !0),
          v || ((w = ll(p, "click", e[3])), (v = !0));
      },
      p(x, S) {
        (!b || S & 1) &&
          r !==
            (r =
              x[0]("modals.switchChain.heading", {
                default: sr.modals.switchChain.heading,
              }) + "") &&
          zr(i, r),
          (!b || S & 3) &&
            a !==
              (a =
                x[0]("modals.switchChain.paragraph1", {
                  default: sr.modals.switchChain.paragraph1,
                  values: {
                    app: (x[1] && x[1].name) || "This app",
                    nextNetworkName: x[2],
                  },
                }) + "") &&
            zr(l, a),
          (!b || S & 1) &&
            d !==
              (d =
                x[0]("modals.switchChain.paragraph2", {
                  default: sr.modals.switchChain.paragraph2,
                }) + "") &&
            zr(f, d);
      },
      i(x) {
        b || (Ke(g.$$.fragment, x), (b = !0));
      },
      o(x) {
        ot(g.$$.fragment, x), (b = !1);
      },
      d(x) {
        x && st(t), ar(g), (v = !1), w();
      },
    }
  );
}
function p7e(e) {
  let t, n;
  return (
    (t = new IO({
      props: { close: e[3], $$slots: { default: [h7e] }, $$scope: { ctx: e } },
    })),
    {
      c() {
        pr(t.$$.fragment);
      },
      m(r, i) {
        or(t, r, i), (n = !0);
      },
      p(r, [i]) {
        const s = {};
        i & 67 && (s.$$scope = { dirty: i, ctx: r }), t.$set(s);
      },
      i(r) {
        n || (Ke(t.$$.fragment, r), (n = !0));
      },
      o(r) {
        ot(t.$$.fragment, r), (n = !1);
      },
      d(r) {
        ar(t, r);
      },
    }
  );
}
function m7e(e, t, n) {
  let r, i, s;
  is(e, Fy, (c) => n(5, (r = c))), is(e, _h, (c) => n(0, (i = c)));
  const o = r.chain.label;
  function a() {
    Fy.next(null);
  }
  const l = Pn.select("appMetadata").pipe(bd(Pn.get().appMetadata), Rd(1));
  return is(e, l, (c) => n(1, (s = c))), [i, s, o, a, l];
}
class g7e extends co {
  constructor(t) {
    super(), lo(this, t, m7e, p7e, oo, {}, f7e);
  }
}
function y7e(e) {
  ao(
    e,
    "svelte-z54y2j",
    ".icon.svelte-z54y2j{border-radius:50px;color:var(--onboard-primary-500, var(--primary-500))}"
  );
}
function v7e(e) {
  let t, n;
  return {
    c() {
      (t = We("div")),
        Se(t, "class", "icon flex svelte-z54y2j"),
        Se(t, "style", (n = `width: ${e[0]}px; height: ${e[0]}px;`));
    },
    m(r, i) {
      at(r, t, i), (t.innerHTML = L8);
    },
    p(r, [i]) {
      i & 1 &&
        n !== (n = `width: ${r[0]}px; height: ${r[0]}px;`) &&
        Se(t, "style", n);
    },
    i: rt,
    o: rt,
    d(r) {
      r && st(t);
    },
  };
}
function w7e(e, t, n) {
  let { size: r = 20 } = t;
  return (
    (e.$$set = (i) => {
      "size" in i && n(0, (r = i.size));
    }),
    [r]
  );
}
let b7e = class extends co {
  constructor(t) {
    super(), lo(this, t, w7e, v7e, oo, { size: 0 }, y7e);
  }
};
function x7e(e) {
  ao(
    e,
    "svelte-20hjq1",
    `.content.svelte-20hjq1{padding:1rem;width:300px;font-family:var(--onboard-font-family-normal, var(--font-family-normal));font-size:var(--onboard-font-size-5, var(--font-size-5));line-height:24px;background:var(
      --onboard-action-required-modal-background,
      var(--onboard-white, var(--white))
    )}.icon-container.svelte-20hjq1{width:3rem;height:3rem;background:var(--onboard-primary-100, var(--primary-100));border-radius:24px}h4.svelte-20hjq1{margin:1.5rem 0 0.5rem 0;font-weight:600}.action-required-heading.svelte-20hjq1,.action-required-info.svelte-20hjq1{color:var(
      --onboard-action-required-text-color,
      var(--onboard-black, inherit)
    )}.action-required-btn.svelte-20hjq1{color:var(
      --onboard-action-required-btn-text-color,
      var(--onboard-black, inherit)
    )}p.svelte-20hjq1{margin:0;font-weight:400}a.svelte-20hjq1{font-weight:600}button.svelte-20hjq1{margin-top:1.5rem;font-weight:600}`
  );
}
function Z$(e) {
  let t,
    n =
      e[1]("modals.actionRequired.linkText", { values: { wallet: e[0] } }) + "",
    r;
  return {
    c() {
      (t = We("a")),
        (r = hr(n)),
        Se(
          t,
          "href",
          "https://metamask.zendesk.com/hc/en-us/articles/360061346311-Switching-accounts-in-MetaMask"
        ),
        Se(t, "target", "_blank"),
        Se(t, "rel", "noreferrer noopener"),
        Se(t, "class", "svelte-20hjq1");
    },
    m(i, s) {
      at(i, t, s), Te(t, r);
    },
    p(i, s) {
      s & 3 &&
        n !==
          (n =
            i[1]("modals.actionRequired.linkText", {
              values: { wallet: i[0] },
            }) + "") &&
        zr(r, n);
    },
    d(i) {
      i && st(t);
    },
  };
}
function _7e(e) {
  let t,
    n,
    r,
    i,
    s,
    o =
      e[1]("modals.actionRequired.heading", { values: { wallet: e[0] } }) + "",
    a,
    l,
    c,
    u =
      e[1]("modals.actionRequired.paragraph", { values: { wallet: e[0] } }) +
      "",
    d,
    f,
    h,
    p,
    g = e[1]("modals.actionRequired.buttonText") + "",
    b,
    v,
    w,
    x;
  r = new b7e({});
  let S = e[0] === "MetaMask" && Z$(e);
  return {
    c() {
      (t = We("div")),
        (n = We("div")),
        pr(r.$$.fragment),
        (i = qt()),
        (s = We("h4")),
        (a = hr(o)),
        (l = qt()),
        (c = We("p")),
        (d = hr(u)),
        (f = qt()),
        S && S.c(),
        (h = qt()),
        (p = We("button")),
        (b = hr(g)),
        Se(
          n,
          "class",
          "icon-container flex justify-center items-center svelte-20hjq1"
        ),
        Se(s, "class", "action-required-heading svelte-20hjq1"),
        Se(c, "class", "action-required-info svelte-20hjq1"),
        Se(
          p,
          "class",
          "button-neutral-solid rounded action-required-btn svelte-20hjq1"
        ),
        Se(t, "class", "content svelte-20hjq1");
    },
    m(R, O) {
      at(R, t, O),
        Te(t, n),
        or(r, n, null),
        Te(t, i),
        Te(t, s),
        Te(s, a),
        Te(t, l),
        Te(t, c),
        Te(c, d),
        Te(c, f),
        S && S.m(c, null),
        Te(t, h),
        Te(t, p),
        Te(p, b),
        (v = !0),
        w || ((x = ll(p, "click", e[2])), (w = !0));
    },
    p(R, O) {
      (!v || O & 3) &&
        o !==
          (o =
            R[1]("modals.actionRequired.heading", {
              values: { wallet: R[0] },
            }) + "") &&
        zr(a, o),
        (!v || O & 3) &&
          u !==
            (u =
              R[1]("modals.actionRequired.paragraph", {
                values: { wallet: R[0] },
              }) + "") &&
          zr(d, u),
        R[0] === "MetaMask"
          ? S
            ? S.p(R, O)
            : ((S = Z$(R)), S.c(), S.m(c, null))
          : S && (S.d(1), (S = null)),
        (!v || O & 2) &&
          g !== (g = R[1]("modals.actionRequired.buttonText") + "") &&
          zr(b, g);
    },
    i(R) {
      v || (Ke(r.$$.fragment, R), (v = !0));
    },
    o(R) {
      ot(r.$$.fragment, R), (v = !1);
    },
    d(R) {
      R && st(t), ar(r), S && S.d(), (w = !1), x();
    },
  };
}
function S7e(e) {
  let t, n;
  return (
    (t = new IO({
      props: { close: e[2], $$slots: { default: [_7e] }, $$scope: { ctx: e } },
    })),
    {
      c() {
        pr(t.$$.fragment);
      },
      m(r, i) {
        or(t, r, i), (n = !0);
      },
      p(r, [i]) {
        const s = {};
        i & 11 && (s.$$scope = { dirty: i, ctx: r }), t.$set(s);
      },
      i(r) {
        n || (Ke(t.$$.fragment, r), (n = !0));
      },
      o(r) {
        ot(t.$$.fragment, r), (n = !1);
      },
      d(r) {
        ar(t, r);
      },
    }
  );
}
function E7e(e, t, n) {
  let r;
  is(e, _h, (o) => n(1, (r = o)));
  let { wallet: i } = t;
  function s() {
    du.next({ inProgress: !1, actionRequired: "" });
  }
  return (
    (e.$$set = (o) => {
      "wallet" in o && n(0, (i = o.wallet));
    }),
    [i, r, s]
  );
}
class A7e extends co {
  constructor(t) {
    super(), lo(this, t, E7e, S7e, oo, { wallet: 0 }, x7e);
  }
}
function C7e(e) {
  ao(
    e,
    "svelte-w5zexe",
    `.flex{display:flex}.inline-flex{display:inline-flex}.flex-column{flex-direction:column}.items-center{align-items:center}.items-end{align-items:flex-end}.items-start{align-items:flex-start}.justify-center{justify-content:center}.justify-start{justify-content:flex-start}.justify-between{justify-content:space-between}.justify-end{justify-content:flex-end}.justify-around{justify-content:space-around}.relative{position:relative}.absolute{position:absolute}.fixed{position:fixed}.pointer{cursor:pointer}.shadow-1{box-shadow:var(--onboard-shadow-1, var(--shadow-1))}.w-100{width:100%}*{box-sizing:border-box}input{background:var(--onboard-white, var(--white))}input{width:100%;padding:0.5rem 1rem;outline:2px solid var(--onboard-gray-200, var(--gray-200));border:none;border-radius:8px;font-size:1rem;line-height:1.5;color:var(--onboard-gray-600, var(--gray-600));transition:all 200ms ease-in-out}input[type='checkbox']{-webkit-appearance:none;appearance:none;width:auto;background:var(--onboard-white, var(--white));outline:1px solid var(--onboard-gray-300, var(--gray-300));border:none;padding:0.5em;border-radius:3px;display:flex;justify-content:center;align-items:center;position:relative;cursor:pointer}input[type='checkbox']:hover{border-color:var(
      --onboard-checkbox-background,
      var(--onboard-primary-500, var(--primary-500))
    )}input[type='checkbox']:checked{background:var(
      --onboard-checkbox-background,
      var(--onboard-primary-500, var(--primary-500))
    );border-color:var(
      --onboard-checkbox-background,
      var(--onboard-primary-500, var(--primary-500))
    );color:var(--onboard-checkbox-color, var(--onboard-white, var(--white)))}input[type='checkbox']:checked:after{content:url("data:image/svg+xml,%3Csvg width='0.885em' height='0.6em' viewBox='0 0 14 11' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M0 6L5 11L14 2L12.59 0.58L5 8.17L1.41 4.59L0 6Z' fill='white'/%3E%3C/svg%3E");font-size:12px;position:absolute;color:var(--onboard-checkbox-color, var(--onboard-white, var(--white)))}input:hover{border-color:var(
      --onboard-checkbox-color,
      var(--onboard-white, var(--white))
    )}input:focus{border-color:var(--onboard-primary-500, var(--primary-500));box-shadow:0 0 1px 1px
      var(
        --onboard-checkbox-background,
        var(--onboard-primary-500, var(--primary-500))
      );box-shadow:0 0 0 1px -moz-mac-focusring}input:disabled, textarea:disabled, select:disabled{background:var(--gray-100)}input::-moz-focus-inner{outline:0;padding:0;margin-top:-2px;margin-bottom:-2px}a{color:var(
      --onboard-link-color,
      var(--onboard-primary-500, var(--primary-500))
    );text-decoration:none}a:hover{text-decoration:underline}button{display:flex;align-items:center;justify-content:center;padding:calc(var(--onboard-spacing-4, var(--spacing-4)) - 1px);border-radius:24px;cursor:pointer;font:inherit;border:none;transition:background-color 150ms ease-in-out, color 150ms ease-in-out}.onboard-button-primary{background:var(--onboard-white, var(--white));padding:calc(var(--onboard-spacing-5, var(--spacing-5)) - 1px)
      calc(var(--onboard-spacing-4, var(--spacing-4)) - 1px);color:var(--onboard-gray-500, var(--gray-500));font-size:var(--onboard-font-size-6, var(--font-size-6));line-height:var(--onboard-font-line-height-3, var(--font-line-height-3));border:1px solid var(--onboard-gray-500, var(--gray-500));font-weight:600}.button-neutral-solid{width:100%;border-radius:8px;background:var(--onboard-gray-500, var(--gray-500));color:var(--onboard-white, var(--white));line-height:var(--onboard-font-line-height-3, var(--font-line-height-3))}.button-neutral-solid-b{width:100%;background:var(--onboard-gray-100, var(--gray-100));color:var(--onboard-gray-500, var(--gray-500));line-height:var(--onboard-font-line-height-3, var(--font-line-height-3))}button.rounded{border-radius:24px}.button-neutral-solid:hover{background:var(--onboard-gray-700, var(--gray-700))}.button-neutral-solid-b:hover{background:var(--onboard-gray-200, var(--gray-200))}.button-neutral-solid:active{color:var(--onboard-gray-300, var(--gray-300))}.button-neutral-solid-b:active{color:var(--onboard-gray-600, var(--gray-600));background:var(--onboard-gray-300, var(--gray-300))}.container.svelte-w5zexe{padding:16px;font-family:var(--onboard-font-family-normal, var(--font-family-normal));pointer-events:none;touch-action:none;width:100%}.z-indexed.svelte-w5zexe{z-index:var(--account-center-z-index)}@media all and (min-width: 428px){.container.svelte-w5zexe{max-width:348px}}`
  );
}
function Q$(e) {
  let t, n;
  return (
    (t = new d7e({ props: { autoSelect: e[8].autoSelect } })),
    {
      c() {
        pr(t.$$.fragment);
      },
      m(r, i) {
        or(t, r, i), (n = !0);
      },
      p(r, i) {
        const s = {};
        i & 256 && (s.autoSelect = r[8].autoSelect), t.$set(s);
      },
      i(r) {
        n || (Ke(t.$$.fragment, r), (n = !0));
      },
      o(r) {
        ot(t.$$.fragment, r), (n = !1);
      },
      d(r) {
        ar(t, r);
      },
    }
  );
}
function X$(e) {
  let t, n;
  return (
    (t = new A7e({ props: { wallet: e[8].actionRequired } })),
    {
      c() {
        pr(t.$$.fragment);
      },
      m(r, i) {
        or(t, r, i), (n = !0);
      },
      p(r, i) {
        const s = {};
        i & 256 && (s.wallet = r[8].actionRequired), t.$set(s);
      },
      i(r) {
        n || (Ke(t.$$.fragment, r), (n = !0));
      },
      o(r) {
        ot(t.$$.fragment, r), (n = !1);
      },
      d(r) {
        ar(t, r);
      },
    }
  );
}
function J$(e) {
  let t, n;
  return (
    (t = new g7e({})),
    {
      c() {
        pr(t.$$.fragment);
      },
      m(r, i) {
        or(t, r, i), (n = !0);
      },
      i(r) {
        n || (Ke(t.$$.fragment, r), (n = !0));
      },
      o(r) {
        ot(t.$$.fragment, r), (n = !1);
      },
      d(r) {
        ar(t, r);
      },
    }
  );
}
function ez(e) {
  let t,
    n =
      e[3].position.includes("bottom") &&
      e[1].position.includes("bottom") &&
      e[7],
    r,
    i,
    s,
    o = e[3].position.includes("top") && e[1].position.includes("top") && e[7],
    a,
    l,
    c = n && tz(e),
    u = {
      ctx: e,
      current: null,
      token: null,
      hasCatch: !1,
      pending: P7e,
      then: R7e,
      catch: N7e,
      value: 23,
      blocks: [, , ,],
    };
  Qm(e[16], u);
  let d = o && nz(e);
  return {
    c() {
      (t = We("div")),
        c && c.c(),
        (r = qt()),
        (i = We("div")),
        u.block.c(),
        (s = qt()),
        d && d.c(),
        Se(i, "id", "account-center-with-notify"),
        Se(
          t,
          "class",
          "container flex flex-column fixed z-indexed svelte-w5zexe"
        ),
        Se(
          t,
          "style",
          (a =
            e[15](D5)[e[1].position] +
            "; " +
            (e[11].type === "mobile" && e[1].position.includes("top")
              ? "padding-bottom: 0;"
              : e[11].type === "mobile" && e[1].position.includes("bottom")
              ? "padding-top:0;"
              : ""))
        );
    },
    m(f, h) {
      at(f, t, h),
        c && c.m(t, null),
        Te(t, r),
        Te(t, i),
        u.block.m(i, (u.anchor = null)),
        (u.mount = () => i),
        (u.anchor = null),
        Te(t, s),
        d && d.m(t, null),
        (l = !0);
    },
    p(f, h) {
      (e = f),
        h & 138 &&
          (n =
            e[3].position.includes("bottom") &&
            e[1].position.includes("bottom") &&
            e[7]),
        n
          ? c
            ? (c.p(e, h), h & 138 && Ke(c, 1))
            : ((c = tz(e)), c.c(), Ke(c, 1), c.m(t, r))
          : c &&
            (zi(),
            ot(c, 1, 1, () => {
              c = null;
            }),
            Wi()),
        xv(u, e, h),
        h & 138 &&
          (o =
            e[3].position.includes("top") &&
            e[1].position.includes("top") &&
            e[7]),
        o
          ? d
            ? (d.p(e, h), h & 138 && Ke(d, 1))
            : ((d = nz(e)), d.c(), Ke(d, 1), d.m(t, null))
          : d &&
            (zi(),
            ot(d, 1, 1, () => {
              d = null;
            }),
            Wi()),
        (!l ||
          (h & 2 &&
            a !==
              (a =
                e[15](D5)[e[1].position] +
                "; " +
                (e[11].type === "mobile" && e[1].position.includes("top")
                  ? "padding-bottom: 0;"
                  : e[11].type === "mobile" && e[1].position.includes("bottom")
                  ? "padding-top:0;"
                  : "")))) &&
          Se(t, "style", a);
    },
    i(f) {
      l || (Ke(c), Ke(u.block), Ke(d), (l = !0));
    },
    o(f) {
      ot(c);
      for (let h = 0; h < 3; h += 1) {
        const p = u.blocks[h];
        ot(p);
      }
      ot(d), (l = !1);
    },
    d(f) {
      f && st(t),
        c && c.d(),
        u.block.d(),
        (u.token = null),
        (u = null),
        d && d.d();
    },
  };
}
function tz(e) {
  let t,
    n,
    r = {
      ctx: e,
      current: null,
      token: null,
      hasCatch: !1,
      pending: I7e,
      then: T7e,
      catch: k7e,
      value: 22,
      blocks: [, , ,],
    };
  return (
    Qm(e[17], r),
    {
      c() {
        (t = xi()), r.block.c();
      },
      m(i, s) {
        at(i, t, s),
          r.block.m(i, (r.anchor = s)),
          (r.mount = () => t.parentNode),
          (r.anchor = t),
          (n = !0);
      },
      p(i, s) {
        (e = i), xv(r, e, s);
      },
      i(i) {
        n || (Ke(r.block), (n = !0));
      },
      o(i) {
        for (let s = 0; s < 3; s += 1) {
          const o = r.blocks[s];
          ot(o);
        }
        n = !1;
      },
      d(i) {
        i && st(t), r.block.d(i), (r.token = null), (r = null);
      },
    }
  );
}
function k7e(e) {
  return { c: rt, m: rt, p: rt, i: rt, o: rt, d: rt };
}
function T7e(e) {
  let t,
    n,
    r = e[22] && M7e(e);
  return {
    c() {
      r && r.c(), (t = xi());
    },
    m(i, s) {
      r && r.m(i, s), at(i, t, s), (n = !0);
    },
    p(i, s) {
      i[22] && r.p(i, s);
    },
    i(i) {
      n || (Ke(r), (n = !0));
    },
    o(i) {
      ot(r), (n = !1);
    },
    d(i) {
      r && r.d(i), i && st(t);
    },
  };
}
function M7e(e) {
  let t, n, r;
  var i = e[22];
  function s(o) {
    return {
      props: {
        notifications: o[10],
        position: o[3].position,
        sharedContainer: o[0],
      },
    };
  }
  return (
    i && (t = Od(i, s(e))),
    {
      c() {
        t && pr(t.$$.fragment), (n = xi());
      },
      m(o, a) {
        t && or(t, o, a), at(o, n, a), (r = !0);
      },
      p(o, a) {
        const l = {};
        if (
          (a & 1024 && (l.notifications = o[10]),
          a & 8 && (l.position = o[3].position),
          a & 1 && (l.sharedContainer = o[0]),
          i !== (i = o[22]))
        ) {
          if (t) {
            zi();
            const c = t;
            ot(c.$$.fragment, 1, 0, () => {
              ar(c, 1);
            }),
              Wi();
          }
          i
            ? ((t = Od(i, s(o))),
              pr(t.$$.fragment),
              Ke(t.$$.fragment, 1),
              or(t, n.parentNode, n))
            : (t = null);
        } else i && t.$set(l);
      },
      i(o) {
        r || (t && Ke(t.$$.fragment, o), (r = !0));
      },
      o(o) {
        t && ot(t.$$.fragment, o), (r = !1);
      },
      d(o) {
        o && st(n), t && ar(t, o);
      },
    }
  );
}
function I7e(e) {
  return { c: rt, m: rt, p: rt, i: rt, o: rt, d: rt };
}
function N7e(e) {
  return { c: rt, m: rt, p: rt, i: rt, o: rt, d: rt };
}
function R7e(e) {
  let t,
    n,
    r = e[23] && O7e(e);
  return {
    c() {
      r && r.c(), (t = xi());
    },
    m(i, s) {
      r && r.m(i, s), at(i, t, s), (n = !0);
    },
    p(i, s) {
      i[23] && r.p(i, s);
    },
    i(i) {
      n || (Ke(r), (n = !0));
    },
    o(i) {
      ot(r), (n = !1);
    },
    d(i) {
      r && r.d(i), i && st(t);
    },
  };
}
function O7e(e) {
  let t, n, r;
  var i = e[23];
  function s(o) {
    return {};
  }
  return (
    i && (t = Od(i, s())),
    {
      c() {
        t && pr(t.$$.fragment), (n = xi());
      },
      m(o, a) {
        t && or(t, o, a), at(o, n, a), (r = !0);
      },
      p(o, a) {
        if (i !== (i = o[23])) {
          if (t) {
            zi();
            const l = t;
            ot(l.$$.fragment, 1, 0, () => {
              ar(l, 1);
            }),
              Wi();
          }
          i
            ? ((t = Od(i, s())),
              pr(t.$$.fragment),
              Ke(t.$$.fragment, 1),
              or(t, n.parentNode, n))
            : (t = null);
        }
      },
      i(o) {
        r || (t && Ke(t.$$.fragment, o), (r = !0));
      },
      o(o) {
        t && ot(t.$$.fragment, o), (r = !1);
      },
      d(o) {
        o && st(n), t && ar(t, o);
      },
    }
  );
}
function P7e(e) {
  return { c: rt, m: rt, p: rt, i: rt, o: rt, d: rt };
}
function nz(e) {
  let t,
    n,
    r = {
      ctx: e,
      current: null,
      token: null,
      hasCatch: !1,
      pending: B7e,
      then: j7e,
      catch: L7e,
      value: 22,
      blocks: [, , ,],
    };
  return (
    Qm(e[17], r),
    {
      c() {
        (t = xi()), r.block.c();
      },
      m(i, s) {
        at(i, t, s),
          r.block.m(i, (r.anchor = s)),
          (r.mount = () => t.parentNode),
          (r.anchor = t),
          (n = !0);
      },
      p(i, s) {
        (e = i), xv(r, e, s);
      },
      i(i) {
        n || (Ke(r.block), (n = !0));
      },
      o(i) {
        for (let s = 0; s < 3; s += 1) {
          const o = r.blocks[s];
          ot(o);
        }
        n = !1;
      },
      d(i) {
        i && st(t), r.block.d(i), (r.token = null), (r = null);
      },
    }
  );
}
function L7e(e) {
  return { c: rt, m: rt, p: rt, i: rt, o: rt, d: rt };
}
function j7e(e) {
  let t,
    n,
    r = e[22] && D7e(e);
  return {
    c() {
      r && r.c(), (t = xi());
    },
    m(i, s) {
      r && r.m(i, s), at(i, t, s), (n = !0);
    },
    p(i, s) {
      i[22] && r.p(i, s);
    },
    i(i) {
      n || (Ke(r), (n = !0));
    },
    o(i) {
      ot(r), (n = !1);
    },
    d(i) {
      r && r.d(i), i && st(t);
    },
  };
}
function D7e(e) {
  let t, n, r;
  var i = e[22];
  function s(o) {
    return {
      props: {
        notifications: o[10],
        position: o[3].position,
        sharedContainer: o[0],
      },
    };
  }
  return (
    i && (t = Od(i, s(e))),
    {
      c() {
        t && pr(t.$$.fragment), (n = xi());
      },
      m(o, a) {
        t && or(t, o, a), at(o, n, a), (r = !0);
      },
      p(o, a) {
        const l = {};
        if (
          (a & 1024 && (l.notifications = o[10]),
          a & 8 && (l.position = o[3].position),
          a & 1 && (l.sharedContainer = o[0]),
          i !== (i = o[22]))
        ) {
          if (t) {
            zi();
            const c = t;
            ot(c.$$.fragment, 1, 0, () => {
              ar(c, 1);
            }),
              Wi();
          }
          i
            ? ((t = Od(i, s(o))),
              pr(t.$$.fragment),
              Ke(t.$$.fragment, 1),
              or(t, n.parentNode, n))
            : (t = null);
        } else i && t.$set(l);
      },
      i(o) {
        r || (t && Ke(t.$$.fragment, o), (r = !0));
      },
      o(o) {
        t && ot(t.$$.fragment, o), (r = !1);
      },
      d(o) {
        o && st(n), t && ar(t, o);
      },
    }
  );
}
function B7e(e) {
  return { c: rt, m: rt, p: rt, i: rt, o: rt, d: rt };
}
function rz(e) {
  let t,
    n,
    r,
    i,
    s = e[1].enabled && e[2].length && iz(e);
  return {
    c() {
      (t = We("div")),
        (n = We("div")),
        s && s.c(),
        Se(
          t,
          "class",
          "container flex flex-column fixed z-indexed svelte-w5zexe"
        ),
        Se(
          t,
          "style",
          (r =
            e[15](D5)[e[1].position] +
            "; " +
            (e[11].type === "mobile" && e[1].position.includes("top")
              ? "padding-bottom: 0;"
              : e[11].type === "mobile" && e[1].position.includes("bottom")
              ? "padding-top:0;"
              : ""))
        );
    },
    m(o, a) {
      at(o, t, a), Te(t, n), s && s.m(n, null), (i = !0);
    },
    p(o, a) {
      o[1].enabled && o[2].length
        ? s
          ? (s.p(o, a), a & 6 && Ke(s, 1))
          : ((s = iz(o)), s.c(), Ke(s, 1), s.m(n, null))
        : s &&
          (zi(),
          ot(s, 1, 1, () => {
            s = null;
          }),
          Wi()),
        (!i ||
          (a & 2 &&
            r !==
              (r =
                o[15](D5)[o[1].position] +
                "; " +
                (o[11].type === "mobile" && o[1].position.includes("top")
                  ? "padding-bottom: 0;"
                  : o[11].type === "mobile" && o[1].position.includes("bottom")
                  ? "padding-top:0;"
                  : "")))) &&
          Se(t, "style", r);
    },
    i(o) {
      i || (Ke(s), (i = !0));
    },
    o(o) {
      ot(s), (i = !1);
    },
    d(o) {
      o && st(t), s && s.d();
    },
  };
}
function iz(e) {
  let t,
    n,
    r = {
      ctx: e,
      current: null,
      token: null,
      hasCatch: !1,
      pending: z7e,
      then: U7e,
      catch: F7e,
      value: 23,
      blocks: [, , ,],
    };
  return (
    Qm(e[16], r),
    {
      c() {
        (t = xi()), r.block.c();
      },
      m(i, s) {
        at(i, t, s),
          r.block.m(i, (r.anchor = s)),
          (r.mount = () => t.parentNode),
          (r.anchor = t),
          (n = !0);
      },
      p(i, s) {
        (e = i), xv(r, e, s);
      },
      i(i) {
        n || (Ke(r.block), (n = !0));
      },
      o(i) {
        for (let s = 0; s < 3; s += 1) {
          const o = r.blocks[s];
          ot(o);
        }
        n = !1;
      },
      d(i) {
        i && st(t), r.block.d(i), (r.token = null), (r = null);
      },
    }
  );
}
function F7e(e) {
  return { c: rt, m: rt, p: rt, i: rt, o: rt, d: rt };
}
function U7e(e) {
  let t,
    n,
    r = e[23] && $7e(e);
  return {
    c() {
      r && r.c(), (t = xi());
    },
    m(i, s) {
      r && r.m(i, s), at(i, t, s), (n = !0);
    },
    p(i, s) {
      i[23] && r.p(i, s);
    },
    i(i) {
      n || (Ke(r), (n = !0));
    },
    o(i) {
      ot(r), (n = !1);
    },
    d(i) {
      r && r.d(i), i && st(t);
    },
  };
}
function $7e(e) {
  let t, n, r;
  var i = e[23];
  function s(o) {
    return {};
  }
  return (
    i && (t = Od(i, s())),
    {
      c() {
        t && pr(t.$$.fragment), (n = xi());
      },
      m(o, a) {
        t && or(t, o, a), at(o, n, a), (r = !0);
      },
      p(o, a) {
        if (i !== (i = o[23])) {
          if (t) {
            zi();
            const l = t;
            ot(l.$$.fragment, 1, 0, () => {
              ar(l, 1);
            }),
              Wi();
          }
          i
            ? ((t = Od(i, s())),
              pr(t.$$.fragment),
              Ke(t.$$.fragment, 1),
              or(t, n.parentNode, n))
            : (t = null);
        }
      },
      i(o) {
        r || (t && Ke(t.$$.fragment, o), (r = !0));
      },
      o(o) {
        t && ot(t.$$.fragment, o), (r = !1);
      },
      d(o) {
        o && st(n), t && ar(t, o);
      },
    }
  );
}
function z7e(e) {
  return { c: rt, m: rt, p: rt, i: rt, o: rt, d: rt };
}
function sz(e) {
  let t,
    n,
    r,
    i = {
      ctx: e,
      current: null,
      token: null,
      hasCatch: !1,
      pending: G7e,
      then: H7e,
      catch: W7e,
      value: 22,
      blocks: [, , ,],
    };
  return (
    Qm(e[17], i),
    {
      c() {
        (t = We("div")),
          i.block.c(),
          Se(
            t,
            "class",
            "container flex flex-column fixed z-indexed svelte-w5zexe"
          ),
          Se(
            t,
            "style",
            (n =
              e[15](oz)[e[3].position] +
              "; " +
              (e[11].type === "mobile" && e[3].position.includes("top")
                ? "padding-bottom: 0;"
                : e[11].type === "mobile" && e[3].position.includes("bottom")
                ? "padding-top:0;"
                : ""))
          );
      },
      m(s, o) {
        at(s, t, o),
          i.block.m(t, (i.anchor = null)),
          (i.mount = () => t),
          (i.anchor = null),
          (r = !0);
      },
      p(s, o) {
        (e = s),
          xv(i, e, o),
          (!r ||
            (o & 8 &&
              n !==
                (n =
                  e[15](oz)[e[3].position] +
                  "; " +
                  (e[11].type === "mobile" && e[3].position.includes("top")
                    ? "padding-bottom: 0;"
                    : e[11].type === "mobile" &&
                      e[3].position.includes("bottom")
                    ? "padding-top:0;"
                    : "")))) &&
            Se(t, "style", n);
      },
      i(s) {
        r || (Ke(i.block), (r = !0));
      },
      o(s) {
        for (let o = 0; o < 3; o += 1) {
          const a = i.blocks[o];
          ot(a);
        }
        r = !1;
      },
      d(s) {
        s && st(t), i.block.d(), (i.token = null), (i = null);
      },
    }
  );
}
function W7e(e) {
  return { c: rt, m: rt, p: rt, i: rt, o: rt, d: rt };
}
function H7e(e) {
  let t,
    n,
    r = e[22] && V7e(e);
  return {
    c() {
      r && r.c(), (t = xi());
    },
    m(i, s) {
      r && r.m(i, s), at(i, t, s), (n = !0);
    },
    p(i, s) {
      i[22] && r.p(i, s);
    },
    i(i) {
      n || (Ke(r), (n = !0));
    },
    o(i) {
      ot(r), (n = !1);
    },
    d(i) {
      r && r.d(i), i && st(t);
    },
  };
}
function V7e(e) {
  let t, n, r;
  var i = e[22];
  function s(o) {
    return {
      props: {
        notifications: o[10],
        position: o[3].position,
        sharedContainer: o[0],
      },
    };
  }
  return (
    i && (t = Od(i, s(e))),
    {
      c() {
        t && pr(t.$$.fragment), (n = xi());
      },
      m(o, a) {
        t && or(t, o, a), at(o, n, a), (r = !0);
      },
      p(o, a) {
        const l = {};
        if (
          (a & 1024 && (l.notifications = o[10]),
          a & 8 && (l.position = o[3].position),
          a & 1 && (l.sharedContainer = o[0]),
          i !== (i = o[22]))
        ) {
          if (t) {
            zi();
            const c = t;
            ot(c.$$.fragment, 1, 0, () => {
              ar(c, 1);
            }),
              Wi();
          }
          i
            ? ((t = Od(i, s(o))),
              pr(t.$$.fragment),
              Ke(t.$$.fragment, 1),
              or(t, n.parentNode, n))
            : (t = null);
        } else i && t.$set(l);
      },
      i(o) {
        r || (t && Ke(t.$$.fragment, o), (r = !0));
      },
      o(o) {
        t && ot(t.$$.fragment, o), (r = !1);
      },
      d(o) {
        o && st(n), t && ar(t, o);
      },
    }
  );
}
function G7e(e) {
  return { c: rt, m: rt, p: rt, i: rt, o: rt, d: rt };
}
function q7e(e) {
  let t,
    n,
    r,
    i,
    s,
    o,
    a,
    l = e[8].inProgress && Q$(e),
    c = e[8].actionRequired && X$(e),
    u = e[9] && J$(),
    d = e[4] && ez(e),
    f = e[5] && rz(e),
    h = e[6] && sz(e);
  return {
    c() {
      l && l.c(),
        (t = qt()),
        c && c.c(),
        (n = qt()),
        u && u.c(),
        (r = qt()),
        d && d.c(),
        (i = qt()),
        f && f.c(),
        (s = qt()),
        h && h.c(),
        (o = xi());
    },
    m(p, g) {
      l && l.m(p, g),
        at(p, t, g),
        c && c.m(p, g),
        at(p, n, g),
        u && u.m(p, g),
        at(p, r, g),
        d && d.m(p, g),
        at(p, i, g),
        f && f.m(p, g),
        at(p, s, g),
        h && h.m(p, g),
        at(p, o, g),
        (a = !0);
    },
    p(p, [g]) {
      p[8].inProgress
        ? l
          ? (l.p(p, g), g & 256 && Ke(l, 1))
          : ((l = Q$(p)), l.c(), Ke(l, 1), l.m(t.parentNode, t))
        : l &&
          (zi(),
          ot(l, 1, 1, () => {
            l = null;
          }),
          Wi()),
        p[8].actionRequired
          ? c
            ? (c.p(p, g), g & 256 && Ke(c, 1))
            : ((c = X$(p)), c.c(), Ke(c, 1), c.m(n.parentNode, n))
          : c &&
            (zi(),
            ot(c, 1, 1, () => {
              c = null;
            }),
            Wi()),
        p[9]
          ? u
            ? g & 512 && Ke(u, 1)
            : ((u = J$()), u.c(), Ke(u, 1), u.m(r.parentNode, r))
          : u &&
            (zi(),
            ot(u, 1, 1, () => {
              u = null;
            }),
            Wi()),
        p[4]
          ? d
            ? (d.p(p, g), g & 16 && Ke(d, 1))
            : ((d = ez(p)), d.c(), Ke(d, 1), d.m(i.parentNode, i))
          : d &&
            (zi(),
            ot(d, 1, 1, () => {
              d = null;
            }),
            Wi()),
        p[5]
          ? f
            ? (f.p(p, g), g & 32 && Ke(f, 1))
            : ((f = rz(p)), f.c(), Ke(f, 1), f.m(s.parentNode, s))
          : f &&
            (zi(),
            ot(f, 1, 1, () => {
              f = null;
            }),
            Wi()),
        p[6]
          ? h
            ? (h.p(p, g), g & 64 && Ke(h, 1))
            : ((h = sz(p)), h.c(), Ke(h, 1), h.m(o.parentNode, o))
          : h &&
            (zi(),
            ot(h, 1, 1, () => {
              h = null;
            }),
            Wi());
    },
    i(p) {
      a || (Ke(l), Ke(c), Ke(u), Ke(d), Ke(f), Ke(h), (a = !0));
    },
    o(p) {
      ot(l), ot(c), ot(u), ot(d), ot(f), ot(h), (a = !1);
    },
    d(p) {
      l && l.d(p),
        p && st(t),
        c && c.d(p),
        p && st(n),
        u && u.d(p),
        p && st(r),
        d && d.d(p),
        p && st(i),
        f && f.d(p),
        p && st(s),
        h && h.d(p),
        p && st(o);
    },
  };
}
const D5 = "account-center",
  oz = "notify-onboard-container";
function K7e(e, t, n) {
  let r, i, s, o, a, l, c, u, d, f, h, p;
  is(e, CO, (I) => n(2, (u = I))),
    is(e, du, (I) => n(8, (f = I))),
    is(e, Fy, (I) => n(9, (h = I)));
  const { device: g, containerElements: b } = Sa,
    v = Pn.select("accountCenter").pipe(bd(Pn.get().accountCenter), Rd(1));
  is(e, v, (I) => n(1, (c = I)));
  const w = Pn.select("notify").pipe(bd(Pn.get().notify), Rd(1));
  is(e, w, (I) => n(3, (d = I)));
  const x = Pn.select("notifications").pipe(bd(Pn.get().notifications));
  is(e, x, (I) => n(10, (p = I)));
  const S = (I) => ({
      topLeft: `
        top: var(--${I}-position-top, 0); 
        left: var(--${I}-position-left, 0);`,
      topRight: `
        top: var(--${I}-position-top, 0); 
        right: var(--${I}-position-right, 0);`,
      bottomRight: `
        bottom: var(--${I}-position-bottom, 0); 
        right: var(--${I}-position-right, 0);`,
      bottomLeft: `
        bottom: var(--${I}-position-bottom, 0); 
        left: var(--${I}-position-left, 0);`,
    }),
    R = c.enabled
      ? At(() => import("./Index-6c094240-CJJBIa9k.js"), []).then(
          (I) => I.default
        )
      : Promise.resolve(null),
    O = d.enabled
      ? At(() => import("./Index-64ac63ff-CmYtspfx.js"), []).then(
          (I) => I.default
        )
      : Promise.resolve(null),
    B = c.enabled && b && b.accountCenter,
    C = (I, P, M, k) => {
      const T = I.attachShadow({ mode: "open" });
      let A = document.querySelector("onboard-v2").shadowRoot.styleSheets;
      const N = new CSSStyleSheet();
      Object.values(A).forEach((D) => {
        Object.values(D.cssRules).forEach((z) => N.insertRule(z.cssText));
      }),
        (T.adoptedStyleSheets = [N]);
      const L = document.querySelector(P);
      if ((L.appendChild(I), !L))
        throw new Error(`Element with query ${P} does not exist.`);
      (async () => {
        let D = await M;
        D && new D({ target: T, props: { settings: k, mountInContainer: !0 } });
      })();
    };
  if (B) {
    const I = document.createElement("onboard-account-center");
    C(I, B, R, c);
  }
  return (
    (e.$$.update = () => {
      e.$$.dirty & 10 &&
        n(0, (r = !B && c.enabled && d.enabled && d.position === c.position)),
        e.$$.dirty & 10 &&
          n(7, (i = g.type === "mobile" || c.position === d.position)),
        e.$$.dirty & 10 &&
          n(
            18,
            (s =
              (d.position.includes("bottom") &&
                c.position.includes("bottom")) ||
              (d.position.includes("top") && c.position.includes("top")))
          ),
        e.$$.dirty & 262158 &&
          n(
            6,
            (o =
              d.enabled &&
              (!c.enabled ||
                B ||
                (d.position !== c.position && g.type !== "mobile") ||
                (g.type === "mobile" && !s) ||
                !u.length))
          ),
        e.$$.dirty & 262158 &&
          n(
            5,
            (a =
              c.enabled &&
              (!d.enabled ||
                (d.position !== c.position && g.type !== "mobile") ||
                (g.type === "mobile" && !s)) &&
              u.length)
          ),
        e.$$.dirty & 262159 &&
          n(
            4,
            (l =
              d.enabled &&
              c.enabled &&
              (r || (g.type === "mobile" && s)) &&
              u.length)
          );
    }),
    [r, c, u, d, l, a, o, i, f, h, p, g, v, w, x, S, R, O, s]
  );
}
class Y7e extends co {
  constructor(t) {
    super(), lo(this, t, K7e, q7e, oo, {}, C7e);
  }
}
const Aw = {
  connectWallet: fAe,
  disconnectWallet: MO,
  setChain: xAe,
  state: {
    get: Pn.get,
    select: Pn.select,
    actions: {
      setWalletModules: xee,
      setLocale: aAe,
      updateNotify: W4,
      customNotification: iAe,
      updateBalances: hAe,
      updateAccountCenter: bee,
      setPrimaryWallet: nAe,
      updateTheme: _ee,
      updateAppMetadata: See,
    },
  },
};
function Z7e(e) {
  if (typeof window > "u") return Aw;
  if (e) {
    const x = z9e(e);
    if (x) throw x;
  }
  const {
    wallets: t,
    chains: n,
    appMetadata: r,
    i18n: i,
    accountCenter: s,
    notify: o,
    gas: a,
    connect: l,
    containerElements: c,
    transactionPreview: u,
    theme: d,
    disableFontDownload: f,
    unstoppableResolution: h,
    wagmi: p,
  } = e;
  c && S$({ containerElements: c });
  const { device: g, svelteInstance: b } = Sa;
  if (
    (b &&
      (console.warn(
        "Re-initializing Onboard and resetting back to initial state"
      ),
      EO.next()),
    kAe(i),
    eAe(UEe(n)),
    typeof l < "u" && rAe(l),
    typeof s < "u")
  ) {
    let x;
    const {
      hideTransactionProtectionBtn: S,
      transactionProtectionInfoLink: R,
    } = s;
    g.type === "mobile"
      ? (x = Object.assign(
          Object.assign(Object.assign({}, dp.accountCenter), {
            hideTransactionProtectionBtn: S,
            transactionProtectionInfoLink: R,
          }),
          s.mobile ? s.mobile : {}
        ))
      : s.desktop &&
        (x = Object.assign(
          Object.assign(Object.assign({}, dp.accountCenter), {
            hideTransactionProtectionBtn: S,
            transactionProtectionInfoLink: R,
          }),
          s.desktop
        )),
      typeof x < "u" && bee(x);
  }
  let v;
  if (
    (typeof p < "u" &&
      (v = p(Object.assign({ disconnect: MO, updateChain: wee }, bAe()))),
    typeof o < "u")
  )
    if (
      (console.warn(
        "Support for notifications on transaction state changes have been deprecated. Custom notifications can still be sent ot the user."
      ),
      "desktop" in o || "mobile" in o)
    ) {
      const x = Y9e(o);
      if (x) throw x;
      o &&
        o.desktop &&
        o.desktop.position &&
        s &&
        s.desktop &&
        s.desktop.position &&
        (o.desktop.position = s.desktop.position),
        o &&
          o.mobile &&
          o.mobile.position &&
          s &&
          s.mobile &&
          s.mobile.position &&
          (o.mobile.position = s.mobile.position);
      let S = {};
      g.type === "mobile" && o.mobile
        ? (S = Object.assign(Object.assign({}, dp.notify), o.mobile))
        : o.desktop &&
          (S = Object.assign(Object.assign({}, dp.notify), o.desktop)),
        W4(S);
    } else {
      const x = vee(o);
      if (x) throw x;
      const S = Object.assign(Object.assign({}, dp.notify), o);
      W4(S);
    }
  else {
    const x = dp.notify;
    W4(x);
  }
  const w = b || J7e(d || {}, f || !1);
  if (
    (S$({
      svelteInstance: w,
      initialWalletInit: t,
      gas: a,
      unstoppableResolution: h,
      wagmi: v,
    }),
    r && See(r),
    u &&
      console.error(
        "Transaction Preview support has been removed and is no longer supported within Web3-Onboard"
      ),
    d && _ee(d),
    l && (l.autoConnectLastWallet || l.autoConnectAllPreviousWallet))
  ) {
    const x = j8(xd.LAST_CONNECTED_WALLET);
    try {
      const S = JSON.parse(x);
      S && Array.isArray(S) && S.length && az(S, l),
        S && typeof S == "string" && az([S], l);
    } catch (S) {
      S instanceof SyntaxError &&
        x &&
        Aw.connectWallet({ autoSelect: { label: x, disableModals: !0 } });
    }
  }
  return Aw;
}
const Q7e = (e, t) =>
    t ||
    (document.body &&
      (getComputedStyle(document.body).getPropertyValue(
        "--onboard-font-family-normal"
      ) ||
        getComputedStyle(document.body).getPropertyValue("--w3o-font-family")))
      ? !0
      : e
      ? !!(typeof e == "object" && e["--w3o-font-family"])
      : !1,
  X7e = async () => {
    const { InterVar: e } = await At(async () => {
        const { InterVar: n } = await import("./index-BHOazxOL.js");
        return { InterVar: n };
      }, []),
      t = document.createElement("style");
    (t.innerHTML = `
    ${e}
  `),
      document.body.appendChild(t);
  },
  az = async (e, t) => {
    const n = [],
      r = e;
    if (!t.autoConnectAllPreviousWallet)
      Aw.connectWallet({ autoSelect: { label: r[0], disableModals: !0 } }),
        n.push(r[0]);
    else
      for (let i = r.length; i--; )
        (
          await Aw.connectWallet({
            autoSelect: { label: r[i], disableModals: !0 },
          })
        ).some((o) => o.label === r[i]) && n.unshift(r[i]);
    D8(xd.LAST_CONNECTED_WALLET, JSON.stringify(n));
  };
function J7e(e, t) {
  class n extends HTMLElement {
    constructor() {
      super();
    }
  }
  customElements.get("onboard-v2") || customElements.define("onboard-v2", n),
    Q7e(e, t) || X7e();
  const r = document.createElement("onboard-v2"),
    i = r.attachShadow({ mode: "open" });
  (r.style.all = "initial"),
    (i.innerHTML = `

  <style>
    :host {
          /* COLORS */
          --white: white;
          --black: black;
          --primary-1: #2F80ED;
          --primary-100: #eff1fc;
          --primary-200: #d0d4f7;
          --primary-300: #b1b8f2;
          --primary-400: #929bed;
          --primary-500: #6370e5;
          --primary-600: #454ea0;
          --primary-700: #323873;
          --gray-100: #ebebed;
          --gray-200: #c2c4c9;
          --gray-300: #999ca5;
          --gray-400: #707481;
          --gray-500: #33394b;
          --gray-600: #242835;
          --gray-700: #1a1d26;
          --success-100: #d1fae3;
          --success-200: #baf7d5;
          --success-300: #a4f4c6;
          --success-400: #8df2b8;
          --success-500: #5aec99;
          --success-600: #18ce66;
          --success-700: #129b4d;
          --danger-100: #ffe5e6;
          --danger-200: #ffcccc;
          --danger-300: #ffb3b3;
          --danger-400: #ff8080;
          --danger-500: #ff4f4f;
          --danger-600: #cc0000;
          --danger-700: #660000;
          --warning-100: #ffefcc;
          --warning-200: #ffe7b3;
          --warning-300: #ffd780;
          --warning-400: #ffc74c;
          --warning-500: #ffaf00;
          --warning-600: #cc8c00;
          --warning-700: #664600;

          /* FONTS */
          --font-family-normal: var(--w3o-font-family, Inter, sans-serif);

          --font-size-1: 3rem;
          --font-size-2: 2.25rem;
          --font-size-3: 1.5rem;
          --font-size-4: 1.25rem;
          --font-size-5: 1rem;
          --font-size-6: .875rem;
          --font-size-7: .75rem;

          --font-line-height-1: 24px;
          --font-line-height-2: 20px;
          --font-line-height-3: 16px;
          --font-line-height-4: 12px;

          /* SPACING */
          --spacing-1: 3rem;
          --spacing-2: 2rem;
          --spacing-3: 1.5rem;
          --spacing-4: 1rem;
          --spacing-5: 0.5rem;
          --spacing-6: 0.25rem;
          --spacing-7: 0.125rem;

          /* BORDER RADIUS */
          --border-radius-1: 24px;
          --border-radius-2: 20px;
          --border-radius-3: 16px;
          --border-radius-4: 12px;
          --border-radius-5: 8px;

          /* SHADOWS */
          --shadow-0: none;
          --shadow-1: 0px 4px 12px rgba(0, 0, 0, 0.1);
          --shadow-2: inset 0px -1px 0px rgba(0, 0, 0, 0.1);
          --shadow-3: 0px 4px 16px rgba(0, 0, 0, 0.2);

          /* MODAL POSITIONING */
          --modal-z-index: 10;
          --modal-top: unset;
          --modal-right: unset;
          --modal-bottom: unset;
          --modal-left: unset;

          /* MODAL STYLES */
          --modal-backdrop: rgba(0, 0, 0, 0.6);

        }
      </style>
    `);
  let s;
  Sa &&
    Sa.containerElements &&
    Sa.containerElements.connectModal &&
    (s = Sa.containerElements.connectModal);
  const o = s || Pn.get().accountCenter.containerElement || "body",
    a = document.querySelector(o);
  if (!a) throw new Error(`Element with query ${o} does not exist.`);
  return a.appendChild(r), new Y7e({ target: i });
}
var B5 = { exports: {} };
B5.exports;
(function (e, t) {
  var n = 200,
    r = "Expected a function",
    i = "__lodash_hash_undefined__",
    s = 1,
    o = 2,
    a = 1 / 0,
    l = 9007199254740991,
    c = "[object Arguments]",
    u = "[object Array]",
    d = "[object Boolean]",
    f = "[object Date]",
    h = "[object Error]",
    p = "[object Function]",
    g = "[object GeneratorFunction]",
    b = "[object Map]",
    v = "[object Number]",
    w = "[object Object]",
    x = "[object Promise]",
    S = "[object RegExp]",
    R = "[object Set]",
    O = "[object String]",
    B = "[object Symbol]",
    C = "[object WeakMap]",
    I = "[object ArrayBuffer]",
    P = "[object DataView]",
    M = "[object Float32Array]",
    k = "[object Float64Array]",
    T = "[object Int8Array]",
    _ = "[object Int16Array]",
    A = "[object Int32Array]",
    N = "[object Uint8Array]",
    L = "[object Uint8ClampedArray]",
    F = "[object Uint16Array]",
    D = "[object Uint32Array]",
    j = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    z = /^\w*$/,
    $ = /^\./,
    K =
      /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
    re = /[\\^$.*+?()[\]{}|]/g,
    G = /\\(\\)?/g,
    ne = /^\[object .+?Constructor\]$/,
    ae = /^(?:0|[1-9]\d*)$/,
    le = {};
  (le[M] = le[k] = le[T] = le[_] = le[A] = le[N] = le[L] = le[F] = le[D] = !0),
    (le[c] =
      le[u] =
      le[I] =
      le[d] =
      le[P] =
      le[f] =
      le[h] =
      le[p] =
      le[b] =
      le[v] =
      le[w] =
      le[S] =
      le[R] =
      le[O] =
      le[C] =
        !1);
  var ge = typeof Bn == "object" && Bn && Bn.Object === Object && Bn,
    Oe = typeof self == "object" && self && self.Object === Object && self,
    _e = ge || Oe || Function("return this")(),
    Ee = t && !t.nodeType && t,
    He = Ee && !0 && e && !e.nodeType && e,
    je = He && He.exports === Ee,
    Be = je && ge.process,
    rn = (function () {
      try {
        return Be && Be.binding("util");
      } catch {}
    })(),
    Wt = rn && rn.isTypedArray;
  function Mt(W, Z) {
    var se = W ? W.length : 0;
    return !!se && Qe(W, Z, 0) > -1;
  }
  function an(W, Z) {
    for (var se = -1, ye = W ? W.length : 0; ++se < ye; )
      if (Z(W[se], se, W)) return !0;
    return !1;
  }
  function kt(W, Z, se, ye) {
    for (var Je = W.length, De = se + -1; ++De < Je; )
      if (Z(W[De], De, W)) return De;
    return -1;
  }
  function Qe(W, Z, se) {
    if (Z !== Z) return kt(W, Vt, se);
    for (var ye = se - 1, Je = W.length; ++ye < Je; )
      if (W[ye] === Z) return ye;
    return -1;
  }
  function Vt(W) {
    return W !== W;
  }
  function Rt(W) {
    return function (Z) {
      return Z == null ? void 0 : Z[W];
    };
  }
  function mt(W, Z) {
    for (var se = -1, ye = Array(W); ++se < W; ) ye[se] = Z(se);
    return ye;
  }
  function Pt(W) {
    return function (Z) {
      return W(Z);
    };
  }
  function wn(W, Z) {
    return W.has(Z);
  }
  function xt(W, Z) {
    return W == null ? void 0 : W[Z];
  }
  function Tt(W) {
    var Z = !1;
    if (W != null && typeof W.toString != "function")
      try {
        Z = !!(W + "");
      } catch {}
    return Z;
  }
  function _n(W) {
    var Z = -1,
      se = Array(W.size);
    return (
      W.forEach(function (ye, Je) {
        se[++Z] = [Je, ye];
      }),
      se
    );
  }
  function Q(W, Z) {
    return function (se) {
      return W(Z(se));
    };
  }
  function H(W) {
    var Z = -1,
      se = Array(W.size);
    return (
      W.forEach(function (ye) {
        se[++Z] = ye;
      }),
      se
    );
  }
  var q = Array.prototype,
    ee = Function.prototype,
    ce = Object.prototype,
    pe = _e["__core-js_shared__"],
    we = (function () {
      var W = /[^.]+$/.exec((pe && pe.keys && pe.keys.IE_PROTO) || "");
      return W ? "Symbol(src)_1." + W : "";
    })(),
    ht = ee.toString,
    vt = ce.hasOwnProperty,
    ct = ce.toString,
    Lt = RegExp(
      "^" +
        ht
          .call(vt)
          .replace(re, "\\$&")
          .replace(
            /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
            "$1.*?"
          ) +
        "$"
    ),
    wt = _e.Symbol,
    Ht = _e.Uint8Array,
    mn = ce.propertyIsEnumerable,
    jn = q.splice,
    Gt = Q(Object.keys, Object),
    Cn = ja(_e, "DataView"),
    cn = ja(_e, "Map"),
    Yt = ja(_e, "Promise"),
    ln = ja(_e, "Set"),
    oe = ja(_e, "WeakMap"),
    de = ja(Object, "create"),
    be = ie(Cn),
    Me = ie(cn),
    Fe = ie(Yt),
    it = ie(ln),
    ft = ie(oe),
    ze = wt ? wt.prototype : void 0,
    nt = ze ? ze.valueOf : void 0,
    Xe = ze ? ze.toString : void 0;
  function Ve(W) {
    var Z = -1,
      se = W ? W.length : 0;
    for (this.clear(); ++Z < se; ) {
      var ye = W[Z];
      this.set(ye[0], ye[1]);
    }
  }
  function bt() {
    this.__data__ = de ? de(null) : {};
  }
  function gt(W) {
    return this.has(W) && delete this.__data__[W];
  }
  function un(W) {
    var Z = this.__data__;
    if (de) {
      var se = Z[W];
      return se === i ? void 0 : se;
    }
    return vt.call(Z, W) ? Z[W] : void 0;
  }
  function Rn(W) {
    var Z = this.__data__;
    return de ? Z[W] !== void 0 : vt.call(Z, W);
  }
  function bn(W, Z) {
    var se = this.__data__;
    return (se[W] = de && Z === void 0 ? i : Z), this;
  }
  (Ve.prototype.clear = bt),
    (Ve.prototype.delete = gt),
    (Ve.prototype.get = un),
    (Ve.prototype.has = Rn),
    (Ve.prototype.set = bn);
  function Sn(W) {
    var Z = -1,
      se = W ? W.length : 0;
    for (this.clear(); ++Z < se; ) {
      var ye = W[Z];
      this.set(ye[0], ye[1]);
    }
  }
  function Si() {
    this.__data__ = [];
  }
  function vr(W) {
    var Z = this.__data__,
      se = fl(Z, W);
    if (se < 0) return !1;
    var ye = Z.length - 1;
    return se == ye ? Z.pop() : jn.call(Z, se, 1), !0;
  }
  function pi(W) {
    var Z = this.__data__,
      se = fl(Z, W);
    return se < 0 ? void 0 : Z[se][1];
  }
  function ii(W) {
    return fl(this.__data__, W) > -1;
  }
  function Ki(W, Z) {
    var se = this.__data__,
      ye = fl(se, W);
    return ye < 0 ? se.push([W, Z]) : (se[ye][1] = Z), this;
  }
  (Sn.prototype.clear = Si),
    (Sn.prototype.delete = vr),
    (Sn.prototype.get = pi),
    (Sn.prototype.has = ii),
    (Sn.prototype.set = Ki);
  function si(W) {
    var Z = -1,
      se = W ? W.length : 0;
    for (this.clear(); ++Z < se; ) {
      var ye = W[Z];
      this.set(ye[0], ye[1]);
    }
  }
  function Ti() {
    this.__data__ = { hash: new Ve(), map: new (cn || Sn)(), string: new Ve() };
  }
  function Yi(W) {
    return Gc(this, W).delete(W);
  }
  function Es(W) {
    return Gc(this, W).get(W);
  }
  function In(W) {
    return Gc(this, W).has(W);
  }
  function On(W, Z) {
    return Gc(this, W).set(W, Z), this;
  }
  (si.prototype.clear = Ti),
    (si.prototype.delete = Yi),
    (si.prototype.get = Es),
    (si.prototype.has = In),
    (si.prototype.set = On);
  function Ei(W) {
    var Z = -1,
      se = W ? W.length : 0;
    for (this.__data__ = new si(); ++Z < se; ) this.add(W[Z]);
  }
  function As(W) {
    return this.__data__.set(W, i), this;
  }
  function wr(W) {
    return this.__data__.has(W);
  }
  (Ei.prototype.add = Ei.prototype.push = As), (Ei.prototype.has = wr);
  function Mi(W) {
    this.__data__ = new Sn(W);
  }
  function ha() {
    this.__data__ = new Sn();
  }
  function ju(W) {
    return this.__data__.delete(W);
  }
  function Hc(W) {
    return this.__data__.get(W);
  }
  function Yd(W) {
    return this.__data__.has(W);
  }
  function _0(W, Z) {
    var se = this.__data__;
    if (se instanceof Sn) {
      var ye = se.__data__;
      if (!cn || ye.length < n - 1) return ye.push([W, Z]), this;
      se = this.__data__ = new si(ye);
    }
    return se.set(W, Z), this;
  }
  (Mi.prototype.clear = ha),
    (Mi.prototype.delete = ju),
    (Mi.prototype.get = Hc),
    (Mi.prototype.has = Yd),
    (Mi.prototype.set = _0);
  function Ih(W, Z) {
    var se = qn(W) || Wn(W) ? mt(W.length, String) : [],
      ye = se.length,
      Je = !!ye;
    for (var De in W)
      vt.call(W, De) && !(Je && (De == "length" || Da(De, ye))) && se.push(De);
    return se;
  }
  function fl(W, Z) {
    for (var se = W.length; se--; ) if (jt(W[se][0], Z)) return se;
    return -1;
  }
  function hl(W, Z) {
    Z = Kc(Z, W) ? [Z] : ef(Z);
    for (var se = 0, ye = Z.length; W != null && se < ye; ) W = W[$u(Z[se++])];
    return se && se == ye ? W : void 0;
  }
  function Zd(W) {
    return ct.call(W);
  }
  function Nh(W, Z) {
    return W != null && Z in Object(W);
  }
  function Ql(W, Z, se, ye, Je) {
    return W === Z
      ? !0
      : W == null || Z == null || (!Di(W) && !Gs(Z))
      ? W !== W && Z !== Z
      : Du(W, Z, Ql, se, ye, Je);
  }
  function Du(W, Z, se, ye, Je, De) {
    var Ze = qn(W),
      yn = qn(Z),
      fn = u,
      ur = u;
    Ze || ((fn = Os(W)), (fn = fn == c ? w : fn)),
      yn || ((ur = Os(Z)), (ur = ur == c ? w : ur));
    var Kn = fn == w && !Tt(W),
      dr = ur == w && !Tt(Z),
      br = fn == ur;
    if (br && !Kn)
      return (
        De || (De = new Mi()),
        Ze || Jl(W) ? Fu(W, Z, se, ye, Je, De) : Uu(W, Z, fn, se, ye, Je, De)
      );
    if (!(Je & o)) {
      var Ai = Kn && vt.call(W, "__wrapped__"),
        mi = dr && vt.call(Z, "__wrapped__");
      if (Ai || mi) {
        var vs = Ai ? W.value() : W,
          Ni = mi ? Z.value() : Z;
        return De || (De = new Mi()), se(vs, Ni, ye, Je, De);
      }
    }
    return br ? (De || (De = new Mi()), tf(W, Z, se, ye, Je, De)) : !1;
  }
  function S0(W, Z, se, ye) {
    var Je = se.length,
      De = Je;
    if (W == null) return !De;
    for (W = Object(W); Je--; ) {
      var Ze = se[Je];
      if (Ze[2] ? Ze[1] !== W[Ze[0]] : !(Ze[0] in W)) return !1;
    }
    for (; ++Je < De; ) {
      Ze = se[Je];
      var yn = Ze[0],
        fn = W[yn],
        ur = Ze[1];
      if (Ze[2]) {
        if (fn === void 0 && !(yn in W)) return !1;
      } else {
        var Kn = new Mi(),
          dr;
        if (!(dr === void 0 ? Ql(ur, fn, ye, s | o, Kn) : dr)) return !1;
      }
    }
    return !0;
  }
  function Rh(W) {
    if (!Di(W) || E0(W)) return !1;
    var Z = Br(W) || Tt(W) ? Lt : ne;
    return Z.test(ie(W));
  }
  function Qd(W) {
    return Gs(W) && Ii(W.length) && !!le[ct.call(W)];
  }
  function Bu(W) {
    return typeof W == "function"
      ? W
      : W == null
      ? rf
      : typeof W == "object"
      ? qn(W)
        ? Ph(W[0], W[1])
        : Oh(W)
      : qv(W);
  }
  function Xl(W) {
    if (!jh(W)) return Gt(W);
    var Z = [];
    for (var se in Object(W))
      vt.call(W, se) && se != "constructor" && Z.push(se);
    return Z;
  }
  function Oh(W) {
    var Z = qc(W);
    return Z.length == 1 && Z[0][2]
      ? Dr(Z[0][0], Z[0][1])
      : function (se) {
          return se === W || S0(se, W, Z);
        };
  }
  function Ph(W, Z) {
    return Kc(W) && Dh(Z)
      ? Dr($u(W), Z)
      : function (se) {
          var ye = C1(se, W);
          return ye === void 0 && ye === Z
            ? k1(se, W)
            : Ql(Z, ye, void 0, s | o);
        };
  }
  function Xd(W) {
    return function (Z) {
      return hl(Z, W);
    };
  }
  function Lh(W) {
    if (typeof W == "string") return W;
    if (Bi(W)) return Xe ? Xe.call(W) : "";
    var Z = W + "";
    return Z == "0" && 1 / W == -a ? "-0" : Z;
  }
  function Jd(W, Z, se) {
    var ye = -1,
      Je = Mt,
      De = W.length,
      Ze = !0,
      yn = [],
      fn = yn;
    if (De >= n) {
      var ur = Z ? null : Vc(W);
      if (ur) return H(ur);
      (Ze = !1), (Je = wn), (fn = new Ei());
    } else fn = Z ? [] : yn;
    e: for (; ++ye < De; ) {
      var Kn = W[ye],
        dr = Z ? Z(Kn) : Kn;
      if (((Kn = Kn !== 0 ? Kn : 0), Ze && dr === dr)) {
        for (var br = fn.length; br--; ) if (fn[br] === dr) continue e;
        Z && fn.push(dr), yn.push(Kn);
      } else Je(fn, dr, se) || (fn !== yn && fn.push(dr), yn.push(Kn));
    }
    return yn;
  }
  function ef(W) {
    return qn(W) ? W : Rr(W);
  }
  var Vc =
    ln && 1 / H(new ln([, -0]))[1] == a
      ? function (W) {
          return new ln(W);
        }
      : Co;
  function Fu(W, Z, se, ye, Je, De) {
    var Ze = Je & o,
      yn = W.length,
      fn = Z.length;
    if (yn != fn && !(Ze && fn > yn)) return !1;
    var ur = De.get(W);
    if (ur && De.get(Z)) return ur == Z;
    var Kn = -1,
      dr = !0,
      br = Je & s ? new Ei() : void 0;
    for (De.set(W, Z), De.set(Z, W); ++Kn < yn; ) {
      var Ai = W[Kn],
        mi = Z[Kn];
      if (ye) var vs = Ze ? ye(mi, Ai, Kn, Z, W, De) : ye(Ai, mi, Kn, W, Z, De);
      if (vs !== void 0) {
        if (vs) continue;
        dr = !1;
        break;
      }
      if (br) {
        if (
          !an(Z, function (Ni, ko) {
            if (!br.has(ko) && (Ai === Ni || se(Ai, Ni, ye, Je, De)))
              return br.add(ko);
          })
        ) {
          dr = !1;
          break;
        }
      } else if (!(Ai === mi || se(Ai, mi, ye, Je, De))) {
        dr = !1;
        break;
      }
    }
    return De.delete(W), De.delete(Z), dr;
  }
  function Uu(W, Z, se, ye, Je, De, Ze) {
    switch (se) {
      case P:
        if (W.byteLength != Z.byteLength || W.byteOffset != Z.byteOffset)
          return !1;
        (W = W.buffer), (Z = Z.buffer);
      case I:
        return !(W.byteLength != Z.byteLength || !ye(new Ht(W), new Ht(Z)));
      case d:
      case f:
      case v:
        return jt(+W, +Z);
      case h:
        return W.name == Z.name && W.message == Z.message;
      case S:
      case O:
        return W == Z + "";
      case b:
        var yn = _n;
      case R:
        var fn = De & o;
        if ((yn || (yn = H), W.size != Z.size && !fn)) return !1;
        var ur = Ze.get(W);
        if (ur) return ur == Z;
        (De |= s), Ze.set(W, Z);
        var Kn = Fu(yn(W), yn(Z), ye, Je, De, Ze);
        return Ze.delete(W), Kn;
      case B:
        if (nt) return nt.call(W) == nt.call(Z);
    }
    return !1;
  }
  function tf(W, Z, se, ye, Je, De) {
    var Ze = Je & o,
      yn = Bh(W),
      fn = yn.length,
      ur = Bh(Z),
      Kn = ur.length;
    if (fn != Kn && !Ze) return !1;
    for (var dr = fn; dr--; ) {
      var br = yn[dr];
      if (!(Ze ? br in Z : vt.call(Z, br))) return !1;
    }
    var Ai = De.get(W);
    if (Ai && De.get(Z)) return Ai == Z;
    var mi = !0;
    De.set(W, Z), De.set(Z, W);
    for (var vs = Ze; ++dr < fn; ) {
      br = yn[dr];
      var Ni = W[br],
        ko = Z[br];
      if (ye) var Fh = Ze ? ye(ko, Ni, br, Z, W, De) : ye(Ni, ko, br, W, Z, De);
      if (!(Fh === void 0 ? Ni === ko || se(Ni, ko, ye, Je, De) : Fh)) {
        mi = !1;
        break;
      }
      vs || (vs = br == "constructor");
    }
    if (mi && !vs) {
      var ec = W.constructor,
        pl = Z.constructor;
      ec != pl &&
        "constructor" in W &&
        "constructor" in Z &&
        !(
          typeof ec == "function" &&
          ec instanceof ec &&
          typeof pl == "function" &&
          pl instanceof pl
        ) &&
        (mi = !1);
    }
    return De.delete(W), De.delete(Z), mi;
  }
  function Gc(W, Z) {
    var se = W.__data__;
    return Yc(Z) ? se[typeof Z == "string" ? "string" : "hash"] : se.map;
  }
  function qc(W) {
    for (var Z = Bh(W), se = Z.length; se--; ) {
      var ye = Z[se],
        Je = W[ye];
      Z[se] = [ye, Je, Dh(Je)];
    }
    return Z;
  }
  function ja(W, Z) {
    var se = xt(W, Z);
    return Rh(se) ? se : void 0;
  }
  var Os = Zd;
  ((Cn && Os(new Cn(new ArrayBuffer(1))) != P) ||
    (cn && Os(new cn()) != b) ||
    (Yt && Os(Yt.resolve()) != x) ||
    (ln && Os(new ln()) != R) ||
    (oe && Os(new oe()) != C)) &&
    (Os = function (W) {
      var Z = ct.call(W),
        se = Z == w ? W.constructor : void 0,
        ye = se ? ie(se) : void 0;
      if (ye)
        switch (ye) {
          case be:
            return P;
          case Me:
            return b;
          case Fe:
            return x;
          case it:
            return R;
          case ft:
            return C;
        }
      return Z;
    });
  function Ps(W, Z, se) {
    Z = Kc(Z, W) ? [Z] : ef(Z);
    for (var ye, Je = -1, Ze = Z.length; ++Je < Ze; ) {
      var De = $u(Z[Je]);
      if (!(ye = W != null && se(W, De))) break;
      W = W[De];
    }
    if (ye) return ye;
    var Ze = W ? W.length : 0;
    return !!Ze && Ii(Ze) && Da(De, Ze) && (qn(W) || Wn(W));
  }
  function Da(W, Z) {
    return (
      (Z = Z ?? l),
      !!Z &&
        (typeof W == "number" || ae.test(W)) &&
        W > -1 &&
        W % 1 == 0 &&
        W < Z
    );
  }
  function Kc(W, Z) {
    if (qn(W)) return !1;
    var se = typeof W;
    return se == "number" ||
      se == "symbol" ||
      se == "boolean" ||
      W == null ||
      Bi(W)
      ? !0
      : z.test(W) || !j.test(W) || (Z != null && W in Object(Z));
  }
  function Yc(W) {
    var Z = typeof W;
    return Z == "string" || Z == "number" || Z == "symbol" || Z == "boolean"
      ? W !== "__proto__"
      : W === null;
  }
  function E0(W) {
    return !!we && we in W;
  }
  function jh(W) {
    var Z = W && W.constructor,
      se = (typeof Z == "function" && Z.prototype) || ce;
    return W === se;
  }
  function Dh(W) {
    return W === W && !Di(W);
  }
  function Dr(W, Z) {
    return function (se) {
      return se == null ? !1 : se[W] === Z && (Z !== void 0 || W in Object(se));
    };
  }
  var Rr = Ie(function (W) {
    W = nf(W);
    var Z = [];
    return (
      $.test(W) && Z.push(""),
      W.replace(K, function (se, ye, Je, De) {
        Z.push(Je ? De.replace(G, "$1") : ye || se);
      }),
      Z
    );
  });
  function $u(W) {
    if (typeof W == "string" || Bi(W)) return W;
    var Z = W + "";
    return Z == "0" && 1 / W == -a ? "-0" : Z;
  }
  function ie(W) {
    if (W != null) {
      try {
        return ht.call(W);
      } catch {}
      try {
        return W + "";
      } catch {}
    }
    return "";
  }
  function me(W, Z) {
    return W && W.length ? Jd(W, Bu(Z)) : [];
  }
  function Ie(W, Z) {
    if (typeof W != "function" || (Z && typeof Z != "function"))
      throw new TypeError(r);
    var se = function () {
      var ye = arguments,
        Je = Z ? Z.apply(this, ye) : ye[0],
        De = se.cache;
      if (De.has(Je)) return De.get(Je);
      var Ze = W.apply(this, ye);
      return (se.cache = De.set(Je, Ze)), Ze;
    };
    return (se.cache = new (Ie.Cache || si)()), se;
  }
  Ie.Cache = si;
  function jt(W, Z) {
    return W === Z || (W !== W && Z !== Z);
  }
  function Wn(W) {
    return (
      dn(W) &&
      vt.call(W, "callee") &&
      (!mn.call(W, "callee") || ct.call(W) == c)
    );
  }
  var qn = Array.isArray;
  function cr(W) {
    return W != null && Ii(W.length) && !Br(W);
  }
  function dn(W) {
    return Gs(W) && cr(W);
  }
  function Br(W) {
    var Z = Di(W) ? ct.call(W) : "";
    return Z == p || Z == g;
  }
  function Ii(W) {
    return typeof W == "number" && W > -1 && W % 1 == 0 && W <= l;
  }
  function Di(W) {
    var Z = typeof W;
    return !!W && (Z == "object" || Z == "function");
  }
  function Gs(W) {
    return !!W && typeof W == "object";
  }
  function Bi(W) {
    return typeof W == "symbol" || (Gs(W) && ct.call(W) == B);
  }
  var Jl = Wt ? Pt(Wt) : Qd;
  function nf(W) {
    return W == null ? "" : Lh(W);
  }
  function C1(W, Z, se) {
    var ye = W == null ? void 0 : hl(W, Z);
    return ye === void 0 ? se : ye;
  }
  function k1(W, Z) {
    return W != null && Ps(W, Z, Nh);
  }
  function Bh(W) {
    return cr(W) ? Ih(W) : Xl(W);
  }
  function rf(W) {
    return W;
  }
  function Co() {}
  function qv(W) {
    return Kc(W) ? Rt($u(W)) : Xd(W);
  }
  e.exports = me;
})(B5, B5.exports);
var eke = B5.exports;
const tke = Gi(eke);
var Dt;
(function (e) {
  (e.AlphaWallet = "isAlphaWallet"),
    (e.ApexWallet = "isApexWallet"),
    (e.AToken = "isAToken"),
    (e.BifrostWallet = "isBifrost"),
    (e.Binance = "bbcSignTx"),
    (e.Bitpie = "isBitpie"),
    (e.BlockWallet = "isBlockWallet"),
    (e.Coinbase = "isToshi"),
    (e.CoinbaseExtension = "isCoinbaseWallet"),
    (e.Detected = "request"),
    (e.Dcent = "isDcentWallet"),
    (e.Exodus = "isExodus"),
    (e.Frontier = "isFrontier"),
    (e.Frame = "isFrame"),
    (e.HuobiWallet = "isHbWallet"),
    (e.HyperPay = "isHyperPay"),
    (e.ImToken = "isImToken"),
    (e.InfinityWallet = "isInfinityWallet"),
    (e.Liquality = "isLiquality"),
    (e.MeetOne = "wallet"),
    (e.MetaMask = "isMetaMask"),
    (e.MyKey = "isMYKEY"),
    (e.OwnBit = "isOwnbit"),
    (e.Status = "isStatus"),
    (e.Trust = "isTrust"),
    (e.TokenPocket = "isTokenPocket"),
    (e.TP = "isTp"),
    (e.WalletIo = "isWalletIO"),
    (e.XDEFI = "isXDEFI"),
    (e.OneInch = "isOneInchIOSWallet"),
    (e.Tokenary = "isTokenary"),
    (e.Tally = "isTally"),
    (e.BraveWallet = "isBraveWallet"),
    (e.Rabby = "isRabby"),
    (e.MathWallet = "isMathWallet"),
    (e.Bitget = "isBitKeep"),
    (e.Sequence = "isSequence"),
    (e.Core = "isAvalanche"),
    (e.Opera = "isOpera"),
    (e.Bitski = "isBitski"),
    (e.Enkrypt = "isEnkrypt"),
    (e.Phantom = "isPhantom"),
    (e.OKXWallet = "isOkxWallet"),
    (e.Zeal = "isZeal"),
    (e.Zerion = "isZerion"),
    (e.Rainbow = "isRainbow"),
    (e.SafePal = "isSafePal"),
    (e.DeFiWallet = "isDeficonnectProvider"),
    (e.Safeheron = "isSafeheron"),
    (e.Talisman = "isTalisman"),
    (e.OneKey = "isOneKey"),
    (e.Fordefi = "isFordefi"),
    (e.Coin98Wallet = "isCoin98"),
    (e.SubWallet = "isSubWallet"),
    (e.Kayros = "isKayros"),
    (e.FoxWallet = "isFoxWallet");
})(Dt || (Dt = {}));
var Ra;
(function (e) {
  (e.Binance = "https://www.bnbchain.org/ru/blog/binance-extension-wallet/"),
    (e.Bitget = "https://web3.bitget.com/en/wallet-download"),
    (e.Coinbase = "https://www.coinbase.com/wallet/downloads"),
    (e.MetaMask = "https://metamask.io/download/"),
    (e.OKXWallet = "https://okx.com/download"),
    (e.Phantom = "https://phantom.app/ul/v1/connect"),
    (e.Talisman = "https://www.talisman.xyz/"),
    (e.Trust = "https://link.trustwallet.com"),
    (e.OneKey = "https://onekey.so/download/"),
    (e.RoninWallet = "https://wallet.skymavis.com/"),
    (e.Coin98Wallet = "https://coin98.com/wallet/"),
    (e.SubWallet = "https://www.subwallet.app/"),
    (e.Kayros = "https://www.kayros.games/wallet/"),
    (e.XDEFI = "https://xdefi.io/"),
    (e.FoxWallet = "https://foxwallet.com/download");
})(Ra || (Ra = {}));
var on;
(function (e) {
  (e.AlphaWallet = "AlphaWallet"),
    (e.ApexWallet = "Apex Wallet"),
    (e.AToken = "AToken"),
    (e.BifrostWallet = "Bifrost Wallet"),
    (e.Binance = "Binance Smart Wallet"),
    (e.Bitpie = "Bitpie"),
    (e.Bitski = "Bitski"),
    (e.BlockWallet = "BlockWallet"),
    (e.Brave = "Brave Wallet"),
    (e.Coinbase = "Coinbase Wallet"),
    (e.Dcent = "D'CENT"),
    (e.Detected = "Detected Wallet"),
    (e.Exodus = "Exodus"),
    (e.Frame = "Frame"),
    (e.Frontier = "Frontier"),
    (e.HuobiWallet = "Huobi Wallet"),
    (e.HyperPay = "HyperPay"),
    (e.ImToken = "imToken"),
    (e.InfinityWallet = "Infinity Wallet"),
    (e.Liquality = "Liquality"),
    (e.MeetOne = "MeetOne"),
    (e.MetaMask = "MetaMask"),
    (e.MyKey = "MyKey"),
    (e.Opera = "Opera Wallet"),
    (e.OwnBit = "OwnBit"),
    (e.Status = "Status Wallet"),
    (e.Trust = "Trust Wallet"),
    (e.TokenPocket = "TokenPocket"),
    (e.TP = "TP Wallet"),
    (e.WalletIo = "Wallet.io"),
    (e.XDEFI = "XDEFI Wallet"),
    (e.OneInch = "1inch Wallet"),
    (e.Tokenary = "Tokenary Wallet"),
    (e.Tally = "Taho"),
    (e.Rabby = "Rabby Wallet"),
    (e.MathWallet = "MathWallet"),
    (e.Bitget = "Bitget Wallet"),
    (e.Sequence = "Sequence"),
    (e.Core = "Core"),
    (e.Enkrypt = "Enkrypt"),
    (e.Zeal = "Zeal"),
    (e.Phantom = "Phantom"),
    (e.OKXWallet = "OKX Wallet"),
    (e.Zerion = "Zerion"),
    (e.Rainbow = "Rainbow"),
    (e.SafePal = "SafePal"),
    (e.DeFiWallet = "DeFi Wallet"),
    (e.Safeheron = "Safeheron"),
    (e.Talisman = "Talisman"),
    (e.OneKey = "OneKey"),
    (e.Fordefi = "Fordefi"),
    (e.RoninWallet = "Ronin Wallet"),
    (e.Coin98Wallet = "Coin98 Wallet"),
    (e.SubWallet = "SubWallet"),
    (e.Kayros = "Kayros"),
    (e.FoxWallet = "FoxWallet");
})(on || (on = {}));
var Kt;
(function (e) {
  (e.Ethereum = "ethereum"),
    (e.Binance = "BinanceChain"),
    (e.Tally = "tally"),
    (e.Web3 = "web3"),
    (e.Arbitrum = "arbitrum"),
    (e.XFI = "xfi"),
    (e.Bitget = "bitkeep"),
    (e.Avalanche = "avalanche"),
    (e.Bitski = "Bitski"),
    (e.Enkrypt = "enkrypt"),
    (e.Zeal = "zeal"),
    (e.Phantom = "phantom"),
    (e.OKXWallet = "okxwallet"),
    (e.Trust = "trustwallet"),
    (e.Frontier = "frontier"),
    (e.DeFiConnectProvider = "deficonnectProvider"),
    (e.Safeheron = "safeheron"),
    (e.Talisman = "talismanEth"),
    (e.OneKey = "$onekey"),
    (e.RoninWallet = "ronin"),
    (e.Coin98Wallet = "coin98"),
    (e.SubWallet = "SubWallet"),
    (e.Kayros = "kayros"),
    (e.FoxWallet = "foxwallet");
})(Kt || (Kt = {}));
const So = null;
function Bc(e, t) {
  return async () => ({
    provider:
      window.ethereum.providers && Array.isArray(window.ethereum.providers)
        ? nke(e, t)
        : window.ethereum,
  });
}
function nke(e, t) {
  return window.ethereum.providers.find((n) =>
    t ? !!n[e] && !Ree(e, n) : !!n[e]
  );
}
function Ree(e, t) {
  return Object.values(Dt)
    .filter((r) => r !== e && r !== Dt.Detected)
    .some((r) => !!t[r]);
}
const rke = {
    label: on.MetaMask,
    injectedNamespace: Kt.Ethereum,
    checkProviderIdentity: ({ provider: e }) =>
      !!e && !!e[Dt.MetaMask] && !Ree(Dt.MetaMask, e),
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./metamask-BnRi-VtU.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: Bc(Dt.MetaMask, !0),
    platforms: ["all"],
    externalUrl: Ra.MetaMask,
  },
  ike = {
    label: on.InfinityWallet,
    injectedNamespace: Kt.Ethereum,
    checkProviderIdentity: ({ provider: e }) => !!e && !!e[Dt.InfinityWallet],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./infinitywallet-B3Dl-7rf.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: Bc(Dt.InfinityWallet),
    platforms: ["desktop"],
  },
  ske = {
    label: on.Exodus,
    injectedNamespace: Kt.Ethereum,
    checkProviderIdentity: ({ provider: e }) => !!e && !!e[Dt.Exodus],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./exodus-CokzJYSo.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: Bc(Dt.Exodus),
    platforms: ["all"],
  },
  oke = {
    label: on.Frontier,
    injectedNamespace: Kt.Frontier,
    checkProviderIdentity: ({ provider: e }) =>
      !!e && !!e.ethereum && !!e.ethereum[Dt.Frontier],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./frontier-KVnJjdmQ.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: async () => ({ provider: hi(window.frontier.ethereum) }),
    platforms: ["all"],
  },
  ake = {
    label: on.Brave,
    injectedNamespace: Kt.Ethereum,
    checkProviderIdentity: ({ provider: e }) => !!e && !!e[Dt.BraveWallet],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./brave-BaDXvGW7.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: Bc(Dt.BraveWallet),
    platforms: ["all"],
  },
  lke = {
    label: on.Binance,
    injectedNamespace: Kt.Binance,
    checkProviderIdentity: ({ provider: e }) => !!e && !!e[Dt.Binance],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./binance-DKfHEPwi.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: async () => {
      let e = { ...window.BinanceChain };
      window.BinanceChain = e;
      const t = window.BinanceChain.on.bind(window.BinanceChain);
      window.BinanceChain.on = (r, i) => {
        r === "chainChanged"
          ? t(r, (s) => {
              i(`0x${parseInt(s).toString(16)}`);
            })
          : t(r, i);
      };
      const n = hi(window.BinanceChain, {
        eth_chainId: ({ baseRequest: r }) =>
          r({ method: "eth_chainId" }).then(
            (i) => `0x${parseInt(i).toString(16)}`
          ),
        eth_selectAccounts: So,
        wallet_switchEthereumChain: So,
      });
      return (n.removeListener = (r, i) => {}), { provider: n };
    },
    platforms: ["desktop"],
    externalUrl: Ra.Binance,
  },
  cke = {
    label: on.Coinbase,
    injectedNamespace: Kt.Ethereum,
    checkProviderIdentity: ({ provider: e }) =>
      (!!e && !!e[Dt.Coinbase]) || (!!e && !!e[Dt.CoinbaseExtension]),
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./coinbase-CrEj8Vm7.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: async () => {
      const { provider: e } = await Bc(Dt.CoinbaseExtension)(),
        t = e.on.bind(e);
      return (
        (e.on = (n, r) => {
          n === "chainChanged"
            ? t(n, (i) => {
                r(`0x${parseInt(i).toString(16)}`);
              })
            : t(n, r);
        }),
        { provider: e }
      );
    },
    platforms: ["all"],
    externalUrl: Ra.Coinbase,
  },
  uke = {
    label: on.Detected,
    injectedNamespace: Kt.Ethereum,
    checkProviderIdentity: ({ provider: e }) => !!e && !!e[Dt.Detected],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./detected-B5TJ64kR.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: async () => ({ provider: window.ethereum }),
    platforms: ["all"],
  },
  dke = {
    label: on.Trust,
    injectedNamespace: Kt.Trust,
    checkProviderIdentity: ({ provider: e }) => !!e && !!e[Dt.Trust],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./trust-DzcMxGnK.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: async () => {
      const e = window.hasOwnProperty(Kt.Ethereum);
      let t;
      return (
        e && window[Kt.Ethereum].isTrust
          ? (t = window[Kt.Ethereum])
          : (t = window[Kt.Trust]),
        { provider: t }
      );
    },
    platforms: ["all"],
    externalUrl: Ra.Trust,
  },
  fke = {
    label: on.Opera,
    injectedNamespace: Kt.Ethereum,
    checkProviderIdentity: ({ provider: e }) => !!e && !!e[Dt.Opera],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./opera-BlUFsBw2.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: async () => ({
      provider: hi(window.ethereum, {
        eth_requestAccounts: async ({ baseRequest: e }) =>
          e({ method: "eth_accounts" }),
        eth_selectAccounts: So,
      }),
    }),
    platforms: ["all"],
  },
  hke = {
    label: on.Status,
    injectedNamespace: Kt.Ethereum,
    checkProviderIdentity: ({ provider: e }) => !!e && !!e[Dt.Status],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./status-DEbRpCSZ.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: async () => ({ provider: window.ethereum }),
    platforms: ["mobile"],
  },
  pke = {
    label: on.AlphaWallet,
    injectedNamespace: Kt.Ethereum,
    checkProviderIdentity: ({ provider: e }) => !!e && !!e[Dt.AlphaWallet],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./alphawallet-BYxyLSyF.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: async () => ({
      provider: hi(window.ethereum, {
        wallet_switchEthereumChain: So,
        eth_selectAccounts: So,
      }),
    }),
    platforms: ["mobile"],
  },
  mke = {
    label: on.ApexWallet,
    injectedNamespace: Kt.Ethereum,
    checkProviderIdentity: ({ provider: e }) => !!e && !!e[Dt.ApexWallet],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./apexwallet-NS7FlaY4.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: async () => ({ provider: window.ethereum }),
    platforms: ["desktop", "Chrome", "Chromium", "Microsoft Edge"],
  },
  gke = {
    label: on.AToken,
    injectedNamespace: Kt.Ethereum,
    checkProviderIdentity: ({ provider: e }) => !!e && !!e[Dt.AToken],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./atoken-CMEoSy7G.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: async () => ({ provider: window.ethereum }),
    platforms: ["mobile"],
  },
  yke = {
    label: on.BifrostWallet,
    injectedNamespace: Kt.Ethereum,
    checkProviderIdentity: ({ provider: e }) => !!e && !!e[Dt.BifrostWallet],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./bifrostwallet-CzEJJq7Q.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: Bc(Dt.BifrostWallet),
    platforms: ["all"],
  },
  vke = {
    label: on.Bitpie,
    injectedNamespace: Kt.Ethereum,
    checkProviderIdentity: () => !!window.Bitpie,
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./bitpie-BjtS8guf.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: async () => ({
      provider: hi(window.ethereum, {
        wallet_switchEthereumChain: So,
        eth_selectAccounts: So,
      }),
    }),
    platforms: ["mobile"],
  },
  wke = {
    label: on.BlockWallet,
    injectedNamespace: Kt.Ethereum,
    checkProviderIdentity: ({ provider: e }) => !!e && !!e[Dt.BlockWallet],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./blockwallet-Cv_NU9OT.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: Bc(Dt.BlockWallet),
    platforms: ["desktop"],
  },
  bke = {
    label: on.Frame,
    injectedNamespace: Kt.Ethereum,
    checkProviderIdentity: ({ provider: e }) => !!e && !!e[Dt.Frame],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./frame-BNDnw4sb.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: async () => {
      const e = window.ethereum;
      if (!e || !e.connected)
        throw new Error(
          "Frame App must be open with a hot wallet connected. If not installed first download the Frame App."
        );
      return { provider: e };
    },
    platforms: ["desktop"],
  },
  xke = {
    label: on.HuobiWallet,
    injectedNamespace: Kt.Ethereum,
    checkProviderIdentity: ({ provider: e }) => !!e && !!e[Dt.HuobiWallet],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./huobiwallet-Ct6qXzy7.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: async () => ({
      provider: hi(window.ethereum, {
        wallet_switchEthereumChain: So,
        eth_selectAccounts: So,
      }),
    }),
    platforms: ["mobile"],
  },
  _ke = {
    label: on.HyperPay,
    injectedNamespace: Kt.Ethereum,
    checkProviderIdentity: () => !!window.hiWallet,
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./hyperpay-7nxffAdA.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: async () => ({
      provider: hi(window.ethereum, {
        wallet_switchEthereumChain: So,
        eth_selectAccounts: So,
      }),
    }),
    platforms: ["mobile"],
  },
  Ske = {
    label: on.ImToken,
    injectedNamespace: Kt.Ethereum,
    checkProviderIdentity: ({ provider: e }) => !!e && !!e[Dt.ImToken],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./imtoken-5GbbboMy.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: async () => ({
      provider: hi(window.ethereum, { eth_selectAccounts: So }),
    }),
    platforms: ["mobile"],
  },
  Eke = {
    label: on.Liquality,
    injectedNamespace: Kt.Ethereum,
    checkProviderIdentity: ({ provider: e }) => !!e && !!e[Dt.Liquality],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./liquality-BIQsbXhN.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: async () => {
      const e = hi(window.ethereum, {
        wallet_switchEthereumChain: So,
        eth_selectAccounts: So,
      });
      return (e.removeListener = (t, n) => {}), { provider: e };
    },
    platforms: ["desktop"],
  },
  Ake = {
    label: on.MeetOne,
    injectedNamespace: Kt.Ethereum,
    checkProviderIdentity: ({ provider: e }) =>
      !!e && e[Dt.MeetOne] === "MEETONE",
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./meetone-BWx30j-q.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: async () => ({ provider: window.ethereum }),
    platforms: ["mobile"],
  },
  Cke = {
    label: on.MyKey,
    injectedNamespace: Kt.Ethereum,
    checkProviderIdentity: ({ provider: e }) => !!e && !!e[Dt.MyKey],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./mykey-DXV41ggG.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: async () => ({ provider: window.ethereum }),
    platforms: ["mobile"],
  },
  kke = {
    label: on.OwnBit,
    injectedNamespace: Kt.Ethereum,
    checkProviderIdentity: ({ provider: e }) => !!e && !!e[Dt.OwnBit],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./ownbit-BdTY-PH9.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: async () => {
      const e = hi(window.ethereum, {
        eth_chainId: ({ baseRequest: t }) =>
          t({ method: "eth_chainId" }).then(
            (n) => `0x${parseInt(n).toString(16)}`
          ),
        wallet_switchEthereumChain: So,
        eth_selectAccounts: So,
      });
      return (
        (e.removeListener = (t, n) => {}),
        (e.on = (t, n) => {}),
        { provider: e }
      );
    },
    platforms: ["mobile"],
  },
  Tke = {
    label: on.TokenPocket,
    injectedNamespace: Kt.Ethereum,
    checkProviderIdentity: ({ provider: e }) =>
      !!e && !!e[Dt.TokenPocket] && !e[Dt.TP],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./tokenpocket-Dbi32VQr.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: Bc(Dt.TokenPocket),
    platforms: ["all"],
  },
  Mke = {
    label: on.TP,
    injectedNamespace: Kt.Ethereum,
    checkProviderIdentity: ({ provider: e }) => !!e && !!e[Dt.TP],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./tp-BbFFERM0.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: async () => ({
      provider: hi(window.ethereum, {
        wallet_switchEthereumChain: So,
        eth_selectAccounts: So,
      }),
    }),
    platforms: ["mobile"],
  },
  Ike = {
    label: on.XDEFI,
    injectedNamespace: Kt.XFI,
    checkProviderIdentity: ({ provider: e }) =>
      e && e.ethereum && e.ethereum[Dt.XDEFI],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./xdefi-CpZ4LxGD.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: async () => ({ provider: window.xfi && window.xfi.ethereum }),
    platforms: ["all"],
    externalUrl: Ra.XDEFI,
  },
  Nke = {
    label: on.OneInch,
    injectedNamespace: Kt.Ethereum,
    checkProviderIdentity: ({ provider: e }) => !!e && !!e[Dt.OneInch],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./oneInch-Jk8tDDo8.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: async () => ({ provider: hi(window.ethereum) }),
    platforms: ["mobile"],
  },
  Rke = {
    label: on.Tokenary,
    injectedNamespace: Kt.Ethereum,
    checkProviderIdentity: ({ provider: e }) => !!e && !!e[Dt.Tokenary],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./tokenary-DSpo6s4M.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: async () => ({ provider: hi(window.ethereum) }),
    platforms: ["all"],
  },
  Oke = {
    label: on.Tally,
    injectedNamespace: Kt.Tally,
    checkProviderIdentity: ({ provider: e }) => !!e && !!e[Dt.Tally],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./tallywallet-CxbOvuj7.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: async () => ({ provider: hi(window.tally) }),
    platforms: ["desktop"],
  },
  Pke = {
    label: on.Zeal,
    injectedNamespace: Kt.Zeal,
    checkProviderIdentity: ({ provider: e }) => !!e && !!e[Dt.Zeal],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./zeal-b2F8mFyk.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: async () => ({ provider: hi(window.zeal) }),
    platforms: ["desktop"],
  },
  Lke = {
    label: on.Rabby,
    injectedNamespace: Kt.Ethereum,
    checkProviderIdentity: ({ provider: e }) => !!e && !!e[Dt.Rabby],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./rabby-CIHjwZn9.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: async () => ({ provider: hi(window.ethereum) }),
    platforms: ["desktop"],
  },
  jke = {
    label: on.MathWallet,
    injectedNamespace: Kt.Ethereum,
    checkProviderIdentity: ({ provider: e }) => !!e && !!e[Dt.MathWallet],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./mathwallet-47rJD3aJ.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: Bc(Dt.MathWallet),
    platforms: ["all"],
  },
  Dke = {
    label: on.Bitget,
    injectedNamespace: Kt.Bitget,
    checkProviderIdentity: ({ provider: e }) => !!e && !!e.ethereum[Dt.Bitget],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./bitget-CGoh9UgG.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: async () => ({
      provider: window.bitkeep && window.bitkeep.ethereum,
    }),
    platforms: ["all"],
    externalUrl: Ra.Bitget,
  },
  Bke = {
    label: on.Sequence,
    injectedNamespace: Kt.Ethereum,
    checkProviderIdentity: ({ provider: e }) => !!e && !!e[Dt.Sequence],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./sequence-Dec4m3rM.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: async () => ({ provider: window.ethereum }),
    platforms: ["all"],
  },
  Fke = {
    label: on.Core,
    injectedNamespace: Kt.Avalanche,
    checkProviderIdentity: ({ provider: e }) => !!e && !!e[Dt.Core],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./core-bAnGbZV0.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: Bc(Dt.Core),
    platforms: ["desktop", "Chrome", "Chromium", "Microsoft Edge"],
  },
  Uke = {
    label: on.Bitski,
    injectedNamespace: Kt.Bitski,
    checkProviderIdentity: ({ provider: e }) =>
      !!e && !!e.getProvider && !!e.getProvider().isBitski,
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./bitski-SmR6xDPs.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: async () => ({
      provider:
        window.Bitski &&
        window.Bitski.getProvider &&
        window.Bitski.getProvider(),
    }),
    platforms: ["all"],
  },
  $ke = {
    label: on.Zerion,
    injectedNamespace: Kt.Ethereum,
    checkProviderIdentity: ({ provider: e }) => !!e && !!e[Dt.Zerion],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./zerion-XrObZCmj.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: async () => ({ provider: hi(window.ethereum) }),
    platforms: ["all"],
  },
  zke = {
    label: on.Enkrypt,
    injectedNamespace: Kt.Enkrypt,
    checkProviderIdentity: ({ provider: e }) =>
      !!e && !!e.providers && !!e.providers.ethereum,
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./enkrypt-8Yg7sLuK.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: async () => {
      const e = window.enkrypt.providers.ethereum.on.bind(
        window.enkrypt.providers.ethereum
      );
      window.enkrypt.providers.ethereum.on = (n, r) => {
        n === "chainChanged"
          ? e(n, (i) => {
              r(`0x${parseInt(i).toString(16)}`);
            })
          : e(n, r);
      };
      const t = hi(window.enkrypt.providers.ethereum, {
        eth_chainId: ({ baseRequest: n }) =>
          n({ method: "eth_chainId" }).then(
            (r) => `0x${parseInt(r).toString(16)}`
          ),
      });
      return (t.removeListener = (n, r) => {}), { provider: t };
    },
    platforms: ["all"],
  },
  Wke = {
    label: on.Phantom,
    injectedNamespace: Kt.Phantom,
    checkProviderIdentity: ({ provider: e }) =>
      !!e && !!e.ethereum && !!e.ethereum[Dt.Phantom],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./phantom-Bq8oBCC9.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: async () => ({ provider: hi(window.phantom.ethereum) }),
    platforms: ["all"],
    externalUrl: Ra.Phantom,
  },
  Hke = {
    label: on.SafePal,
    injectedNamespace: Kt.Ethereum,
    checkProviderIdentity: ({ provider: e }) => !!e && !!e[Dt.SafePal],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./safepal-1ALKnv5Z.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: async () => ({ provider: hi(window.ethereum) }),
    platforms: ["all"],
  },
  Vke = {
    label: on.Rainbow,
    injectedNamespace: Kt.Ethereum,
    checkProviderIdentity: ({ provider: e }) => !!e && !!e[Dt.Rainbow],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./rainbow-Bk0xXB-l.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: Bc(Dt.Rainbow),
    platforms: ["all"],
  },
  Gke = {
    label: on.OKXWallet,
    injectedNamespace: Kt.OKXWallet,
    checkProviderIdentity: ({ provider: e }) => !!e && !!e[Dt.OKXWallet],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./okxwallet-CRkGxbWO.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: async () => ({ provider: hi(window.okxwallet) }),
    platforms: ["all"],
    externalUrl: Ra.OKXWallet,
  },
  qke = {
    label: on.DeFiWallet,
    injectedNamespace: Kt.DeFiConnectProvider,
    checkProviderIdentity: ({ provider: e }) => !!e && !!e[Dt.DeFiWallet],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./defiwallet-BTfpwPtA.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: async () => ({ provider: hi(window.deficonnectProvider) }),
    platforms: ["all"],
  },
  Kke = {
    label: on.Safeheron,
    injectedNamespace: Kt.Safeheron,
    checkProviderIdentity: ({ provider: e }) => !!e && !!e[Dt.Safeheron],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./safeheron-CpAKyowH.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: async () => ({ provider: hi(window.safeheron) }),
    platforms: ["desktop", "Chrome", "Chromium", "Microsoft Edge"],
  },
  Yke = {
    label: on.Talisman,
    injectedNamespace: Kt.Talisman,
    checkProviderIdentity: ({ provider: e }) => !!e && !!e[Dt.Talisman],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./talisman-Bvq7wiKe.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: async () => ({ provider: hi(window.talismanEth) }),
    platforms: ["desktop"],
    externalUrl: Ra.Talisman,
  },
  Zke = {
    label: on.RoninWallet,
    injectedNamespace: Kt.RoninWallet,
    checkProviderIdentity: ({ provider: e }) => !!e,
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./roninwallet-CsrXM8Qy.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: async () => ({ provider: hi(window.ronin.provider) }),
    platforms: ["all"],
    externalUrl: Ra.RoninWallet,
  },
  Qke = {
    label: on.OneKey,
    injectedNamespace: Kt.OneKey,
    checkProviderIdentity: ({ provider: e }) =>
      !!e && !!e.ethereum && !!e.ethereum[Dt.OneKey],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./onekey-CGcUTfNZ.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: async () => ({ provider: hi(window.$onekey.ethereum) }),
    platforms: ["all"],
    externalUrl: Ra.OneKey,
  },
  Xke = {
    label: on.Fordefi,
    injectedNamespace: Kt.Ethereum,
    checkProviderIdentity: ({ provider: e }) => !!e && !!e[Dt.Fordefi],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./fordefi-CP4eKV3b.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: Bc(Dt.Fordefi, !0),
    platforms: ["desktop"],
  },
  Jke = {
    label: on.Coin98Wallet,
    injectedNamespace: Kt.Ethereum,
    checkProviderIdentity: ({ provider: e }) => !!e && !!e[Dt.Coin98Wallet],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./coin98wallet-BPH2yV6a.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: async () => {
      const e = window.hasOwnProperty(Kt.Ethereum);
      let t;
      return (
        e && window[Kt.Ethereum].isCoin98
          ? (t = window[Kt.Ethereum])
          : (t = window[Kt.Coin98Wallet].provider),
        { provider: t }
      );
    },
    platforms: ["all"],
    externalUrl: Ra.Coin98Wallet,
  },
  eTe = {
    label: on.SubWallet,
    injectedNamespace: Kt.SubWallet,
    checkProviderIdentity: ({ provider: e }) => !!e && !!e[Dt.SubWallet],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./subwallet-DrohCGOh.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: async () => ({ provider: hi(window.SubWallet) }),
    platforms: ["all"],
    externalUrl: Ra.SubWallet,
  },
  tTe = {
    label: on.Kayros,
    injectedNamespace: Kt.Kayros,
    checkProviderIdentity: ({ provider: e }) => !!e && !!e[Dt.Kayros],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./kayros-B17ntheB.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: async () => ({ provider: hi(window.kayros) }),
    platforms: ["desktop"],
  },
  nTe = {
    label: on.FoxWallet,
    injectedNamespace: Kt.FoxWallet,
    checkProviderIdentity: ({ provider: e }) => !!e && !!e[Dt.FoxWallet],
    getIcon: async () =>
      (
        await At(async () => {
          const { default: e } = await import("./foxwallet-DcpMvgwH.js");
          return { default: e };
        }, [])
      ).default,
    getInterface: async () => ({ provider: hi(window.foxwallet) }),
    platforms: ["mobile"],
  },
  rTe = [
    Pke,
    ske,
    oke,
    rke,
    yke,
    lke,
    cke,
    uke,
    dke,
    fke,
    hke,
    pke,
    mke,
    gke,
    Dke,
    vke,
    wke,
    ake,
    bke,
    xke,
    _ke,
    Ske,
    Eke,
    Ake,
    Cke,
    kke,
    Tke,
    Mke,
    Ike,
    Nke,
    Rke,
    Oke,
    Lke,
    jke,
    Bke,
    Fke,
    Uke,
    zke,
    Wke,
    Gke,
    $ke,
    Vke,
    Hke,
    qke,
    ike,
    Kke,
    Yke,
    Qke,
    Xke,
    Zke,
    Jke,
    eTe,
    tTe,
    nTe,
  ],
  iTe = fe.object({
    label: fe.string().required(),
    getIcon: fe.function().arity(0).required(),
    getInterface: fe.function().maxArity(1).required(),
    injectedNamespace: fe.string().required(),
    checkProviderIdentity: fe.function().arity(1).required(),
    platforms: fe.array().items(fe.string()),
    externalUrl: fe.string(),
  }),
  sTe = fe.array().items(iTe),
  oTe = fe
    .object()
    .pattern(
      /\w+/,
      fe.any().allow(fe.boolean(), fe.array().items(fe.string()))
    ),
  aTe = fe.object({
    custom: sTe,
    filter: oTe,
    displayUnavailable: [fe.boolean(), fe.array().items(fe.string())],
    walletUnavailableMessage: fe.function(),
    sort: fe.function(),
    externalUrl: fe.string(),
  }),
  lTe = (e) => Eo(aTe, e),
  cTe = ({ label: e, externalUrl: t }) =>
    t
      ? `Please <a href="${t}" target="_blank">install or switch to</a> ${e} to continue`
      : `Please install or enable ${e} to continue`,
  uTe = (e, t, n) => {
    var r;
    return e
      ? t({ provider: e, device: n })
        ? !0
        : !!(
            !((r = e.providers) === null || r === void 0) &&
            r.some((i) => t({ provider: i, device: n }))
          )
      : !1;
  };
function dTe(e) {
  if (typeof window > "u") return () => null;
  if (e) {
    const t = lTe(e);
    if (t && t.error) throw t.error;
  }
  return (t) => {
    const { device: n } = t,
      {
        custom: r = [],
        filter: i = {},
        displayUnavailable: s,
        sort: o,
        walletUnavailableMessage: a,
      } = e || {},
      c = tke([...r, ...rTe], ({ label: u }) => u).reduce((u, d) => {
        const {
            label: f,
            platforms: h,
            injectedNamespace: p,
            checkProviderIdentity: g,
          } = d,
          b = i[f],
          v = b === !1,
          w = window[p],
          x = uTe(w, g, n);
        let S = !1;
        Array.isArray(b) &&
          (b.includes(n.type) || b.includes(n.os.name)) &&
          (S = !0),
          b === "unavailable" && !x && (S = !0);
        const R =
          !h.includes("all") && !h.includes(n.type) && !h.includes(n.os.name);
        return (
          !v &&
            !S &&
            !R &&
            (x ||
              s === !0 ||
              (Array.isArray(s) && s.length && s.includes(d.label))) &&
            u.push(
              (s === !0 ||
                (Array.isArray(s) && s.length && s.includes(d.label))) &&
                !x
                ? {
                    ...d,
                    getInterface: async () => {
                      throw new Error(a ? a(d) : cTe(d));
                    },
                  }
                : d
            ),
          u
        );
      }, []);
    if (c.length) {
      const u = c.length > 1,
        d = c
          .filter((f) => {
            const { label: h } = f;
            return !(h === on.Detected && u);
          })
          .map(({ label: f, getIcon: h, getInterface: p }) => ({
            label: f,
            getIcon: h,
            getInterface: p,
          }))
          .sort((f, h) => (f.label < h.label ? -1 : f.label > h.label ? 1 : 0));
      return o ? o(d) : d;
    }
    return [];
  };
}
function fTe(e) {
  const {
    buttonPosition: t,
    modalZIndex: n,
    apiKey: r,
    buildEnv: i,
    enableLogging: s,
    loginConfig: o,
    showTorusButton: a,
    integrity: l,
    whiteLabel: c,
  } = {};
  return () => ({
    label: "Torus",
    getIcon: async () =>
      (
        await At(async () => {
          const { default: u } = await import("./icon-CK0OD64e.js");
          return { default: u };
        }, [])
      ).default,
    getInterface: async ({ chains: u }) => {
      const { default: d } = await At(async () => {
          const { default: x } = await import("./torus.esm-DhhKzN1Z.js");
          return { default: x };
        }, __vite__mapDeps([5, 6, 7])),
        {
          createEIP1193Provider: f,
          ProviderRpcErrorCode: h,
          ProviderRpcError: p,
        } = await At(async () => {
          const {
            createEIP1193Provider: x,
            ProviderRpcErrorCode: S,
            ProviderRpcError: R,
          } = await import("./index-BHOazxOL.js");
          return {
            createEIP1193Provider: x,
            ProviderRpcErrorCode: S,
            ProviderRpcError: R,
          };
        }, []),
        [g] = u;
      let b = new d({ buttonPosition: t, modalZIndex: n, apiKey: r });
      await b.init({
        buildEnv: i,
        enableLogging: s,
        network: {
          host: g.rpcUrl || "",
          chainId: parseInt(g.id),
          networkName: g.label,
        },
        showTorusButton: a,
        loginConfig: o,
        integrity: l,
        whiteLabel: c,
      });
      const v = b.provider,
        w = f(v, {
          eth_requestAccounts: async () => {
            try {
              return await b.login();
            } catch {
              throw new p({
                code: h.ACCOUNT_ACCESS_REJECTED,
                message: "Account access rejected",
              });
            }
          },
          eth_selectAccounts: null,
          wallet_switchEthereumChain: async ({ params: x }) => {
            const S = u.find(({ id: R }) => R === x[0].chainId);
            if (!S) throw new Error("chain must be set before switching");
            return (
              await b.setProvider({
                host: S.rpcUrl || "",
                chainId: parseInt(S.id),
                networkName: S.label,
              }),
              null
            );
          },
          eth_chainId: async ({ baseRequest: x }) => {
            const S = await x({ method: "eth_chainId" });
            return `0x${parseInt(S).toString(16)}`;
          },
        });
      return (w.disconnect = () => b.cleanUp()), { provider: w, instance: b };
    },
  });
}
const hTe = fe.object({
    handleUri: fe.func().optional(),
    version: fe
      .number()
      .optional()
      .custom((e, t) => {
        if (e === 1)
          console.warn(
            "Version 1 of WalletConnect has been fully deprecated. This version of @web3-onboard/walletconnect only supports version 2"
          );
        else if (e !== 2 && e !== void 0)
          return t.error("any.invalid", {
            message:
              "Invalid version number. This version of @web3-onboard/walletconnect only supports version 2",
          });
        return e;
      }, "Custom version validation"),
    projectId: fe
      .string()
      .messages({
        "any.required":
          "WalletConnect version 2 requires a projectId. Please visit https://cloud.walletconnect.com to get one.",
      }),
    dappUrl: fe
      .string()
      .optional()
      .custom(
        (e, t) =>
          e ||
          t.message({
            message:
              "It is strongly recommended to supply a dappUrl as it is required by some wallets (i.e. MetaMask) to allow connection.",
            type: "any.custom",
          }),
        "Custom dappUrl validation"
      ),
    requiredChains: fe.array().items(fe.number()).optional(),
    optionalChains: fe.array().items(fe.number()).optional(),
    qrModalOptions: fe.object().optional(),
    additionalRequiredMethods: fe.array().items(fe.string()).optional(),
    additionalOptionalMethods: fe.array().items(fe.string()).optional(),
  }),
  pTe = (e, t) => {
    const n = e.validate(t);
    return n.error ? n : null;
  },
  mTe = (e) => pTe(hTe, e),
  lz = [
    "eth_sendTransaction",
    "eth_signTransaction",
    "personal_sign",
    "eth_sign",
    "eth_signTypedData",
    "eth_signTypedData_v4",
    "wallet_addEthereumChain",
    "wallet_switchEthereumChain",
  ];
function gTe(e) {
  if (!e.projectId)
    throw new Error(
      "WalletConnect requires a projectId. Please visit https://cloud.walletconnect.com to get one."
    );
  e.dappUrl ||
    console.warn(
      "It is strongly recommended to supply a dappUrl to the WalletConnect init object as it is required by some wallets (i.e. MetaMask) to allow connection."
    );
  const {
    projectId: t,
    handleUri: n,
    requiredChains: r,
    optionalChains: i,
    qrModalOptions: s,
    additionalRequiredMethods: o,
    additionalOptionalMethods: a,
    dappUrl: l,
  } = e;
  let c;
  return () => ({
    label: "WalletConnect",
    getIcon: async () =>
      (
        await At(async () => {
          const { default: u } = await import("./icon-CKT6anLG.js");
          return { default: u };
        }, [])
      ).default,
    getInterface: async ({ chains: u, EventEmitter: d, appMetadata: f }) => {
      const { ProviderRpcError: h, ProviderRpcErrorCode: p } =
          await At(async () => {
            const { ProviderRpcError: _, ProviderRpcErrorCode: A } =
              await import("./index-BHOazxOL.js");
            return { ProviderRpcError: _, ProviderRpcErrorCode: A };
          }, []),
        { default: g, REQUIRED_METHODS: b } = await At(async () => {
          const { default: _, REQUIRED_METHODS: A } = await import(
            "./index.es-CXxqt0IP.js"
          );
          return { default: _, REQUIRED_METHODS: A };
        }, __vite__mapDeps([8, 7, 9])),
        { Subject: v, fromEvent: w } = await At(async () => {
          const { Subject: _, fromEvent: A } = await import(
            "./index-BQ3hr_zk.js"
          );
          return { Subject: _, fromEvent: A };
        }, __vite__mapDeps([10, 11])),
        { takeUntil: x, take: S } = await At(async () => {
          const { takeUntil: _, take: A } = await import(
            "./index-YFI_ZhEv.js"
          ).then((N) => N.p);
          return { takeUntil: _, take: A };
        }, []),
        R = () => {
          if (!f) return;
          const _ = l || f.explore || "";
          !_ &&
            !_.length &&
            console.warn(
              "It is strongly recommended to supply a dappUrl as it is required by some wallets (i.e. MetaMask) to allow connection."
            );
          const A = {
            name: f.name,
            description: f.description || "",
            url: _,
            icons: [],
          };
          return (
            f.icon !== void 0 && f.icon.length && (A.icons = [f.icon]),
            f.logo !== void 0 &&
              f.logo.length &&
              (A.icons = A.icons.length ? [...A.icons, f.logo] : [f.logo]),
            A
          );
        },
        O =
          Array.isArray(r) && r.length && r.every((_) => !isNaN(_))
            ? r.map((_) => parseInt(_))
            : [],
        B =
          Array.isArray(i) && i.length && i.every((_) => !isNaN(_))
            ? i.map((_) => parseInt(_))
            : u.map(({ id: _ }) => parseInt(_, 16)),
        C = new Set(o && Array.isArray(o) ? [...o, ...b] : b),
        I = Array.from(C),
        P = a && Array.isArray(a) ? [...a, ...lz] : lz,
        M = await g.init({
          projectId: t,
          chains: O,
          methods: I,
          optionalChains: B,
          optionalMethods: P,
          showQrModal: !0,
          rpcMap: u
            .map(({ id: _, rpcUrl: A }) => ({ id: _, rpcUrl: A }))
            .reduce(
              (_, { id: A, rpcUrl: N }) => ((_[parseInt(A, 16)] = N || ""), _),
              {}
            ),
          metadata: R(),
          qrModalOptions: s,
        }),
        k = new d();
      class T {
        constructor({ connector: A, chains: N }) {
          (this.emit = k.emit.bind(k)),
            (this.on = k.on.bind(k)),
            (this.removeListener = k.removeListener.bind(k)),
            (this.connector = A),
            (this.chains = N),
            (this.disconnected$ = new v()),
            w(this.connector, "accountsChanged", (F) => F)
              .pipe(x(this.disconnected$))
              .subscribe({
                next: (F) => {
                  const D = Array.isArray(F) ? F : [F];
                  this.emit("accountsChanged", D);
                },
                error: console.warn,
              }),
            w(this.connector, "chainChanged", (F) => F)
              .pipe(x(this.disconnected$))
              .subscribe({
                next: (F) => {
                  const D = kC(F) ? F : `0x${F.toString(16)}`;
                  this.emit("chainChanged", D);
                },
                error: console.warn,
              }),
            w(this.connector, "session_delete", (F) => F)
              .pipe(x(this.disconnected$))
              .subscribe({
                next: () => {
                  this.emit("accountsChanged", []),
                    this.disconnected$.next(!0),
                    typeof localStorage < "u" &&
                      localStorage.removeItem("walletconnect");
                },
                error: console.warn,
              }),
            (this.disconnect = () => {
              this.connector.session &&
                (this.connector.disconnect(), (c = null));
            }),
            e &&
              n &&
              w(this.connector, "display_uri", (F) => F)
                .pipe(x(this.disconnected$))
                .subscribe(async (F) => {
                  try {
                    n && (await n(F));
                  } catch (D) {
                    throw `An error occurred when handling the URI. Error: ${D}`;
                  }
                }),
            (() => {
              const F = this.connector.session;
              (c = F),
                F &&
                  (this.emit("accountsChanged", this.connector.accounts),
                  this.emit("chainChanged", this.connector.chainId));
            })(),
            (this.request = async ({ method: F, params: D }) => {
              if (F === "eth_chainId")
                return kC(this.connector.chainId)
                  ? this.connector.chainId
                  : `0x${this.connector.chainId.toString(16)}`;
              if (F === "eth_requestAccounts")
                return new Promise(async (j, z) => {
                  if (
                    (w(this.connector, "connect", ($) => $)
                      .pipe(S(1))
                      .subscribe({
                        next: ({ chainId: $ }) => {
                          this.emit("accountsChanged", this.connector.accounts);
                          const K = kC($) ? $ : `0x${$.toString(16)}`;
                          this.emit("chainChanged", K),
                            j(this.connector.accounts);
                        },
                        error: z,
                      }),
                    !this.connector.session)
                  )
                    await this.connector.connect().catch(($) => {
                      console.error("err creating new session: ", $),
                        z(
                          new h({
                            code: 4001,
                            message: "User rejected the request.",
                          })
                        );
                    });
                  else {
                    const $ = this.connector.accounts,
                      K = this.connector.chainId;
                    c = this.connector.session;
                    const re = `0x${K.toString(16)}`;
                    return this.emit("chainChanged", re), j($);
                  }
                });
              if (F === "eth_selectAccounts")
                throw new h({
                  code: p.UNSUPPORTED_METHOD,
                  message: `The Provider does not support the requested method: ${F}`,
                });
              if (F == "wallet_switchEthereumChain") {
                if (!D)
                  throw new h({
                    code: p.INVALID_PARAMS,
                    message:
                      "The Provider requires a chainId to be passed in as an argument",
                  });
                const j = D[0];
                if (!j.hasOwnProperty("chainId") || typeof j.chainId > "u")
                  throw new h({
                    code: p.INVALID_PARAMS,
                    message:
                      "The Provider requires a chainId to be passed in as an argument",
                  });
                return this.connector.request({
                  method: "wallet_switchEthereumChain",
                  params: [{ chainId: j.chainId }],
                });
              }
              return this.connector.request({ method: F, params: D });
            });
        }
      }
      return { provider: new T({ chains: u, connector: M }), instance: c };
    },
  });
}
const kC = (e) => !(typeof e != "string" || !e.match(/^0x[0-9A-Fa-f]*$/));
function yTe(e) {
  if (!e)
    throw new Error(
      "WalletConnect requires an initialization object to be passed - see the official docs for an example: https://onboard.blocknative.com/docs/wallets/walletconnect"
    );
  if (e) {
    const t = mTe(e);
    if (t) throw t;
  }
  return gTe(e);
}
const vTe = [
    {
      id: 1,
      token: "ETH",
      label: "Ethereum Mainnet",
      rpcUrl: "https://ethereum.publicnode.com",
    },
  ],
  cz = `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="12" viewBox="0 0 14 12" fill="none">
  <path d="M7.80871 7.57895H3.97993L0.679257 4.35789V3.22105C0.679257 3.22105 3.05492 0.977145 4.11196 0H7.94074L4.64007 3.16882V4.4016L7.80871 7.57895Z" fill="#6A56F6"/>
  <path d="M6.48844 4.42105L10.3172 4.42105L13.6179 7.64211V8.77895C13.6179 8.77895 11.2422 11.0229 10.1852 12H6.35642L9.65709 8.83118V7.5984L6.48844 4.42105Z" fill="#6A56F6"/>
  <path d="M13.9997 3.2374H6.19129C6.19129 3.2374 8.41973 1.07089 9.52506 0H10.7133L14 3.2371L13.9997 3.2374Z" fill="#6A56F6"/>
  <path d="M0.000318806 8.7626H7.80871C7.80871 8.7626 5.58027 10.9291 4.47494 12H3.28669L0 8.7629L0.000318806 8.7626Z" fill="#6A56F6"/>
</svg>`,
  wTe = {
    name: "SOL DEX",
    description: "SOL DEX",
    icon: cz,
    logo: cz,
    recommendedInjectedWallets: [
      { name: "MetaMask", url: "https://metamask.io" },
      { name: "WalletConnect", url: "https://walletconnect.com/" },
    ],
  },
  bTe = () => {
    const e =
        (navigator == null ? void 0 : navigator.userAgent) ||
        (navigator == null ? void 0 : navigator.vendor) ||
        (window == null ? void 0 : window.opera),
      t = /android|iphone|ipad|ipod|windows phone/i.test(e),
      n = dTe({
        filter: { Phantom: !1 },
        displayUnavailable: t
          ? !1
          : [
              "Trust Wallet",
              "MetaMask",
              "Coinbase Wallet",
              "Phantom",
              "Rainbow",
              "OKX Wallet",
            ],
        sort: (a) => a,
      }),
      r = fTe(),
      i = yTe({
        version: 2,
        handleUri: (a) => console.warn(a, "walletconnect uri"),
        projectId: "d2423ba732cce1398612959331709d36",
        requiredChains: [1],
        optionalChains: [56, 137, 42161],
        dappUrl: window.origin,
      });
    return Z7e({
      wallets: [n, r, i],
      chains: vTe,
      appMetadata: wTe,
      connect: {
        showSidebar: !1,
        autoConnectLastWallet: !0,
        autoConnectAllPreviousWallet: !0,
      },
      theme: "system",
      notify: { enabled: !1 },
      accountCenter: { mobile: { enabled: !1 }, desktop: { enabled: !1 } },
      disableFontDownload: !0,
      containerElements: {
        connectModal: "#custom-onboard-modal .custom-onboard-modal-inner",
      },
    });
  },
  xTe = (e, t) =>
    !e && !t
      ? !0
      : !e || !t
      ? !1
      : e.address.toLowerCase() === t.address.toLowerCase() &&
        e.providerName.toLowerCase() === t.providerName.toLowerCase() &&
        e.chainId == t.chainId,
  F5 = (e, t, n) =>
    e
      ? e.length < 13
        ? e
        : `${e.slice(0, t)}...${e.slice(e.length - n)}`
      : "",
  Mm = (e = !1) => {
    e
      ? document.body.classList.add("lock")
      : document.body.classList.remove("lock");
  },
  U5 = (e, t) =>
    t === "price"
      ? e == null
        ? "0.00"
        : e < 1e-5
        ? e.toFixed(5)
        : e >= 1
        ? (e * 100) % 10 === 0
          ? e.toFixed(1)
          : e.toFixed(2)
        : e.toFixed(5)
      : e
      ? (e * 100) % 10 === 0
        ? e == null
          ? void 0
          : e.toFixed(1)
        : e == null
        ? void 0
        : e.toFixed(2)
      : 0,
  _Te = (e) => {
    const n = Math.floor(Date.now() / 1e3) - e,
      r = Math.floor(n / 60),
      i = Math.floor(n / 3600),
      s = Math.floor(n / 86400);
    return r < 60 ? `${r} min` : i < 24 ? `${i} h` : `${s} d`;
  },
  uz = (e) =>
    e.toLocaleDateString("en-US", {
      year: "numeric",
      month: "long",
      day: "numeric",
    }),
  dz = (e) =>
    e.toLocaleTimeString("en-US", {
      hour: "numeric",
      minute: "numeric",
      hour12: !0,
    }),
  STe = (e, t) => t === e.at(-1),
  ETe = () => /iPad|iPhone|iPod/.test(navigator.userAgent),
  $5 = (e) => `/svg/token-icons/${e.toLowerCase()}.svg`,
  ATe = (e, t) => (
    (e = Math.ceil(e)),
    (t = Math.floor(t)),
    Math.floor(Math.random() * (t - e + 1)) + e
  ),
  fz = /^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,4})+$/i,
  TC = [
    "wormhole",
    "gmt",
    "nosana",
    "bonk",
    "beercoin",
    "blockasset",
    "io",
    "drift token",
    "wrapped solana",
    "pyth network",
    "render",
    "star atlas",
    "metaplex",
  ],
  CTe = 4,
  z8 = "https://docs.solanex.ai/",
  Oee = "https://t.me/solanex_ai",
  Pee = "https://x.com/solanex_ai",
  kTe = "https://solanex.ai/audits/0xguard.pdf",
  Fc = ({ children: e, className: t }) =>
    m.jsx("div", {
      className: xn("max-w-[1280px] w-full px-[16px] mx-auto relative", t),
      children: e,
    }),
  TTe = "_title_1qxm0_1",
  MTe = { title: TTe },
  ITe = ({ children: e, className: t }) =>
    m.jsx("h2", {
      className: xn(
        t,
        MTe.title,
        "text-[28px] laptop:text-[48px] font-semibold leading-[110%] tracking-[0.56px] laptop:tracking-[1.12px]"
      ),
      children: e,
    }),
  NTe = ({ children: e, className: t }) =>
    m.jsx("p", {
      className: xn(
        "text-typoMain text-[14px] laptop:text-[18px] leading-[140%] tracking-[0.28px] laptop:tracking-[0.36px]",
        t
      ),
      children: e,
    }),
  Oa = ({ children: e }) => m.jsx("div", { children: e });
Oa.Title = ITe;
Oa.Article = NTe;
const RTe = "_Image_15l8v_1",
  OTe = "_load_15l8v_7",
  PTe = "_fadeIn_15l8v_15",
  LTe = "_absolute_15l8v_20",
  jTe = "_skeleton_15l8v_39",
  j_ = {
    Image: RTe,
    load: OTe,
    fadeIn: PTe,
    absolute: LTe,
    skeleton: jTe,
    "skeleton-animation": "_skeleton-animation_15l8v_1",
  },
  Ln = ({
    lazy: e = !1,
    absolute: t,
    src: n,
    mobSrc: r,
    alt: i = "img",
    className: s,
    conMaxWidth: o = "",
    conMaxHeight: a = "",
    root: l,
    objectFit: c = "contain",
    style: u,
    ...d
  }) => {
    const f = ji(),
      h = Y.useRef(null),
      p = Lse(h, {
        root: l || void 0,
        rootMargin: "100%",
        threshold: 0,
        once: !0,
      }),
      g = xn(
        j_.Image,
        { [j_.load]: p || !e, [j_.absolute]: t, [j_.fadeIn]: p },
        s
      ),
      b = { maxWidth: o, maxHeight: a, ...u },
      v = f && r ? r : n;
    return m.jsx("img", {
      ref: h,
      className: g,
      src: e ? (p ? v : "") : v,
      alt: i,
      style: { ...b, objectFit: c },
      ...d,
    });
  },
  DTe = "_base_1yibl_1",
  BTe = "_anim_1yibl_12",
  FTe = "_check_1yibl_28",
  UTe = "_size44_1yibl_31",
  $Te = "_size48_1yibl_40",
  zTe = "_size52_1yibl_49",
  WTe = "_size58_1yibl_58",
  HTe = "_size36_1yibl_67",
  VTe = "_size40_1yibl_76",
  GTe = "_size32_1yibl_85",
  qTe = "_fullWidth_1yibl_94",
  KTe = "_primary_1yibl_97",
  YTe = "_secondary_1yibl_119",
  ZTe = "_outline_1yibl_137",
  QTe = "_white_1yibl_154",
  XTe = "_loading_1yibl_169",
  ea = {
    base: DTe,
    anim: BTe,
    check: FTe,
    size44: UTe,
    size48: $Te,
    size52: zTe,
    size58: WTe,
    size36: HTe,
    size40: VTe,
    size32: GTe,
    fullWidth: qTe,
    primary: KTe,
    secondary: YTe,
    outline: ZTe,
    white: QTe,
    loading: XTe,
  },
  Nr = ({
    size: e = "58",
    variant: t = "primary",
    children: n,
    fullWidth: r,
    name: i,
    loading: s,
    check: o,
    to: a,
    withAnim: l = !0,
    ...c
  }) => {
    const u = DN(),
      d = Y.useRef(null),
      f = () => {
        a && u(a);
      },
      h = (p) => {
        const g = d.current;
        if (!g) return;
        const b = g.getBoundingClientRect(),
          v = p.clientX - b.left,
          w = p.clientY - b.top;
        g.style.setProperty("--x", `${v}px`),
          g.style.setProperty("--y", `${w}px`);
      };
    return m.jsx("button", {
      disabled: s,
      "aria-label": i,
      style: {
        maxWidth: c == null ? void 0 : c.maxwidth,
        ...(c == null ? void 0 : c.style),
      },
      ...c,
      ref: d,
      className: xn(c.className, ea.base, {
        [ea.size32]: e === "32",
        [ea.size36]: e === "36",
        [ea.size40]: e === "40",
        [ea.size44]: e === "44",
        [ea.size48]: e === "48",
        [ea.size52]: e === "52",
        [ea.size58]: e === "58",
        [ea.check]: o,
        [ea.primary]: t === "primary",
        [ea.outline]: t === "outline",
        [ea.secondary]: t === "secondary",
        [ea.white]: t === "white",
        [ea.fullWidth]: r,
        [ea.loading]: s,
        [ea.anim]: l,
      }),
      onMouseMove: h,
      onClick: a ? f : c.onClick,
      children: m.jsxs(m.Fragment, { children: [n, s && m.jsx(Ab, {})] }),
    });
  },
  z5 = ({ till: e, style: t, childrenClasses: n }) => {
    const [r, i] = Y.useState(0),
      [s, o] = Y.useState({ days: "00", hrs: "00", mins: "00", sec: "00" });
    Y.useLayoutEffect(() => {
      if (r === 0) {
        o({ days: "00", hrs: "00", mins: "00", sec: "00" });
        return;
      }
      let f = Math.floor(r / 1e3);
      const h = Math.floor(f / (24 * 60 * 60)),
        p = h > 9 ? h.toString() : `0${h}`;
      f %= 24 * 60 * 60;
      const g = Math.floor(f / (60 * 60)),
        b = g > 9 ? g.toString() : `0${g}`;
      f %= 60 * 60;
      const v = Math.floor(f / 60),
        w = v > 9 ? v.toString() : `0${v}`;
      f %= 60;
      const x = f > 9 ? f.toString() : `0${f}`;
      o({ days: p, hrs: b, mins: w, sec: x });
    }, [r]),
      Y.useEffect(() => {
        if (!e) return;
        let f;
        const h = () => {
          const p = e - new Date().getTime();
          if (p < 1e3) {
            if (r === 0) return;
            f && (clearInterval(f), (f = void 0)), i(0);
          } else i(p);
        };
        return (
          h(), (f = setInterval(h, 1e3)), () => (f ? clearInterval(f) : void 0)
        );
      }, [e]);
    const a = "text-[#6A56F6] font-[300] leading-[110%] ",
      l =
        a +
        (n != null && n.dotsClasses
          ? n == null
            ? void 0
            : n.dotsClasses
          : "text-[36px]"),
      c =
        a +
        (n != null && n.numClasses
          ? n == null
            ? void 0
            : n.numClasses
          : "text-[36px] text-shadow"),
      u =
        a +
        (n != null && n.dateClasses
          ? n == null
            ? void 0
            : n.dateClasses
          : "text-[10px] capitalize text-shadow"),
      d =
        (n == null ? void 0 : n.cellClasses) ||
        "flex flex-col items-center justify-center min-w-[50px]";
    return m.jsx("div", {
      style: { background: "rgba(2, 1, 6, 0.32)", ...t },
      className: xn(
        "rounded-[8px] py-[7px] px-[8px] flex justify-between laptop:gap-[4px] laptop:mb-[5px]"
      ),
      children: Object.entries(s).map(([f, h], p, g) =>
        m.jsxs(
          Y.Fragment,
          {
            children: [
              m.jsxs("div", {
                className: d,
                children: [
                  m.jsx("span", { className: c, children: h }),
                  m.jsx("span", { className: u, children: f }),
                ],
              }),
              p !== g.length - 1 &&
                m.jsx("span", { className: l, children: ":" }),
            ],
          },
          p
        )
      ),
    });
  },
  JTe = "_rotate_186lf_1",
  eMe = { rotate: JTe },
  Ab = ({ size: e = 16 }) => {
    const t = `w-[${e}px] h-[${e}px]`;
    return m.jsx("div", {
      className: xn(t),
      children: m.jsxs("svg", {
        className: eMe.rotate,
        xmlns: "http://www.w3.org/2000/svg",
        width: "100%",
        height: "100%",
        viewBox: "0 0 18 18",
        fill: "none",
        children: [
          m.jsx("path", {
            d: "M9 1.57147L9 3.57147",
            stroke: "#6A56F6",
            strokeWidth: "2",
            strokeLinecap: "round",
          }),
          m.jsx("path", {
            d: "M16.4287 9.00012L14.4287 9.00012",
            stroke: "#6A56F6",
            strokeWidth: "2",
            strokeLinecap: "round",
          }),
          m.jsx("path", {
            d: "M9 16.4288L9 14.4288",
            stroke: "#6A56F6",
            strokeOpacity: "0.16",
            strokeWidth: "2",
            strokeLinecap: "round",
          }),
          m.jsx("path", {
            d: "M1.57129 9.00012L3.57129 9.00012",
            stroke: "#6A56F6",
            strokeOpacity: "0.64",
            strokeWidth: "2",
            strokeLinecap: "round",
          }),
          m.jsx("path", {
            d: "M14.2529 3.74725L12.8387 5.16147",
            stroke: "#6A56F6",
            strokeWidth: "2",
            strokeLinecap: "round",
          }),
          m.jsx("path", {
            d: "M3.74707 14.253L5.16128 12.8388",
            stroke: "#6A56F6",
            strokeOpacity: "0.32",
            strokeWidth: "2",
            strokeLinecap: "round",
          }),
          m.jsx("path", {
            d: "M3.74707 3.74725L5.16128 5.16147",
            stroke: "#6A56F6",
            strokeWidth: "2",
            strokeLinecap: "round",
          }),
        ],
      }),
    });
  },
  nM = ({
    children: e,
    duration: t = 30,
    direction: n = "left",
    repeat: r = 2,
    className: i,
    gapClass: s = "gap-[16px] laptop:gap-[32px]",
    isPauseOnHover: o = !1,
  }) => {
    const [a, l] = Y.useState(!1),
      c = "flex flex-row flex-nowrap relative z-[1] " + s,
      u = "inline-flex flex-nowrap " + s,
      d = {
        animationName: "slide",
        animationDuration: `${t}s`,
        animationDirection: n === "left" ? "initial" : "reverse",
        animationTimingFunction: "linear",
        animationIterationCount: "infinite",
        animationPlayState: a ? "paused" : "running",
      },
      f = (h) => o && l(h);
    return m.jsx("div", {
      className: xn(c, i),
      onMouseEnter: () => f(!0),
      onMouseLeave: () => f(!1),
      children: Array.from({ length: r }).map((h, p) =>
        m.jsx("div", { style: d, className: u, children: e }, p)
      ),
    });
  },
  Xm = ({ text: e, onCopy: t, children: n, onCopyElement: r }) => {
    const [i, s] = Y.useState(!1),
      o = async (a) => {
        a.stopPropagation();
        try {
          await navigator.clipboard.writeText(e),
            s(!0),
            t && t(),
            setTimeout(() => s(!1), 1e3);
        } catch (l) {
          console.error("Failed to copy text: ", l);
        }
      };
    return m.jsxs(m.Fragment, {
      children: [
        m.jsx("button", { onClick: o, children: i && r ? r : n }),
        i &&
          m.jsx("span", {
            className: "tooltip-box tooltip-top",
            children: "Copied to clipboard",
          }),
      ],
    });
  };
var W5 = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ W5.exports;
(function (e, t) {
  (function () {
    var n,
      r = "4.17.21",
      i = 200,
      s = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.",
      o = "Expected a function",
      a = "Invalid `variable` option passed into `_.template`",
      l = "__lodash_hash_undefined__",
      c = 500,
      u = "__lodash_placeholder__",
      d = 1,
      f = 2,
      h = 4,
      p = 1,
      g = 2,
      b = 1,
      v = 2,
      w = 4,
      x = 8,
      S = 16,
      R = 32,
      O = 64,
      B = 128,
      C = 256,
      I = 512,
      P = 30,
      M = "...",
      k = 800,
      T = 16,
      _ = 1,
      A = 2,
      N = 3,
      L = 1 / 0,
      F = 9007199254740991,
      D = 17976931348623157e292,
      j = NaN,
      z = 4294967295,
      $ = z - 1,
      K = z >>> 1,
      re = [
        ["ary", B],
        ["bind", b],
        ["bindKey", v],
        ["curry", x],
        ["curryRight", S],
        ["flip", I],
        ["partial", R],
        ["partialRight", O],
        ["rearg", C],
      ],
      G = "[object Arguments]",
      ne = "[object Array]",
      ae = "[object AsyncFunction]",
      le = "[object Boolean]",
      ge = "[object Date]",
      Oe = "[object DOMException]",
      _e = "[object Error]",
      Ee = "[object Function]",
      He = "[object GeneratorFunction]",
      je = "[object Map]",
      Be = "[object Number]",
      rn = "[object Null]",
      Wt = "[object Object]",
      Mt = "[object Promise]",
      an = "[object Proxy]",
      kt = "[object RegExp]",
      Qe = "[object Set]",
      Vt = "[object String]",
      Rt = "[object Symbol]",
      mt = "[object Undefined]",
      Pt = "[object WeakMap]",
      wn = "[object WeakSet]",
      xt = "[object ArrayBuffer]",
      Tt = "[object DataView]",
      _n = "[object Float32Array]",
      Q = "[object Float64Array]",
      H = "[object Int8Array]",
      q = "[object Int16Array]",
      ee = "[object Int32Array]",
      ce = "[object Uint8Array]",
      pe = "[object Uint8ClampedArray]",
      we = "[object Uint16Array]",
      ht = "[object Uint32Array]",
      vt = /\b__p \+= '';/g,
      ct = /\b(__p \+=) '' \+/g,
      Lt = /(__e\(.*?\)|\b__t\)) \+\n'';/g,
      wt = /&(?:amp|lt|gt|quot|#39);/g,
      Ht = /[&<>"']/g,
      mn = RegExp(wt.source),
      jn = RegExp(Ht.source),
      Gt = /<%-([\s\S]+?)%>/g,
      Cn = /<%([\s\S]+?)%>/g,
      cn = /<%=([\s\S]+?)%>/g,
      Yt = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      ln = /^\w*$/,
      oe =
        /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
      de = /[\\^$.*+?()[\]{}|]/g,
      be = RegExp(de.source),
      Me = /^\s+/,
      Fe = /\s/,
      it = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
      ft = /\{\n\/\* \[wrapped with (.+)\] \*/,
      ze = /,? & /,
      nt = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,
      Xe = /[()=,{}\[\]\/\s]/,
      Ve = /\\(\\)?/g,
      bt = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,
      gt = /\w*$/,
      un = /^[-+]0x[0-9a-f]+$/i,
      Rn = /^0b[01]+$/i,
      bn = /^\[object .+?Constructor\]$/,
      Sn = /^0o[0-7]+$/i,
      Si = /^(?:0|[1-9]\d*)$/,
      vr = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,
      pi = /($^)/,
      ii = /['\n\r\u2028\u2029\\]/g,
      Ki = "\\ud800-\\udfff",
      si = "\\u0300-\\u036f",
      Ti = "\\ufe20-\\ufe2f",
      Yi = "\\u20d0-\\u20ff",
      Es = si + Ti + Yi,
      In = "\\u2700-\\u27bf",
      On = "a-z\\xdf-\\xf6\\xf8-\\xff",
      Ei = "\\xac\\xb1\\xd7\\xf7",
      As = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf",
      wr = "\\u2000-\\u206f",
      Mi =
        " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
      ha = "A-Z\\xc0-\\xd6\\xd8-\\xde",
      ju = "\\ufe0e\\ufe0f",
      Hc = Ei + As + wr + Mi,
      Yd = "['’]",
      _0 = "[" + Ki + "]",
      Ih = "[" + Hc + "]",
      fl = "[" + Es + "]",
      hl = "\\d+",
      Zd = "[" + In + "]",
      Nh = "[" + On + "]",
      Ql = "[^" + Ki + Hc + hl + In + On + ha + "]",
      Du = "\\ud83c[\\udffb-\\udfff]",
      S0 = "(?:" + fl + "|" + Du + ")",
      Rh = "[^" + Ki + "]",
      Qd = "(?:\\ud83c[\\udde6-\\uddff]){2}",
      Bu = "[\\ud800-\\udbff][\\udc00-\\udfff]",
      Xl = "[" + ha + "]",
      Oh = "\\u200d",
      Ph = "(?:" + Nh + "|" + Ql + ")",
      Xd = "(?:" + Xl + "|" + Ql + ")",
      Lh = "(?:" + Yd + "(?:d|ll|m|re|s|t|ve))?",
      Jd = "(?:" + Yd + "(?:D|LL|M|RE|S|T|VE))?",
      ef = S0 + "?",
      Vc = "[" + ju + "]?",
      Fu = "(?:" + Oh + "(?:" + [Rh, Qd, Bu].join("|") + ")" + Vc + ef + ")*",
      Uu = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])",
      tf = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])",
      Gc = Vc + ef + Fu,
      qc = "(?:" + [Zd, Qd, Bu].join("|") + ")" + Gc,
      ja = "(?:" + [Rh + fl + "?", fl, Qd, Bu, _0].join("|") + ")",
      Os = RegExp(Yd, "g"),
      Ps = RegExp(fl, "g"),
      Da = RegExp(Du + "(?=" + Du + ")|" + ja + Gc, "g"),
      Kc = RegExp(
        [
          Xl + "?" + Nh + "+" + Lh + "(?=" + [Ih, Xl, "$"].join("|") + ")",
          Xd + "+" + Jd + "(?=" + [Ih, Xl + Ph, "$"].join("|") + ")",
          Xl + "?" + Ph + "+" + Lh,
          Xl + "+" + Jd,
          tf,
          Uu,
          hl,
          qc,
        ].join("|"),
        "g"
      ),
      Yc = RegExp("[" + Oh + Ki + Es + ju + "]"),
      E0 = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,
      jh = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout",
      ],
      Dh = -1,
      Dr = {};
    (Dr[_n] =
      Dr[Q] =
      Dr[H] =
      Dr[q] =
      Dr[ee] =
      Dr[ce] =
      Dr[pe] =
      Dr[we] =
      Dr[ht] =
        !0),
      (Dr[G] =
        Dr[ne] =
        Dr[xt] =
        Dr[le] =
        Dr[Tt] =
        Dr[ge] =
        Dr[_e] =
        Dr[Ee] =
        Dr[je] =
        Dr[Be] =
        Dr[Wt] =
        Dr[kt] =
        Dr[Qe] =
        Dr[Vt] =
        Dr[Pt] =
          !1);
    var Rr = {};
    (Rr[G] =
      Rr[ne] =
      Rr[xt] =
      Rr[Tt] =
      Rr[le] =
      Rr[ge] =
      Rr[_n] =
      Rr[Q] =
      Rr[H] =
      Rr[q] =
      Rr[ee] =
      Rr[je] =
      Rr[Be] =
      Rr[Wt] =
      Rr[kt] =
      Rr[Qe] =
      Rr[Vt] =
      Rr[Rt] =
      Rr[ce] =
      Rr[pe] =
      Rr[we] =
      Rr[ht] =
        !0),
      (Rr[_e] = Rr[Ee] = Rr[Pt] = !1);
    var $u = {
        À: "A",
        Á: "A",
        Â: "A",
        Ã: "A",
        Ä: "A",
        Å: "A",
        à: "a",
        á: "a",
        â: "a",
        ã: "a",
        ä: "a",
        å: "a",
        Ç: "C",
        ç: "c",
        Ð: "D",
        ð: "d",
        È: "E",
        É: "E",
        Ê: "E",
        Ë: "E",
        è: "e",
        é: "e",
        ê: "e",
        ë: "e",
        Ì: "I",
        Í: "I",
        Î: "I",
        Ï: "I",
        ì: "i",
        í: "i",
        î: "i",
        ï: "i",
        Ñ: "N",
        ñ: "n",
        Ò: "O",
        Ó: "O",
        Ô: "O",
        Õ: "O",
        Ö: "O",
        Ø: "O",
        ò: "o",
        ó: "o",
        ô: "o",
        õ: "o",
        ö: "o",
        ø: "o",
        Ù: "U",
        Ú: "U",
        Û: "U",
        Ü: "U",
        ù: "u",
        ú: "u",
        û: "u",
        ü: "u",
        Ý: "Y",
        ý: "y",
        ÿ: "y",
        Æ: "Ae",
        æ: "ae",
        Þ: "Th",
        þ: "th",
        ß: "ss",
        Ā: "A",
        Ă: "A",
        Ą: "A",
        ā: "a",
        ă: "a",
        ą: "a",
        Ć: "C",
        Ĉ: "C",
        Ċ: "C",
        Č: "C",
        ć: "c",
        ĉ: "c",
        ċ: "c",
        č: "c",
        Ď: "D",
        Đ: "D",
        ď: "d",
        đ: "d",
        Ē: "E",
        Ĕ: "E",
        Ė: "E",
        Ę: "E",
        Ě: "E",
        ē: "e",
        ĕ: "e",
        ė: "e",
        ę: "e",
        ě: "e",
        Ĝ: "G",
        Ğ: "G",
        Ġ: "G",
        Ģ: "G",
        ĝ: "g",
        ğ: "g",
        ġ: "g",
        ģ: "g",
        Ĥ: "H",
        Ħ: "H",
        ĥ: "h",
        ħ: "h",
        Ĩ: "I",
        Ī: "I",
        Ĭ: "I",
        Į: "I",
        İ: "I",
        ĩ: "i",
        ī: "i",
        ĭ: "i",
        į: "i",
        ı: "i",
        Ĵ: "J",
        ĵ: "j",
        Ķ: "K",
        ķ: "k",
        ĸ: "k",
        Ĺ: "L",
        Ļ: "L",
        Ľ: "L",
        Ŀ: "L",
        Ł: "L",
        ĺ: "l",
        ļ: "l",
        ľ: "l",
        ŀ: "l",
        ł: "l",
        Ń: "N",
        Ņ: "N",
        Ň: "N",
        Ŋ: "N",
        ń: "n",
        ņ: "n",
        ň: "n",
        ŋ: "n",
        Ō: "O",
        Ŏ: "O",
        Ő: "O",
        ō: "o",
        ŏ: "o",
        ő: "o",
        Ŕ: "R",
        Ŗ: "R",
        Ř: "R",
        ŕ: "r",
        ŗ: "r",
        ř: "r",
        Ś: "S",
        Ŝ: "S",
        Ş: "S",
        Š: "S",
        ś: "s",
        ŝ: "s",
        ş: "s",
        š: "s",
        Ţ: "T",
        Ť: "T",
        Ŧ: "T",
        ţ: "t",
        ť: "t",
        ŧ: "t",
        Ũ: "U",
        Ū: "U",
        Ŭ: "U",
        Ů: "U",
        Ű: "U",
        Ų: "U",
        ũ: "u",
        ū: "u",
        ŭ: "u",
        ů: "u",
        ű: "u",
        ų: "u",
        Ŵ: "W",
        ŵ: "w",
        Ŷ: "Y",
        ŷ: "y",
        Ÿ: "Y",
        Ź: "Z",
        Ż: "Z",
        Ž: "Z",
        ź: "z",
        ż: "z",
        ž: "z",
        Ĳ: "IJ",
        ĳ: "ij",
        Œ: "Oe",
        œ: "oe",
        ŉ: "'n",
        ſ: "s",
      },
      ie = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;",
      },
      me = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'",
      },
      Ie = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029",
      },
      jt = parseFloat,
      Wn = parseInt,
      qn = typeof Bn == "object" && Bn && Bn.Object === Object && Bn,
      cr = typeof self == "object" && self && self.Object === Object && self,
      dn = qn || cr || Function("return this")(),
      Br = t && !t.nodeType && t,
      Ii = Br && !0 && e && !e.nodeType && e,
      Di = Ii && Ii.exports === Br,
      Gs = Di && qn.process,
      Bi = (function () {
        try {
          var ve = Ii && Ii.require && Ii.require("util").types;
          return ve || (Gs && Gs.binding && Gs.binding("util"));
        } catch {}
      })(),
      Jl = Bi && Bi.isArrayBuffer,
      nf = Bi && Bi.isDate,
      C1 = Bi && Bi.isMap,
      k1 = Bi && Bi.isRegExp,
      Bh = Bi && Bi.isSet,
      rf = Bi && Bi.isTypedArray;
    function Co(ve, Ue, Ne) {
      switch (Ne.length) {
        case 0:
          return ve.call(Ue);
        case 1:
          return ve.call(Ue, Ne[0]);
        case 2:
          return ve.call(Ue, Ne[0], Ne[1]);
        case 3:
          return ve.call(Ue, Ne[0], Ne[1], Ne[2]);
      }
      return ve.apply(Ue, Ne);
    }
    function qv(ve, Ue, Ne, Bt) {
      for (var Dn = -1, Xr = ve == null ? 0 : ve.length; ++Dn < Xr; ) {
        var qs = ve[Dn];
        Ue(Bt, qs, Ne(qs), ve);
      }
      return Bt;
    }
    function W(ve, Ue) {
      for (
        var Ne = -1, Bt = ve == null ? 0 : ve.length;
        ++Ne < Bt && Ue(ve[Ne], Ne, ve) !== !1;

      );
      return ve;
    }
    function Z(ve, Ue) {
      for (
        var Ne = ve == null ? 0 : ve.length;
        Ne-- && Ue(ve[Ne], Ne, ve) !== !1;

      );
      return ve;
    }
    function se(ve, Ue) {
      for (var Ne = -1, Bt = ve == null ? 0 : ve.length; ++Ne < Bt; )
        if (!Ue(ve[Ne], Ne, ve)) return !1;
      return !0;
    }
    function ye(ve, Ue) {
      for (
        var Ne = -1, Bt = ve == null ? 0 : ve.length, Dn = 0, Xr = [];
        ++Ne < Bt;

      ) {
        var qs = ve[Ne];
        Ue(qs, Ne, ve) && (Xr[Dn++] = qs);
      }
      return Xr;
    }
    function Je(ve, Ue) {
      var Ne = ve == null ? 0 : ve.length;
      return !!Ne && Ni(ve, Ue, 0) > -1;
    }
    function De(ve, Ue, Ne) {
      for (var Bt = -1, Dn = ve == null ? 0 : ve.length; ++Bt < Dn; )
        if (Ne(Ue, ve[Bt])) return !0;
      return !1;
    }
    function Ze(ve, Ue) {
      for (
        var Ne = -1, Bt = ve == null ? 0 : ve.length, Dn = Array(Bt);
        ++Ne < Bt;

      )
        Dn[Ne] = Ue(ve[Ne], Ne, ve);
      return Dn;
    }
    function yn(ve, Ue) {
      for (var Ne = -1, Bt = Ue.length, Dn = ve.length; ++Ne < Bt; )
        ve[Dn + Ne] = Ue[Ne];
      return ve;
    }
    function fn(ve, Ue, Ne, Bt) {
      var Dn = -1,
        Xr = ve == null ? 0 : ve.length;
      for (Bt && Xr && (Ne = ve[++Dn]); ++Dn < Xr; )
        Ne = Ue(Ne, ve[Dn], Dn, ve);
      return Ne;
    }
    function ur(ve, Ue, Ne, Bt) {
      var Dn = ve == null ? 0 : ve.length;
      for (Bt && Dn && (Ne = ve[--Dn]); Dn--; ) Ne = Ue(Ne, ve[Dn], Dn, ve);
      return Ne;
    }
    function Kn(ve, Ue) {
      for (var Ne = -1, Bt = ve == null ? 0 : ve.length; ++Ne < Bt; )
        if (Ue(ve[Ne], Ne, ve)) return !0;
      return !1;
    }
    var dr = pl("length");
    function br(ve) {
      return ve.split("");
    }
    function Ai(ve) {
      return ve.match(nt) || [];
    }
    function mi(ve, Ue, Ne) {
      var Bt;
      return (
        Ne(ve, function (Dn, Xr, qs) {
          if (Ue(Dn, Xr, qs)) return (Bt = Xr), !1;
        }),
        Bt
      );
    }
    function vs(ve, Ue, Ne, Bt) {
      for (var Dn = ve.length, Xr = Ne + (Bt ? 1 : -1); Bt ? Xr-- : ++Xr < Dn; )
        if (Ue(ve[Xr], Xr, ve)) return Xr;
      return -1;
    }
    function Ni(ve, Ue, Ne) {
      return Ue === Ue ? ble(ve, Ue, Ne) : vs(ve, Fh, Ne);
    }
    function ko(ve, Ue, Ne, Bt) {
      for (var Dn = Ne - 1, Xr = ve.length; ++Dn < Xr; )
        if (Bt(ve[Dn], Ue)) return Dn;
      return -1;
    }
    function Fh(ve) {
      return ve !== ve;
    }
    function ec(ve, Ue) {
      var Ne = ve == null ? 0 : ve.length;
      return Ne ? r9(ve, Ue) / Ne : j;
    }
    function pl(ve) {
      return function (Ue) {
        return Ue == null ? n : Ue[ve];
      };
    }
    function n9(ve) {
      return function (Ue) {
        return ve == null ? n : ve[Ue];
      };
    }
    function JL(ve, Ue, Ne, Bt, Dn) {
      return (
        Dn(ve, function (Xr, qs, Ci) {
          Ne = Bt ? ((Bt = !1), Xr) : Ue(Ne, Xr, qs, Ci);
        }),
        Ne
      );
    }
    function ule(ve, Ue) {
      var Ne = ve.length;
      for (ve.sort(Ue); Ne--; ) ve[Ne] = ve[Ne].value;
      return ve;
    }
    function r9(ve, Ue) {
      for (var Ne, Bt = -1, Dn = ve.length; ++Bt < Dn; ) {
        var Xr = Ue(ve[Bt]);
        Xr !== n && (Ne = Ne === n ? Xr : Ne + Xr);
      }
      return Ne;
    }
    function i9(ve, Ue) {
      for (var Ne = -1, Bt = Array(ve); ++Ne < ve; ) Bt[Ne] = Ue(Ne);
      return Bt;
    }
    function dle(ve, Ue) {
      return Ze(Ue, function (Ne) {
        return [Ne, ve[Ne]];
      });
    }
    function ej(ve) {
      return ve && ve.slice(0, ij(ve) + 1).replace(Me, "");
    }
    function ml(ve) {
      return function (Ue) {
        return ve(Ue);
      };
    }
    function s9(ve, Ue) {
      return Ze(Ue, function (Ne) {
        return ve[Ne];
      });
    }
    function Kv(ve, Ue) {
      return ve.has(Ue);
    }
    function tj(ve, Ue) {
      for (var Ne = -1, Bt = ve.length; ++Ne < Bt && Ni(Ue, ve[Ne], 0) > -1; );
      return Ne;
    }
    function nj(ve, Ue) {
      for (var Ne = ve.length; Ne-- && Ni(Ue, ve[Ne], 0) > -1; );
      return Ne;
    }
    function fle(ve, Ue) {
      for (var Ne = ve.length, Bt = 0; Ne--; ) ve[Ne] === Ue && ++Bt;
      return Bt;
    }
    var hle = n9($u),
      ple = n9(ie);
    function mle(ve) {
      return "\\" + Ie[ve];
    }
    function gle(ve, Ue) {
      return ve == null ? n : ve[Ue];
    }
    function T1(ve) {
      return Yc.test(ve);
    }
    function yle(ve) {
      return E0.test(ve);
    }
    function vle(ve) {
      for (var Ue, Ne = []; !(Ue = ve.next()).done; ) Ne.push(Ue.value);
      return Ne;
    }
    function o9(ve) {
      var Ue = -1,
        Ne = Array(ve.size);
      return (
        ve.forEach(function (Bt, Dn) {
          Ne[++Ue] = [Dn, Bt];
        }),
        Ne
      );
    }
    function rj(ve, Ue) {
      return function (Ne) {
        return ve(Ue(Ne));
      };
    }
    function Uh(ve, Ue) {
      for (var Ne = -1, Bt = ve.length, Dn = 0, Xr = []; ++Ne < Bt; ) {
        var qs = ve[Ne];
        (qs === Ue || qs === u) && ((ve[Ne] = u), (Xr[Dn++] = Ne));
      }
      return Xr;
    }
    function v3(ve) {
      var Ue = -1,
        Ne = Array(ve.size);
      return (
        ve.forEach(function (Bt) {
          Ne[++Ue] = Bt;
        }),
        Ne
      );
    }
    function wle(ve) {
      var Ue = -1,
        Ne = Array(ve.size);
      return (
        ve.forEach(function (Bt) {
          Ne[++Ue] = [Bt, Bt];
        }),
        Ne
      );
    }
    function ble(ve, Ue, Ne) {
      for (var Bt = Ne - 1, Dn = ve.length; ++Bt < Dn; )
        if (ve[Bt] === Ue) return Bt;
      return -1;
    }
    function xle(ve, Ue, Ne) {
      for (var Bt = Ne + 1; Bt--; ) if (ve[Bt] === Ue) return Bt;
      return Bt;
    }
    function M1(ve) {
      return T1(ve) ? Sle(ve) : dr(ve);
    }
    function Zc(ve) {
      return T1(ve) ? Ele(ve) : br(ve);
    }
    function ij(ve) {
      for (var Ue = ve.length; Ue-- && Fe.test(ve.charAt(Ue)); );
      return Ue;
    }
    var _le = n9(me);
    function Sle(ve) {
      for (var Ue = (Da.lastIndex = 0); Da.test(ve); ) ++Ue;
      return Ue;
    }
    function Ele(ve) {
      return ve.match(Da) || [];
    }
    function Ale(ve) {
      return ve.match(Kc) || [];
    }
    var Cle = function ve(Ue) {
        Ue = Ue == null ? dn : I1.defaults(dn.Object(), Ue, I1.pick(dn, jh));
        var Ne = Ue.Array,
          Bt = Ue.Date,
          Dn = Ue.Error,
          Xr = Ue.Function,
          qs = Ue.Math,
          Ci = Ue.Object,
          a9 = Ue.RegExp,
          kle = Ue.String,
          tc = Ue.TypeError,
          w3 = Ne.prototype,
          Tle = Xr.prototype,
          N1 = Ci.prototype,
          b3 = Ue["__core-js_shared__"],
          x3 = Tle.toString,
          oi = N1.hasOwnProperty,
          Mle = 0,
          sj = (function () {
            var y = /[^.]+$/.exec((b3 && b3.keys && b3.keys.IE_PROTO) || "");
            return y ? "Symbol(src)_1." + y : "";
          })(),
          _3 = N1.toString,
          Ile = x3.call(Ci),
          Nle = dn._,
          Rle = a9(
            "^" +
              x3
                .call(oi)
                .replace(de, "\\$&")
                .replace(
                  /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                  "$1.*?"
                ) +
              "$"
          ),
          S3 = Di ? Ue.Buffer : n,
          $h = Ue.Symbol,
          E3 = Ue.Uint8Array,
          oj = S3 ? S3.allocUnsafe : n,
          A3 = rj(Ci.getPrototypeOf, Ci),
          aj = Ci.create,
          lj = N1.propertyIsEnumerable,
          C3 = w3.splice,
          cj = $h ? $h.isConcatSpreadable : n,
          Yv = $h ? $h.iterator : n,
          A0 = $h ? $h.toStringTag : n,
          k3 = (function () {
            try {
              var y = I0(Ci, "defineProperty");
              return y({}, "", {}), y;
            } catch {}
          })(),
          Ole = Ue.clearTimeout !== dn.clearTimeout && Ue.clearTimeout,
          Ple = Bt && Bt.now !== dn.Date.now && Bt.now,
          Lle = Ue.setTimeout !== dn.setTimeout && Ue.setTimeout,
          T3 = qs.ceil,
          M3 = qs.floor,
          l9 = Ci.getOwnPropertySymbols,
          jle = S3 ? S3.isBuffer : n,
          uj = Ue.isFinite,
          Dle = w3.join,
          Ble = rj(Ci.keys, Ci),
          Ks = qs.max,
          Go = qs.min,
          Fle = Bt.now,
          Ule = Ue.parseInt,
          dj = qs.random,
          $le = w3.reverse,
          c9 = I0(Ue, "DataView"),
          Zv = I0(Ue, "Map"),
          u9 = I0(Ue, "Promise"),
          R1 = I0(Ue, "Set"),
          Qv = I0(Ue, "WeakMap"),
          Xv = I0(Ci, "create"),
          I3 = Qv && new Qv(),
          O1 = {},
          zle = N0(c9),
          Wle = N0(Zv),
          Hle = N0(u9),
          Vle = N0(R1),
          Gle = N0(Qv),
          N3 = $h ? $h.prototype : n,
          Jv = N3 ? N3.valueOf : n,
          fj = N3 ? N3.toString : n;
        function J(y) {
          if (ws(y) && !Fn(y) && !(y instanceof xr)) {
            if (y instanceof nc) return y;
            if (oi.call(y, "__wrapped__")) return hD(y);
          }
          return new nc(y);
        }
        var P1 = (function () {
          function y() {}
          return function (E) {
            if (!ss(E)) return {};
            if (aj) return aj(E);
            y.prototype = E;
            var U = new y();
            return (y.prototype = n), U;
          };
        })();
        function R3() {}
        function nc(y, E) {
          (this.__wrapped__ = y),
            (this.__actions__ = []),
            (this.__chain__ = !!E),
            (this.__index__ = 0),
            (this.__values__ = n);
        }
        (J.templateSettings = {
          escape: Gt,
          evaluate: Cn,
          interpolate: cn,
          variable: "",
          imports: { _: J },
        }),
          (J.prototype = R3.prototype),
          (J.prototype.constructor = J),
          (nc.prototype = P1(R3.prototype)),
          (nc.prototype.constructor = nc);
        function xr(y) {
          (this.__wrapped__ = y),
            (this.__actions__ = []),
            (this.__dir__ = 1),
            (this.__filtered__ = !1),
            (this.__iteratees__ = []),
            (this.__takeCount__ = z),
            (this.__views__ = []);
        }
        function qle() {
          var y = new xr(this.__wrapped__);
          return (
            (y.__actions__ = Ba(this.__actions__)),
            (y.__dir__ = this.__dir__),
            (y.__filtered__ = this.__filtered__),
            (y.__iteratees__ = Ba(this.__iteratees__)),
            (y.__takeCount__ = this.__takeCount__),
            (y.__views__ = Ba(this.__views__)),
            y
          );
        }
        function Kle() {
          if (this.__filtered__) {
            var y = new xr(this);
            (y.__dir__ = -1), (y.__filtered__ = !0);
          } else (y = this.clone()), (y.__dir__ *= -1);
          return y;
        }
        function Yle() {
          var y = this.__wrapped__.value(),
            E = this.__dir__,
            U = Fn(y),
            V = E < 0,
            X = U ? y.length : 0,
            te = aue(0, X, this.__views__),
            ue = te.start,
            he = te.end,
            xe = he - ue,
            Ge = V ? he : ue - 1,
            qe = this.__iteratees__,
            et = qe.length,
            St = 0,
            en = Go(xe, this.__takeCount__);
          if (!U || (!V && X == xe && en == xe)) return jj(y, this.__actions__);
          var kn = [];
          e: for (; xe-- && St < en; ) {
            Ge += E;
            for (var Qn = -1, Tn = y[Ge]; ++Qn < et; ) {
              var mr = qe[Qn],
                Cr = mr.iteratee,
                vl = mr.type,
                ga = Cr(Tn);
              if (vl == A) Tn = ga;
              else if (!ga) {
                if (vl == _) continue e;
                break e;
              }
            }
            kn[St++] = Tn;
          }
          return kn;
        }
        (xr.prototype = P1(R3.prototype)), (xr.prototype.constructor = xr);
        function C0(y) {
          var E = -1,
            U = y == null ? 0 : y.length;
          for (this.clear(); ++E < U; ) {
            var V = y[E];
            this.set(V[0], V[1]);
          }
        }
        function Zle() {
          (this.__data__ = Xv ? Xv(null) : {}), (this.size = 0);
        }
        function Qle(y) {
          var E = this.has(y) && delete this.__data__[y];
          return (this.size -= E ? 1 : 0), E;
        }
        function Xle(y) {
          var E = this.__data__;
          if (Xv) {
            var U = E[y];
            return U === l ? n : U;
          }
          return oi.call(E, y) ? E[y] : n;
        }
        function Jle(y) {
          var E = this.__data__;
          return Xv ? E[y] !== n : oi.call(E, y);
        }
        function ece(y, E) {
          var U = this.__data__;
          return (
            (this.size += this.has(y) ? 0 : 1),
            (U[y] = Xv && E === n ? l : E),
            this
          );
        }
        (C0.prototype.clear = Zle),
          (C0.prototype.delete = Qle),
          (C0.prototype.get = Xle),
          (C0.prototype.has = Jle),
          (C0.prototype.set = ece);
        function sf(y) {
          var E = -1,
            U = y == null ? 0 : y.length;
          for (this.clear(); ++E < U; ) {
            var V = y[E];
            this.set(V[0], V[1]);
          }
        }
        function tce() {
          (this.__data__ = []), (this.size = 0);
        }
        function nce(y) {
          var E = this.__data__,
            U = O3(E, y);
          if (U < 0) return !1;
          var V = E.length - 1;
          return U == V ? E.pop() : C3.call(E, U, 1), --this.size, !0;
        }
        function rce(y) {
          var E = this.__data__,
            U = O3(E, y);
          return U < 0 ? n : E[U][1];
        }
        function ice(y) {
          return O3(this.__data__, y) > -1;
        }
        function sce(y, E) {
          var U = this.__data__,
            V = O3(U, y);
          return V < 0 ? (++this.size, U.push([y, E])) : (U[V][1] = E), this;
        }
        (sf.prototype.clear = tce),
          (sf.prototype.delete = nce),
          (sf.prototype.get = rce),
          (sf.prototype.has = ice),
          (sf.prototype.set = sce);
        function of(y) {
          var E = -1,
            U = y == null ? 0 : y.length;
          for (this.clear(); ++E < U; ) {
            var V = y[E];
            this.set(V[0], V[1]);
          }
        }
        function oce() {
          (this.size = 0),
            (this.__data__ = {
              hash: new C0(),
              map: new (Zv || sf)(),
              string: new C0(),
            });
        }
        function ace(y) {
          var E = V3(this, y).delete(y);
          return (this.size -= E ? 1 : 0), E;
        }
        function lce(y) {
          return V3(this, y).get(y);
        }
        function cce(y) {
          return V3(this, y).has(y);
        }
        function uce(y, E) {
          var U = V3(this, y),
            V = U.size;
          return U.set(y, E), (this.size += U.size == V ? 0 : 1), this;
        }
        (of.prototype.clear = oce),
          (of.prototype.delete = ace),
          (of.prototype.get = lce),
          (of.prototype.has = cce),
          (of.prototype.set = uce);
        function k0(y) {
          var E = -1,
            U = y == null ? 0 : y.length;
          for (this.__data__ = new of(); ++E < U; ) this.add(y[E]);
        }
        function dce(y) {
          return this.__data__.set(y, l), this;
        }
        function fce(y) {
          return this.__data__.has(y);
        }
        (k0.prototype.add = k0.prototype.push = dce), (k0.prototype.has = fce);
        function Qc(y) {
          var E = (this.__data__ = new sf(y));
          this.size = E.size;
        }
        function hce() {
          (this.__data__ = new sf()), (this.size = 0);
        }
        function pce(y) {
          var E = this.__data__,
            U = E.delete(y);
          return (this.size = E.size), U;
        }
        function mce(y) {
          return this.__data__.get(y);
        }
        function gce(y) {
          return this.__data__.has(y);
        }
        function yce(y, E) {
          var U = this.__data__;
          if (U instanceof sf) {
            var V = U.__data__;
            if (!Zv || V.length < i - 1)
              return V.push([y, E]), (this.size = ++U.size), this;
            U = this.__data__ = new of(V);
          }
          return U.set(y, E), (this.size = U.size), this;
        }
        (Qc.prototype.clear = hce),
          (Qc.prototype.delete = pce),
          (Qc.prototype.get = mce),
          (Qc.prototype.has = gce),
          (Qc.prototype.set = yce);
        function hj(y, E) {
          var U = Fn(y),
            V = !U && R0(y),
            X = !U && !V && Gh(y),
            te = !U && !V && !X && B1(y),
            ue = U || V || X || te,
            he = ue ? i9(y.length, kle) : [],
            xe = he.length;
          for (var Ge in y)
            (E || oi.call(y, Ge)) &&
              !(
                ue &&
                (Ge == "length" ||
                  (X && (Ge == "offset" || Ge == "parent")) ||
                  (te &&
                    (Ge == "buffer" ||
                      Ge == "byteLength" ||
                      Ge == "byteOffset")) ||
                  uf(Ge, xe))
              ) &&
              he.push(Ge);
          return he;
        }
        function pj(y) {
          var E = y.length;
          return E ? y[x9(0, E - 1)] : n;
        }
        function vce(y, E) {
          return G3(Ba(y), T0(E, 0, y.length));
        }
        function wce(y) {
          return G3(Ba(y));
        }
        function d9(y, E, U) {
          ((U !== n && !Xc(y[E], U)) || (U === n && !(E in y))) && af(y, E, U);
        }
        function e2(y, E, U) {
          var V = y[E];
          (!(oi.call(y, E) && Xc(V, U)) || (U === n && !(E in y))) &&
            af(y, E, U);
        }
        function O3(y, E) {
          for (var U = y.length; U--; ) if (Xc(y[U][0], E)) return U;
          return -1;
        }
        function bce(y, E, U, V) {
          return (
            zh(y, function (X, te, ue) {
              E(V, X, U(X), ue);
            }),
            V
          );
        }
        function mj(y, E) {
          return y && Wu(E, uo(E), y);
        }
        function xce(y, E) {
          return y && Wu(E, Ua(E), y);
        }
        function af(y, E, U) {
          E == "__proto__" && k3
            ? k3(y, E, {
                configurable: !0,
                enumerable: !0,
                value: U,
                writable: !0,
              })
            : (y[E] = U);
        }
        function f9(y, E) {
          for (var U = -1, V = E.length, X = Ne(V), te = y == null; ++U < V; )
            X[U] = te ? n : G9(y, E[U]);
          return X;
        }
        function T0(y, E, U) {
          return (
            y === y &&
              (U !== n && (y = y <= U ? y : U),
              E !== n && (y = y >= E ? y : E)),
            y
          );
        }
        function rc(y, E, U, V, X, te) {
          var ue,
            he = E & d,
            xe = E & f,
            Ge = E & h;
          if ((U && (ue = X ? U(y, V, X, te) : U(y)), ue !== n)) return ue;
          if (!ss(y)) return y;
          var qe = Fn(y);
          if (qe) {
            if (((ue = cue(y)), !he)) return Ba(y, ue);
          } else {
            var et = qo(y),
              St = et == Ee || et == He;
            if (Gh(y)) return Fj(y, he);
            if (et == Wt || et == G || (St && !X)) {
              if (((ue = xe || St ? {} : iD(y)), !he))
                return xe ? Xce(y, xce(ue, y)) : Qce(y, mj(ue, y));
            } else {
              if (!Rr[et]) return X ? y : {};
              ue = uue(y, et, he);
            }
          }
          te || (te = new Qc());
          var en = te.get(y);
          if (en) return en;
          te.set(y, ue),
            OD(y)
              ? y.forEach(function (Tn) {
                  ue.add(rc(Tn, E, U, Tn, y, te));
                })
              : ND(y) &&
                y.forEach(function (Tn, mr) {
                  ue.set(mr, rc(Tn, E, U, mr, y, te));
                });
          var kn = Ge ? (xe ? R9 : N9) : xe ? Ua : uo,
            Qn = qe ? n : kn(y);
          return (
            W(Qn || y, function (Tn, mr) {
              Qn && ((mr = Tn), (Tn = y[mr])),
                e2(ue, mr, rc(Tn, E, U, mr, y, te));
            }),
            ue
          );
        }
        function _ce(y) {
          var E = uo(y);
          return function (U) {
            return gj(U, y, E);
          };
        }
        function gj(y, E, U) {
          var V = U.length;
          if (y == null) return !V;
          for (y = Ci(y); V--; ) {
            var X = U[V],
              te = E[X],
              ue = y[X];
            if ((ue === n && !(X in y)) || !te(ue)) return !1;
          }
          return !0;
        }
        function yj(y, E, U) {
          if (typeof y != "function") throw new tc(o);
          return a2(function () {
            y.apply(n, U);
          }, E);
        }
        function t2(y, E, U, V) {
          var X = -1,
            te = Je,
            ue = !0,
            he = y.length,
            xe = [],
            Ge = E.length;
          if (!he) return xe;
          U && (E = Ze(E, ml(U))),
            V
              ? ((te = De), (ue = !1))
              : E.length >= i && ((te = Kv), (ue = !1), (E = new k0(E)));
          e: for (; ++X < he; ) {
            var qe = y[X],
              et = U == null ? qe : U(qe);
            if (((qe = V || qe !== 0 ? qe : 0), ue && et === et)) {
              for (var St = Ge; St--; ) if (E[St] === et) continue e;
              xe.push(qe);
            } else te(E, et, V) || xe.push(qe);
          }
          return xe;
        }
        var zh = Hj(zu),
          vj = Hj(p9, !0);
        function Sce(y, E) {
          var U = !0;
          return (
            zh(y, function (V, X, te) {
              return (U = !!E(V, X, te)), U;
            }),
            U
          );
        }
        function P3(y, E, U) {
          for (var V = -1, X = y.length; ++V < X; ) {
            var te = y[V],
              ue = E(te);
            if (ue != null && (he === n ? ue === ue && !yl(ue) : U(ue, he)))
              var he = ue,
                xe = te;
          }
          return xe;
        }
        function Ece(y, E, U, V) {
          var X = y.length;
          for (
            U = Yn(U),
              U < 0 && (U = -U > X ? 0 : X + U),
              V = V === n || V > X ? X : Yn(V),
              V < 0 && (V += X),
              V = U > V ? 0 : LD(V);
            U < V;

          )
            y[U++] = E;
          return y;
        }
        function wj(y, E) {
          var U = [];
          return (
            zh(y, function (V, X, te) {
              E(V, X, te) && U.push(V);
            }),
            U
          );
        }
        function To(y, E, U, V, X) {
          var te = -1,
            ue = y.length;
          for (U || (U = fue), X || (X = []); ++te < ue; ) {
            var he = y[te];
            E > 0 && U(he)
              ? E > 1
                ? To(he, E - 1, U, V, X)
                : yn(X, he)
              : V || (X[X.length] = he);
          }
          return X;
        }
        var h9 = Vj(),
          bj = Vj(!0);
        function zu(y, E) {
          return y && h9(y, E, uo);
        }
        function p9(y, E) {
          return y && bj(y, E, uo);
        }
        function L3(y, E) {
          return ye(E, function (U) {
            return df(y[U]);
          });
        }
        function M0(y, E) {
          E = Hh(E, y);
          for (var U = 0, V = E.length; y != null && U < V; ) y = y[Hu(E[U++])];
          return U && U == V ? y : n;
        }
        function xj(y, E, U) {
          var V = E(y);
          return Fn(y) ? V : yn(V, U(y));
        }
        function pa(y) {
          return y == null
            ? y === n
              ? mt
              : rn
            : A0 && A0 in Ci(y)
            ? oue(y)
            : wue(y);
        }
        function m9(y, E) {
          return y > E;
        }
        function Ace(y, E) {
          return y != null && oi.call(y, E);
        }
        function Cce(y, E) {
          return y != null && E in Ci(y);
        }
        function kce(y, E, U) {
          return y >= Go(E, U) && y < Ks(E, U);
        }
        function g9(y, E, U) {
          for (
            var V = U ? De : Je,
              X = y[0].length,
              te = y.length,
              ue = te,
              he = Ne(te),
              xe = 1 / 0,
              Ge = [];
            ue--;

          ) {
            var qe = y[ue];
            ue && E && (qe = Ze(qe, ml(E))),
              (xe = Go(qe.length, xe)),
              (he[ue] =
                !U && (E || (X >= 120 && qe.length >= 120))
                  ? new k0(ue && qe)
                  : n);
          }
          qe = y[0];
          var et = -1,
            St = he[0];
          e: for (; ++et < X && Ge.length < xe; ) {
            var en = qe[et],
              kn = E ? E(en) : en;
            if (
              ((en = U || en !== 0 ? en : 0), !(St ? Kv(St, kn) : V(Ge, kn, U)))
            ) {
              for (ue = te; --ue; ) {
                var Qn = he[ue];
                if (!(Qn ? Kv(Qn, kn) : V(y[ue], kn, U))) continue e;
              }
              St && St.push(kn), Ge.push(en);
            }
          }
          return Ge;
        }
        function Tce(y, E, U, V) {
          return (
            zu(y, function (X, te, ue) {
              E(V, U(X), te, ue);
            }),
            V
          );
        }
        function n2(y, E, U) {
          (E = Hh(E, y)), (y = lD(y, E));
          var V = y == null ? y : y[Hu(sc(E))];
          return V == null ? n : Co(V, y, U);
        }
        function _j(y) {
          return ws(y) && pa(y) == G;
        }
        function Mce(y) {
          return ws(y) && pa(y) == xt;
        }
        function Ice(y) {
          return ws(y) && pa(y) == ge;
        }
        function r2(y, E, U, V, X) {
          return y === E
            ? !0
            : y == null || E == null || (!ws(y) && !ws(E))
            ? y !== y && E !== E
            : Nce(y, E, U, V, r2, X);
        }
        function Nce(y, E, U, V, X, te) {
          var ue = Fn(y),
            he = Fn(E),
            xe = ue ? ne : qo(y),
            Ge = he ? ne : qo(E);
          (xe = xe == G ? Wt : xe), (Ge = Ge == G ? Wt : Ge);
          var qe = xe == Wt,
            et = Ge == Wt,
            St = xe == Ge;
          if (St && Gh(y)) {
            if (!Gh(E)) return !1;
            (ue = !0), (qe = !1);
          }
          if (St && !qe)
            return (
              te || (te = new Qc()),
              ue || B1(y) ? tD(y, E, U, V, X, te) : iue(y, E, xe, U, V, X, te)
            );
          if (!(U & p)) {
            var en = qe && oi.call(y, "__wrapped__"),
              kn = et && oi.call(E, "__wrapped__");
            if (en || kn) {
              var Qn = en ? y.value() : y,
                Tn = kn ? E.value() : E;
              return te || (te = new Qc()), X(Qn, Tn, U, V, te);
            }
          }
          return St ? (te || (te = new Qc()), sue(y, E, U, V, X, te)) : !1;
        }
        function Rce(y) {
          return ws(y) && qo(y) == je;
        }
        function y9(y, E, U, V) {
          var X = U.length,
            te = X,
            ue = !V;
          if (y == null) return !te;
          for (y = Ci(y); X--; ) {
            var he = U[X];
            if (ue && he[2] ? he[1] !== y[he[0]] : !(he[0] in y)) return !1;
          }
          for (; ++X < te; ) {
            he = U[X];
            var xe = he[0],
              Ge = y[xe],
              qe = he[1];
            if (ue && he[2]) {
              if (Ge === n && !(xe in y)) return !1;
            } else {
              var et = new Qc();
              if (V) var St = V(Ge, qe, xe, y, E, et);
              if (!(St === n ? r2(qe, Ge, p | g, V, et) : St)) return !1;
            }
          }
          return !0;
        }
        function Sj(y) {
          if (!ss(y) || pue(y)) return !1;
          var E = df(y) ? Rle : bn;
          return E.test(N0(y));
        }
        function Oce(y) {
          return ws(y) && pa(y) == kt;
        }
        function Pce(y) {
          return ws(y) && qo(y) == Qe;
        }
        function Lce(y) {
          return ws(y) && X3(y.length) && !!Dr[pa(y)];
        }
        function Ej(y) {
          return typeof y == "function"
            ? y
            : y == null
            ? $a
            : typeof y == "object"
            ? Fn(y)
              ? kj(y[0], y[1])
              : Cj(y)
            : GD(y);
        }
        function v9(y) {
          if (!o2(y)) return Ble(y);
          var E = [];
          for (var U in Ci(y)) oi.call(y, U) && U != "constructor" && E.push(U);
          return E;
        }
        function jce(y) {
          if (!ss(y)) return vue(y);
          var E = o2(y),
            U = [];
          for (var V in y)
            (V == "constructor" && (E || !oi.call(y, V))) || U.push(V);
          return U;
        }
        function w9(y, E) {
          return y < E;
        }
        function Aj(y, E) {
          var U = -1,
            V = Fa(y) ? Ne(y.length) : [];
          return (
            zh(y, function (X, te, ue) {
              V[++U] = E(X, te, ue);
            }),
            V
          );
        }
        function Cj(y) {
          var E = P9(y);
          return E.length == 1 && E[0][2]
            ? oD(E[0][0], E[0][1])
            : function (U) {
                return U === y || y9(U, y, E);
              };
        }
        function kj(y, E) {
          return j9(y) && sD(E)
            ? oD(Hu(y), E)
            : function (U) {
                var V = G9(U, y);
                return V === n && V === E ? q9(U, y) : r2(E, V, p | g);
              };
        }
        function j3(y, E, U, V, X) {
          y !== E &&
            h9(
              E,
              function (te, ue) {
                if ((X || (X = new Qc()), ss(te))) Dce(y, E, ue, U, j3, V, X);
                else {
                  var he = V ? V(B9(y, ue), te, ue + "", y, E, X) : n;
                  he === n && (he = te), d9(y, ue, he);
                }
              },
              Ua
            );
        }
        function Dce(y, E, U, V, X, te, ue) {
          var he = B9(y, U),
            xe = B9(E, U),
            Ge = ue.get(xe);
          if (Ge) {
            d9(y, U, Ge);
            return;
          }
          var qe = te ? te(he, xe, U + "", y, E, ue) : n,
            et = qe === n;
          if (et) {
            var St = Fn(xe),
              en = !St && Gh(xe),
              kn = !St && !en && B1(xe);
            (qe = xe),
              St || en || kn
                ? Fn(he)
                  ? (qe = he)
                  : Cs(he)
                  ? (qe = Ba(he))
                  : en
                  ? ((et = !1), (qe = Fj(xe, !0)))
                  : kn
                  ? ((et = !1), (qe = Uj(xe, !0)))
                  : (qe = [])
                : l2(xe) || R0(xe)
                ? ((qe = he),
                  R0(he) ? (qe = jD(he)) : (!ss(he) || df(he)) && (qe = iD(xe)))
                : (et = !1);
          }
          et && (ue.set(xe, qe), X(qe, xe, V, te, ue), ue.delete(xe)),
            d9(y, U, qe);
        }
        function Tj(y, E) {
          var U = y.length;
          if (U) return (E += E < 0 ? U : 0), uf(E, U) ? y[E] : n;
        }
        function Mj(y, E, U) {
          E.length
            ? (E = Ze(E, function (te) {
                return Fn(te)
                  ? function (ue) {
                      return M0(ue, te.length === 1 ? te[0] : te);
                    }
                  : te;
              }))
            : (E = [$a]);
          var V = -1;
          E = Ze(E, ml(En()));
          var X = Aj(y, function (te, ue, he) {
            var xe = Ze(E, function (Ge) {
              return Ge(te);
            });
            return { criteria: xe, index: ++V, value: te };
          });
          return ule(X, function (te, ue) {
            return Zce(te, ue, U);
          });
        }
        function Bce(y, E) {
          return Ij(y, E, function (U, V) {
            return q9(y, V);
          });
        }
        function Ij(y, E, U) {
          for (var V = -1, X = E.length, te = {}; ++V < X; ) {
            var ue = E[V],
              he = M0(y, ue);
            U(he, ue) && i2(te, Hh(ue, y), he);
          }
          return te;
        }
        function Fce(y) {
          return function (E) {
            return M0(E, y);
          };
        }
        function b9(y, E, U, V) {
          var X = V ? ko : Ni,
            te = -1,
            ue = E.length,
            he = y;
          for (y === E && (E = Ba(E)), U && (he = Ze(y, ml(U))); ++te < ue; )
            for (
              var xe = 0, Ge = E[te], qe = U ? U(Ge) : Ge;
              (xe = X(he, qe, xe, V)) > -1;

            )
              he !== y && C3.call(he, xe, 1), C3.call(y, xe, 1);
          return y;
        }
        function Nj(y, E) {
          for (var U = y ? E.length : 0, V = U - 1; U--; ) {
            var X = E[U];
            if (U == V || X !== te) {
              var te = X;
              uf(X) ? C3.call(y, X, 1) : E9(y, X);
            }
          }
          return y;
        }
        function x9(y, E) {
          return y + M3(dj() * (E - y + 1));
        }
        function Uce(y, E, U, V) {
          for (
            var X = -1, te = Ks(T3((E - y) / (U || 1)), 0), ue = Ne(te);
            te--;

          )
            (ue[V ? te : ++X] = y), (y += U);
          return ue;
        }
        function _9(y, E) {
          var U = "";
          if (!y || E < 1 || E > F) return U;
          do E % 2 && (U += y), (E = M3(E / 2)), E && (y += y);
          while (E);
          return U;
        }
        function nr(y, E) {
          return F9(aD(y, E, $a), y + "");
        }
        function $ce(y) {
          return pj(F1(y));
        }
        function zce(y, E) {
          var U = F1(y);
          return G3(U, T0(E, 0, U.length));
        }
        function i2(y, E, U, V) {
          if (!ss(y)) return y;
          E = Hh(E, y);
          for (
            var X = -1, te = E.length, ue = te - 1, he = y;
            he != null && ++X < te;

          ) {
            var xe = Hu(E[X]),
              Ge = U;
            if (
              xe === "__proto__" ||
              xe === "constructor" ||
              xe === "prototype"
            )
              return y;
            if (X != ue) {
              var qe = he[xe];
              (Ge = V ? V(qe, xe, he) : n),
                Ge === n && (Ge = ss(qe) ? qe : uf(E[X + 1]) ? [] : {});
            }
            e2(he, xe, Ge), (he = he[xe]);
          }
          return y;
        }
        var Rj = I3
            ? function (y, E) {
                return I3.set(y, E), y;
              }
            : $a,
          Wce = k3
            ? function (y, E) {
                return k3(y, "toString", {
                  configurable: !0,
                  enumerable: !1,
                  value: Y9(E),
                  writable: !0,
                });
              }
            : $a;
        function Hce(y) {
          return G3(F1(y));
        }
        function ic(y, E, U) {
          var V = -1,
            X = y.length;
          E < 0 && (E = -E > X ? 0 : X + E),
            (U = U > X ? X : U),
            U < 0 && (U += X),
            (X = E > U ? 0 : (U - E) >>> 0),
            (E >>>= 0);
          for (var te = Ne(X); ++V < X; ) te[V] = y[V + E];
          return te;
        }
        function Vce(y, E) {
          var U;
          return (
            zh(y, function (V, X, te) {
              return (U = E(V, X, te)), !U;
            }),
            !!U
          );
        }
        function D3(y, E, U) {
          var V = 0,
            X = y == null ? V : y.length;
          if (typeof E == "number" && E === E && X <= K) {
            for (; V < X; ) {
              var te = (V + X) >>> 1,
                ue = y[te];
              ue !== null && !yl(ue) && (U ? ue <= E : ue < E)
                ? (V = te + 1)
                : (X = te);
            }
            return X;
          }
          return S9(y, E, $a, U);
        }
        function S9(y, E, U, V) {
          var X = 0,
            te = y == null ? 0 : y.length;
          if (te === 0) return 0;
          E = U(E);
          for (
            var ue = E !== E, he = E === null, xe = yl(E), Ge = E === n;
            X < te;

          ) {
            var qe = M3((X + te) / 2),
              et = U(y[qe]),
              St = et !== n,
              en = et === null,
              kn = et === et,
              Qn = yl(et);
            if (ue) var Tn = V || kn;
            else
              Ge
                ? (Tn = kn && (V || St))
                : he
                ? (Tn = kn && St && (V || !en))
                : xe
                ? (Tn = kn && St && !en && (V || !Qn))
                : en || Qn
                ? (Tn = !1)
                : (Tn = V ? et <= E : et < E);
            Tn ? (X = qe + 1) : (te = qe);
          }
          return Go(te, $);
        }
        function Oj(y, E) {
          for (var U = -1, V = y.length, X = 0, te = []; ++U < V; ) {
            var ue = y[U],
              he = E ? E(ue) : ue;
            if (!U || !Xc(he, xe)) {
              var xe = he;
              te[X++] = ue === 0 ? 0 : ue;
            }
          }
          return te;
        }
        function Pj(y) {
          return typeof y == "number" ? y : yl(y) ? j : +y;
        }
        function gl(y) {
          if (typeof y == "string") return y;
          if (Fn(y)) return Ze(y, gl) + "";
          if (yl(y)) return fj ? fj.call(y) : "";
          var E = y + "";
          return E == "0" && 1 / y == -L ? "-0" : E;
        }
        function Wh(y, E, U) {
          var V = -1,
            X = Je,
            te = y.length,
            ue = !0,
            he = [],
            xe = he;
          if (U) (ue = !1), (X = De);
          else if (te >= i) {
            var Ge = E ? null : nue(y);
            if (Ge) return v3(Ge);
            (ue = !1), (X = Kv), (xe = new k0());
          } else xe = E ? [] : he;
          e: for (; ++V < te; ) {
            var qe = y[V],
              et = E ? E(qe) : qe;
            if (((qe = U || qe !== 0 ? qe : 0), ue && et === et)) {
              for (var St = xe.length; St--; ) if (xe[St] === et) continue e;
              E && xe.push(et), he.push(qe);
            } else X(xe, et, U) || (xe !== he && xe.push(et), he.push(qe));
          }
          return he;
        }
        function E9(y, E) {
          return (
            (E = Hh(E, y)), (y = lD(y, E)), y == null || delete y[Hu(sc(E))]
          );
        }
        function Lj(y, E, U, V) {
          return i2(y, E, U(M0(y, E)), V);
        }
        function B3(y, E, U, V) {
          for (
            var X = y.length, te = V ? X : -1;
            (V ? te-- : ++te < X) && E(y[te], te, y);

          );
          return U
            ? ic(y, V ? 0 : te, V ? te + 1 : X)
            : ic(y, V ? te + 1 : 0, V ? X : te);
        }
        function jj(y, E) {
          var U = y;
          return (
            U instanceof xr && (U = U.value()),
            fn(
              E,
              function (V, X) {
                return X.func.apply(X.thisArg, yn([V], X.args));
              },
              U
            )
          );
        }
        function A9(y, E, U) {
          var V = y.length;
          if (V < 2) return V ? Wh(y[0]) : [];
          for (var X = -1, te = Ne(V); ++X < V; )
            for (var ue = y[X], he = -1; ++he < V; )
              he != X && (te[X] = t2(te[X] || ue, y[he], E, U));
          return Wh(To(te, 1), E, U);
        }
        function Dj(y, E, U) {
          for (var V = -1, X = y.length, te = E.length, ue = {}; ++V < X; ) {
            var he = V < te ? E[V] : n;
            U(ue, y[V], he);
          }
          return ue;
        }
        function C9(y) {
          return Cs(y) ? y : [];
        }
        function k9(y) {
          return typeof y == "function" ? y : $a;
        }
        function Hh(y, E) {
          return Fn(y) ? y : j9(y, E) ? [y] : fD(ei(y));
        }
        var Gce = nr;
        function Vh(y, E, U) {
          var V = y.length;
          return (U = U === n ? V : U), !E && U >= V ? y : ic(y, E, U);
        }
        var Bj =
          Ole ||
          function (y) {
            return dn.clearTimeout(y);
          };
        function Fj(y, E) {
          if (E) return y.slice();
          var U = y.length,
            V = oj ? oj(U) : new y.constructor(U);
          return y.copy(V), V;
        }
        function T9(y) {
          var E = new y.constructor(y.byteLength);
          return new E3(E).set(new E3(y)), E;
        }
        function qce(y, E) {
          var U = E ? T9(y.buffer) : y.buffer;
          return new y.constructor(U, y.byteOffset, y.byteLength);
        }
        function Kce(y) {
          var E = new y.constructor(y.source, gt.exec(y));
          return (E.lastIndex = y.lastIndex), E;
        }
        function Yce(y) {
          return Jv ? Ci(Jv.call(y)) : {};
        }
        function Uj(y, E) {
          var U = E ? T9(y.buffer) : y.buffer;
          return new y.constructor(U, y.byteOffset, y.length);
        }
        function $j(y, E) {
          if (y !== E) {
            var U = y !== n,
              V = y === null,
              X = y === y,
              te = yl(y),
              ue = E !== n,
              he = E === null,
              xe = E === E,
              Ge = yl(E);
            if (
              (!he && !Ge && !te && y > E) ||
              (te && ue && xe && !he && !Ge) ||
              (V && ue && xe) ||
              (!U && xe) ||
              !X
            )
              return 1;
            if (
              (!V && !te && !Ge && y < E) ||
              (Ge && U && X && !V && !te) ||
              (he && U && X) ||
              (!ue && X) ||
              !xe
            )
              return -1;
          }
          return 0;
        }
        function Zce(y, E, U) {
          for (
            var V = -1,
              X = y.criteria,
              te = E.criteria,
              ue = X.length,
              he = U.length;
            ++V < ue;

          ) {
            var xe = $j(X[V], te[V]);
            if (xe) {
              if (V >= he) return xe;
              var Ge = U[V];
              return xe * (Ge == "desc" ? -1 : 1);
            }
          }
          return y.index - E.index;
        }
        function zj(y, E, U, V) {
          for (
            var X = -1,
              te = y.length,
              ue = U.length,
              he = -1,
              xe = E.length,
              Ge = Ks(te - ue, 0),
              qe = Ne(xe + Ge),
              et = !V;
            ++he < xe;

          )
            qe[he] = E[he];
          for (; ++X < ue; ) (et || X < te) && (qe[U[X]] = y[X]);
          for (; Ge--; ) qe[he++] = y[X++];
          return qe;
        }
        function Wj(y, E, U, V) {
          for (
            var X = -1,
              te = y.length,
              ue = -1,
              he = U.length,
              xe = -1,
              Ge = E.length,
              qe = Ks(te - he, 0),
              et = Ne(qe + Ge),
              St = !V;
            ++X < qe;

          )
            et[X] = y[X];
          for (var en = X; ++xe < Ge; ) et[en + xe] = E[xe];
          for (; ++ue < he; ) (St || X < te) && (et[en + U[ue]] = y[X++]);
          return et;
        }
        function Ba(y, E) {
          var U = -1,
            V = y.length;
          for (E || (E = Ne(V)); ++U < V; ) E[U] = y[U];
          return E;
        }
        function Wu(y, E, U, V) {
          var X = !U;
          U || (U = {});
          for (var te = -1, ue = E.length; ++te < ue; ) {
            var he = E[te],
              xe = V ? V(U[he], y[he], he, U, y) : n;
            xe === n && (xe = y[he]), X ? af(U, he, xe) : e2(U, he, xe);
          }
          return U;
        }
        function Qce(y, E) {
          return Wu(y, L9(y), E);
        }
        function Xce(y, E) {
          return Wu(y, nD(y), E);
        }
        function F3(y, E) {
          return function (U, V) {
            var X = Fn(U) ? qv : bce,
              te = E ? E() : {};
            return X(U, y, En(V, 2), te);
          };
        }
        function L1(y) {
          return nr(function (E, U) {
            var V = -1,
              X = U.length,
              te = X > 1 ? U[X - 1] : n,
              ue = X > 2 ? U[2] : n;
            for (
              te = y.length > 3 && typeof te == "function" ? (X--, te) : n,
                ue && ma(U[0], U[1], ue) && ((te = X < 3 ? n : te), (X = 1)),
                E = Ci(E);
              ++V < X;

            ) {
              var he = U[V];
              he && y(E, he, V, te);
            }
            return E;
          });
        }
        function Hj(y, E) {
          return function (U, V) {
            if (U == null) return U;
            if (!Fa(U)) return y(U, V);
            for (
              var X = U.length, te = E ? X : -1, ue = Ci(U);
              (E ? te-- : ++te < X) && V(ue[te], te, ue) !== !1;

            );
            return U;
          };
        }
        function Vj(y) {
          return function (E, U, V) {
            for (var X = -1, te = Ci(E), ue = V(E), he = ue.length; he--; ) {
              var xe = ue[y ? he : ++X];
              if (U(te[xe], xe, te) === !1) break;
            }
            return E;
          };
        }
        function Jce(y, E, U) {
          var V = E & b,
            X = s2(y);
          function te() {
            var ue = this && this !== dn && this instanceof te ? X : y;
            return ue.apply(V ? U : this, arguments);
          }
          return te;
        }
        function Gj(y) {
          return function (E) {
            E = ei(E);
            var U = T1(E) ? Zc(E) : n,
              V = U ? U[0] : E.charAt(0),
              X = U ? Vh(U, 1).join("") : E.slice(1);
            return V[y]() + X;
          };
        }
        function j1(y) {
          return function (E) {
            return fn(HD(WD(E).replace(Os, "")), y, "");
          };
        }
        function s2(y) {
          return function () {
            var E = arguments;
            switch (E.length) {
              case 0:
                return new y();
              case 1:
                return new y(E[0]);
              case 2:
                return new y(E[0], E[1]);
              case 3:
                return new y(E[0], E[1], E[2]);
              case 4:
                return new y(E[0], E[1], E[2], E[3]);
              case 5:
                return new y(E[0], E[1], E[2], E[3], E[4]);
              case 6:
                return new y(E[0], E[1], E[2], E[3], E[4], E[5]);
              case 7:
                return new y(E[0], E[1], E[2], E[3], E[4], E[5], E[6]);
            }
            var U = P1(y.prototype),
              V = y.apply(U, E);
            return ss(V) ? V : U;
          };
        }
        function eue(y, E, U) {
          var V = s2(y);
          function X() {
            for (
              var te = arguments.length, ue = Ne(te), he = te, xe = D1(X);
              he--;

            )
              ue[he] = arguments[he];
            var Ge =
              te < 3 && ue[0] !== xe && ue[te - 1] !== xe ? [] : Uh(ue, xe);
            if (((te -= Ge.length), te < U))
              return Qj(y, E, U3, X.placeholder, n, ue, Ge, n, n, U - te);
            var qe = this && this !== dn && this instanceof X ? V : y;
            return Co(qe, this, ue);
          }
          return X;
        }
        function qj(y) {
          return function (E, U, V) {
            var X = Ci(E);
            if (!Fa(E)) {
              var te = En(U, 3);
              (E = uo(E)),
                (U = function (he) {
                  return te(X[he], he, X);
                });
            }
            var ue = y(E, U, V);
            return ue > -1 ? X[te ? E[ue] : ue] : n;
          };
        }
        function Kj(y) {
          return cf(function (E) {
            var U = E.length,
              V = U,
              X = nc.prototype.thru;
            for (y && E.reverse(); V--; ) {
              var te = E[V];
              if (typeof te != "function") throw new tc(o);
              if (X && !ue && H3(te) == "wrapper") var ue = new nc([], !0);
            }
            for (V = ue ? V : U; ++V < U; ) {
              te = E[V];
              var he = H3(te),
                xe = he == "wrapper" ? O9(te) : n;
              xe &&
              D9(xe[0]) &&
              xe[1] == (B | x | R | C) &&
              !xe[4].length &&
              xe[9] == 1
                ? (ue = ue[H3(xe[0])].apply(ue, xe[3]))
                : (ue = te.length == 1 && D9(te) ? ue[he]() : ue.thru(te));
            }
            return function () {
              var Ge = arguments,
                qe = Ge[0];
              if (ue && Ge.length == 1 && Fn(qe)) return ue.plant(qe).value();
              for (var et = 0, St = U ? E[et].apply(this, Ge) : qe; ++et < U; )
                St = E[et].call(this, St);
              return St;
            };
          });
        }
        function U3(y, E, U, V, X, te, ue, he, xe, Ge) {
          var qe = E & B,
            et = E & b,
            St = E & v,
            en = E & (x | S),
            kn = E & I,
            Qn = St ? n : s2(y);
          function Tn() {
            for (var mr = arguments.length, Cr = Ne(mr), vl = mr; vl--; )
              Cr[vl] = arguments[vl];
            if (en)
              var ga = D1(Tn),
                wl = fle(Cr, ga);
            if (
              (V && (Cr = zj(Cr, V, X, en)),
              te && (Cr = Wj(Cr, te, ue, en)),
              (mr -= wl),
              en && mr < Ge)
            ) {
              var ks = Uh(Cr, ga);
              return Qj(y, E, U3, Tn.placeholder, U, Cr, ks, he, xe, Ge - mr);
            }
            var Jc = et ? U : this,
              hf = St ? Jc[y] : y;
            return (
              (mr = Cr.length),
              he ? (Cr = bue(Cr, he)) : kn && mr > 1 && Cr.reverse(),
              qe && xe < mr && (Cr.length = xe),
              this && this !== dn && this instanceof Tn && (hf = Qn || s2(hf)),
              hf.apply(Jc, Cr)
            );
          }
          return Tn;
        }
        function Yj(y, E) {
          return function (U, V) {
            return Tce(U, y, E(V), {});
          };
        }
        function $3(y, E) {
          return function (U, V) {
            var X;
            if (U === n && V === n) return E;
            if ((U !== n && (X = U), V !== n)) {
              if (X === n) return V;
              typeof U == "string" || typeof V == "string"
                ? ((U = gl(U)), (V = gl(V)))
                : ((U = Pj(U)), (V = Pj(V))),
                (X = y(U, V));
            }
            return X;
          };
        }
        function M9(y) {
          return cf(function (E) {
            return (
              (E = Ze(E, ml(En()))),
              nr(function (U) {
                var V = this;
                return y(E, function (X) {
                  return Co(X, V, U);
                });
              })
            );
          });
        }
        function z3(y, E) {
          E = E === n ? " " : gl(E);
          var U = E.length;
          if (U < 2) return U ? _9(E, y) : E;
          var V = _9(E, T3(y / M1(E)));
          return T1(E) ? Vh(Zc(V), 0, y).join("") : V.slice(0, y);
        }
        function tue(y, E, U, V) {
          var X = E & b,
            te = s2(y);
          function ue() {
            for (
              var he = -1,
                xe = arguments.length,
                Ge = -1,
                qe = V.length,
                et = Ne(qe + xe),
                St = this && this !== dn && this instanceof ue ? te : y;
              ++Ge < qe;

            )
              et[Ge] = V[Ge];
            for (; xe--; ) et[Ge++] = arguments[++he];
            return Co(St, X ? U : this, et);
          }
          return ue;
        }
        function Zj(y) {
          return function (E, U, V) {
            return (
              V && typeof V != "number" && ma(E, U, V) && (U = V = n),
              (E = ff(E)),
              U === n ? ((U = E), (E = 0)) : (U = ff(U)),
              (V = V === n ? (E < U ? 1 : -1) : ff(V)),
              Uce(E, U, V, y)
            );
          };
        }
        function W3(y) {
          return function (E, U) {
            return (
              (typeof E == "string" && typeof U == "string") ||
                ((E = oc(E)), (U = oc(U))),
              y(E, U)
            );
          };
        }
        function Qj(y, E, U, V, X, te, ue, he, xe, Ge) {
          var qe = E & x,
            et = qe ? ue : n,
            St = qe ? n : ue,
            en = qe ? te : n,
            kn = qe ? n : te;
          (E |= qe ? R : O), (E &= ~(qe ? O : R)), E & w || (E &= ~(b | v));
          var Qn = [y, E, X, en, et, kn, St, he, xe, Ge],
            Tn = U.apply(n, Qn);
          return D9(y) && cD(Tn, Qn), (Tn.placeholder = V), uD(Tn, y, E);
        }
        function I9(y) {
          var E = qs[y];
          return function (U, V) {
            if (
              ((U = oc(U)), (V = V == null ? 0 : Go(Yn(V), 292)), V && uj(U))
            ) {
              var X = (ei(U) + "e").split("e"),
                te = E(X[0] + "e" + (+X[1] + V));
              return (
                (X = (ei(te) + "e").split("e")), +(X[0] + "e" + (+X[1] - V))
              );
            }
            return E(U);
          };
        }
        var nue =
          R1 && 1 / v3(new R1([, -0]))[1] == L
            ? function (y) {
                return new R1(y);
              }
            : X9;
        function Xj(y) {
          return function (E) {
            var U = qo(E);
            return U == je ? o9(E) : U == Qe ? wle(E) : dle(E, y(E));
          };
        }
        function lf(y, E, U, V, X, te, ue, he) {
          var xe = E & v;
          if (!xe && typeof y != "function") throw new tc(o);
          var Ge = V ? V.length : 0;
          if (
            (Ge || ((E &= ~(R | O)), (V = X = n)),
            (ue = ue === n ? ue : Ks(Yn(ue), 0)),
            (he = he === n ? he : Yn(he)),
            (Ge -= X ? X.length : 0),
            E & O)
          ) {
            var qe = V,
              et = X;
            V = X = n;
          }
          var St = xe ? n : O9(y),
            en = [y, E, U, V, X, qe, et, te, ue, he];
          if (
            (St && yue(en, St),
            (y = en[0]),
            (E = en[1]),
            (U = en[2]),
            (V = en[3]),
            (X = en[4]),
            (he = en[9] =
              en[9] === n ? (xe ? 0 : y.length) : Ks(en[9] - Ge, 0)),
            !he && E & (x | S) && (E &= ~(x | S)),
            !E || E == b)
          )
            var kn = Jce(y, E, U);
          else
            E == x || E == S
              ? (kn = eue(y, E, he))
              : (E == R || E == (b | R)) && !X.length
              ? (kn = tue(y, E, U, V))
              : (kn = U3.apply(n, en));
          var Qn = St ? Rj : cD;
          return uD(Qn(kn, en), y, E);
        }
        function Jj(y, E, U, V) {
          return y === n || (Xc(y, N1[U]) && !oi.call(V, U)) ? E : y;
        }
        function eD(y, E, U, V, X, te) {
          return (
            ss(y) && ss(E) && (te.set(E, y), j3(y, E, n, eD, te), te.delete(E)),
            y
          );
        }
        function rue(y) {
          return l2(y) ? n : y;
        }
        function tD(y, E, U, V, X, te) {
          var ue = U & p,
            he = y.length,
            xe = E.length;
          if (he != xe && !(ue && xe > he)) return !1;
          var Ge = te.get(y),
            qe = te.get(E);
          if (Ge && qe) return Ge == E && qe == y;
          var et = -1,
            St = !0,
            en = U & g ? new k0() : n;
          for (te.set(y, E), te.set(E, y); ++et < he; ) {
            var kn = y[et],
              Qn = E[et];
            if (V)
              var Tn = ue ? V(Qn, kn, et, E, y, te) : V(kn, Qn, et, y, E, te);
            if (Tn !== n) {
              if (Tn) continue;
              St = !1;
              break;
            }
            if (en) {
              if (
                !Kn(E, function (mr, Cr) {
                  if (!Kv(en, Cr) && (kn === mr || X(kn, mr, U, V, te)))
                    return en.push(Cr);
                })
              ) {
                St = !1;
                break;
              }
            } else if (!(kn === Qn || X(kn, Qn, U, V, te))) {
              St = !1;
              break;
            }
          }
          return te.delete(y), te.delete(E), St;
        }
        function iue(y, E, U, V, X, te, ue) {
          switch (U) {
            case Tt:
              if (y.byteLength != E.byteLength || y.byteOffset != E.byteOffset)
                return !1;
              (y = y.buffer), (E = E.buffer);
            case xt:
              return !(
                y.byteLength != E.byteLength || !te(new E3(y), new E3(E))
              );
            case le:
            case ge:
            case Be:
              return Xc(+y, +E);
            case _e:
              return y.name == E.name && y.message == E.message;
            case kt:
            case Vt:
              return y == E + "";
            case je:
              var he = o9;
            case Qe:
              var xe = V & p;
              if ((he || (he = v3), y.size != E.size && !xe)) return !1;
              var Ge = ue.get(y);
              if (Ge) return Ge == E;
              (V |= g), ue.set(y, E);
              var qe = tD(he(y), he(E), V, X, te, ue);
              return ue.delete(y), qe;
            case Rt:
              if (Jv) return Jv.call(y) == Jv.call(E);
          }
          return !1;
        }
        function sue(y, E, U, V, X, te) {
          var ue = U & p,
            he = N9(y),
            xe = he.length,
            Ge = N9(E),
            qe = Ge.length;
          if (xe != qe && !ue) return !1;
          for (var et = xe; et--; ) {
            var St = he[et];
            if (!(ue ? St in E : oi.call(E, St))) return !1;
          }
          var en = te.get(y),
            kn = te.get(E);
          if (en && kn) return en == E && kn == y;
          var Qn = !0;
          te.set(y, E), te.set(E, y);
          for (var Tn = ue; ++et < xe; ) {
            St = he[et];
            var mr = y[St],
              Cr = E[St];
            if (V)
              var vl = ue ? V(Cr, mr, St, E, y, te) : V(mr, Cr, St, y, E, te);
            if (!(vl === n ? mr === Cr || X(mr, Cr, U, V, te) : vl)) {
              Qn = !1;
              break;
            }
            Tn || (Tn = St == "constructor");
          }
          if (Qn && !Tn) {
            var ga = y.constructor,
              wl = E.constructor;
            ga != wl &&
              "constructor" in y &&
              "constructor" in E &&
              !(
                typeof ga == "function" &&
                ga instanceof ga &&
                typeof wl == "function" &&
                wl instanceof wl
              ) &&
              (Qn = !1);
          }
          return te.delete(y), te.delete(E), Qn;
        }
        function cf(y) {
          return F9(aD(y, n, gD), y + "");
        }
        function N9(y) {
          return xj(y, uo, L9);
        }
        function R9(y) {
          return xj(y, Ua, nD);
        }
        var O9 = I3
          ? function (y) {
              return I3.get(y);
            }
          : X9;
        function H3(y) {
          for (
            var E = y.name + "", U = O1[E], V = oi.call(O1, E) ? U.length : 0;
            V--;

          ) {
            var X = U[V],
              te = X.func;
            if (te == null || te == y) return X.name;
          }
          return E;
        }
        function D1(y) {
          var E = oi.call(J, "placeholder") ? J : y;
          return E.placeholder;
        }
        function En() {
          var y = J.iteratee || Z9;
          return (
            (y = y === Z9 ? Ej : y),
            arguments.length ? y(arguments[0], arguments[1]) : y
          );
        }
        function V3(y, E) {
          var U = y.__data__;
          return hue(E) ? U[typeof E == "string" ? "string" : "hash"] : U.map;
        }
        function P9(y) {
          for (var E = uo(y), U = E.length; U--; ) {
            var V = E[U],
              X = y[V];
            E[U] = [V, X, sD(X)];
          }
          return E;
        }
        function I0(y, E) {
          var U = gle(y, E);
          return Sj(U) ? U : n;
        }
        function oue(y) {
          var E = oi.call(y, A0),
            U = y[A0];
          try {
            y[A0] = n;
            var V = !0;
          } catch {}
          var X = _3.call(y);
          return V && (E ? (y[A0] = U) : delete y[A0]), X;
        }
        var L9 = l9
            ? function (y) {
                return y == null
                  ? []
                  : ((y = Ci(y)),
                    ye(l9(y), function (E) {
                      return lj.call(y, E);
                    }));
              }
            : J9,
          nD = l9
            ? function (y) {
                for (var E = []; y; ) yn(E, L9(y)), (y = A3(y));
                return E;
              }
            : J9,
          qo = pa;
        ((c9 && qo(new c9(new ArrayBuffer(1))) != Tt) ||
          (Zv && qo(new Zv()) != je) ||
          (u9 && qo(u9.resolve()) != Mt) ||
          (R1 && qo(new R1()) != Qe) ||
          (Qv && qo(new Qv()) != Pt)) &&
          (qo = function (y) {
            var E = pa(y),
              U = E == Wt ? y.constructor : n,
              V = U ? N0(U) : "";
            if (V)
              switch (V) {
                case zle:
                  return Tt;
                case Wle:
                  return je;
                case Hle:
                  return Mt;
                case Vle:
                  return Qe;
                case Gle:
                  return Pt;
              }
            return E;
          });
        function aue(y, E, U) {
          for (var V = -1, X = U.length; ++V < X; ) {
            var te = U[V],
              ue = te.size;
            switch (te.type) {
              case "drop":
                y += ue;
                break;
              case "dropRight":
                E -= ue;
                break;
              case "take":
                E = Go(E, y + ue);
                break;
              case "takeRight":
                y = Ks(y, E - ue);
                break;
            }
          }
          return { start: y, end: E };
        }
        function lue(y) {
          var E = y.match(ft);
          return E ? E[1].split(ze) : [];
        }
        function rD(y, E, U) {
          E = Hh(E, y);
          for (var V = -1, X = E.length, te = !1; ++V < X; ) {
            var ue = Hu(E[V]);
            if (!(te = y != null && U(y, ue))) break;
            y = y[ue];
          }
          return te || ++V != X
            ? te
            : ((X = y == null ? 0 : y.length),
              !!X && X3(X) && uf(ue, X) && (Fn(y) || R0(y)));
        }
        function cue(y) {
          var E = y.length,
            U = new y.constructor(E);
          return (
            E &&
              typeof y[0] == "string" &&
              oi.call(y, "index") &&
              ((U.index = y.index), (U.input = y.input)),
            U
          );
        }
        function iD(y) {
          return typeof y.constructor == "function" && !o2(y) ? P1(A3(y)) : {};
        }
        function uue(y, E, U) {
          var V = y.constructor;
          switch (E) {
            case xt:
              return T9(y);
            case le:
            case ge:
              return new V(+y);
            case Tt:
              return qce(y, U);
            case _n:
            case Q:
            case H:
            case q:
            case ee:
            case ce:
            case pe:
            case we:
            case ht:
              return Uj(y, U);
            case je:
              return new V();
            case Be:
            case Vt:
              return new V(y);
            case kt:
              return Kce(y);
            case Qe:
              return new V();
            case Rt:
              return Yce(y);
          }
        }
        function due(y, E) {
          var U = E.length;
          if (!U) return y;
          var V = U - 1;
          return (
            (E[V] = (U > 1 ? "& " : "") + E[V]),
            (E = E.join(U > 2 ? ", " : " ")),
            y.replace(
              it,
              `{
/* [wrapped with ` +
                E +
                `] */
`
            )
          );
        }
        function fue(y) {
          return Fn(y) || R0(y) || !!(cj && y && y[cj]);
        }
        function uf(y, E) {
          var U = typeof y;
          return (
            (E = E ?? F),
            !!E &&
              (U == "number" || (U != "symbol" && Si.test(y))) &&
              y > -1 &&
              y % 1 == 0 &&
              y < E
          );
        }
        function ma(y, E, U) {
          if (!ss(U)) return !1;
          var V = typeof E;
          return (
            V == "number" ? Fa(U) && uf(E, U.length) : V == "string" && E in U
          )
            ? Xc(U[E], y)
            : !1;
        }
        function j9(y, E) {
          if (Fn(y)) return !1;
          var U = typeof y;
          return U == "number" ||
            U == "symbol" ||
            U == "boolean" ||
            y == null ||
            yl(y)
            ? !0
            : ln.test(y) || !Yt.test(y) || (E != null && y in Ci(E));
        }
        function hue(y) {
          var E = typeof y;
          return E == "string" ||
            E == "number" ||
            E == "symbol" ||
            E == "boolean"
            ? y !== "__proto__"
            : y === null;
        }
        function D9(y) {
          var E = H3(y),
            U = J[E];
          if (typeof U != "function" || !(E in xr.prototype)) return !1;
          if (y === U) return !0;
          var V = O9(U);
          return !!V && y === V[0];
        }
        function pue(y) {
          return !!sj && sj in y;
        }
        var mue = b3 ? df : eA;
        function o2(y) {
          var E = y && y.constructor,
            U = (typeof E == "function" && E.prototype) || N1;
          return y === U;
        }
        function sD(y) {
          return y === y && !ss(y);
        }
        function oD(y, E) {
          return function (U) {
            return U == null ? !1 : U[y] === E && (E !== n || y in Ci(U));
          };
        }
        function gue(y) {
          var E = Z3(y, function (V) {
              return U.size === c && U.clear(), V;
            }),
            U = E.cache;
          return E;
        }
        function yue(y, E) {
          var U = y[1],
            V = E[1],
            X = U | V,
            te = X < (b | v | B),
            ue =
              (V == B && U == x) ||
              (V == B && U == C && y[7].length <= E[8]) ||
              (V == (B | C) && E[7].length <= E[8] && U == x);
          if (!(te || ue)) return y;
          V & b && ((y[2] = E[2]), (X |= U & b ? 0 : w));
          var he = E[3];
          if (he) {
            var xe = y[3];
            (y[3] = xe ? zj(xe, he, E[4]) : he),
              (y[4] = xe ? Uh(y[3], u) : E[4]);
          }
          return (
            (he = E[5]),
            he &&
              ((xe = y[5]),
              (y[5] = xe ? Wj(xe, he, E[6]) : he),
              (y[6] = xe ? Uh(y[5], u) : E[6])),
            (he = E[7]),
            he && (y[7] = he),
            V & B && (y[8] = y[8] == null ? E[8] : Go(y[8], E[8])),
            y[9] == null && (y[9] = E[9]),
            (y[0] = E[0]),
            (y[1] = X),
            y
          );
        }
        function vue(y) {
          var E = [];
          if (y != null) for (var U in Ci(y)) E.push(U);
          return E;
        }
        function wue(y) {
          return _3.call(y);
        }
        function aD(y, E, U) {
          return (
            (E = Ks(E === n ? y.length - 1 : E, 0)),
            function () {
              for (
                var V = arguments,
                  X = -1,
                  te = Ks(V.length - E, 0),
                  ue = Ne(te);
                ++X < te;

              )
                ue[X] = V[E + X];
              X = -1;
              for (var he = Ne(E + 1); ++X < E; ) he[X] = V[X];
              return (he[E] = U(ue)), Co(y, this, he);
            }
          );
        }
        function lD(y, E) {
          return E.length < 2 ? y : M0(y, ic(E, 0, -1));
        }
        function bue(y, E) {
          for (var U = y.length, V = Go(E.length, U), X = Ba(y); V--; ) {
            var te = E[V];
            y[V] = uf(te, U) ? X[te] : n;
          }
          return y;
        }
        function B9(y, E) {
          if (
            !(E === "constructor" && typeof y[E] == "function") &&
            E != "__proto__"
          )
            return y[E];
        }
        var cD = dD(Rj),
          a2 =
            Lle ||
            function (y, E) {
              return dn.setTimeout(y, E);
            },
          F9 = dD(Wce);
        function uD(y, E, U) {
          var V = E + "";
          return F9(y, due(V, xue(lue(V), U)));
        }
        function dD(y) {
          var E = 0,
            U = 0;
          return function () {
            var V = Fle(),
              X = T - (V - U);
            if (((U = V), X > 0)) {
              if (++E >= k) return arguments[0];
            } else E = 0;
            return y.apply(n, arguments);
          };
        }
        function G3(y, E) {
          var U = -1,
            V = y.length,
            X = V - 1;
          for (E = E === n ? V : E; ++U < E; ) {
            var te = x9(U, X),
              ue = y[te];
            (y[te] = y[U]), (y[U] = ue);
          }
          return (y.length = E), y;
        }
        var fD = gue(function (y) {
          var E = [];
          return (
            y.charCodeAt(0) === 46 && E.push(""),
            y.replace(oe, function (U, V, X, te) {
              E.push(X ? te.replace(Ve, "$1") : V || U);
            }),
            E
          );
        });
        function Hu(y) {
          if (typeof y == "string" || yl(y)) return y;
          var E = y + "";
          return E == "0" && 1 / y == -L ? "-0" : E;
        }
        function N0(y) {
          if (y != null) {
            try {
              return x3.call(y);
            } catch {}
            try {
              return y + "";
            } catch {}
          }
          return "";
        }
        function xue(y, E) {
          return (
            W(re, function (U) {
              var V = "_." + U[0];
              E & U[1] && !Je(y, V) && y.push(V);
            }),
            y.sort()
          );
        }
        function hD(y) {
          if (y instanceof xr) return y.clone();
          var E = new nc(y.__wrapped__, y.__chain__);
          return (
            (E.__actions__ = Ba(y.__actions__)),
            (E.__index__ = y.__index__),
            (E.__values__ = y.__values__),
            E
          );
        }
        function _ue(y, E, U) {
          (U ? ma(y, E, U) : E === n) ? (E = 1) : (E = Ks(Yn(E), 0));
          var V = y == null ? 0 : y.length;
          if (!V || E < 1) return [];
          for (var X = 0, te = 0, ue = Ne(T3(V / E)); X < V; )
            ue[te++] = ic(y, X, (X += E));
          return ue;
        }
        function Sue(y) {
          for (
            var E = -1, U = y == null ? 0 : y.length, V = 0, X = [];
            ++E < U;

          ) {
            var te = y[E];
            te && (X[V++] = te);
          }
          return X;
        }
        function Eue() {
          var y = arguments.length;
          if (!y) return [];
          for (var E = Ne(y - 1), U = arguments[0], V = y; V--; )
            E[V - 1] = arguments[V];
          return yn(Fn(U) ? Ba(U) : [U], To(E, 1));
        }
        var Aue = nr(function (y, E) {
            return Cs(y) ? t2(y, To(E, 1, Cs, !0)) : [];
          }),
          Cue = nr(function (y, E) {
            var U = sc(E);
            return (
              Cs(U) && (U = n), Cs(y) ? t2(y, To(E, 1, Cs, !0), En(U, 2)) : []
            );
          }),
          kue = nr(function (y, E) {
            var U = sc(E);
            return Cs(U) && (U = n), Cs(y) ? t2(y, To(E, 1, Cs, !0), n, U) : [];
          });
        function Tue(y, E, U) {
          var V = y == null ? 0 : y.length;
          return V
            ? ((E = U || E === n ? 1 : Yn(E)), ic(y, E < 0 ? 0 : E, V))
            : [];
        }
        function Mue(y, E, U) {
          var V = y == null ? 0 : y.length;
          return V
            ? ((E = U || E === n ? 1 : Yn(E)),
              (E = V - E),
              ic(y, 0, E < 0 ? 0 : E))
            : [];
        }
        function Iue(y, E) {
          return y && y.length ? B3(y, En(E, 3), !0, !0) : [];
        }
        function Nue(y, E) {
          return y && y.length ? B3(y, En(E, 3), !0) : [];
        }
        function Rue(y, E, U, V) {
          var X = y == null ? 0 : y.length;
          return X
            ? (U && typeof U != "number" && ma(y, E, U) && ((U = 0), (V = X)),
              Ece(y, E, U, V))
            : [];
        }
        function pD(y, E, U) {
          var V = y == null ? 0 : y.length;
          if (!V) return -1;
          var X = U == null ? 0 : Yn(U);
          return X < 0 && (X = Ks(V + X, 0)), vs(y, En(E, 3), X);
        }
        function mD(y, E, U) {
          var V = y == null ? 0 : y.length;
          if (!V) return -1;
          var X = V - 1;
          return (
            U !== n && ((X = Yn(U)), (X = U < 0 ? Ks(V + X, 0) : Go(X, V - 1))),
            vs(y, En(E, 3), X, !0)
          );
        }
        function gD(y) {
          var E = y == null ? 0 : y.length;
          return E ? To(y, 1) : [];
        }
        function Oue(y) {
          var E = y == null ? 0 : y.length;
          return E ? To(y, L) : [];
        }
        function Pue(y, E) {
          var U = y == null ? 0 : y.length;
          return U ? ((E = E === n ? 1 : Yn(E)), To(y, E)) : [];
        }
        function Lue(y) {
          for (var E = -1, U = y == null ? 0 : y.length, V = {}; ++E < U; ) {
            var X = y[E];
            V[X[0]] = X[1];
          }
          return V;
        }
        function yD(y) {
          return y && y.length ? y[0] : n;
        }
        function jue(y, E, U) {
          var V = y == null ? 0 : y.length;
          if (!V) return -1;
          var X = U == null ? 0 : Yn(U);
          return X < 0 && (X = Ks(V + X, 0)), Ni(y, E, X);
        }
        function Due(y) {
          var E = y == null ? 0 : y.length;
          return E ? ic(y, 0, -1) : [];
        }
        var Bue = nr(function (y) {
            var E = Ze(y, C9);
            return E.length && E[0] === y[0] ? g9(E) : [];
          }),
          Fue = nr(function (y) {
            var E = sc(y),
              U = Ze(y, C9);
            return (
              E === sc(U) ? (E = n) : U.pop(),
              U.length && U[0] === y[0] ? g9(U, En(E, 2)) : []
            );
          }),
          Uue = nr(function (y) {
            var E = sc(y),
              U = Ze(y, C9);
            return (
              (E = typeof E == "function" ? E : n),
              E && U.pop(),
              U.length && U[0] === y[0] ? g9(U, n, E) : []
            );
          });
        function $ue(y, E) {
          return y == null ? "" : Dle.call(y, E);
        }
        function sc(y) {
          var E = y == null ? 0 : y.length;
          return E ? y[E - 1] : n;
        }
        function zue(y, E, U) {
          var V = y == null ? 0 : y.length;
          if (!V) return -1;
          var X = V;
          return (
            U !== n && ((X = Yn(U)), (X = X < 0 ? Ks(V + X, 0) : Go(X, V - 1))),
            E === E ? xle(y, E, X) : vs(y, Fh, X, !0)
          );
        }
        function Wue(y, E) {
          return y && y.length ? Tj(y, Yn(E)) : n;
        }
        var Hue = nr(vD);
        function vD(y, E) {
          return y && y.length && E && E.length ? b9(y, E) : y;
        }
        function Vue(y, E, U) {
          return y && y.length && E && E.length ? b9(y, E, En(U, 2)) : y;
        }
        function Gue(y, E, U) {
          return y && y.length && E && E.length ? b9(y, E, n, U) : y;
        }
        var que = cf(function (y, E) {
          var U = y == null ? 0 : y.length,
            V = f9(y, E);
          return (
            Nj(
              y,
              Ze(E, function (X) {
                return uf(X, U) ? +X : X;
              }).sort($j)
            ),
            V
          );
        });
        function Kue(y, E) {
          var U = [];
          if (!(y && y.length)) return U;
          var V = -1,
            X = [],
            te = y.length;
          for (E = En(E, 3); ++V < te; ) {
            var ue = y[V];
            E(ue, V, y) && (U.push(ue), X.push(V));
          }
          return Nj(y, X), U;
        }
        function U9(y) {
          return y == null ? y : $le.call(y);
        }
        function Yue(y, E, U) {
          var V = y == null ? 0 : y.length;
          return V
            ? (U && typeof U != "number" && ma(y, E, U)
                ? ((E = 0), (U = V))
                : ((E = E == null ? 0 : Yn(E)), (U = U === n ? V : Yn(U))),
              ic(y, E, U))
            : [];
        }
        function Zue(y, E) {
          return D3(y, E);
        }
        function Que(y, E, U) {
          return S9(y, E, En(U, 2));
        }
        function Xue(y, E) {
          var U = y == null ? 0 : y.length;
          if (U) {
            var V = D3(y, E);
            if (V < U && Xc(y[V], E)) return V;
          }
          return -1;
        }
        function Jue(y, E) {
          return D3(y, E, !0);
        }
        function ede(y, E, U) {
          return S9(y, E, En(U, 2), !0);
        }
        function tde(y, E) {
          var U = y == null ? 0 : y.length;
          if (U) {
            var V = D3(y, E, !0) - 1;
            if (Xc(y[V], E)) return V;
          }
          return -1;
        }
        function nde(y) {
          return y && y.length ? Oj(y) : [];
        }
        function rde(y, E) {
          return y && y.length ? Oj(y, En(E, 2)) : [];
        }
        function ide(y) {
          var E = y == null ? 0 : y.length;
          return E ? ic(y, 1, E) : [];
        }
        function sde(y, E, U) {
          return y && y.length
            ? ((E = U || E === n ? 1 : Yn(E)), ic(y, 0, E < 0 ? 0 : E))
            : [];
        }
        function ode(y, E, U) {
          var V = y == null ? 0 : y.length;
          return V
            ? ((E = U || E === n ? 1 : Yn(E)),
              (E = V - E),
              ic(y, E < 0 ? 0 : E, V))
            : [];
        }
        function ade(y, E) {
          return y && y.length ? B3(y, En(E, 3), !1, !0) : [];
        }
        function lde(y, E) {
          return y && y.length ? B3(y, En(E, 3)) : [];
        }
        var cde = nr(function (y) {
            return Wh(To(y, 1, Cs, !0));
          }),
          ude = nr(function (y) {
            var E = sc(y);
            return Cs(E) && (E = n), Wh(To(y, 1, Cs, !0), En(E, 2));
          }),
          dde = nr(function (y) {
            var E = sc(y);
            return (
              (E = typeof E == "function" ? E : n), Wh(To(y, 1, Cs, !0), n, E)
            );
          });
        function fde(y) {
          return y && y.length ? Wh(y) : [];
        }
        function hde(y, E) {
          return y && y.length ? Wh(y, En(E, 2)) : [];
        }
        function pde(y, E) {
          return (
            (E = typeof E == "function" ? E : n),
            y && y.length ? Wh(y, n, E) : []
          );
        }
        function $9(y) {
          if (!(y && y.length)) return [];
          var E = 0;
          return (
            (y = ye(y, function (U) {
              if (Cs(U)) return (E = Ks(U.length, E)), !0;
            })),
            i9(E, function (U) {
              return Ze(y, pl(U));
            })
          );
        }
        function wD(y, E) {
          if (!(y && y.length)) return [];
          var U = $9(y);
          return E == null
            ? U
            : Ze(U, function (V) {
                return Co(E, n, V);
              });
        }
        var mde = nr(function (y, E) {
            return Cs(y) ? t2(y, E) : [];
          }),
          gde = nr(function (y) {
            return A9(ye(y, Cs));
          }),
          yde = nr(function (y) {
            var E = sc(y);
            return Cs(E) && (E = n), A9(ye(y, Cs), En(E, 2));
          }),
          vde = nr(function (y) {
            var E = sc(y);
            return (E = typeof E == "function" ? E : n), A9(ye(y, Cs), n, E);
          }),
          wde = nr($9);
        function bde(y, E) {
          return Dj(y || [], E || [], e2);
        }
        function xde(y, E) {
          return Dj(y || [], E || [], i2);
        }
        var _de = nr(function (y) {
          var E = y.length,
            U = E > 1 ? y[E - 1] : n;
          return (U = typeof U == "function" ? (y.pop(), U) : n), wD(y, U);
        });
        function bD(y) {
          var E = J(y);
          return (E.__chain__ = !0), E;
        }
        function Sde(y, E) {
          return E(y), y;
        }
        function q3(y, E) {
          return E(y);
        }
        var Ede = cf(function (y) {
          var E = y.length,
            U = E ? y[0] : 0,
            V = this.__wrapped__,
            X = function (te) {
              return f9(te, y);
            };
          return E > 1 ||
            this.__actions__.length ||
            !(V instanceof xr) ||
            !uf(U)
            ? this.thru(X)
            : ((V = V.slice(U, +U + (E ? 1 : 0))),
              V.__actions__.push({ func: q3, args: [X], thisArg: n }),
              new nc(V, this.__chain__).thru(function (te) {
                return E && !te.length && te.push(n), te;
              }));
        });
        function Ade() {
          return bD(this);
        }
        function Cde() {
          return new nc(this.value(), this.__chain__);
        }
        function kde() {
          this.__values__ === n && (this.__values__ = PD(this.value()));
          var y = this.__index__ >= this.__values__.length,
            E = y ? n : this.__values__[this.__index__++];
          return { done: y, value: E };
        }
        function Tde() {
          return this;
        }
        function Mde(y) {
          for (var E, U = this; U instanceof R3; ) {
            var V = hD(U);
            (V.__index__ = 0),
              (V.__values__ = n),
              E ? (X.__wrapped__ = V) : (E = V);
            var X = V;
            U = U.__wrapped__;
          }
          return (X.__wrapped__ = y), E;
        }
        function Ide() {
          var y = this.__wrapped__;
          if (y instanceof xr) {
            var E = y;
            return (
              this.__actions__.length && (E = new xr(this)),
              (E = E.reverse()),
              E.__actions__.push({ func: q3, args: [U9], thisArg: n }),
              new nc(E, this.__chain__)
            );
          }
          return this.thru(U9);
        }
        function Nde() {
          return jj(this.__wrapped__, this.__actions__);
        }
        var Rde = F3(function (y, E, U) {
          oi.call(y, U) ? ++y[U] : af(y, U, 1);
        });
        function Ode(y, E, U) {
          var V = Fn(y) ? se : Sce;
          return U && ma(y, E, U) && (E = n), V(y, En(E, 3));
        }
        function Pde(y, E) {
          var U = Fn(y) ? ye : wj;
          return U(y, En(E, 3));
        }
        var Lde = qj(pD),
          jde = qj(mD);
        function Dde(y, E) {
          return To(K3(y, E), 1);
        }
        function Bde(y, E) {
          return To(K3(y, E), L);
        }
        function Fde(y, E, U) {
          return (U = U === n ? 1 : Yn(U)), To(K3(y, E), U);
        }
        function xD(y, E) {
          var U = Fn(y) ? W : zh;
          return U(y, En(E, 3));
        }
        function _D(y, E) {
          var U = Fn(y) ? Z : vj;
          return U(y, En(E, 3));
        }
        var Ude = F3(function (y, E, U) {
          oi.call(y, U) ? y[U].push(E) : af(y, U, [E]);
        });
        function $de(y, E, U, V) {
          (y = Fa(y) ? y : F1(y)), (U = U && !V ? Yn(U) : 0);
          var X = y.length;
          return (
            U < 0 && (U = Ks(X + U, 0)),
            J3(y) ? U <= X && y.indexOf(E, U) > -1 : !!X && Ni(y, E, U) > -1
          );
        }
        var zde = nr(function (y, E, U) {
            var V = -1,
              X = typeof E == "function",
              te = Fa(y) ? Ne(y.length) : [];
            return (
              zh(y, function (ue) {
                te[++V] = X ? Co(E, ue, U) : n2(ue, E, U);
              }),
              te
            );
          }),
          Wde = F3(function (y, E, U) {
            af(y, U, E);
          });
        function K3(y, E) {
          var U = Fn(y) ? Ze : Aj;
          return U(y, En(E, 3));
        }
        function Hde(y, E, U, V) {
          return y == null
            ? []
            : (Fn(E) || (E = E == null ? [] : [E]),
              (U = V ? n : U),
              Fn(U) || (U = U == null ? [] : [U]),
              Mj(y, E, U));
        }
        var Vde = F3(
          function (y, E, U) {
            y[U ? 0 : 1].push(E);
          },
          function () {
            return [[], []];
          }
        );
        function Gde(y, E, U) {
          var V = Fn(y) ? fn : JL,
            X = arguments.length < 3;
          return V(y, En(E, 4), U, X, zh);
        }
        function qde(y, E, U) {
          var V = Fn(y) ? ur : JL,
            X = arguments.length < 3;
          return V(y, En(E, 4), U, X, vj);
        }
        function Kde(y, E) {
          var U = Fn(y) ? ye : wj;
          return U(y, Q3(En(E, 3)));
        }
        function Yde(y) {
          var E = Fn(y) ? pj : $ce;
          return E(y);
        }
        function Zde(y, E, U) {
          (U ? ma(y, E, U) : E === n) ? (E = 1) : (E = Yn(E));
          var V = Fn(y) ? vce : zce;
          return V(y, E);
        }
        function Qde(y) {
          var E = Fn(y) ? wce : Hce;
          return E(y);
        }
        function Xde(y) {
          if (y == null) return 0;
          if (Fa(y)) return J3(y) ? M1(y) : y.length;
          var E = qo(y);
          return E == je || E == Qe ? y.size : v9(y).length;
        }
        function Jde(y, E, U) {
          var V = Fn(y) ? Kn : Vce;
          return U && ma(y, E, U) && (E = n), V(y, En(E, 3));
        }
        var efe = nr(function (y, E) {
            if (y == null) return [];
            var U = E.length;
            return (
              U > 1 && ma(y, E[0], E[1])
                ? (E = [])
                : U > 2 && ma(E[0], E[1], E[2]) && (E = [E[0]]),
              Mj(y, To(E, 1), [])
            );
          }),
          Y3 =
            Ple ||
            function () {
              return dn.Date.now();
            };
        function tfe(y, E) {
          if (typeof E != "function") throw new tc(o);
          return (
            (y = Yn(y)),
            function () {
              if (--y < 1) return E.apply(this, arguments);
            }
          );
        }
        function SD(y, E, U) {
          return (
            (E = U ? n : E),
            (E = y && E == null ? y.length : E),
            lf(y, B, n, n, n, n, E)
          );
        }
        function ED(y, E) {
          var U;
          if (typeof E != "function") throw new tc(o);
          return (
            (y = Yn(y)),
            function () {
              return (
                --y > 0 && (U = E.apply(this, arguments)), y <= 1 && (E = n), U
              );
            }
          );
        }
        var z9 = nr(function (y, E, U) {
            var V = b;
            if (U.length) {
              var X = Uh(U, D1(z9));
              V |= R;
            }
            return lf(y, V, E, U, X);
          }),
          AD = nr(function (y, E, U) {
            var V = b | v;
            if (U.length) {
              var X = Uh(U, D1(AD));
              V |= R;
            }
            return lf(E, V, y, U, X);
          });
        function CD(y, E, U) {
          E = U ? n : E;
          var V = lf(y, x, n, n, n, n, n, E);
          return (V.placeholder = CD.placeholder), V;
        }
        function kD(y, E, U) {
          E = U ? n : E;
          var V = lf(y, S, n, n, n, n, n, E);
          return (V.placeholder = kD.placeholder), V;
        }
        function TD(y, E, U) {
          var V,
            X,
            te,
            ue,
            he,
            xe,
            Ge = 0,
            qe = !1,
            et = !1,
            St = !0;
          if (typeof y != "function") throw new tc(o);
          (E = oc(E) || 0),
            ss(U) &&
              ((qe = !!U.leading),
              (et = "maxWait" in U),
              (te = et ? Ks(oc(U.maxWait) || 0, E) : te),
              (St = "trailing" in U ? !!U.trailing : St));
          function en(ks) {
            var Jc = V,
              hf = X;
            return (V = X = n), (Ge = ks), (ue = y.apply(hf, Jc)), ue;
          }
          function kn(ks) {
            return (Ge = ks), (he = a2(mr, E)), qe ? en(ks) : ue;
          }
          function Qn(ks) {
            var Jc = ks - xe,
              hf = ks - Ge,
              qD = E - Jc;
            return et ? Go(qD, te - hf) : qD;
          }
          function Tn(ks) {
            var Jc = ks - xe,
              hf = ks - Ge;
            return xe === n || Jc >= E || Jc < 0 || (et && hf >= te);
          }
          function mr() {
            var ks = Y3();
            if (Tn(ks)) return Cr(ks);
            he = a2(mr, Qn(ks));
          }
          function Cr(ks) {
            return (he = n), St && V ? en(ks) : ((V = X = n), ue);
          }
          function vl() {
            he !== n && Bj(he), (Ge = 0), (V = xe = X = he = n);
          }
          function ga() {
            return he === n ? ue : Cr(Y3());
          }
          function wl() {
            var ks = Y3(),
              Jc = Tn(ks);
            if (((V = arguments), (X = this), (xe = ks), Jc)) {
              if (he === n) return kn(xe);
              if (et) return Bj(he), (he = a2(mr, E)), en(xe);
            }
            return he === n && (he = a2(mr, E)), ue;
          }
          return (wl.cancel = vl), (wl.flush = ga), wl;
        }
        var nfe = nr(function (y, E) {
            return yj(y, 1, E);
          }),
          rfe = nr(function (y, E, U) {
            return yj(y, oc(E) || 0, U);
          });
        function ife(y) {
          return lf(y, I);
        }
        function Z3(y, E) {
          if (typeof y != "function" || (E != null && typeof E != "function"))
            throw new tc(o);
          var U = function () {
            var V = arguments,
              X = E ? E.apply(this, V) : V[0],
              te = U.cache;
            if (te.has(X)) return te.get(X);
            var ue = y.apply(this, V);
            return (U.cache = te.set(X, ue) || te), ue;
          };
          return (U.cache = new (Z3.Cache || of)()), U;
        }
        Z3.Cache = of;
        function Q3(y) {
          if (typeof y != "function") throw new tc(o);
          return function () {
            var E = arguments;
            switch (E.length) {
              case 0:
                return !y.call(this);
              case 1:
                return !y.call(this, E[0]);
              case 2:
                return !y.call(this, E[0], E[1]);
              case 3:
                return !y.call(this, E[0], E[1], E[2]);
            }
            return !y.apply(this, E);
          };
        }
        function sfe(y) {
          return ED(2, y);
        }
        var ofe = Gce(function (y, E) {
            E =
              E.length == 1 && Fn(E[0])
                ? Ze(E[0], ml(En()))
                : Ze(To(E, 1), ml(En()));
            var U = E.length;
            return nr(function (V) {
              for (var X = -1, te = Go(V.length, U); ++X < te; )
                V[X] = E[X].call(this, V[X]);
              return Co(y, this, V);
            });
          }),
          W9 = nr(function (y, E) {
            var U = Uh(E, D1(W9));
            return lf(y, R, n, E, U);
          }),
          MD = nr(function (y, E) {
            var U = Uh(E, D1(MD));
            return lf(y, O, n, E, U);
          }),
          afe = cf(function (y, E) {
            return lf(y, C, n, n, n, E);
          });
        function lfe(y, E) {
          if (typeof y != "function") throw new tc(o);
          return (E = E === n ? E : Yn(E)), nr(y, E);
        }
        function cfe(y, E) {
          if (typeof y != "function") throw new tc(o);
          return (
            (E = E == null ? 0 : Ks(Yn(E), 0)),
            nr(function (U) {
              var V = U[E],
                X = Vh(U, 0, E);
              return V && yn(X, V), Co(y, this, X);
            })
          );
        }
        function ufe(y, E, U) {
          var V = !0,
            X = !0;
          if (typeof y != "function") throw new tc(o);
          return (
            ss(U) &&
              ((V = "leading" in U ? !!U.leading : V),
              (X = "trailing" in U ? !!U.trailing : X)),
            TD(y, E, { leading: V, maxWait: E, trailing: X })
          );
        }
        function dfe(y) {
          return SD(y, 1);
        }
        function ffe(y, E) {
          return W9(k9(E), y);
        }
        function hfe() {
          if (!arguments.length) return [];
          var y = arguments[0];
          return Fn(y) ? y : [y];
        }
        function pfe(y) {
          return rc(y, h);
        }
        function mfe(y, E) {
          return (E = typeof E == "function" ? E : n), rc(y, h, E);
        }
        function gfe(y) {
          return rc(y, d | h);
        }
        function yfe(y, E) {
          return (E = typeof E == "function" ? E : n), rc(y, d | h, E);
        }
        function vfe(y, E) {
          return E == null || gj(y, E, uo(E));
        }
        function Xc(y, E) {
          return y === E || (y !== y && E !== E);
        }
        var wfe = W3(m9),
          bfe = W3(function (y, E) {
            return y >= E;
          }),
          R0 = _j(
            (function () {
              return arguments;
            })()
          )
            ? _j
            : function (y) {
                return ws(y) && oi.call(y, "callee") && !lj.call(y, "callee");
              },
          Fn = Ne.isArray,
          xfe = Jl ? ml(Jl) : Mce;
        function Fa(y) {
          return y != null && X3(y.length) && !df(y);
        }
        function Cs(y) {
          return ws(y) && Fa(y);
        }
        function _fe(y) {
          return y === !0 || y === !1 || (ws(y) && pa(y) == le);
        }
        var Gh = jle || eA,
          Sfe = nf ? ml(nf) : Ice;
        function Efe(y) {
          return ws(y) && y.nodeType === 1 && !l2(y);
        }
        function Afe(y) {
          if (y == null) return !0;
          if (
            Fa(y) &&
            (Fn(y) ||
              typeof y == "string" ||
              typeof y.splice == "function" ||
              Gh(y) ||
              B1(y) ||
              R0(y))
          )
            return !y.length;
          var E = qo(y);
          if (E == je || E == Qe) return !y.size;
          if (o2(y)) return !v9(y).length;
          for (var U in y) if (oi.call(y, U)) return !1;
          return !0;
        }
        function Cfe(y, E) {
          return r2(y, E);
        }
        function kfe(y, E, U) {
          U = typeof U == "function" ? U : n;
          var V = U ? U(y, E) : n;
          return V === n ? r2(y, E, n, U) : !!V;
        }
        function H9(y) {
          if (!ws(y)) return !1;
          var E = pa(y);
          return (
            E == _e ||
            E == Oe ||
            (typeof y.message == "string" &&
              typeof y.name == "string" &&
              !l2(y))
          );
        }
        function Tfe(y) {
          return typeof y == "number" && uj(y);
        }
        function df(y) {
          if (!ss(y)) return !1;
          var E = pa(y);
          return E == Ee || E == He || E == ae || E == an;
        }
        function ID(y) {
          return typeof y == "number" && y == Yn(y);
        }
        function X3(y) {
          return typeof y == "number" && y > -1 && y % 1 == 0 && y <= F;
        }
        function ss(y) {
          var E = typeof y;
          return y != null && (E == "object" || E == "function");
        }
        function ws(y) {
          return y != null && typeof y == "object";
        }
        var ND = C1 ? ml(C1) : Rce;
        function Mfe(y, E) {
          return y === E || y9(y, E, P9(E));
        }
        function Ife(y, E, U) {
          return (U = typeof U == "function" ? U : n), y9(y, E, P9(E), U);
        }
        function Nfe(y) {
          return RD(y) && y != +y;
        }
        function Rfe(y) {
          if (mue(y)) throw new Dn(s);
          return Sj(y);
        }
        function Ofe(y) {
          return y === null;
        }
        function Pfe(y) {
          return y == null;
        }
        function RD(y) {
          return typeof y == "number" || (ws(y) && pa(y) == Be);
        }
        function l2(y) {
          if (!ws(y) || pa(y) != Wt) return !1;
          var E = A3(y);
          if (E === null) return !0;
          var U = oi.call(E, "constructor") && E.constructor;
          return typeof U == "function" && U instanceof U && x3.call(U) == Ile;
        }
        var V9 = k1 ? ml(k1) : Oce;
        function Lfe(y) {
          return ID(y) && y >= -F && y <= F;
        }
        var OD = Bh ? ml(Bh) : Pce;
        function J3(y) {
          return typeof y == "string" || (!Fn(y) && ws(y) && pa(y) == Vt);
        }
        function yl(y) {
          return typeof y == "symbol" || (ws(y) && pa(y) == Rt);
        }
        var B1 = rf ? ml(rf) : Lce;
        function jfe(y) {
          return y === n;
        }
        function Dfe(y) {
          return ws(y) && qo(y) == Pt;
        }
        function Bfe(y) {
          return ws(y) && pa(y) == wn;
        }
        var Ffe = W3(w9),
          Ufe = W3(function (y, E) {
            return y <= E;
          });
        function PD(y) {
          if (!y) return [];
          if (Fa(y)) return J3(y) ? Zc(y) : Ba(y);
          if (Yv && y[Yv]) return vle(y[Yv]());
          var E = qo(y),
            U = E == je ? o9 : E == Qe ? v3 : F1;
          return U(y);
        }
        function ff(y) {
          if (!y) return y === 0 ? y : 0;
          if (((y = oc(y)), y === L || y === -L)) {
            var E = y < 0 ? -1 : 1;
            return E * D;
          }
          return y === y ? y : 0;
        }
        function Yn(y) {
          var E = ff(y),
            U = E % 1;
          return E === E ? (U ? E - U : E) : 0;
        }
        function LD(y) {
          return y ? T0(Yn(y), 0, z) : 0;
        }
        function oc(y) {
          if (typeof y == "number") return y;
          if (yl(y)) return j;
          if (ss(y)) {
            var E = typeof y.valueOf == "function" ? y.valueOf() : y;
            y = ss(E) ? E + "" : E;
          }
          if (typeof y != "string") return y === 0 ? y : +y;
          y = ej(y);
          var U = Rn.test(y);
          return U || Sn.test(y)
            ? Wn(y.slice(2), U ? 2 : 8)
            : un.test(y)
            ? j
            : +y;
        }
        function jD(y) {
          return Wu(y, Ua(y));
        }
        function $fe(y) {
          return y ? T0(Yn(y), -F, F) : y === 0 ? y : 0;
        }
        function ei(y) {
          return y == null ? "" : gl(y);
        }
        var zfe = L1(function (y, E) {
            if (o2(E) || Fa(E)) {
              Wu(E, uo(E), y);
              return;
            }
            for (var U in E) oi.call(E, U) && e2(y, U, E[U]);
          }),
          DD = L1(function (y, E) {
            Wu(E, Ua(E), y);
          }),
          e_ = L1(function (y, E, U, V) {
            Wu(E, Ua(E), y, V);
          }),
          Wfe = L1(function (y, E, U, V) {
            Wu(E, uo(E), y, V);
          }),
          Hfe = cf(f9);
        function Vfe(y, E) {
          var U = P1(y);
          return E == null ? U : mj(U, E);
        }
        var Gfe = nr(function (y, E) {
            y = Ci(y);
            var U = -1,
              V = E.length,
              X = V > 2 ? E[2] : n;
            for (X && ma(E[0], E[1], X) && (V = 1); ++U < V; )
              for (
                var te = E[U], ue = Ua(te), he = -1, xe = ue.length;
                ++he < xe;

              ) {
                var Ge = ue[he],
                  qe = y[Ge];
                (qe === n || (Xc(qe, N1[Ge]) && !oi.call(y, Ge))) &&
                  (y[Ge] = te[Ge]);
              }
            return y;
          }),
          qfe = nr(function (y) {
            return y.push(n, eD), Co(BD, n, y);
          });
        function Kfe(y, E) {
          return mi(y, En(E, 3), zu);
        }
        function Yfe(y, E) {
          return mi(y, En(E, 3), p9);
        }
        function Zfe(y, E) {
          return y == null ? y : h9(y, En(E, 3), Ua);
        }
        function Qfe(y, E) {
          return y == null ? y : bj(y, En(E, 3), Ua);
        }
        function Xfe(y, E) {
          return y && zu(y, En(E, 3));
        }
        function Jfe(y, E) {
          return y && p9(y, En(E, 3));
        }
        function ehe(y) {
          return y == null ? [] : L3(y, uo(y));
        }
        function the(y) {
          return y == null ? [] : L3(y, Ua(y));
        }
        function G9(y, E, U) {
          var V = y == null ? n : M0(y, E);
          return V === n ? U : V;
        }
        function nhe(y, E) {
          return y != null && rD(y, E, Ace);
        }
        function q9(y, E) {
          return y != null && rD(y, E, Cce);
        }
        var rhe = Yj(function (y, E, U) {
            E != null && typeof E.toString != "function" && (E = _3.call(E)),
              (y[E] = U);
          }, Y9($a)),
          ihe = Yj(function (y, E, U) {
            E != null && typeof E.toString != "function" && (E = _3.call(E)),
              oi.call(y, E) ? y[E].push(U) : (y[E] = [U]);
          }, En),
          she = nr(n2);
        function uo(y) {
          return Fa(y) ? hj(y) : v9(y);
        }
        function Ua(y) {
          return Fa(y) ? hj(y, !0) : jce(y);
        }
        function ohe(y, E) {
          var U = {};
          return (
            (E = En(E, 3)),
            zu(y, function (V, X, te) {
              af(U, E(V, X, te), V);
            }),
            U
          );
        }
        function ahe(y, E) {
          var U = {};
          return (
            (E = En(E, 3)),
            zu(y, function (V, X, te) {
              af(U, X, E(V, X, te));
            }),
            U
          );
        }
        var lhe = L1(function (y, E, U) {
            j3(y, E, U);
          }),
          BD = L1(function (y, E, U, V) {
            j3(y, E, U, V);
          }),
          che = cf(function (y, E) {
            var U = {};
            if (y == null) return U;
            var V = !1;
            (E = Ze(E, function (te) {
              return (te = Hh(te, y)), V || (V = te.length > 1), te;
            })),
              Wu(y, R9(y), U),
              V && (U = rc(U, d | f | h, rue));
            for (var X = E.length; X--; ) E9(U, E[X]);
            return U;
          });
        function uhe(y, E) {
          return FD(y, Q3(En(E)));
        }
        var dhe = cf(function (y, E) {
          return y == null ? {} : Bce(y, E);
        });
        function FD(y, E) {
          if (y == null) return {};
          var U = Ze(R9(y), function (V) {
            return [V];
          });
          return (
            (E = En(E)),
            Ij(y, U, function (V, X) {
              return E(V, X[0]);
            })
          );
        }
        function fhe(y, E, U) {
          E = Hh(E, y);
          var V = -1,
            X = E.length;
          for (X || ((X = 1), (y = n)); ++V < X; ) {
            var te = y == null ? n : y[Hu(E[V])];
            te === n && ((V = X), (te = U)), (y = df(te) ? te.call(y) : te);
          }
          return y;
        }
        function hhe(y, E, U) {
          return y == null ? y : i2(y, E, U);
        }
        function phe(y, E, U, V) {
          return (
            (V = typeof V == "function" ? V : n), y == null ? y : i2(y, E, U, V)
          );
        }
        var UD = Xj(uo),
          $D = Xj(Ua);
        function mhe(y, E, U) {
          var V = Fn(y),
            X = V || Gh(y) || B1(y);
          if (((E = En(E, 4)), U == null)) {
            var te = y && y.constructor;
            X
              ? (U = V ? new te() : [])
              : ss(y)
              ? (U = df(te) ? P1(A3(y)) : {})
              : (U = {});
          }
          return (
            (X ? W : zu)(y, function (ue, he, xe) {
              return E(U, ue, he, xe);
            }),
            U
          );
        }
        function ghe(y, E) {
          return y == null ? !0 : E9(y, E);
        }
        function yhe(y, E, U) {
          return y == null ? y : Lj(y, E, k9(U));
        }
        function vhe(y, E, U, V) {
          return (
            (V = typeof V == "function" ? V : n),
            y == null ? y : Lj(y, E, k9(U), V)
          );
        }
        function F1(y) {
          return y == null ? [] : s9(y, uo(y));
        }
        function whe(y) {
          return y == null ? [] : s9(y, Ua(y));
        }
        function bhe(y, E, U) {
          return (
            U === n && ((U = E), (E = n)),
            U !== n && ((U = oc(U)), (U = U === U ? U : 0)),
            E !== n && ((E = oc(E)), (E = E === E ? E : 0)),
            T0(oc(y), E, U)
          );
        }
        function xhe(y, E, U) {
          return (
            (E = ff(E)),
            U === n ? ((U = E), (E = 0)) : (U = ff(U)),
            (y = oc(y)),
            kce(y, E, U)
          );
        }
        function _he(y, E, U) {
          if (
            (U && typeof U != "boolean" && ma(y, E, U) && (E = U = n),
            U === n &&
              (typeof E == "boolean"
                ? ((U = E), (E = n))
                : typeof y == "boolean" && ((U = y), (y = n))),
            y === n && E === n
              ? ((y = 0), (E = 1))
              : ((y = ff(y)), E === n ? ((E = y), (y = 0)) : (E = ff(E))),
            y > E)
          ) {
            var V = y;
            (y = E), (E = V);
          }
          if (U || y % 1 || E % 1) {
            var X = dj();
            return Go(y + X * (E - y + jt("1e-" + ((X + "").length - 1))), E);
          }
          return x9(y, E);
        }
        var She = j1(function (y, E, U) {
          return (E = E.toLowerCase()), y + (U ? zD(E) : E);
        });
        function zD(y) {
          return K9(ei(y).toLowerCase());
        }
        function WD(y) {
          return (y = ei(y)), y && y.replace(vr, hle).replace(Ps, "");
        }
        function Ehe(y, E, U) {
          (y = ei(y)), (E = gl(E));
          var V = y.length;
          U = U === n ? V : T0(Yn(U), 0, V);
          var X = U;
          return (U -= E.length), U >= 0 && y.slice(U, X) == E;
        }
        function Ahe(y) {
          return (y = ei(y)), y && jn.test(y) ? y.replace(Ht, ple) : y;
        }
        function Che(y) {
          return (y = ei(y)), y && be.test(y) ? y.replace(de, "\\$&") : y;
        }
        var khe = j1(function (y, E, U) {
            return y + (U ? "-" : "") + E.toLowerCase();
          }),
          The = j1(function (y, E, U) {
            return y + (U ? " " : "") + E.toLowerCase();
          }),
          Mhe = Gj("toLowerCase");
        function Ihe(y, E, U) {
          (y = ei(y)), (E = Yn(E));
          var V = E ? M1(y) : 0;
          if (!E || V >= E) return y;
          var X = (E - V) / 2;
          return z3(M3(X), U) + y + z3(T3(X), U);
        }
        function Nhe(y, E, U) {
          (y = ei(y)), (E = Yn(E));
          var V = E ? M1(y) : 0;
          return E && V < E ? y + z3(E - V, U) : y;
        }
        function Rhe(y, E, U) {
          (y = ei(y)), (E = Yn(E));
          var V = E ? M1(y) : 0;
          return E && V < E ? z3(E - V, U) + y : y;
        }
        function Ohe(y, E, U) {
          return (
            U || E == null ? (E = 0) : E && (E = +E),
            Ule(ei(y).replace(Me, ""), E || 0)
          );
        }
        function Phe(y, E, U) {
          return (
            (U ? ma(y, E, U) : E === n) ? (E = 1) : (E = Yn(E)), _9(ei(y), E)
          );
        }
        function Lhe() {
          var y = arguments,
            E = ei(y[0]);
          return y.length < 3 ? E : E.replace(y[1], y[2]);
        }
        var jhe = j1(function (y, E, U) {
          return y + (U ? "_" : "") + E.toLowerCase();
        });
        function Dhe(y, E, U) {
          return (
            U && typeof U != "number" && ma(y, E, U) && (E = U = n),
            (U = U === n ? z : U >>> 0),
            U
              ? ((y = ei(y)),
                y &&
                (typeof E == "string" || (E != null && !V9(E))) &&
                ((E = gl(E)), !E && T1(y))
                  ? Vh(Zc(y), 0, U)
                  : y.split(E, U))
              : []
          );
        }
        var Bhe = j1(function (y, E, U) {
          return y + (U ? " " : "") + K9(E);
        });
        function Fhe(y, E, U) {
          return (
            (y = ei(y)),
            (U = U == null ? 0 : T0(Yn(U), 0, y.length)),
            (E = gl(E)),
            y.slice(U, U + E.length) == E
          );
        }
        function Uhe(y, E, U) {
          var V = J.templateSettings;
          U && ma(y, E, U) && (E = n), (y = ei(y)), (E = e_({}, E, V, Jj));
          var X = e_({}, E.imports, V.imports, Jj),
            te = uo(X),
            ue = s9(X, te),
            he,
            xe,
            Ge = 0,
            qe = E.interpolate || pi,
            et = "__p += '",
            St = a9(
              (E.escape || pi).source +
                "|" +
                qe.source +
                "|" +
                (qe === cn ? bt : pi).source +
                "|" +
                (E.evaluate || pi).source +
                "|$",
              "g"
            ),
            en =
              "//# sourceURL=" +
              (oi.call(E, "sourceURL")
                ? (E.sourceURL + "").replace(/\s/g, " ")
                : "lodash.templateSources[" + ++Dh + "]") +
              `
`;
          y.replace(St, function (Tn, mr, Cr, vl, ga, wl) {
            return (
              Cr || (Cr = vl),
              (et += y.slice(Ge, wl).replace(ii, mle)),
              mr &&
                ((he = !0),
                (et +=
                  `' +
__e(` +
                  mr +
                  `) +
'`)),
              ga &&
                ((xe = !0),
                (et +=
                  `';
` +
                  ga +
                  `;
__p += '`)),
              Cr &&
                (et +=
                  `' +
((__t = (` +
                  Cr +
                  `)) == null ? '' : __t) +
'`),
              (Ge = wl + Tn.length),
              Tn
            );
          }),
            (et += `';
`);
          var kn = oi.call(E, "variable") && E.variable;
          if (!kn)
            et =
              `with (obj) {
` +
              et +
              `
}
`;
          else if (Xe.test(kn)) throw new Dn(a);
          (et = (xe ? et.replace(vt, "") : et)
            .replace(ct, "$1")
            .replace(Lt, "$1;")),
            (et =
              "function(" +
              (kn || "obj") +
              `) {
` +
              (kn
                ? ""
                : `obj || (obj = {});
`) +
              "var __t, __p = ''" +
              (he ? ", __e = _.escape" : "") +
              (xe
                ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
`
                : `;
`) +
              et +
              `return __p
}`);
          var Qn = VD(function () {
            return Xr(te, en + "return " + et).apply(n, ue);
          });
          if (((Qn.source = et), H9(Qn))) throw Qn;
          return Qn;
        }
        function $he(y) {
          return ei(y).toLowerCase();
        }
        function zhe(y) {
          return ei(y).toUpperCase();
        }
        function Whe(y, E, U) {
          if (((y = ei(y)), y && (U || E === n))) return ej(y);
          if (!y || !(E = gl(E))) return y;
          var V = Zc(y),
            X = Zc(E),
            te = tj(V, X),
            ue = nj(V, X) + 1;
          return Vh(V, te, ue).join("");
        }
        function Hhe(y, E, U) {
          if (((y = ei(y)), y && (U || E === n))) return y.slice(0, ij(y) + 1);
          if (!y || !(E = gl(E))) return y;
          var V = Zc(y),
            X = nj(V, Zc(E)) + 1;
          return Vh(V, 0, X).join("");
        }
        function Vhe(y, E, U) {
          if (((y = ei(y)), y && (U || E === n))) return y.replace(Me, "");
          if (!y || !(E = gl(E))) return y;
          var V = Zc(y),
            X = tj(V, Zc(E));
          return Vh(V, X).join("");
        }
        function Ghe(y, E) {
          var U = P,
            V = M;
          if (ss(E)) {
            var X = "separator" in E ? E.separator : X;
            (U = "length" in E ? Yn(E.length) : U),
              (V = "omission" in E ? gl(E.omission) : V);
          }
          y = ei(y);
          var te = y.length;
          if (T1(y)) {
            var ue = Zc(y);
            te = ue.length;
          }
          if (U >= te) return y;
          var he = U - M1(V);
          if (he < 1) return V;
          var xe = ue ? Vh(ue, 0, he).join("") : y.slice(0, he);
          if (X === n) return xe + V;
          if ((ue && (he += xe.length - he), V9(X))) {
            if (y.slice(he).search(X)) {
              var Ge,
                qe = xe;
              for (
                X.global || (X = a9(X.source, ei(gt.exec(X)) + "g")),
                  X.lastIndex = 0;
                (Ge = X.exec(qe));

              )
                var et = Ge.index;
              xe = xe.slice(0, et === n ? he : et);
            }
          } else if (y.indexOf(gl(X), he) != he) {
            var St = xe.lastIndexOf(X);
            St > -1 && (xe = xe.slice(0, St));
          }
          return xe + V;
        }
        function qhe(y) {
          return (y = ei(y)), y && mn.test(y) ? y.replace(wt, _le) : y;
        }
        var Khe = j1(function (y, E, U) {
            return y + (U ? " " : "") + E.toUpperCase();
          }),
          K9 = Gj("toUpperCase");
        function HD(y, E, U) {
          return (
            (y = ei(y)),
            (E = U ? n : E),
            E === n ? (yle(y) ? Ale(y) : Ai(y)) : y.match(E) || []
          );
        }
        var VD = nr(function (y, E) {
            try {
              return Co(y, n, E);
            } catch (U) {
              return H9(U) ? U : new Dn(U);
            }
          }),
          Yhe = cf(function (y, E) {
            return (
              W(E, function (U) {
                (U = Hu(U)), af(y, U, z9(y[U], y));
              }),
              y
            );
          });
        function Zhe(y) {
          var E = y == null ? 0 : y.length,
            U = En();
          return (
            (y = E
              ? Ze(y, function (V) {
                  if (typeof V[1] != "function") throw new tc(o);
                  return [U(V[0]), V[1]];
                })
              : []),
            nr(function (V) {
              for (var X = -1; ++X < E; ) {
                var te = y[X];
                if (Co(te[0], this, V)) return Co(te[1], this, V);
              }
            })
          );
        }
        function Qhe(y) {
          return _ce(rc(y, d));
        }
        function Y9(y) {
          return function () {
            return y;
          };
        }
        function Xhe(y, E) {
          return y == null || y !== y ? E : y;
        }
        var Jhe = Kj(),
          epe = Kj(!0);
        function $a(y) {
          return y;
        }
        function Z9(y) {
          return Ej(typeof y == "function" ? y : rc(y, d));
        }
        function tpe(y) {
          return Cj(rc(y, d));
        }
        function npe(y, E) {
          return kj(y, rc(E, d));
        }
        var rpe = nr(function (y, E) {
            return function (U) {
              return n2(U, y, E);
            };
          }),
          ipe = nr(function (y, E) {
            return function (U) {
              return n2(y, U, E);
            };
          });
        function Q9(y, E, U) {
          var V = uo(E),
            X = L3(E, V);
          U == null &&
            !(ss(E) && (X.length || !V.length)) &&
            ((U = E), (E = y), (y = this), (X = L3(E, uo(E))));
          var te = !(ss(U) && "chain" in U) || !!U.chain,
            ue = df(y);
          return (
            W(X, function (he) {
              var xe = E[he];
              (y[he] = xe),
                ue &&
                  (y.prototype[he] = function () {
                    var Ge = this.__chain__;
                    if (te || Ge) {
                      var qe = y(this.__wrapped__),
                        et = (qe.__actions__ = Ba(this.__actions__));
                      return (
                        et.push({ func: xe, args: arguments, thisArg: y }),
                        (qe.__chain__ = Ge),
                        qe
                      );
                    }
                    return xe.apply(y, yn([this.value()], arguments));
                  });
            }),
            y
          );
        }
        function spe() {
          return dn._ === this && (dn._ = Nle), this;
        }
        function X9() {}
        function ope(y) {
          return (
            (y = Yn(y)),
            nr(function (E) {
              return Tj(E, y);
            })
          );
        }
        var ape = M9(Ze),
          lpe = M9(se),
          cpe = M9(Kn);
        function GD(y) {
          return j9(y) ? pl(Hu(y)) : Fce(y);
        }
        function upe(y) {
          return function (E) {
            return y == null ? n : M0(y, E);
          };
        }
        var dpe = Zj(),
          fpe = Zj(!0);
        function J9() {
          return [];
        }
        function eA() {
          return !1;
        }
        function hpe() {
          return {};
        }
        function ppe() {
          return "";
        }
        function mpe() {
          return !0;
        }
        function gpe(y, E) {
          if (((y = Yn(y)), y < 1 || y > F)) return [];
          var U = z,
            V = Go(y, z);
          (E = En(E)), (y -= z);
          for (var X = i9(V, E); ++U < y; ) E(U);
          return X;
        }
        function ype(y) {
          return Fn(y) ? Ze(y, Hu) : yl(y) ? [y] : Ba(fD(ei(y)));
        }
        function vpe(y) {
          var E = ++Mle;
          return ei(y) + E;
        }
        var wpe = $3(function (y, E) {
            return y + E;
          }, 0),
          bpe = I9("ceil"),
          xpe = $3(function (y, E) {
            return y / E;
          }, 1),
          _pe = I9("floor");
        function Spe(y) {
          return y && y.length ? P3(y, $a, m9) : n;
        }
        function Epe(y, E) {
          return y && y.length ? P3(y, En(E, 2), m9) : n;
        }
        function Ape(y) {
          return ec(y, $a);
        }
        function Cpe(y, E) {
          return ec(y, En(E, 2));
        }
        function kpe(y) {
          return y && y.length ? P3(y, $a, w9) : n;
        }
        function Tpe(y, E) {
          return y && y.length ? P3(y, En(E, 2), w9) : n;
        }
        var Mpe = $3(function (y, E) {
            return y * E;
          }, 1),
          Ipe = I9("round"),
          Npe = $3(function (y, E) {
            return y - E;
          }, 0);
        function Rpe(y) {
          return y && y.length ? r9(y, $a) : 0;
        }
        function Ope(y, E) {
          return y && y.length ? r9(y, En(E, 2)) : 0;
        }
        return (
          (J.after = tfe),
          (J.ary = SD),
          (J.assign = zfe),
          (J.assignIn = DD),
          (J.assignInWith = e_),
          (J.assignWith = Wfe),
          (J.at = Hfe),
          (J.before = ED),
          (J.bind = z9),
          (J.bindAll = Yhe),
          (J.bindKey = AD),
          (J.castArray = hfe),
          (J.chain = bD),
          (J.chunk = _ue),
          (J.compact = Sue),
          (J.concat = Eue),
          (J.cond = Zhe),
          (J.conforms = Qhe),
          (J.constant = Y9),
          (J.countBy = Rde),
          (J.create = Vfe),
          (J.curry = CD),
          (J.curryRight = kD),
          (J.debounce = TD),
          (J.defaults = Gfe),
          (J.defaultsDeep = qfe),
          (J.defer = nfe),
          (J.delay = rfe),
          (J.difference = Aue),
          (J.differenceBy = Cue),
          (J.differenceWith = kue),
          (J.drop = Tue),
          (J.dropRight = Mue),
          (J.dropRightWhile = Iue),
          (J.dropWhile = Nue),
          (J.fill = Rue),
          (J.filter = Pde),
          (J.flatMap = Dde),
          (J.flatMapDeep = Bde),
          (J.flatMapDepth = Fde),
          (J.flatten = gD),
          (J.flattenDeep = Oue),
          (J.flattenDepth = Pue),
          (J.flip = ife),
          (J.flow = Jhe),
          (J.flowRight = epe),
          (J.fromPairs = Lue),
          (J.functions = ehe),
          (J.functionsIn = the),
          (J.groupBy = Ude),
          (J.initial = Due),
          (J.intersection = Bue),
          (J.intersectionBy = Fue),
          (J.intersectionWith = Uue),
          (J.invert = rhe),
          (J.invertBy = ihe),
          (J.invokeMap = zde),
          (J.iteratee = Z9),
          (J.keyBy = Wde),
          (J.keys = uo),
          (J.keysIn = Ua),
          (J.map = K3),
          (J.mapKeys = ohe),
          (J.mapValues = ahe),
          (J.matches = tpe),
          (J.matchesProperty = npe),
          (J.memoize = Z3),
          (J.merge = lhe),
          (J.mergeWith = BD),
          (J.method = rpe),
          (J.methodOf = ipe),
          (J.mixin = Q9),
          (J.negate = Q3),
          (J.nthArg = ope),
          (J.omit = che),
          (J.omitBy = uhe),
          (J.once = sfe),
          (J.orderBy = Hde),
          (J.over = ape),
          (J.overArgs = ofe),
          (J.overEvery = lpe),
          (J.overSome = cpe),
          (J.partial = W9),
          (J.partialRight = MD),
          (J.partition = Vde),
          (J.pick = dhe),
          (J.pickBy = FD),
          (J.property = GD),
          (J.propertyOf = upe),
          (J.pull = Hue),
          (J.pullAll = vD),
          (J.pullAllBy = Vue),
          (J.pullAllWith = Gue),
          (J.pullAt = que),
          (J.range = dpe),
          (J.rangeRight = fpe),
          (J.rearg = afe),
          (J.reject = Kde),
          (J.remove = Kue),
          (J.rest = lfe),
          (J.reverse = U9),
          (J.sampleSize = Zde),
          (J.set = hhe),
          (J.setWith = phe),
          (J.shuffle = Qde),
          (J.slice = Yue),
          (J.sortBy = efe),
          (J.sortedUniq = nde),
          (J.sortedUniqBy = rde),
          (J.split = Dhe),
          (J.spread = cfe),
          (J.tail = ide),
          (J.take = sde),
          (J.takeRight = ode),
          (J.takeRightWhile = ade),
          (J.takeWhile = lde),
          (J.tap = Sde),
          (J.throttle = ufe),
          (J.thru = q3),
          (J.toArray = PD),
          (J.toPairs = UD),
          (J.toPairsIn = $D),
          (J.toPath = ype),
          (J.toPlainObject = jD),
          (J.transform = mhe),
          (J.unary = dfe),
          (J.union = cde),
          (J.unionBy = ude),
          (J.unionWith = dde),
          (J.uniq = fde),
          (J.uniqBy = hde),
          (J.uniqWith = pde),
          (J.unset = ghe),
          (J.unzip = $9),
          (J.unzipWith = wD),
          (J.update = yhe),
          (J.updateWith = vhe),
          (J.values = F1),
          (J.valuesIn = whe),
          (J.without = mde),
          (J.words = HD),
          (J.wrap = ffe),
          (J.xor = gde),
          (J.xorBy = yde),
          (J.xorWith = vde),
          (J.zip = wde),
          (J.zipObject = bde),
          (J.zipObjectDeep = xde),
          (J.zipWith = _de),
          (J.entries = UD),
          (J.entriesIn = $D),
          (J.extend = DD),
          (J.extendWith = e_),
          Q9(J, J),
          (J.add = wpe),
          (J.attempt = VD),
          (J.camelCase = She),
          (J.capitalize = zD),
          (J.ceil = bpe),
          (J.clamp = bhe),
          (J.clone = pfe),
          (J.cloneDeep = gfe),
          (J.cloneDeepWith = yfe),
          (J.cloneWith = mfe),
          (J.conformsTo = vfe),
          (J.deburr = WD),
          (J.defaultTo = Xhe),
          (J.divide = xpe),
          (J.endsWith = Ehe),
          (J.eq = Xc),
          (J.escape = Ahe),
          (J.escapeRegExp = Che),
          (J.every = Ode),
          (J.find = Lde),
          (J.findIndex = pD),
          (J.findKey = Kfe),
          (J.findLast = jde),
          (J.findLastIndex = mD),
          (J.findLastKey = Yfe),
          (J.floor = _pe),
          (J.forEach = xD),
          (J.forEachRight = _D),
          (J.forIn = Zfe),
          (J.forInRight = Qfe),
          (J.forOwn = Xfe),
          (J.forOwnRight = Jfe),
          (J.get = G9),
          (J.gt = wfe),
          (J.gte = bfe),
          (J.has = nhe),
          (J.hasIn = q9),
          (J.head = yD),
          (J.identity = $a),
          (J.includes = $de),
          (J.indexOf = jue),
          (J.inRange = xhe),
          (J.invoke = she),
          (J.isArguments = R0),
          (J.isArray = Fn),
          (J.isArrayBuffer = xfe),
          (J.isArrayLike = Fa),
          (J.isArrayLikeObject = Cs),
          (J.isBoolean = _fe),
          (J.isBuffer = Gh),
          (J.isDate = Sfe),
          (J.isElement = Efe),
          (J.isEmpty = Afe),
          (J.isEqual = Cfe),
          (J.isEqualWith = kfe),
          (J.isError = H9),
          (J.isFinite = Tfe),
          (J.isFunction = df),
          (J.isInteger = ID),
          (J.isLength = X3),
          (J.isMap = ND),
          (J.isMatch = Mfe),
          (J.isMatchWith = Ife),
          (J.isNaN = Nfe),
          (J.isNative = Rfe),
          (J.isNil = Pfe),
          (J.isNull = Ofe),
          (J.isNumber = RD),
          (J.isObject = ss),
          (J.isObjectLike = ws),
          (J.isPlainObject = l2),
          (J.isRegExp = V9),
          (J.isSafeInteger = Lfe),
          (J.isSet = OD),
          (J.isString = J3),
          (J.isSymbol = yl),
          (J.isTypedArray = B1),
          (J.isUndefined = jfe),
          (J.isWeakMap = Dfe),
          (J.isWeakSet = Bfe),
          (J.join = $ue),
          (J.kebabCase = khe),
          (J.last = sc),
          (J.lastIndexOf = zue),
          (J.lowerCase = The),
          (J.lowerFirst = Mhe),
          (J.lt = Ffe),
          (J.lte = Ufe),
          (J.max = Spe),
          (J.maxBy = Epe),
          (J.mean = Ape),
          (J.meanBy = Cpe),
          (J.min = kpe),
          (J.minBy = Tpe),
          (J.stubArray = J9),
          (J.stubFalse = eA),
          (J.stubObject = hpe),
          (J.stubString = ppe),
          (J.stubTrue = mpe),
          (J.multiply = Mpe),
          (J.nth = Wue),
          (J.noConflict = spe),
          (J.noop = X9),
          (J.now = Y3),
          (J.pad = Ihe),
          (J.padEnd = Nhe),
          (J.padStart = Rhe),
          (J.parseInt = Ohe),
          (J.random = _he),
          (J.reduce = Gde),
          (J.reduceRight = qde),
          (J.repeat = Phe),
          (J.replace = Lhe),
          (J.result = fhe),
          (J.round = Ipe),
          (J.runInContext = ve),
          (J.sample = Yde),
          (J.size = Xde),
          (J.snakeCase = jhe),
          (J.some = Jde),
          (J.sortedIndex = Zue),
          (J.sortedIndexBy = Que),
          (J.sortedIndexOf = Xue),
          (J.sortedLastIndex = Jue),
          (J.sortedLastIndexBy = ede),
          (J.sortedLastIndexOf = tde),
          (J.startCase = Bhe),
          (J.startsWith = Fhe),
          (J.subtract = Npe),
          (J.sum = Rpe),
          (J.sumBy = Ope),
          (J.template = Uhe),
          (J.times = gpe),
          (J.toFinite = ff),
          (J.toInteger = Yn),
          (J.toLength = LD),
          (J.toLower = $he),
          (J.toNumber = oc),
          (J.toSafeInteger = $fe),
          (J.toString = ei),
          (J.toUpper = zhe),
          (J.trim = Whe),
          (J.trimEnd = Hhe),
          (J.trimStart = Vhe),
          (J.truncate = Ghe),
          (J.unescape = qhe),
          (J.uniqueId = vpe),
          (J.upperCase = Khe),
          (J.upperFirst = K9),
          (J.each = xD),
          (J.eachRight = _D),
          (J.first = yD),
          Q9(
            J,
            (function () {
              var y = {};
              return (
                zu(J, function (E, U) {
                  oi.call(J.prototype, U) || (y[U] = E);
                }),
                y
              );
            })(),
            { chain: !1 }
          ),
          (J.VERSION = r),
          W(
            [
              "bind",
              "bindKey",
              "curry",
              "curryRight",
              "partial",
              "partialRight",
            ],
            function (y) {
              J[y].placeholder = J;
            }
          ),
          W(["drop", "take"], function (y, E) {
            (xr.prototype[y] = function (U) {
              U = U === n ? 1 : Ks(Yn(U), 0);
              var V = this.__filtered__ && !E ? new xr(this) : this.clone();
              return (
                V.__filtered__
                  ? (V.__takeCount__ = Go(U, V.__takeCount__))
                  : V.__views__.push({
                      size: Go(U, z),
                      type: y + (V.__dir__ < 0 ? "Right" : ""),
                    }),
                V
              );
            }),
              (xr.prototype[y + "Right"] = function (U) {
                return this.reverse()[y](U).reverse();
              });
          }),
          W(["filter", "map", "takeWhile"], function (y, E) {
            var U = E + 1,
              V = U == _ || U == N;
            xr.prototype[y] = function (X) {
              var te = this.clone();
              return (
                te.__iteratees__.push({ iteratee: En(X, 3), type: U }),
                (te.__filtered__ = te.__filtered__ || V),
                te
              );
            };
          }),
          W(["head", "last"], function (y, E) {
            var U = "take" + (E ? "Right" : "");
            xr.prototype[y] = function () {
              return this[U](1).value()[0];
            };
          }),
          W(["initial", "tail"], function (y, E) {
            var U = "drop" + (E ? "" : "Right");
            xr.prototype[y] = function () {
              return this.__filtered__ ? new xr(this) : this[U](1);
            };
          }),
          (xr.prototype.compact = function () {
            return this.filter($a);
          }),
          (xr.prototype.find = function (y) {
            return this.filter(y).head();
          }),
          (xr.prototype.findLast = function (y) {
            return this.reverse().find(y);
          }),
          (xr.prototype.invokeMap = nr(function (y, E) {
            return typeof y == "function"
              ? new xr(this)
              : this.map(function (U) {
                  return n2(U, y, E);
                });
          })),
          (xr.prototype.reject = function (y) {
            return this.filter(Q3(En(y)));
          }),
          (xr.prototype.slice = function (y, E) {
            y = Yn(y);
            var U = this;
            return U.__filtered__ && (y > 0 || E < 0)
              ? new xr(U)
              : (y < 0 ? (U = U.takeRight(-y)) : y && (U = U.drop(y)),
                E !== n &&
                  ((E = Yn(E)), (U = E < 0 ? U.dropRight(-E) : U.take(E - y))),
                U);
          }),
          (xr.prototype.takeRightWhile = function (y) {
            return this.reverse().takeWhile(y).reverse();
          }),
          (xr.prototype.toArray = function () {
            return this.take(z);
          }),
          zu(xr.prototype, function (y, E) {
            var U = /^(?:filter|find|map|reject)|While$/.test(E),
              V = /^(?:head|last)$/.test(E),
              X = J[V ? "take" + (E == "last" ? "Right" : "") : E],
              te = V || /^find/.test(E);
            X &&
              (J.prototype[E] = function () {
                var ue = this.__wrapped__,
                  he = V ? [1] : arguments,
                  xe = ue instanceof xr,
                  Ge = he[0],
                  qe = xe || Fn(ue),
                  et = function (mr) {
                    var Cr = X.apply(J, yn([mr], he));
                    return V && St ? Cr[0] : Cr;
                  };
                qe &&
                  U &&
                  typeof Ge == "function" &&
                  Ge.length != 1 &&
                  (xe = qe = !1);
                var St = this.__chain__,
                  en = !!this.__actions__.length,
                  kn = te && !St,
                  Qn = xe && !en;
                if (!te && qe) {
                  ue = Qn ? ue : new xr(this);
                  var Tn = y.apply(ue, he);
                  return (
                    Tn.__actions__.push({ func: q3, args: [et], thisArg: n }),
                    new nc(Tn, St)
                  );
                }
                return kn && Qn
                  ? y.apply(this, he)
                  : ((Tn = this.thru(et)),
                    kn ? (V ? Tn.value()[0] : Tn.value()) : Tn);
              });
          }),
          W(
            ["pop", "push", "shift", "sort", "splice", "unshift"],
            function (y) {
              var E = w3[y],
                U = /^(?:push|sort|unshift)$/.test(y) ? "tap" : "thru",
                V = /^(?:pop|shift)$/.test(y);
              J.prototype[y] = function () {
                var X = arguments;
                if (V && !this.__chain__) {
                  var te = this.value();
                  return E.apply(Fn(te) ? te : [], X);
                }
                return this[U](function (ue) {
                  return E.apply(Fn(ue) ? ue : [], X);
                });
              };
            }
          ),
          zu(xr.prototype, function (y, E) {
            var U = J[E];
            if (U) {
              var V = U.name + "";
              oi.call(O1, V) || (O1[V] = []), O1[V].push({ name: E, func: U });
            }
          }),
          (O1[U3(n, v).name] = [{ name: "wrapper", func: n }]),
          (xr.prototype.clone = qle),
          (xr.prototype.reverse = Kle),
          (xr.prototype.value = Yle),
          (J.prototype.at = Ede),
          (J.prototype.chain = Ade),
          (J.prototype.commit = Cde),
          (J.prototype.next = kde),
          (J.prototype.plant = Mde),
          (J.prototype.reverse = Ide),
          (J.prototype.toJSON = J.prototype.valueOf = J.prototype.value = Nde),
          (J.prototype.first = J.prototype.head),
          Yv && (J.prototype[Yv] = Tde),
          J
        );
      },
      I1 = Cle();
    Ii ? (((Ii.exports = I1)._ = I1), (Br._ = I1)) : (dn._ = I1);
  }).call(Bn);
})(W5, W5.exports);
var Im = W5.exports;
const tMe = Gi(Im),
  rM = ({
    children: e,
    title: t,
    placement: n = "top",
    delay: r = 1e3,
    isHover: i,
    width: s = 290,
    isMobile: o = !1,
  }) => {
    const [a, l] = Y.useState(!1),
      c = Y.useRef(null),
      u = Y.useRef(null),
      d = () => {
        l(!0),
          (u.current = setTimeout(() => {
            l(!1), u.current && clearTimeout(u.current);
          }, r));
      };
    return m.jsxs("div", {
      className: "tooltip-container",
      onClick: i ? Im.noop : d,
      onMouseEnter: i ? () => l(!0) : Im.noop,
      onMouseLeave: i ? () => l(!1) : Im.noop,
      children: [
        e,
        a &&
          m.jsx("div", {
            style: { width: s + "px" },
            className: `${
              o ? "tooltip-box-mobile" : "tooltip-box"
            } tooltip-${n}`,
            ref: c,
            children: t,
          }),
      ],
    });
  },
  nMe = "_blurredSpot_1f1ag_1",
  rMe = { blurredSpot: nMe },
  iMe = () => {
    const e = Y.useRef(null),
      t = bJe();
    return (
      Y.useEffect(() => {
        if (e.current) {
          const n = `${t.x - 20 - 100}px`,
            r = `${t.y - 20 - 100}px`;
          (e.current.style.left = n), (e.current.style.top = r);
        }
      }, [t]),
      m.jsx("div", { ref: e, className: xn(rMe.blurredSpot, "fixed") })
    );
  },
  RO = () => {
    const e = w0();
    return m.jsx(Nc, {
      className: "flex",
      to: "/",
      children: m.jsx("img", {
        className: "max-w-[48px] laptop:max-w-[124px]",
        src:  "/svg/logomain.png",
        alt: "logo",
      }),
    });
  },
  sMe = () => {
    const e = w0();
    return m.jsx(Nc, {
      className: "flex",
      to: "/",
      children: m.jsx("img", {
        className: "max-w-[48px] laptop:max-w-[124px]",
        src:  "/svg/logomain.png",
        alt: "logo",
      }),
    });
  },
  oMe = () =>
    m.jsxs("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      width: "16",
      height: "16",
      viewBox: "0 0 16 16",
      fill: "none",
      children: [
        m.jsx("path", {
          d: "M14.6666 5.03333C14.6666 5.47333 14.3066 5.83333 13.8666 5.83333H2.13331C1.69331 5.83333 1.33331 5.47333 1.33331 5.03333V5.02666C1.33331 3.5 2.56665 2.26666 4.09331 2.26666H11.9C13.4266 2.26666 14.6666 3.50666 14.6666 5.03333Z",
          fill: "#B9C0D4",
        }),
        m.jsx("path", {
          d: "M1.33331 7.63331V10.9733C1.33331 12.5 2.56665 13.7333 4.09331 13.7333H11.9C13.4266 13.7333 14.6666 12.4933 14.6666 10.9666V7.63331C14.6666 7.19331 14.3066 6.83331 13.8666 6.83331H2.13331C1.69331 6.83331 1.33331 7.19331 1.33331 7.63331ZM5.33331 11.5H3.99998C3.72665 11.5 3.49998 11.2733 3.49998 11C3.49998 10.7266 3.72665 10.5 3.99998 10.5H5.33331C5.60665 10.5 5.83331 10.7266 5.83331 11C5.83331 11.2733 5.60665 11.5 5.33331 11.5ZM9.66665 11.5H6.99998C6.72665 11.5 6.49998 11.2733 6.49998 11C6.49998 10.7266 6.72665 10.5 6.99998 10.5H9.66665C9.93998 10.5 10.1666 10.7266 10.1666 11C10.1666 11.2733 9.93998 11.5 9.66665 11.5Z",
          fill: "#B9C0D4",
        }),
      ],
    }),
  OO = () =>
    m.jsxs("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      width: "120",
      height: "120",
      viewBox: "0 0 120 120",
      fill: "none",
      className: "absolute top-[0] left-[0] pointer-events-none",
      children: [
        m.jsx("mask", {
          id: "path-1-inside-1_492_7779",
          fill: "white",
          children: m.jsx("path", {
            d: "M12 1.43099e-07C5.37259 6.40674e-08 -6.40674e-08 5.37258 -1.43099e-07 12L-1.43099e-06 120L120 120L120 1.43099e-06L12 1.43099e-07Z",
          }),
        }),
        m.jsx("path", {
          d: "M12 -1C4.8203 -1 -1 4.8203 -1 12L-1 120L0.999999 120L1 12C1 5.92487 5.92487 1 12 1L12 -1ZM120 120L120 1.43099e-06L120 120ZM120 -0.999999L12 -1C4.8203 -1 -1 4.8203 -1 12L1 12C1 5.92487 5.92487 1 12 1L120 1L120 -0.999999ZM-1.43099e-06 120L120 120L-1.43099e-06 120Z",
          fill: "url(#paint0_linear_492_7779)",
          fillOpacity: "0.64",
          mask: "url(#path-1-inside-1_492_7779)",
        }),
        m.jsx("mask", {
          id: "path-3-inside-2_492_7779",
          fill: "white",
          children: m.jsx("path", {
            d: "M12 1.43099e-07C5.37258 6.40674e-08 -6.40674e-08 5.37258 -1.43099e-07 12L-6.67793e-07 56L56 56L56 6.67793e-07L12 1.43099e-07Z",
          }),
        }),
        m.jsx("path", {
          d: "M12 -1C4.8203 -1 -1 4.8203 -1 12L-1 56L0.999999 56L1 12C1 5.92487 5.92487 1 12 1L12 -1ZM56 56L56 6.67793e-07L56 56ZM56 -0.999999L12 -1C4.8203 -1 -1 4.8203 -1 12L1 12C1 5.92487 5.92487 1 12 1L56 1L56 -0.999999ZM-6.67793e-07 56L56 56L-6.67793e-07 56Z",
          fill: "url(#paint1_linear_492_7779)",
          fillOpacity: "0.64",
          mask: "url(#path-3-inside-2_492_7779)",
        }),
        m.jsxs("defs", {
          children: [
            m.jsxs("linearGradient", {
              id: "paint0_linear_492_7779",
              x1: "-2.60672e-06",
              y1: "120.719",
              x2: "89.3969",
              y2: "-20.0131",
              gradientUnits: "userSpaceOnUse",
              children: [
                m.jsx("stop", { stopColor: "#6A56F6", stopOpacity: "0" }),
                m.jsx("stop", { offset: "0.159668", stopColor: "#6A56F6" }),
                m.jsx("stop", { offset: "0.796115", stopColor: "#6A56F6" }),
                m.jsx("stop", {
                  offset: "1",
                  stopColor: "#6A56F6",
                  stopOpacity: "0",
                }),
              ],
            }),
            m.jsxs("linearGradient", {
              id: "paint1_linear_492_7779",
              x1: "-2.76543",
              y1: "55.3979",
              x2: "45.2488",
              y2: "-7.79701",
              gradientUnits: "userSpaceOnUse",
              children: [
                m.jsx("stop", { stopColor: "white", stopOpacity: "0" }),
                m.jsx("stop", { offset: "0.37", stopColor: "white" }),
                m.jsx("stop", { offset: "0.565", stopColor: "white" }),
                m.jsx("stop", {
                  offset: "1",
                  stopColor: "white",
                  stopOpacity: "0",
                }),
              ],
            }),
          ],
        }),
      ],
    }),
  PO = () =>
    m.jsxs("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      width: "194",
      height: "194",
      viewBox: "0 0 194 194",
      fill: "none",
      className: "absolute top-[0] left-[0] pointer-events-none",
      children: [
        m.jsx("g", {
          clipPath: "url(#clip0_543_565)",
          children: m.jsx("g", {
            filter: "url(#filter0_f_543_565)",
            children: m.jsx("ellipse", {
              cx: "11.5",
              cy: "10.5",
              rx: "78.5",
              ry: "30.5",
              fill: "#6A56F6",
              fillOpacity: "0.32",
            }),
          }),
        }),
        m.jsxs("defs", {
          children: [
            m.jsxs("filter", {
              id: "filter0_f_543_565",
              x: "-147",
              y: "-100",
              width: "317",
              height: "221",
              filterUnits: "userSpaceOnUse",
              colorInterpolationFilters: "sRGB",
              children: [
                m.jsx("feFlood", {
                  floodOpacity: "0",
                  result: "BackgroundImageFix",
                }),
                m.jsx("feBlend", {
                  mode: "normal",
                  in: "SourceGraphic",
                  in2: "BackgroundImageFix",
                  result: "shape",
                }),
                m.jsx("feGaussianBlur", {
                  stdDeviation: "40",
                  result: "effect1_foregroundBlur_543_565",
                }),
              ],
            }),
            m.jsx("clipPath", {
              id: "clip0_543_565",
              children: m.jsx("path", {
                d: "M0 12C0 5.37258 5.37258 0 12 0H194V194H0V12Z",
                fill: "white",
              }),
            }),
          ],
        }),
      ],
    }),
  hz = () =>
    m.jsx("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      width: "16",
      height: "16",
      viewBox: "0 0 16 16",
      fill: "none",
      children: m.jsx("path", {
        d: "M8.00016 1.33331C4.32683 1.33331 1.3335 4.32665 1.3335 7.99998C1.3335 11.6733 4.32683 14.6666 8.00016 14.6666C11.6735 14.6666 14.6668 11.6733 14.6668 7.99998C14.6668 4.32665 11.6735 1.33331 8.00016 1.33331ZM7.50016 5.33331C7.50016 5.05998 7.72683 4.83331 8.00016 4.83331C8.2735 4.83331 8.50016 5.05998 8.50016 5.33331V8.66665C8.50016 8.93998 8.2735 9.16665 8.00016 9.16665C7.72683 9.16665 7.50016 8.93998 7.50016 8.66665V5.33331ZM8.6135 10.92C8.58016 11.0066 8.5335 11.0733 8.4735 11.14C8.40683 11.2 8.3335 11.2466 8.2535 11.28C8.1735 11.3133 8.08683 11.3333 8.00016 11.3333C7.9135 11.3333 7.82683 11.3133 7.74683 11.28C7.66683 11.2466 7.5935 11.2 7.52683 11.14C7.46683 11.0733 7.42016 11.0066 7.38683 10.92C7.3535 10.84 7.3335 10.7533 7.3335 10.6666C7.3335 10.58 7.3535 10.4933 7.38683 10.4133C7.42016 10.3333 7.46683 10.26 7.52683 10.1933C7.5935 10.1333 7.66683 10.0866 7.74683 10.0533C7.90683 9.98665 8.0935 9.98665 8.2535 10.0533C8.3335 10.0866 8.40683 10.1333 8.4735 10.1933C8.5335 10.26 8.58016 10.3333 8.6135 10.4133C8.64683 10.4933 8.66683 10.58 8.66683 10.6666C8.66683 10.7533 8.64683 10.84 8.6135 10.92Z",
        fill: "#B9C0D4",
      }),
    }),
  aMe = () =>
    m.jsx("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      width: "20",
      height: "20",
      viewBox: "0 0 20 20",
      fill: "none",
      children: m.jsx("path", {
        d: "M1.6665 9.99998C1.6665 14.6 5.39984 18.3333 9.99984 18.3333C14.5998 18.3333 18.3332 14.6 18.3332 9.99998C18.3332 5.39998 14.5998 1.66665 9.99984 1.66665C5.39984 1.66665 1.6665 5.39998 1.6665 9.99998ZM10.8582 7.05831L13.3582 9.55831C13.4832 9.68331 13.5415 9.84165 13.5415 9.99998C13.5415 10.1583 13.4832 10.3166 13.3582 10.4416L10.8582 12.9416C10.6165 13.1833 10.2165 13.1833 9.97484 12.9416C9.73317 12.7 9.73317 12.3 9.97484 12.0583L11.4082 10.625L7.08317 10.625C6.7415 10.625 6.45817 10.3416 6.45817 9.99998C6.45817 9.65831 6.7415 9.37498 7.08317 9.37498L11.4082 9.37498L9.97484 7.94165C9.73317 7.69998 9.73317 7.29998 9.97484 7.05831C10.2165 6.81665 10.6165 6.81665 10.8582 7.05831Z",
        fill: "#B9C0D4",
      }),
    }),
  lMe = () =>
    m.jsxs("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      width: "32",
      height: "32",
      viewBox: "0 0 32 32",
      fill: "none",
      children: [
        m.jsx("rect", {
          width: "32",
          height: "32",
          rx: "8",
          fill: "white",
          fillOpacity: "0.04",
        }),
        m.jsx("path", {
          d: "M12.4644 12.4645L19.5354 19.5355",
          stroke: "#B9C0D4",
          strokeWidth: "1.2",
          strokeLinecap: "round",
        }),
        m.jsx("path", {
          d: "M19.5356 12.4645L12.4646 19.5355",
          stroke: "#B9C0D4",
          strokeWidth: "1.2",
          strokeLinecap: "round",
        }),
      ],
    }),
  cMe = "_modal_iq833_6",
  uMe = "_modalContent_iq833_6",
  dMe = "_modalHeader_iq833_13",
  fMe = "_modalTitle_iq833_17",
  hMe = "_btnClose_iq833_21",
  C2 = {
    modal: cMe,
    modalContent: uMe,
    modalHeader: dMe,
    modalTitle: fMe,
    btnClose: hMe,
  },
  $x = ({ onClose: e, children: t, title: n, size: r }) => {
    const i = Y.useRef(null),
      s = (o) => {
        i.current && i.current.classList.remove("opacity-100"),
          setTimeout(() => {
            Mm(!1), e && e(o);
          }, 300);
      };
    return (
      Y.useEffect(() => {
        setTimeout(() => {
          i.current && i.current.classList.add("opacity-100");
        }, 0);
        const o = (a) => {
          a.key === "Escape" && s(a);
        };
        return (
          document.addEventListener("keydown", o),
          Mm(!0),
          () => {
            Mm(!1), document.removeEventListener("keydown", o);
          }
        );
      }, []),
      iv.createPortal(
        m.jsx("div", {
          ref: i,
          id: C2.modal,
          tabIndex: -1,
          "aria-hidden": "true",
          onClick: (o) => s(o),
          className:
            "transition-all duration-300 opacity-0 fixed h-screen z-[901] top-0 left-0 right-0 flex items-center w-full p-4 overflow-y-auto overflow-x-hidden",
          children: m.jsxs("div", {
            onClick: (o) => {
              o.stopPropagation();
            },
            className: `${C2.modalContent} m-auto z-[901]`,
            style: {
              maxWidth: r || 392,
              backgroundImage: "url('./assets/overlay.svg')",
              backgroundSize: "cover",
              backgroundRepeat: "no-repeat",
              backgroundPosition: "center",
            },
            children: [
              m.jsx(OO, {}),
              m.jsx(PO, {}),
              m.jsxs("div", {
                className: C2.modalHeader,
                children: [
                  m.jsx("h5", {
                    className: C2.modalTitle,
                    children: m.jsx("h3", { className: "ml-2", children: n }),
                  }),
                  m.jsx("button", {
                    onClick: (o) => s(o),
                    type: "button",
                    className: C2.btnClose,
                    children: m.jsx(lMe, {}),
                  }),
                ],
              }),
              t,
            ],
          }),
        }),
        document.body
      )
    );
  },
  pMe = () =>
    m.jsxs("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      width: "16",
      height: "16",
      viewBox: "0 0 16 16",
      fill: "none",
      children: [
        m.jsx("path", {
          d: "M7.66658 14.5C3.89992 14.5 0.833252 11.4333 0.833252 7.66665C0.833252 3.89998 3.89992 0.833313 7.66658 0.833313C11.4333 0.833313 14.4999 3.89998 14.4999 7.66665C14.4999 11.4333 11.4333 14.5 7.66658 14.5ZM7.66658 1.83331C4.44659 1.83331 1.83325 4.45331 1.83325 7.66665C1.83325 10.88 4.44659 13.5 7.66658 13.5C10.8866 13.5 13.4999 10.88 13.4999 7.66665C13.4999 4.45331 10.8866 1.83331 7.66658 1.83331Z",
          fill: "#B9C0D4",
        }),
        m.jsx("path", {
          d: "M14.6666 15.1666C14.54 15.1666 14.4133 15.12 14.3133 15.02L12.98 13.6866C12.7866 13.4933 12.7866 13.1733 12.98 12.98C13.1733 12.7866 13.4933 12.7866 13.6866 12.98L15.02 14.3133C15.2133 14.5066 15.2133 14.8266 15.02 15.02C14.92 15.12 14.7933 15.1666 14.6666 15.1666Z",
          fill: "#B9C0D4",
        }),
      ],
    }),
  mMe = "_field_v5wb5_1",
  gMe = "_input_v5wb5_13",
  yMe = "_focus_v5wb5_28",
  MC = { field: mMe, input: gMe, focus: yMe },
  vMe = ({ className: e = "", refProp: t, ...n }) => {
    const [r, i] = Y.useState(!1);
    return m.jsxs("div", {
      className: `${MC.field} ${e} ${r ? MC.focus : ""}`,
      children: [
        m.jsx(pMe, {}),
        m.jsx("input", {
          className: MC.input,
          ref: t,
          onFocus: () => i(!0),
          onBlur: () => i(!1),
          ...n,
        }),
      ],
    });
  };
var Lee = {},
  jee = {},
  W8 = { exports: {} },
  J2 = { exports: {} };
(function () {
  var e, t, n, r, i, s;
  typeof performance < "u" && performance !== null && performance.now
    ? (J2.exports = function () {
        return performance.now();
      })
    : typeof Hs < "u" && Hs !== null && Hs.hrtime
    ? ((J2.exports = function () {
        return (e() - i) / 1e6;
      }),
      (t = Hs.hrtime),
      (e = function () {
        var o;
        return (o = t()), o[0] * 1e9 + o[1];
      }),
      (r = e()),
      (s = Hs.uptime() * 1e9),
      (i = r - s))
    : Date.now
    ? ((J2.exports = function () {
        return Date.now() - n;
      }),
      (n = Date.now()))
    : ((J2.exports = function () {
        return new Date().getTime() - n;
      }),
      (n = new Date().getTime()));
}).call(Bn);
var wMe = J2.exports,
  bMe = wMe,
  Zf = typeof window > "u" ? Bn : window,
  D_ = ["moz", "webkit"],
  ny = "AnimationFrame",
  Uy = Zf["request" + ny],
  Cb = Zf["cancel" + ny] || Zf["cancelRequest" + ny];
for (var k2 = 0; !Uy && k2 < D_.length; k2++)
  (Uy = Zf[D_[k2] + "Request" + ny]),
    (Cb = Zf[D_[k2] + "Cancel" + ny] || Zf[D_[k2] + "CancelRequest" + ny]);
if (!Uy || !Cb) {
  var IC = 0,
    pz = 0,
    P0 = [],
    xMe = 1e3 / 60;
  (Uy = function (e) {
    if (P0.length === 0) {
      var t = bMe(),
        n = Math.max(0, xMe - (t - IC));
      (IC = n + t),
        setTimeout(function () {
          var r = P0.slice(0);
          P0.length = 0;
          for (var i = 0; i < r.length; i++)
            if (!r[i].cancelled)
              try {
                r[i].callback(IC);
              } catch (s) {
                setTimeout(function () {
                  throw s;
                }, 0);
              }
        }, Math.round(n));
    }
    return P0.push({ handle: ++pz, callback: e, cancelled: !1 }), pz;
  }),
    (Cb = function (e) {
      for (var t = 0; t < P0.length; t++)
        P0[t].handle === e && (P0[t].cancelled = !0);
    });
}
W8.exports = function (e) {
  return Uy.call(Zf, e);
};
W8.exports.cancel = function () {
  Cb.apply(Zf, arguments);
};
W8.exports.polyfill = function (e) {
  e || (e = Zf), (e.requestAnimationFrame = Uy), (e.cancelAnimationFrame = Cb);
};
var _Me = W8.exports,
  H8 = { exports: {} },
  NC = null,
  mz = ["Webkit", "Moz", "O", "ms"],
  SMe = function (t) {
    NC || (NC = document.createElement("div"));
    var n = NC.style;
    if (t in n) return t;
    for (
      var r = t.charAt(0).toUpperCase() + t.slice(1), i = mz.length;
      i >= 0;
      i--
    ) {
      var s = mz[i] + r;
      if (s in n) return s;
    }
    return !1;
  },
  EMe = TMe,
  AMe = /\s/,
  CMe = /(_|-|\.|:)/,
  kMe = /([a-z][A-Z]|[A-Z][a-z])/;
function TMe(e) {
  return AMe.test(e)
    ? e.toLowerCase()
    : CMe.test(e)
    ? (IMe(e) || e).toLowerCase()
    : kMe.test(e)
    ? RMe(e).toLowerCase()
    : e.toLowerCase();
}
var MMe = /[\W_]+(.|$)/g;
function IMe(e) {
  return e.replace(MMe, function (t, n) {
    return n ? " " + n : "";
  });
}
var NMe = /(.)([A-Z]+)/g;
function RMe(e) {
  return e.replace(NMe, function (t, n, r) {
    return n + " " + r.toLowerCase().split("").join(" ");
  });
}
var OMe = EMe,
  PMe = LMe;
function LMe(e) {
  return OMe(e)
    .replace(/[\W_]+(.|$)/g, function (t, n) {
      return n ? " " + n : "";
    })
    .trim();
}
var jMe = PMe,
  DMe = BMe;
function BMe(e) {
  return jMe(e).replace(/\s(\w)/g, function (t, n) {
    return n.toUpperCase();
  });
}
var FMe = {
    animationIterationCount: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridRow: !0,
    gridColumn: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    stopOpacity: !0,
    strokeDashoffset: !0,
    strokeOpacity: !0,
    strokeWidth: !0,
  },
  UMe = function (e, t) {
    return typeof t == "number" && !FMe[e] ? t + "px" : t;
  },
  $Me = SMe,
  zMe = DMe,
  H4 = { float: "cssFloat" },
  WMe = UMe;
function H5(e, t, n) {
  var r = H4[t];
  if ((typeof r > "u" && (r = VMe(t)), r)) {
    if (n === void 0) return e.style[r];
    e.style[r] = WMe(r, n);
  }
}
function HMe(e, t) {
  for (var n in t) t.hasOwnProperty(n) && H5(e, n, t[n]);
}
function VMe(e) {
  var t = zMe(e),
    n = $Me(t);
  return (H4[t] = H4[e] = H4[n] = n), n;
}
function Dee() {
  arguments.length === 2
    ? typeof arguments[1] == "string"
      ? (arguments[0].style.cssText = arguments[1])
      : HMe(arguments[0], arguments[1])
    : H5(arguments[0], arguments[1], arguments[2]);
}
H8.exports = Dee;
H8.exports.set = Dee;
H8.exports.get = function (e, t) {
  return Array.isArray(t)
    ? t.reduce(function (n, r) {
        return (n[r] = H5(e, r || "")), n;
      }, {})
    : H5(e, t || "");
};
var Bee = H8.exports,
  Fee = { exports: {} },
  GMe = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED",
  qMe = GMe,
  KMe = qMe;
function Uee() {}
function $ee() {}
$ee.resetWarningCache = Uee;
var YMe = function () {
  function e(r, i, s, o, a, l) {
    if (l !== KMe) {
      var c = new Error(
        "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
      );
      throw ((c.name = "Invariant Violation"), c);
    }
  }
  e.isRequired = e;
  function t() {
    return e;
  }
  var n = {
    array: e,
    bigint: e,
    bool: e,
    func: e,
    number: e,
    object: e,
    string: e,
    symbol: e,
    any: e,
    arrayOf: t,
    element: e,
    elementType: e,
    instanceOf: t,
    node: e,
    objectOf: t,
    oneOf: t,
    oneOfType: t,
    shape: t,
    exact: t,
    checkPropTypes: $ee,
    resetWarningCache: Uee,
  };
  return (n.PropTypes = n), n;
};
Fee.exports = YMe();
var ZMe = Fee.exports,
  zee = {};
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), (e.default = t);
  function t(n) {
    return typeof n == "string";
  }
})(zee);
var Wee = {};
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), (e.default = s);
  var t = Bee,
    n = r(t);
  function r(o) {
    return o && o.__esModule ? o : { default: o };
  }
  var i = !1;
  function s() {
    var o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
    if (o && i !== !1) return i;
    if (typeof document < "u") {
      var a = document.createElement("div");
      (0, n.default)(a, {
        width: 100,
        height: 100,
        position: "absolute",
        top: -9999,
        overflow: "scroll",
        MsOverflowStyle: "scrollbar",
      }),
        document.body.appendChild(a),
        (i = a.offsetWidth - a.clientWidth),
        document.body.removeChild(a);
    } else i = 0;
    return i || 0;
  }
})(Wee);
var Hee = {};
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), (e.default = t);
  function t() {
    return !1;
  }
})(Hee);
var Vee = {};
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), (e.default = t);
  function t(n) {
    var r = n.clientWidth,
      i = getComputedStyle(n),
      s = i.paddingLeft,
      o = i.paddingRight;
    return r - parseFloat(s) - parseFloat(o);
  }
})(Vee);
var Gee = {};
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), (e.default = t);
  function t(n) {
    var r = n.clientHeight,
      i = getComputedStyle(n),
      s = i.paddingTop,
      o = i.paddingBottom;
    return r - parseFloat(s) - parseFloat(o);
  }
})(Gee);
var Gl = {};
Object.defineProperty(Gl, "__esModule", { value: !0 });
Gl.containerStyleDefault = {
  position: "relative",
  overflow: "hidden",
  width: "100%",
  height: "100%",
};
Gl.containerStyleAutoHeight = { height: "auto" };
Gl.viewStyleDefault = {
  position: "absolute",
  top: 0,
  left: 0,
  right: 0,
  bottom: 0,
  overflow: "scroll",
  WebkitOverflowScrolling: "touch",
};
Gl.viewStyleAutoHeight = {
  position: "relative",
  top: void 0,
  left: void 0,
  right: void 0,
  bottom: void 0,
};
Gl.viewStyleUniversalInitial = {
  overflow: "hidden",
  marginRight: 0,
  marginBottom: 0,
};
Gl.trackHorizontalStyleDefault = { position: "absolute", height: 6 };
Gl.trackVerticalStyleDefault = { position: "absolute", width: 6 };
Gl.thumbHorizontalStyleDefault = {
  position: "relative",
  display: "block",
  height: "100%",
};
Gl.thumbVerticalStyleDefault = {
  position: "relative",
  display: "block",
  width: "100%",
};
Gl.disableSelectStyle = { userSelect: "none" };
Gl.disableSelectStyleReset = { userSelect: "" };
var b1 = {};
Object.defineProperty(b1, "__esModule", { value: !0 });
var e0 =
  Object.assign ||
  function (e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  };
b1.renderViewDefault = JMe;
b1.renderTrackHorizontalDefault = eIe;
b1.renderTrackVerticalDefault = tIe;
b1.renderThumbHorizontalDefault = nIe;
b1.renderThumbVerticalDefault = rIe;
var QMe = Y,
  zx = XMe(QMe);
function XMe(e) {
  return e && e.__esModule ? e : { default: e };
}
function V8(e, t) {
  var n = {};
  for (var r in e)
    t.indexOf(r) >= 0 ||
      (Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]));
  return n;
}
function JMe(e) {
  return zx.default.createElement("div", e);
}
function eIe(e) {
  var t = e.style,
    n = V8(e, ["style"]),
    r = e0({}, t, { right: 2, bottom: 2, left: 2, borderRadius: 3 });
  return zx.default.createElement("div", e0({ style: r }, n));
}
function tIe(e) {
  var t = e.style,
    n = V8(e, ["style"]),
    r = e0({}, t, { right: 2, bottom: 2, top: 2, borderRadius: 3 });
  return zx.default.createElement("div", e0({ style: r }, n));
}
function nIe(e) {
  var t = e.style,
    n = V8(e, ["style"]),
    r = e0({}, t, {
      cursor: "pointer",
      borderRadius: "inherit",
      backgroundColor: "rgba(0,0,0,.2)",
    });
  return zx.default.createElement("div", e0({ style: r }, n));
}
function rIe(e) {
  var t = e.style,
    n = V8(e, ["style"]),
    r = e0({}, t, {
      cursor: "pointer",
      borderRadius: "inherit",
      backgroundColor: "rgba(0,0,0,.2)",
    });
  return zx.default.createElement("div", e0({ style: r }, n));
}
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 });
  var t =
      Object.assign ||
      function (k) {
        for (var T = 1; T < arguments.length; T++) {
          var _ = arguments[T];
          for (var A in _)
            Object.prototype.hasOwnProperty.call(_, A) && (k[A] = _[A]);
        }
        return k;
      },
    n = (function () {
      function k(T, _) {
        for (var A = 0; A < _.length; A++) {
          var N = _[A];
          (N.enumerable = N.enumerable || !1),
            (N.configurable = !0),
            "value" in N && (N.writable = !0),
            Object.defineProperty(T, N.key, N);
        }
      }
      return function (T, _, A) {
        return _ && k(T.prototype, _), A && k(T, A), T;
      };
    })(),
    r = _Me,
    i = O(r),
    s = Bee,
    o = O(s),
    a = Y,
    l = ZMe,
    c = O(l),
    u = zee,
    d = O(u),
    f = Wee,
    h = O(f),
    p = Hee,
    g = O(p),
    b = Vee,
    v = O(b),
    w = Gee,
    x = O(w),
    S = Gl,
    R = b1;
  function O(k) {
    return k && k.__esModule ? k : { default: k };
  }
  function B(k, T) {
    var _ = {};
    for (var A in k)
      T.indexOf(A) >= 0 ||
        (Object.prototype.hasOwnProperty.call(k, A) && (_[A] = k[A]));
    return _;
  }
  function C(k, T) {
    if (!(k instanceof T))
      throw new TypeError("Cannot call a class as a function");
  }
  function I(k, T) {
    if (!k)
      throw new ReferenceError(
        "this hasn't been initialised - super() hasn't been called"
      );
    return T && (typeof T == "object" || typeof T == "function") ? T : k;
  }
  function P(k, T) {
    if (typeof T != "function" && T !== null)
      throw new TypeError(
        "Super expression must either be null or a function, not " + typeof T
      );
    (k.prototype = Object.create(T && T.prototype, {
      constructor: { value: k, enumerable: !1, writable: !0, configurable: !0 },
    })),
      T &&
        (Object.setPrototypeOf
          ? Object.setPrototypeOf(k, T)
          : (k.__proto__ = T));
  }
  var M = (function (k) {
    P(T, k);
    function T(_) {
      var A;
      C(this, T);
      for (
        var N = arguments.length, L = Array(N > 1 ? N - 1 : 0), F = 1;
        F < N;
        F++
      )
        L[F - 1] = arguments[F];
      var D = I(
        this,
        (A = T.__proto__ || Object.getPrototypeOf(T)).call.apply(
          A,
          [this, _].concat(L)
        )
      );
      return (
        (D.getScrollLeft = D.getScrollLeft.bind(D)),
        (D.getScrollTop = D.getScrollTop.bind(D)),
        (D.getScrollWidth = D.getScrollWidth.bind(D)),
        (D.getScrollHeight = D.getScrollHeight.bind(D)),
        (D.getClientWidth = D.getClientWidth.bind(D)),
        (D.getClientHeight = D.getClientHeight.bind(D)),
        (D.getValues = D.getValues.bind(D)),
        (D.getThumbHorizontalWidth = D.getThumbHorizontalWidth.bind(D)),
        (D.getThumbVerticalHeight = D.getThumbVerticalHeight.bind(D)),
        (D.getScrollLeftForOffset = D.getScrollLeftForOffset.bind(D)),
        (D.getScrollTopForOffset = D.getScrollTopForOffset.bind(D)),
        (D.scrollLeft = D.scrollLeft.bind(D)),
        (D.scrollTop = D.scrollTop.bind(D)),
        (D.scrollToLeft = D.scrollToLeft.bind(D)),
        (D.scrollToTop = D.scrollToTop.bind(D)),
        (D.scrollToRight = D.scrollToRight.bind(D)),
        (D.scrollToBottom = D.scrollToBottom.bind(D)),
        (D.handleTrackMouseEnter = D.handleTrackMouseEnter.bind(D)),
        (D.handleTrackMouseLeave = D.handleTrackMouseLeave.bind(D)),
        (D.handleHorizontalTrackMouseDown =
          D.handleHorizontalTrackMouseDown.bind(D)),
        (D.handleVerticalTrackMouseDown =
          D.handleVerticalTrackMouseDown.bind(D)),
        (D.handleHorizontalThumbMouseDown =
          D.handleHorizontalThumbMouseDown.bind(D)),
        (D.handleVerticalThumbMouseDown =
          D.handleVerticalThumbMouseDown.bind(D)),
        (D.handleWindowResize = D.handleWindowResize.bind(D)),
        (D.handleScroll = D.handleScroll.bind(D)),
        (D.handleDrag = D.handleDrag.bind(D)),
        (D.handleDragEnd = D.handleDragEnd.bind(D)),
        (D.state = { didMountUniversal: !1 }),
        D
      );
    }
    return (
      n(T, [
        {
          key: "componentDidMount",
          value: function () {
            this.addListeners(),
              this.update(),
              this.componentDidMountUniversal();
          },
        },
        {
          key: "componentDidMountUniversal",
          value: function () {
            var A = this.props.universal;
            A && this.setState({ didMountUniversal: !0 });
          },
        },
        {
          key: "componentDidUpdate",
          value: function () {
            this.update();
          },
        },
        {
          key: "componentWillUnmount",
          value: function () {
            this.removeListeners(),
              (0, r.cancel)(this.requestFrame),
              clearTimeout(this.hideTracksTimeout),
              clearInterval(this.detectScrollingInterval);
          },
        },
        {
          key: "getScrollLeft",
          value: function () {
            return this.view ? this.view.scrollLeft : 0;
          },
        },
        {
          key: "getScrollTop",
          value: function () {
            return this.view ? this.view.scrollTop : 0;
          },
        },
        {
          key: "getScrollWidth",
          value: function () {
            return this.view ? this.view.scrollWidth : 0;
          },
        },
        {
          key: "getScrollHeight",
          value: function () {
            return this.view ? this.view.scrollHeight : 0;
          },
        },
        {
          key: "getClientWidth",
          value: function () {
            return this.view ? this.view.clientWidth : 0;
          },
        },
        {
          key: "getClientHeight",
          value: function () {
            return this.view ? this.view.clientHeight : 0;
          },
        },
        {
          key: "getValues",
          value: function () {
            var A = this.view || {},
              N = A.scrollLeft,
              L = N === void 0 ? 0 : N,
              F = A.scrollTop,
              D = F === void 0 ? 0 : F,
              j = A.scrollWidth,
              z = j === void 0 ? 0 : j,
              $ = A.scrollHeight,
              K = $ === void 0 ? 0 : $,
              re = A.clientWidth,
              G = re === void 0 ? 0 : re,
              ne = A.clientHeight,
              ae = ne === void 0 ? 0 : ne;
            return {
              left: L / (z - G) || 0,
              top: D / (K - ae) || 0,
              scrollLeft: L,
              scrollTop: D,
              scrollWidth: z,
              scrollHeight: K,
              clientWidth: G,
              clientHeight: ae,
            };
          },
        },
        {
          key: "getThumbHorizontalWidth",
          value: function () {
            var A = this.props,
              N = A.thumbSize,
              L = A.thumbMinSize,
              F = this.view,
              D = F.scrollWidth,
              j = F.clientWidth,
              z = (0, v.default)(this.trackHorizontal),
              $ = Math.ceil((j / D) * z);
            return z <= $ ? 0 : N || Math.max($, L);
          },
        },
        {
          key: "getThumbVerticalHeight",
          value: function () {
            var A = this.props,
              N = A.thumbSize,
              L = A.thumbMinSize,
              F = this.view,
              D = F.scrollHeight,
              j = F.clientHeight,
              z = (0, x.default)(this.trackVertical),
              $ = Math.ceil((j / D) * z);
            return z <= $ ? 0 : N || Math.max($, L);
          },
        },
        {
          key: "getScrollLeftForOffset",
          value: function (A) {
            var N = this.view,
              L = N.scrollWidth,
              F = N.clientWidth,
              D = (0, v.default)(this.trackHorizontal),
              j = this.getThumbHorizontalWidth();
            return (A / (D - j)) * (L - F);
          },
        },
        {
          key: "getScrollTopForOffset",
          value: function (A) {
            var N = this.view,
              L = N.scrollHeight,
              F = N.clientHeight,
              D = (0, x.default)(this.trackVertical),
              j = this.getThumbVerticalHeight();
            return (A / (D - j)) * (L - F);
          },
        },
        {
          key: "scrollLeft",
          value: function () {
            var A =
              arguments.length > 0 && arguments[0] !== void 0
                ? arguments[0]
                : 0;
            this.view && (this.view.scrollLeft = A);
          },
        },
        {
          key: "scrollTop",
          value: function () {
            var A =
              arguments.length > 0 && arguments[0] !== void 0
                ? arguments[0]
                : 0;
            this.view && (this.view.scrollTop = A);
          },
        },
        {
          key: "scrollToLeft",
          value: function () {
            this.view && (this.view.scrollLeft = 0);
          },
        },
        {
          key: "scrollToTop",
          value: function () {
            this.view && (this.view.scrollTop = 0);
          },
        },
        {
          key: "scrollToRight",
          value: function () {
            this.view && (this.view.scrollLeft = this.view.scrollWidth);
          },
        },
        {
          key: "scrollToBottom",
          value: function () {
            this.view && (this.view.scrollTop = this.view.scrollHeight);
          },
        },
        {
          key: "addListeners",
          value: function () {
            if (!(typeof document > "u" || !this.view)) {
              var A = this.view,
                N = this.trackHorizontal,
                L = this.trackVertical,
                F = this.thumbHorizontal,
                D = this.thumbVertical;
              A.addEventListener("scroll", this.handleScroll),
                (0, h.default)() &&
                  (N.addEventListener("mouseenter", this.handleTrackMouseEnter),
                  N.addEventListener("mouseleave", this.handleTrackMouseLeave),
                  N.addEventListener(
                    "mousedown",
                    this.handleHorizontalTrackMouseDown
                  ),
                  L.addEventListener("mouseenter", this.handleTrackMouseEnter),
                  L.addEventListener("mouseleave", this.handleTrackMouseLeave),
                  L.addEventListener(
                    "mousedown",
                    this.handleVerticalTrackMouseDown
                  ),
                  F.addEventListener(
                    "mousedown",
                    this.handleHorizontalThumbMouseDown
                  ),
                  D.addEventListener(
                    "mousedown",
                    this.handleVerticalThumbMouseDown
                  ),
                  window.addEventListener("resize", this.handleWindowResize));
            }
          },
        },
        {
          key: "removeListeners",
          value: function () {
            if (!(typeof document > "u" || !this.view)) {
              var A = this.view,
                N = this.trackHorizontal,
                L = this.trackVertical,
                F = this.thumbHorizontal,
                D = this.thumbVertical;
              A.removeEventListener("scroll", this.handleScroll),
                (0, h.default)() &&
                  (N.removeEventListener(
                    "mouseenter",
                    this.handleTrackMouseEnter
                  ),
                  N.removeEventListener(
                    "mouseleave",
                    this.handleTrackMouseLeave
                  ),
                  N.removeEventListener(
                    "mousedown",
                    this.handleHorizontalTrackMouseDown
                  ),
                  L.removeEventListener(
                    "mouseenter",
                    this.handleTrackMouseEnter
                  ),
                  L.removeEventListener(
                    "mouseleave",
                    this.handleTrackMouseLeave
                  ),
                  L.removeEventListener(
                    "mousedown",
                    this.handleVerticalTrackMouseDown
                  ),
                  F.removeEventListener(
                    "mousedown",
                    this.handleHorizontalThumbMouseDown
                  ),
                  D.removeEventListener(
                    "mousedown",
                    this.handleVerticalThumbMouseDown
                  ),
                  window.removeEventListener("resize", this.handleWindowResize),
                  this.teardownDragging());
            }
          },
        },
        {
          key: "handleScroll",
          value: function (A) {
            var N = this,
              L = this.props,
              F = L.onScroll,
              D = L.onScrollFrame;
            F && F(A),
              this.update(function (j) {
                var z = j.scrollLeft,
                  $ = j.scrollTop;
                (N.viewScrollLeft = z), (N.viewScrollTop = $), D && D(j);
              }),
              this.detectScrolling();
          },
        },
        {
          key: "handleScrollStart",
          value: function () {
            var A = this.props.onScrollStart;
            A && A(), this.handleScrollStartAutoHide();
          },
        },
        {
          key: "handleScrollStartAutoHide",
          value: function () {
            var A = this.props.autoHide;
            A && this.showTracks();
          },
        },
        {
          key: "handleScrollStop",
          value: function () {
            var A = this.props.onScrollStop;
            A && A(), this.handleScrollStopAutoHide();
          },
        },
        {
          key: "handleScrollStopAutoHide",
          value: function () {
            var A = this.props.autoHide;
            A && this.hideTracks();
          },
        },
        {
          key: "handleWindowResize",
          value: function () {
            (0, h.default)(!1), this.forceUpdate();
          },
        },
        {
          key: "handleHorizontalTrackMouseDown",
          value: function (A) {
            A.preventDefault();
            var N = A.target,
              L = A.clientX,
              F = N.getBoundingClientRect(),
              D = F.left,
              j = this.getThumbHorizontalWidth(),
              z = Math.abs(D - L) - j / 2;
            this.view.scrollLeft = this.getScrollLeftForOffset(z);
          },
        },
        {
          key: "handleVerticalTrackMouseDown",
          value: function (A) {
            A.preventDefault();
            var N = A.target,
              L = A.clientY,
              F = N.getBoundingClientRect(),
              D = F.top,
              j = this.getThumbVerticalHeight(),
              z = Math.abs(D - L) - j / 2;
            this.view.scrollTop = this.getScrollTopForOffset(z);
          },
        },
        {
          key: "handleHorizontalThumbMouseDown",
          value: function (A) {
            A.preventDefault(), this.handleDragStart(A);
            var N = A.target,
              L = A.clientX,
              F = N.offsetWidth,
              D = N.getBoundingClientRect(),
              j = D.left;
            this.prevPageX = F - (L - j);
          },
        },
        {
          key: "handleVerticalThumbMouseDown",
          value: function (A) {
            A.preventDefault(), this.handleDragStart(A);
            var N = A.target,
              L = A.clientY,
              F = N.offsetHeight,
              D = N.getBoundingClientRect(),
              j = D.top;
            this.prevPageY = F - (L - j);
          },
        },
        {
          key: "setupDragging",
          value: function () {
            (0, o.default)(document.body, S.disableSelectStyle),
              document.addEventListener("mousemove", this.handleDrag),
              document.addEventListener("mouseup", this.handleDragEnd),
              (document.onselectstart = g.default);
          },
        },
        {
          key: "teardownDragging",
          value: function () {
            (0, o.default)(document.body, S.disableSelectStyleReset),
              document.removeEventListener("mousemove", this.handleDrag),
              document.removeEventListener("mouseup", this.handleDragEnd),
              (document.onselectstart = void 0);
          },
        },
        {
          key: "handleDragStart",
          value: function (A) {
            (this.dragging = !0),
              A.stopImmediatePropagation(),
              this.setupDragging();
          },
        },
        {
          key: "handleDrag",
          value: function (A) {
            if (this.prevPageX) {
              var N = A.clientX,
                L = this.trackHorizontal.getBoundingClientRect(),
                F = L.left,
                D = this.getThumbHorizontalWidth(),
                j = D - this.prevPageX,
                z = -F + N - j;
              this.view.scrollLeft = this.getScrollLeftForOffset(z);
            }
            if (this.prevPageY) {
              var $ = A.clientY,
                K = this.trackVertical.getBoundingClientRect(),
                re = K.top,
                G = this.getThumbVerticalHeight(),
                ne = G - this.prevPageY,
                ae = -re + $ - ne;
              this.view.scrollTop = this.getScrollTopForOffset(ae);
            }
            return !1;
          },
        },
        {
          key: "handleDragEnd",
          value: function () {
            (this.dragging = !1),
              (this.prevPageX = this.prevPageY = 0),
              this.teardownDragging(),
              this.handleDragEndAutoHide();
          },
        },
        {
          key: "handleDragEndAutoHide",
          value: function () {
            var A = this.props.autoHide;
            A && this.hideTracks();
          },
        },
        {
          key: "handleTrackMouseEnter",
          value: function () {
            (this.trackMouseOver = !0), this.handleTrackMouseEnterAutoHide();
          },
        },
        {
          key: "handleTrackMouseEnterAutoHide",
          value: function () {
            var A = this.props.autoHide;
            A && this.showTracks();
          },
        },
        {
          key: "handleTrackMouseLeave",
          value: function () {
            (this.trackMouseOver = !1), this.handleTrackMouseLeaveAutoHide();
          },
        },
        {
          key: "handleTrackMouseLeaveAutoHide",
          value: function () {
            var A = this.props.autoHide;
            A && this.hideTracks();
          },
        },
        {
          key: "showTracks",
          value: function () {
            clearTimeout(this.hideTracksTimeout),
              (0, o.default)(this.trackHorizontal, { opacity: 1 }),
              (0, o.default)(this.trackVertical, { opacity: 1 });
          },
        },
        {
          key: "hideTracks",
          value: function () {
            var A = this;
            if (!this.dragging && !this.scrolling && !this.trackMouseOver) {
              var N = this.props.autoHideTimeout;
              clearTimeout(this.hideTracksTimeout),
                (this.hideTracksTimeout = setTimeout(function () {
                  (0, o.default)(A.trackHorizontal, { opacity: 0 }),
                    (0, o.default)(A.trackVertical, { opacity: 0 });
                }, N));
            }
          },
        },
        {
          key: "detectScrolling",
          value: function () {
            var A = this;
            this.scrolling ||
              ((this.scrolling = !0),
              this.handleScrollStart(),
              (this.detectScrollingInterval = setInterval(function () {
                A.lastViewScrollLeft === A.viewScrollLeft &&
                  A.lastViewScrollTop === A.viewScrollTop &&
                  (clearInterval(A.detectScrollingInterval),
                  (A.scrolling = !1),
                  A.handleScrollStop()),
                  (A.lastViewScrollLeft = A.viewScrollLeft),
                  (A.lastViewScrollTop = A.viewScrollTop);
              }, 100)));
          },
        },
        {
          key: "raf",
          value: function (A) {
            var N = this;
            this.requestFrame && i.default.cancel(this.requestFrame),
              (this.requestFrame = (0, i.default)(function () {
                (N.requestFrame = void 0), A();
              }));
          },
        },
        {
          key: "update",
          value: function (A) {
            var N = this;
            this.raf(function () {
              return N._update(A);
            });
          },
        },
        {
          key: "_update",
          value: function (A) {
            var N = this.props,
              L = N.onUpdate,
              F = N.hideTracksWhenNotNeeded,
              D = this.getValues();
            if ((0, h.default)()) {
              var j = D.scrollLeft,
                z = D.clientWidth,
                $ = D.scrollWidth,
                K = (0, v.default)(this.trackHorizontal),
                re = this.getThumbHorizontalWidth(),
                G = (j / ($ - z)) * (K - re),
                ne = { width: re, transform: "translateX(" + G + "px)" },
                ae = D.scrollTop,
                le = D.clientHeight,
                ge = D.scrollHeight,
                Oe = (0, x.default)(this.trackVertical),
                _e = this.getThumbVerticalHeight(),
                Ee = (ae / (ge - le)) * (Oe - _e),
                He = { height: _e, transform: "translateY(" + Ee + "px)" };
              if (F) {
                var je = { visibility: $ > z ? "visible" : "hidden" },
                  Be = { visibility: ge > le ? "visible" : "hidden" };
                (0, o.default)(this.trackHorizontal, je),
                  (0, o.default)(this.trackVertical, Be);
              }
              (0, o.default)(this.thumbHorizontal, ne),
                (0, o.default)(this.thumbVertical, He);
            }
            L && L(D), typeof A == "function" && A(D);
          },
        },
        {
          key: "render",
          value: function () {
            var A = this,
              N = (0, h.default)(),
              L = this.props;
            L.onScroll,
              L.onScrollFrame,
              L.onScrollStart,
              L.onScrollStop,
              L.onUpdate;
            var F = L.renderView,
              D = L.renderTrackHorizontal,
              j = L.renderTrackVertical,
              z = L.renderThumbHorizontal,
              $ = L.renderThumbVertical,
              K = L.tagName;
            L.hideTracksWhenNotNeeded;
            var re = L.autoHide;
            L.autoHideTimeout;
            var G = L.autoHideDuration;
            L.thumbSize, L.thumbMinSize;
            var ne = L.universal,
              ae = L.autoHeight,
              le = L.autoHeightMin,
              ge = L.autoHeightMax,
              Oe = L.style,
              _e = L.children,
              Ee = B(L, [
                "onScroll",
                "onScrollFrame",
                "onScrollStart",
                "onScrollStop",
                "onUpdate",
                "renderView",
                "renderTrackHorizontal",
                "renderTrackVertical",
                "renderThumbHorizontal",
                "renderThumbVertical",
                "tagName",
                "hideTracksWhenNotNeeded",
                "autoHide",
                "autoHideTimeout",
                "autoHideDuration",
                "thumbSize",
                "thumbMinSize",
                "universal",
                "autoHeight",
                "autoHeightMin",
                "autoHeightMax",
                "style",
                "children",
              ]),
              He = this.state.didMountUniversal,
              je = t(
                {},
                S.containerStyleDefault,
                ae &&
                  t({}, S.containerStyleAutoHeight, {
                    minHeight: le,
                    maxHeight: ge,
                  }),
                Oe
              ),
              Be = t(
                {},
                S.viewStyleDefault,
                { marginRight: N ? -N : 0, marginBottom: N ? -N : 0 },
                ae &&
                  t({}, S.viewStyleAutoHeight, {
                    minHeight: (0, d.default)(le)
                      ? "calc(" + le + " + " + N + "px)"
                      : le + N,
                    maxHeight: (0, d.default)(ge)
                      ? "calc(" + ge + " + " + N + "px)"
                      : ge + N,
                  }),
                ae && ne && !He && { minHeight: le, maxHeight: ge },
                ne && !He && S.viewStyleUniversalInitial
              ),
              rn = { transition: "opacity " + G + "ms", opacity: 0 },
              Wt = t(
                {},
                S.trackHorizontalStyleDefault,
                re && rn,
                (!N || (ne && !He)) && { display: "none" }
              ),
              Mt = t(
                {},
                S.trackVerticalStyleDefault,
                re && rn,
                (!N || (ne && !He)) && { display: "none" }
              );
            return (0, a.createElement)(
              K,
              t({}, Ee, {
                style: je,
                ref: function (kt) {
                  A.container = kt;
                },
              }),
              [
                (0, a.cloneElement)(
                  F({ style: Be }),
                  {
                    key: "view",
                    ref: function (kt) {
                      A.view = kt;
                    },
                  },
                  _e
                ),
                (0, a.cloneElement)(
                  D({ style: Wt }),
                  {
                    key: "trackHorizontal",
                    ref: function (kt) {
                      A.trackHorizontal = kt;
                    },
                  },
                  (0, a.cloneElement)(
                    z({ style: S.thumbHorizontalStyleDefault }),
                    {
                      ref: function (kt) {
                        A.thumbHorizontal = kt;
                      },
                    }
                  )
                ),
                (0, a.cloneElement)(
                  j({ style: Mt }),
                  {
                    key: "trackVertical",
                    ref: function (kt) {
                      A.trackVertical = kt;
                    },
                  },
                  (0, a.cloneElement)(
                    $({ style: S.thumbVerticalStyleDefault }),
                    {
                      ref: function (kt) {
                        A.thumbVertical = kt;
                      },
                    }
                  )
                ),
              ]
            );
          },
        },
      ]),
      T
    );
  })(a.Component);
  (e.default = M),
    (M.propTypes = {
      onScroll: c.default.func,
      onScrollFrame: c.default.func,
      onScrollStart: c.default.func,
      onScrollStop: c.default.func,
      onUpdate: c.default.func,
      renderView: c.default.func,
      renderTrackHorizontal: c.default.func,
      renderTrackVertical: c.default.func,
      renderThumbHorizontal: c.default.func,
      renderThumbVertical: c.default.func,
      tagName: c.default.string,
      thumbSize: c.default.number,
      thumbMinSize: c.default.number,
      hideTracksWhenNotNeeded: c.default.bool,
      autoHide: c.default.bool,
      autoHideTimeout: c.default.number,
      autoHideDuration: c.default.number,
      autoHeight: c.default.bool,
      autoHeightMin: c.default.oneOfType([c.default.number, c.default.string]),
      autoHeightMax: c.default.oneOfType([c.default.number, c.default.string]),
      universal: c.default.bool,
      style: c.default.object,
      children: c.default.node,
    }),
    (M.defaultProps = {
      renderView: R.renderViewDefault,
      renderTrackHorizontal: R.renderTrackHorizontalDefault,
      renderTrackVertical: R.renderTrackVerticalDefault,
      renderThumbHorizontal: R.renderThumbHorizontalDefault,
      renderThumbVertical: R.renderThumbVerticalDefault,
      tagName: "div",
      thumbMinSize: 30,
      hideTracksWhenNotNeeded: !1,
      autoHide: !1,
      autoHideTimeout: 1e3,
      autoHideDuration: 200,
      autoHeight: !1,
      autoHeightMin: 0,
      autoHeightMax: 200,
      universal: !1,
    });
})(jee);
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.Scrollbars = void 0);
  var t = jee,
    n = r(t);
  function r(i) {
    return i && i.__esModule ? i : { default: i };
  }
  (e.default = n.default), (e.Scrollbars = n.default);
})(Lee);
const iIe = Gi(Lee),
  qee = ({ children: e, className: t, height: n, key: r }) =>
    m.jsx(
      iIe,
      {
        className: t,
        style: { height: n },
        renderThumbVertical: ({ style: i, ...s }) =>
          m.jsx("div", {
            ...s,
            style: {
              ...i,
              background: "#fff!important",
              borderRadius: "10px",
              display: "block!important",
              visibility: "visible",
            },
          }),
        renderTrackVertical: ({ style: i, ...s }) =>
          m.jsx("div", {
            ...s,
            style: {
              ...i,
              backgroundColor: "#fff",
              borderRadius: "10px",
              display: "block",
              visibility: "visible",
            },
          }),
        children: e,
      },
      r
    ),
  sIe = "_input_1sbdo_1",
  oIe = { input: sIe },
  Wx = ({ className: e = "", refProp: t, ...n }) =>
    m.jsx("input", { className: `${oIe.input} ${e}`, ref: t, ...n });
var Fr = ((e) => (
  (e.home = "/"),
  (e.presale = "/presale"),
  (e.referral_presale = "/presale:code"),
  (e.how_to_buy = "/presale/how-to-buy"),
  (e.tokenomics = "/presale/tokenomics"),
  (e.referral = "/presale/invite"),
  (e.how_it_works = "/presale/how-it-works"),
  (e.leaderboard = "/presale/leaderboard"),
  (e.mediaKit = "/media-kit"),
  (e.app = "/app"),
  (e.swap = "/app/swap"),
  (e.audit = "/audit-results"),
  e
))(Fr || {});
const aIe = () =>
    m.jsxs("svg", {
      className: "social-icon",
      xmlns: "http://www.w3.org/2000/svg",
      width: "44",
      height: "44",
      viewBox: "0 0 44 44",
      fill: "none",
      children: [
        m.jsx("rect", { width: "44", height: "44", rx: "8", fill: "#26272B" }),
        m.jsx("path", {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "M23.4334 16.8971C21.8664 17.6081 18.7336 19.0814 14.0364 21.3156C13.2737 21.6469 12.8735 21.9709 12.8373 22.2876C12.7755 22.8241 13.3905 23.0353 14.2258 23.3211C14.3399 23.3607 14.4581 23.4003 14.5789 23.4443C15.4021 23.736 16.5085 24.0776 17.0833 24.0908C17.6056 24.1025 18.1884 23.8679 18.8316 23.3871C23.2199 20.1516 25.4853 18.517 25.6276 18.4818C25.7283 18.4569 25.868 18.4247 25.962 18.517C26.056 18.6079 26.0466 18.7809 26.0372 18.8278C25.9754 19.1107 23.5664 21.5575 22.3176 22.8241C21.9281 23.2185 21.6529 23.4985 21.5965 23.563C21.4702 23.7052 21.3413 23.8416 21.2178 23.972C20.4524 24.7754 19.8803 25.3794 21.25 26.3646C21.908 26.8381 22.4344 27.2295 22.9594 27.6195C23.5328 28.0461 24.1048 28.4712 24.8461 29.0019C25.0341 29.1368 25.214 29.276 25.3899 29.4124C26.0573 29.9328 26.6575 30.399 27.3988 30.3257C27.8285 30.2817 28.2743 29.8405 28.4999 28.5225C29.033 25.4058 30.0831 18.6563 30.3261 15.8738C30.3409 15.6428 30.3319 15.4107 30.2993 15.1819C30.2797 14.997 30.1973 14.827 30.0683 14.7054C29.8763 14.5339 29.5782 14.4972 29.4439 14.5002C28.8383 14.5119 27.909 14.8652 23.4334 16.8971Z",
          fill: "white",
        }),
      ],
    }),
  lIe = () =>
    m.jsxs("svg", {
      className: "social-icon",
      xmlns: "http://www.w3.org/2000/svg",
      width: "44",
      height: "44",
      viewBox: "0 0 44 44",
      fill: "none",
      children: [
        m.jsx("rect", { width: "44", height: "44", rx: "8", fill: "#26272B" }),
        m.jsx("path", {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "M29.5 29.5L23.634 20.7577L23.6441 20.7659L28.9331 14.5H27.1656L22.8571 19.6L19.4355 14.5H14.8001L20.2766 22.6621L20.2759 22.6614L14.5 29.5H16.2675L21.0576 23.8259L24.8646 29.5H29.5ZM18.7352 15.8636L26.9655 28.1364H25.5649L17.3279 15.8636H18.7352Z",
          fill: "white",
        }),
      ],
    }),
  B_ = "text-[#B9C0D4] text-[16px] font-[400] leading-[160%] cursor-pointer",
  gz = "flex items-center gap-[16px]",
  cIe = () =>
    m.jsx("footer", {
      className:
        "mt-[auto] bg-[#131316] py-[56px] laptop:pt-[158px] laptop:pb-[140px]",
      children: m.jsxs(Fc, {
        children: [
          m.jsx("img", {
            className: "ml-[auto] mr-[auto]",
            src: "/svg/footerLogo.svg",
            alt: "logo",
          }),
          m.jsxs("div", {
            style: { borderTop: "1px solid #3F3F46" },
            className:
              "grid grid-cols-1 laptop:grid-cols-3 items-center gap-[20px] mt-[32px] pt-[32px]",
            children: [
              m.jsx("p", {
                className:
                  B_ +
                  " text-center laptop:text-left order-[1] laptop:order-none",
                children: "All right reserved",
              }),
              m.jsxs("ul", {
                className: gz + " justify-center laptop:justify-center",
                children: [
                  m.jsx("li", {
                    children: m.jsx("a", {
                      href: Pee,
                      target: "_blank",
                      rel: "noreferrer",
                      children: m.jsx(lIe, {}),
                    }),
                  }),
                  m.jsx("li", {
                    children: m.jsx("a", {
                      href: Oee,
                      target: "_blank",
                      rel: "noreferrer",
                      children: m.jsx(aIe, {}),
                    }),
                  }),
                ],
              }),
              m.jsxs("ul", {
                className:
                  gz +
                  " justify-center laptop:justify-end order-[-1] laptop:order-none",
                children: [
                  m.jsx("li", {
                    className: B_,
                    children: m.jsx(Nc, {
                      to: Fr.mediaKit,
                      children: "Media Kit",
                    }),
                  }),
                  m.jsx("li", {
                    className: B_,
                    children: m.jsx("a", {
                      href: z8,
                      target: "_blank",
                      rel: "noreferrer",
                      children: "Docs",
                    }),
                  }),
                  m.jsx("li", {
                    className: B_,
                    children: m.jsx(Nc, {
                      to: Fr.presale,
                      children: "Presale",
                    }),
                  }),
                ],
              }),
            ],
          }),
        ],
      }),
    }),
  uIe = ({ setIsMobMenuOpen: e }) => {
    Y.useEffect(
      () => (
        Mm(!0),
        () => {
          Mm(!1);
        }
      ),
      []
    );
    const t = () => e(!1);
    return m.jsxs("div", {
      className: "flex flex-col gap-[32px]",
      children: [
        m.jsxs(Nr, {
          onClick: t,
          to: "/presale",
          className: "!rounded-full",
          children: ["Buy $", $n],
        }),
        m.jsxs("div", {
          className: "flex flex-col gap-[16px]",
          children: [
            m.jsx("p", {
              className:
                "text-[#70707B] text-[14px] not-italic font-semibold leading-[100%] uppercase",
              children: "navigation",
            }),
            m.jsx(Nc, {
              onClick: t,
              to: `${Fr.home}#about`,
              className: "flex flex-col gap-[6px]",
              children: m.jsxs("div", {
                className:
                  "flex px-[8px] gap-[8px] py-[12px] items-center self-stretch",
                children: [
                  m.jsx("div", {
                    children: m.jsx("img", {
                      className: "w-[22px] h-[22px]",
                      src: "/svg/questionmark.svg",
                      alt: "",
                    }),
                  }),
                  m.jsx("div", {
                    className:
                      "text-[#B9C0D4] text-[16px] not-italic font-semibold leading-[100%]",
                    children: "About",
                  }),
                ],
              }),
            }),
            m.jsx(Nc, {
              to: z8,
              target: "_blank",
              children: m.jsxs("div", {
                className:
                  "flex px-[8px] gap-[8px] py-[12px] items-center self-stretch",
                children: [
                  m.jsx("div", {
                    children: m.jsx("img", {
                      className: "w-[22px] h-[22px]",
                      src: "/svg/docs.svg",
                      alt: "",
                    }),
                  }),
                  m.jsx("div", {
                    className:
                      "text-[#B9C0D4] text-[16px] not-italic font-semibold leading-[100%]",
                    children: "Docs",
                  }),
                ],
              }),
            }),
            m.jsx("div", {}),
          ],
        }),
        m.jsxs("div", {
          className: "flex flex-col gap-[16px]",
          children: [
            m.jsx("p", {
              className:
                "text-[#70707B] text-[14px] not-italic font-semibold leading-[100%] uppercase",
              children: "App",
            }),
            m.jsxs("div", {
              className: "flex flex-col gap-[6px]",
              children: [
                m.jsxs("div", {
                  className:
                    "flex px-[8px] py-[12px] rounded-[8px] items-center justify-between bg-black self-stretch",
                  children: [
                    m.jsxs("div", {
                      className: "flex gap-[6px] items-center",
                      children: [
                        m.jsx("div", {
                          children: m.jsx("img", {
                            className: "w-[22px] h-[22px]",
                            src: "/svg/swap.svg",
                            alt: "",
                          }),
                        }),
                        m.jsx("div", {
                          className:
                            "text-[#B9C0D4] text-[16px] not-italic font-semibold leading-[100%]",
                          children: "Swap",
                        }),
                      ],
                    }),
                    m.jsx("div", {
                      className:
                        "flex h-[32px] px-[10px] py-[8px] justify-center items-center gap-[4px] rounded-[35px] bg-[rgba(106,_86,_246,_0.16)]",
                      children: m.jsx("p", {
                        className:
                          "text-[#6A56F6] text-[10px] not-italic font-bold leading-[100%]",
                        children: "SOON",
                      }),
                    }),
                  ],
                }),
                m.jsx("div", {
                  children: m.jsxs("div", {
                    className:
                      "flex px-[8px] py-[12px] rounded-[8px] justify-between bg-black items-center self-stretch",
                    children: [
                      m.jsxs("div", {
                        className: "flex gap-[6px] items-center",
                        children: [
                          m.jsx("div", {
                            children: m.jsx("img", {
                              className: "w-[22px] h-[22px]",
                              src: "/svg/pool.svg",
                              alt: "",
                            }),
                          }),
                          m.jsx("div", {
                            className:
                              "text-[#B9C0D4] text-[16px] not-italic font-semibold leading-[100%]",
                            children: "Pools",
                          }),
                        ],
                      }),
                      m.jsx("div", {
                        className:
                          "flex h-[32px] px-[10px] py-[8px] justify-center items-center gap-[4px] rounded-[35px] bg-[rgba(106,_86,_246,_0.16)]",
                        children: m.jsx("p", {
                          className:
                            "text-[#6A56F6] text-[10px] not-italic font-bold leading-[100%]",
                          children: "SOON",
                        }),
                      }),
                    ],
                  }),
                }),
              ],
            }),
          ],
        }),
      ],
    });
  },
  Kee = ({ isOpen: e }) =>
    m.jsx(m.Fragment, {
      children: e
        ? m.jsxs("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            width: "44",
            height: "44",
            viewBox: "0 0 44 44",
            fill: "none",
            children: [
              m.jsx("path", {
                d: "M0 8C0 3.58172 3.58172 0 8 0H36C40.4183 0 44 3.58172 44 8V36C44 40.4183 40.4183 44 36 44H8C3.58172 44 0 40.4183 0 36V8Z",
                fill: "white",
                fillOpacity: "0.02",
              }),
              m.jsx("path", {
                d: "M0.5 8C0.5 3.85786 3.85786 0.5 8 0.5H36C40.1421 0.5 43.5 3.85786 43.5 8V36C43.5 40.1421 40.1421 43.5 36 43.5H8C3.85786 43.5 0.5 40.1421 0.5 36V8Z",
                stroke: "url(#paint0_linear_910_3299)",
                strokeOpacity: "0.24",
              }),
              m.jsx("path", {
                d: "M17 17L27 27",
                stroke: "white",
                strokeWidth: "1.5",
                strokeLinecap: "round",
              }),
              m.jsx("path", {
                d: "M27 17L17 27",
                stroke: "white",
                strokeWidth: "1.5",
                strokeLinecap: "round",
              }),
              m.jsx("defs", {
                children: m.jsxs("linearGradient", {
                  id: "paint0_linear_910_3299",
                  x1: "5.5",
                  y1: "-5.43644e-07",
                  x2: "44.7034",
                  y2: "2.57416",
                  gradientUnits: "userSpaceOnUse",
                  children: [
                    m.jsx("stop", { stopColor: "white" }),
                    m.jsx("stop", {
                      offset: "1",
                      stopColor: "white",
                      stopOpacity: "0.32",
                    }),
                  ],
                }),
              }),
            ],
          })
        : m.jsxs("svg", {
            width: "44",
            height: "44",
            viewBox: "0 0 44 44",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg",
            children: [
              m.jsx("path", {
                d: "M0 8C0 3.58172 3.58172 0 8 0H36C40.4183 0 44 3.58172 44 8V36C44 40.4183 40.4183 44 36 44H8C3.58172 44 0 40.4183 0 36V8Z",
                fill: "#6A56F6",
              }),
              m.jsx("path", {
                d: "M0.5 8C0.5 3.85786 3.85786 0.5 8 0.5H36C40.1421 0.5 43.5 3.85786 43.5 8V36C43.5 40.1421 40.1421 43.5 36 43.5H8C3.85786 43.5 0.5 40.1421 0.5 36V8Z",
                stroke: "url(#paint0_linear_987_2674)",
                strokeOpacity: "0.42",
              }),
              m.jsx("path", {
                d: "M27.6659 14H26.3341C24.8061 14 24 14.8061 24 16.3341V17.6659C24 19.1939 24.8061 20 26.3341 20H27.6659C29.1939 20 30 19.1939 30 17.6659V16.3341C30 14.8061 29.1939 14 27.6659 14Z",
                fill: "white",
              }),
              m.jsx("path", {
                d: "M17.6729 24H16.3411C14.8061 24 14 24.8051 14 26.3314V27.6616C14 29.1949 14.8061 30 16.3341 30H17.6659C19.1939 30 20 29.1949 20 27.6686V26.3384C20.007 24.8051 19.2009 24 17.6729 24Z",
                fill: "white",
              }),
              m.jsx("path", {
                d: "M17 20C18.6569 20 20 18.6569 20 17C20 15.3431 18.6569 14 17 14C15.3431 14 14 15.3431 14 17C14 18.6569 15.3431 20 17 20Z",
                fill: "white",
              }),
              m.jsx("path", {
                d: "M27 30C28.6569 30 30 28.6569 30 27C30 25.3431 28.6569 24 27 24C25.3431 24 24 25.3431 24 27C24 28.6569 25.3431 30 27 30Z",
                fill: "white",
              }),
              m.jsx("defs", {
                children: m.jsxs("linearGradient", {
                  id: "paint0_linear_987_2674",
                  x1: "5.5",
                  y1: "-5.43644e-07",
                  x2: "44.7034",
                  y2: "2.57416",
                  gradientUnits: "userSpaceOnUse",
                  children: [
                    m.jsx("stop", { stopColor: "white" }),
                    m.jsx("stop", {
                      offset: "1",
                      stopColor: "white",
                      stopOpacity: "0.32",
                    }),
                  ],
                }),
              }),
            ],
          }),
    });
Fr.presale;
const dIe = [
    { path: "#", name: "Swap" },
    { path: "#", name: "Pools" },
    { path: `${Fr.home}#about`, name: "About" },
    { path: z8, name: "Docs", target: "_blank" },
  ],
  fIe = () =>
    m.jsx("nav", {
      className: "flex items-center justify-center gap-[32px]",
      children: dIe.map((e) =>
        e.name === "Pools" || e.name === "Swap"
          ? m.jsxs("div", {
              className: "flex flex-row w-[97px]",
              style: { alignItems: "center", gap: "6px" },
              children: [
                m.jsx(
                  Nc,
                  {
                    className:
                      "text-[#5D6B98] text-[16px] font-[600] leading-[24px]",
                    to: e.path,
                    children: e.name,
                  },
                  e.name
                ),
                m.jsx("img", {
                  src: "/svg/soon.svg",
                  alt: "soon",
                  width: 49,
                  height: 32,
                }),
              ],
            })
          : m.jsx(
              Nc,
              {
                className:
                  "text-[#B9C0D4] text-[16px] font-[600] leading-[24px]",
                to: e.path,
                target: e.target || "",
                children: e.name,
              },
              e.name
            )
      ),
    }),
  hIe = () => {
    const e = w0(),
      [t, n] = Y.useState(!1),
      [r, i] = Y.useState(!1);
    return (
      Ud().pathname,
      Y.useEffect(() => {
        const o = Im.throttle(() => {
          window.scrollY > 50 ? n(!0) : n(!1);
        });
        return (
          window.addEventListener("scroll", o),
          () => {
            window.removeEventListener("scroll", o),
              (document.body.style.overflow = "auto");
          }
        );
      }, []),
      m.jsx(m.Fragment, {
        children: m.jsxs("div", {
          className: `fixed  left-1/2 -translate-x-1/2 w-full h-[100px] z-[100] px-[16px] laptop:px-[32px] ${
            t ? "rounded-[0px]" : "rounded-[64px]"
          }  transition-all ${
            t ? "py-[10px] bg-[url('/svg/header.svg')] bg-cover" : "py-[12px]"
          }`,
          children: [
            m.jsx("header", {
              className: `fixed top-[20px] left-1/2 -translate-x-1/2 w-full max-w-[1240px] z-[100] px-[38px] laptop:px-[32px] ${
                t ? "rounded-[0px]" : "rounded-[64px]"
              }  transition-all ${t ? "py-[10px]" : "py-[12px]"}`,
              children: m.jsxs("div", {
                className: "flex justify-between items-center",
                children: [
                  !e && m.jsx(fIe, {}),
                  m.jsx("div", {
                    className: e
                      ? "relative flex items-center  justify-center"
                      : "absolute flex items-center  justify-center  top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2",
                    children: m.jsx(RO, {}),
                  }),
                  m.jsxs("div", {
                    className: "flex justify-end",
                    children: [
                      m.jsx("div", {
                        className: "hidden md:block w-[180px]",
                        children: m.jsxs(Nr, {
                          size: "48",
                          to: "/presale",
                          fullWidth: !0,
                          children: ["Buy $", $n],
                        }),
                      }),
                      e &&
                        m.jsx("button", {
                          className: "ml-[20px]",
                          onClick: () => {
                            i((o) => !o);
                          },
                          children: m.jsx(Kee, { isOpen: r }),
                        }),
                    ],
                  }),
                ],
              }),
            }),
            e &&
              m.jsx("div", {
                className:
                  "fixed top-[0] left-[0] right-[0] min-h-[556px] h-[100dvh] laptop:hidden z-[78] rounded-[12px] bg-[#09080d]",
                style: {
                  border: " 2px solid #151515",
                  boxShadow: "0px 4px 0px 0px #151515",
                  transform: `translateY(${r ? "0" : "-100%"})`,
                },
                children: m.jsx("nav", {
                  className: "pt-[100px] relative z-[2] px-[16px]",
                  children: r && m.jsx(uIe, { setIsMobMenuOpen: i }),
                }),
              }),
          ],
        }),
      })
    );
  },
  yz = () =>
    m.jsx("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      width: "20",
      height: "20",
      viewBox: "0 0 20 20",
      fill: "none",
      children: m.jsx("path", {
        d: "M2 8.15789L8.5 15L18 5",
        stroke: "#6A56F6",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "bevel",
      }),
    }),
  pIe = () =>
    m.jsxs("svg", {
      className: "absolute top-0 left-0",
      xmlns: "http://www.w3.org/2000/svg",
      width: "900",
      height: "170",
      viewBox: "0 0 900 170",
      fill: "none",
      children: [
        m.jsx("g", {
          filter: "url(#filter0_f_492_3476)",
          children: m.jsx("path", {
            d: "M760 2.09687e-05C760 22.6437 444.5 21 263 73.5C178.825 97.8481 51 87.6256 51 -0.000102997C51 -48 209.715 -41 405.5 -41C601.285 -40.9999 760 -22.6436 760 2.09687e-05Z",
            fill: "#6A56F6",
            fillOpacity: "0.32",
          }),
        }),
        m.jsx("defs", {
          children: m.jsxs("filter", {
            id: "filter0_f_492_3476",
            x: "-89",
            y: "-181.357",
            width: "989",
            height: "406.281",
            filterUnits: "userSpaceOnUse",
            colorInterpolationFilters: "sRGB",
            children: [
              m.jsx("feFlood", {
                floodOpacity: "0",
                result: "BackgroundImageFix",
              }),
              m.jsx("feBlend", {
                mode: "normal",
                in: "SourceGraphic",
                in2: "BackgroundImageFix",
                result: "shape",
              }),
              m.jsx("feGaussianBlur", {
                stdDeviation: "70",
                result: "effect1_foregroundBlur_492_3476",
              }),
            ],
          }),
        }),
      ],
    }),
  mIe = () =>
    m.jsxs("svg", {
      className: "absolute top-0 left-0 w-full",
      xmlns: "http://www.w3.org/2000/svg",
      width: "328",
      height: "181",
      viewBox: "0 0 328 181",
      fill: "none",
      children: [
        m.jsx("g", {
          filter: "url(#filter0_f_281_125)",
          children: m.jsx("path", {
            d: "M460 27.8375C460 43.079 247.738 41.9726 125.629 77.3106C68.9979 93.6994 -17 86.8186 -17 27.8374C-17 -4.47147 89.7801 0.24025 221.5 0.240273C353.22 0.240296 460 12.596 460 27.8375Z",
            fill: "#6A56F6",
            fillOpacity: "0.32",
          }),
        }),
        m.jsx("defs", {
          children: m.jsxs("filter", {
            id: "filter0_f_281_125",
            x: "-113",
            y: "-96",
            width: "669",
            height: "277",
            filterUnits: "userSpaceOnUse",
            colorInterpolationFilters: "sRGB",
            children: [
              m.jsx("feFlood", {
                floodOpacity: "0",
                result: "BackgroundImageFix",
              }),
              m.jsx("feBlend", {
                mode: "normal",
                in: "SourceGraphic",
                in2: "BackgroundImageFix",
                result: "shape",
              }),
              m.jsx("feGaussianBlur", {
                stdDeviation: "48",
                result: "effect1_foregroundBlur_281_125",
              }),
            ],
          }),
        }),
      ],
    }),
  gIe = () => {
    const e = ji(),
      [t, n] = Y.useState(""),
      [r, i] = Y.useState(""),
      [s, o] = Y.useState(!1),
      [a, l] = Y.useState(!1),
      c = "!laptop:text-[18px] !text-[16px] !text-white !font-semibold",
      u = s ? "rgba(106, 86, 246, 0.20)" : "",
      d = (h) => {
        const p = h.target.value;
        fz.test(p) && i(""), n(p);
      },
      f = () => {
        fz.test(t)
          ? (l(!0),
            setTimeout(() => {
              o(!0), l(!1), n("");
            }, 2e3))
          : i("invalid email");
      };
    return m.jsxs("div", {
      style: { background: "rgba(38, 39, 43, 0.42)" },
      className:
        "px-[16px] laptop:px-[64px] py-[24px] laptop:py-[47px] rounded-[16px] laptop:rounded-[20px] border border-borderMain overflow-hidden relative",
      children: [
        m.jsx("div", {
          className:
            "absolute h-full w-full inset-0 bg-noise bg-cover opacity-[0.1]",
        }),
        m.jsx("div", {
          className:
            "absolute h-full w-full laptop:w-[640px] top-0 left-0 laptop:bg-grid bg-gridMob bg-contain",
        }),
        e && m.jsx(mIe, {}),
        !e && m.jsx(pIe, {}),
        m.jsxs("div", {
          className:
            "flex flex-col laptop:flex-row gap-[16px] items-center laptop:justify-between relative z-10",
          children: [
            m.jsx(Ln, {
              className:
                "absolute top-[-3%] left-[-15%] laptop:top-[-40%] laptop:left-[27%]",
              src: "/images/letter-large.webp",
              lazy: !0,
            }),
            m.jsx(Ln, {
              className:
                "absolute top-[34%] left-[60%] laptop:top-[60%] laptop:left-[37%]",
              src: "/images/letter-medium.webp",
              lazy: !0,
            }),
            m.jsx(Ln, {
              className:
                "absolute top-[-5%] left-[83%] laptop:top-[-30%] laptop:left-[42%]",
              src: "/images/letter-small.webp",
              lazy: !0,
            }),
            m.jsx("h3", {
              className:
                "text-white text-[28px] laptop:text-[32px] text-center laptop:text-left font-semibold leading-[120%] laptop:max-w-[221px] mb-[8px] laptop:mb-0",
              children: "Subscribe to our newsletter",
            }),
            m.jsxs("div", {
              style: {
                border: "1px solid rgba(255, 255, 255, 0.12)",
                background: s ? "rgba(106, 86, 246, 0.24)" : "#020106",
              },
              className:
                "w-full laptop:w-[440px] rounded-[42px] backdrop-blur-[12px] py-[13px] laptop:py-[6px] pr-[6px] pl-[16px] laptop:pl-[20px] flex",
              children: [
                m.jsx("input", {
                  value: t,
                  disabled: s,
                  onChange: (h) => d(h),
                  placeholder: s
                    ? "Thank you for subscribing!"
                    : "Enter your email",
                  className:
                    "outline-0 bg-transparent text-white placeholder:text-[#B9C0D4] laptop:text-[18px] leading-[24px] flex-[1_1_50%]",
                }),
                m.jsx(Nr, {
                  style: { background: u },
                  disabled: s,
                  loading: a,
                  onClick: () => f(),
                  className: xn(
                    c,
                    "ml-auto hidden laptop:block",
                    { "laptop:w-[180px]": !s },
                    { "!border-[#6A56F6] !px-[14px]": s }
                  ),
                  variant: "outline",
                  size: "48",
                  children: s ? m.jsx(yz, {}) : "Subscribe",
                }),
              ],
            }),
            m.jsx(Nr, {
              style: { background: u },
              fullWidth: !0,
              onClick: () => f(),
              disabled: s,
              loading: a,
              className: xn(c, "laptop:hidden", { "!border-[#6A56F6]": s }),
              variant: "outline",
              size: "52",
              children: s ? m.jsx(yz, {}) : "Subscribe",
            }),
          ],
        }),
      ],
    });
  };
var kc = ((e) => (
    (e.FIAT = "Buy with card"), (e.CRYPTO = "Buy with crypto"), e
  ))(kc || {}),
  Cg = ((e) => ((e.ASC = "ASC"), (e.DESC = "DESC"), e))(Cg || {}),
  kb = ((e) => (
    (e[(e.Short = 0)] = "Short"),
    (e[(e.Long = 1)] = "Long"),
    (e[(e.m_9 = 2)] = "m_9"),
    e
  ))(kb || {}),
  Yee = ((e) => ((e.date = "date"), e))(Yee || {}),
  wo = ((e) => ((e[(e.solana = 0)] = "solana"), (e[(e.evm = 1)] = "evm"), e))(
    wo || {}
  );
const yIe = "logger/5.7.0";
let vz = !1,
  wz = !1;
const V4 = { debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5 };
let bz = V4.default,
  RC = null;
function vIe() {
  try {
    const e = [];
    if (
      (["NFD", "NFC", "NFKD", "NFKC"].forEach((t) => {
        try {
          if ("test".normalize(t) !== "test") throw new Error("bad normalize");
        } catch {
          e.push(t);
        }
      }),
      e.length)
    )
      throw new Error("missing " + e.join(", "));
    if ("é".normalize("NFD") !== "é") throw new Error("broken implementation");
  } catch (e) {
    return e.message;
  }
  return null;
}
const xz = vIe();
var iM;
(function (e) {
  (e.DEBUG = "DEBUG"),
    (e.INFO = "INFO"),
    (e.WARNING = "WARNING"),
    (e.ERROR = "ERROR"),
    (e.OFF = "OFF");
})(iM || (iM = {}));
var lu;
(function (e) {
  (e.UNKNOWN_ERROR = "UNKNOWN_ERROR"),
    (e.NOT_IMPLEMENTED = "NOT_IMPLEMENTED"),
    (e.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION"),
    (e.NETWORK_ERROR = "NETWORK_ERROR"),
    (e.SERVER_ERROR = "SERVER_ERROR"),
    (e.TIMEOUT = "TIMEOUT"),
    (e.BUFFER_OVERRUN = "BUFFER_OVERRUN"),
    (e.NUMERIC_FAULT = "NUMERIC_FAULT"),
    (e.MISSING_NEW = "MISSING_NEW"),
    (e.INVALID_ARGUMENT = "INVALID_ARGUMENT"),
    (e.MISSING_ARGUMENT = "MISSING_ARGUMENT"),
    (e.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT"),
    (e.CALL_EXCEPTION = "CALL_EXCEPTION"),
    (e.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS"),
    (e.NONCE_EXPIRED = "NONCE_EXPIRED"),
    (e.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED"),
    (e.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT"),
    (e.TRANSACTION_REPLACED = "TRANSACTION_REPLACED"),
    (e.ACTION_REJECTED = "ACTION_REJECTED");
})(lu || (lu = {}));
const _z = "0123456789abcdef";
let $e = class Ys {
  constructor(t) {
    Object.defineProperty(this, "version", {
      enumerable: !0,
      value: t,
      writable: !1,
    });
  }
  _log(t, n) {
    const r = t.toLowerCase();
    V4[r] == null &&
      this.throwArgumentError("invalid log level name", "logLevel", t),
      !(bz > V4[r]) && console.log.apply(console, n);
  }
  debug(...t) {
    this._log(Ys.levels.DEBUG, t);
  }
  info(...t) {
    this._log(Ys.levels.INFO, t);
  }
  warn(...t) {
    this._log(Ys.levels.WARNING, t);
  }
  makeError(t, n, r) {
    if (wz) return this.makeError("censored error", n, {});
    n || (n = Ys.errors.UNKNOWN_ERROR), r || (r = {});
    const i = [];
    Object.keys(r).forEach((l) => {
      const c = r[l];
      try {
        if (c instanceof Uint8Array) {
          let u = "";
          for (let d = 0; d < c.length; d++)
            (u += _z[c[d] >> 4]), (u += _z[c[d] & 15]);
          i.push(l + "=Uint8Array(0x" + u + ")");
        } else i.push(l + "=" + JSON.stringify(c));
      } catch {
        i.push(l + "=" + JSON.stringify(r[l].toString()));
      }
    }),
      i.push(`code=${n}`),
      i.push(`version=${this.version}`);
    const s = t;
    let o = "";
    switch (n) {
      case lu.NUMERIC_FAULT: {
        o = "NUMERIC_FAULT";
        const l = t;
        switch (l) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            o += "-" + l;
            break;
          case "negative-power":
          case "negative-width":
            o += "-unsupported";
            break;
          case "unbound-bitwise-result":
            o += "-unbound-result";
            break;
        }
        break;
      }
      case lu.CALL_EXCEPTION:
      case lu.INSUFFICIENT_FUNDS:
      case lu.MISSING_NEW:
      case lu.NONCE_EXPIRED:
      case lu.REPLACEMENT_UNDERPRICED:
      case lu.TRANSACTION_REPLACED:
      case lu.UNPREDICTABLE_GAS_LIMIT:
        o = n;
        break;
    }
    o && (t += " [ See: https://links.ethers.org/v5-errors-" + o + " ]"),
      i.length && (t += " (" + i.join(", ") + ")");
    const a = new Error(t);
    return (
      (a.reason = s),
      (a.code = n),
      Object.keys(r).forEach(function (l) {
        a[l] = r[l];
      }),
      a
    );
  }
  throwError(t, n, r) {
    throw this.makeError(t, n, r);
  }
  throwArgumentError(t, n, r) {
    return this.throwError(t, Ys.errors.INVALID_ARGUMENT, {
      argument: n,
      value: r,
    });
  }
  assert(t, n, r, i) {
    t || this.throwError(n, r, i);
  }
  assertArgument(t, n, r, i) {
    t || this.throwArgumentError(n, r, i);
  }
  checkNormalize(t) {
    xz &&
      this.throwError(
        "platform missing String.prototype.normalize",
        Ys.errors.UNSUPPORTED_OPERATION,
        { operation: "String.prototype.normalize", form: xz }
      );
  }
  checkSafeUint53(t, n) {
    typeof t == "number" &&
      (n == null && (n = "value not safe"),
      (t < 0 || t >= 9007199254740991) &&
        this.throwError(n, Ys.errors.NUMERIC_FAULT, {
          operation: "checkSafeInteger",
          fault: "out-of-safe-range",
          value: t,
        }),
      t % 1 &&
        this.throwError(n, Ys.errors.NUMERIC_FAULT, {
          operation: "checkSafeInteger",
          fault: "non-integer",
          value: t,
        }));
  }
  checkArgumentCount(t, n, r) {
    r ? (r = ": " + r) : (r = ""),
      t < n &&
        this.throwError("missing argument" + r, Ys.errors.MISSING_ARGUMENT, {
          count: t,
          expectedCount: n,
        }),
      t > n &&
        this.throwError(
          "too many arguments" + r,
          Ys.errors.UNEXPECTED_ARGUMENT,
          { count: t, expectedCount: n }
        );
  }
  checkNew(t, n) {
    (t === Object || t == null) &&
      this.throwError("missing new", Ys.errors.MISSING_NEW, { name: n.name });
  }
  checkAbstract(t, n) {
    t === n
      ? this.throwError(
          "cannot instantiate abstract class " +
            JSON.stringify(n.name) +
            " directly; use a sub-class",
          Ys.errors.UNSUPPORTED_OPERATION,
          { name: t.name, operation: "new" }
        )
      : (t === Object || t == null) &&
        this.throwError("missing new", Ys.errors.MISSING_NEW, { name: n.name });
  }
  static globalLogger() {
    return RC || (RC = new Ys(yIe)), RC;
  }
  static setCensorship(t, n) {
    if (
      (!t &&
        n &&
        this.globalLogger().throwError(
          "cannot permanently disable censorship",
          Ys.errors.UNSUPPORTED_OPERATION,
          { operation: "setCensorship" }
        ),
      vz)
    ) {
      if (!t) return;
      this.globalLogger().throwError(
        "error censorship permanent",
        Ys.errors.UNSUPPORTED_OPERATION,
        { operation: "setCensorship" }
      );
    }
    (wz = !!t), (vz = !!n);
  }
  static setLogLevel(t) {
    const n = V4[t.toLowerCase()];
    if (n == null) {
      Ys.globalLogger().warn("invalid log level - " + t);
      return;
    }
    bz = n;
  }
  static from(t) {
    return new Ys(t);
  }
};
$e.errors = lu;
$e.levels = iM;
const wIe = "bytes/5.7.0",
  xs = new $e(wIe);
function Zee(e) {
  return !!e.toHexString;
}
function ry(e) {
  return (
    e.slice ||
      (e.slice = function () {
        const t = Array.prototype.slice.call(arguments);
        return ry(new Uint8Array(Array.prototype.slice.apply(e, t)));
      }),
    e
  );
}
function LO(e) {
  return (ri(e) && !(e.length % 2)) || G8(e);
}
function Sz(e) {
  return typeof e == "number" && e == e && e % 1 === 0;
}
function G8(e) {
  if (e == null) return !1;
  if (e.constructor === Uint8Array) return !0;
  if (typeof e == "string" || !Sz(e.length) || e.length < 0) return !1;
  for (let t = 0; t < e.length; t++) {
    const n = e[t];
    if (!Sz(n) || n < 0 || n >= 256) return !1;
  }
  return !0;
}
function Nn(e, t) {
  if ((t || (t = {}), typeof e == "number")) {
    xs.checkSafeUint53(e, "invalid arrayify value");
    const n = [];
    for (; e; ) n.unshift(e & 255), (e = parseInt(String(e / 256)));
    return n.length === 0 && n.push(0), ry(new Uint8Array(n));
  }
  if (
    (t.allowMissingPrefix &&
      typeof e == "string" &&
      e.substring(0, 2) !== "0x" &&
      (e = "0x" + e),
    Zee(e) && (e = e.toHexString()),
    ri(e))
  ) {
    let n = e.substring(2);
    n.length % 2 &&
      (t.hexPad === "left"
        ? (n = "0" + n)
        : t.hexPad === "right"
        ? (n += "0")
        : xs.throwArgumentError("hex data is odd-length", "value", e));
    const r = [];
    for (let i = 0; i < n.length; i += 2)
      r.push(parseInt(n.substring(i, i + 2), 16));
    return ry(new Uint8Array(r));
  }
  return G8(e)
    ? ry(new Uint8Array(e))
    : xs.throwArgumentError("invalid arrayify value", "value", e);
}
function Ec(e) {
  const t = e.map((i) => Nn(i)),
    n = t.reduce((i, s) => i + s.length, 0),
    r = new Uint8Array(n);
  return t.reduce((i, s) => (r.set(s, i), i + s.length), 0), ry(r);
}
function $y(e) {
  let t = Nn(e);
  if (t.length === 0) return t;
  let n = 0;
  for (; n < t.length && t[n] === 0; ) n++;
  return n && (t = t.slice(n)), t;
}
function bIe(e, t) {
  (e = Nn(e)),
    e.length > t &&
      xs.throwArgumentError("value out of range", "value", arguments[0]);
  const n = new Uint8Array(t);
  return n.set(e, t - e.length), ry(n);
}
function ri(e, t) {
  return !(
    typeof e != "string" ||
    !e.match(/^0x[0-9A-Fa-f]*$/) ||
    (t && e.length !== 2 + 2 * t)
  );
}
const OC = "0123456789abcdef";
function vn(e, t) {
  if ((t || (t = {}), typeof e == "number")) {
    xs.checkSafeUint53(e, "invalid hexlify value");
    let n = "";
    for (; e; ) (n = OC[e & 15] + n), (e = Math.floor(e / 16));
    return n.length ? (n.length % 2 && (n = "0" + n), "0x" + n) : "0x00";
  }
  if (typeof e == "bigint")
    return (e = e.toString(16)), e.length % 2 ? "0x0" + e : "0x" + e;
  if (
    (t.allowMissingPrefix &&
      typeof e == "string" &&
      e.substring(0, 2) !== "0x" &&
      (e = "0x" + e),
    Zee(e))
  )
    return e.toHexString();
  if (ri(e))
    return (
      e.length % 2 &&
        (t.hexPad === "left"
          ? (e = "0x0" + e.substring(2))
          : t.hexPad === "right"
          ? (e += "0")
          : xs.throwArgumentError("hex data is odd-length", "value", e)),
      e.toLowerCase()
    );
  if (G8(e)) {
    let n = "0x";
    for (let r = 0; r < e.length; r++) {
      let i = e[r];
      n += OC[(i & 240) >> 4] + OC[i & 15];
    }
    return n;
  }
  return xs.throwArgumentError("invalid hexlify value", "value", e);
}
function _v(e) {
  if (typeof e != "string") e = vn(e);
  else if (!ri(e) || e.length % 2) return null;
  return (e.length - 2) / 2;
}
function Qf(e, t, n) {
  return (
    typeof e != "string"
      ? (e = vn(e))
      : (!ri(e) || e.length % 2) &&
        xs.throwArgumentError("invalid hexData", "value", e),
    (t = 2 + 2 * t),
    n != null ? "0x" + e.substring(t, 2 + 2 * n) : "0x" + e.substring(t)
  );
}
function Up(e) {
  let t = "0x";
  return (
    e.forEach((n) => {
      t += vn(n).substring(2);
    }),
    t
  );
}
function jO(e) {
  const t = xIe(vn(e, { hexPad: "left" }));
  return t === "0x" ? "0x0" : t;
}
function xIe(e) {
  typeof e != "string" && (e = vn(e)),
    ri(e) || xs.throwArgumentError("invalid hex string", "value", e),
    (e = e.substring(2));
  let t = 0;
  for (; t < e.length && e[t] === "0"; ) t++;
  return "0x" + e.substring(t);
}
function io(e, t) {
  for (
    typeof e != "string"
      ? (e = vn(e))
      : ri(e) || xs.throwArgumentError("invalid hex string", "value", e),
      e.length > 2 * t + 2 &&
        xs.throwArgumentError("value out of range", "value", arguments[1]);
    e.length < 2 * t + 2;

  )
    e = "0x0" + e.substring(2);
  return e;
}
function q8(e) {
  const t = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x",
  };
  if (LO(e)) {
    let n = Nn(e);
    n.length === 64
      ? ((t.v = 27 + (n[32] >> 7)),
        (n[32] &= 127),
        (t.r = vn(n.slice(0, 32))),
        (t.s = vn(n.slice(32, 64))))
      : n.length === 65
      ? ((t.r = vn(n.slice(0, 32))), (t.s = vn(n.slice(32, 64))), (t.v = n[64]))
      : xs.throwArgumentError("invalid signature string", "signature", e),
      t.v < 27 &&
        (t.v === 0 || t.v === 1
          ? (t.v += 27)
          : xs.throwArgumentError("signature invalid v byte", "signature", e)),
      (t.recoveryParam = 1 - (t.v % 2)),
      t.recoveryParam && (n[32] |= 128),
      (t._vs = vn(n.slice(32, 64)));
  } else {
    if (
      ((t.r = e.r),
      (t.s = e.s),
      (t.v = e.v),
      (t.recoveryParam = e.recoveryParam),
      (t._vs = e._vs),
      t._vs != null)
    ) {
      const i = bIe(Nn(t._vs), 32);
      t._vs = vn(i);
      const s = i[0] >= 128 ? 1 : 0;
      t.recoveryParam == null
        ? (t.recoveryParam = s)
        : t.recoveryParam !== s &&
          xs.throwArgumentError(
            "signature recoveryParam mismatch _vs",
            "signature",
            e
          ),
        (i[0] &= 127);
      const o = vn(i);
      t.s == null
        ? (t.s = o)
        : t.s !== o &&
          xs.throwArgumentError("signature v mismatch _vs", "signature", e);
    }
    if (t.recoveryParam == null)
      t.v == null
        ? xs.throwArgumentError(
            "signature missing v and recoveryParam",
            "signature",
            e
          )
        : t.v === 0 || t.v === 1
        ? (t.recoveryParam = t.v)
        : (t.recoveryParam = 1 - (t.v % 2));
    else if (t.v == null) t.v = 27 + t.recoveryParam;
    else {
      const i = t.v === 0 || t.v === 1 ? t.v : 1 - (t.v % 2);
      t.recoveryParam !== i &&
        xs.throwArgumentError(
          "signature recoveryParam mismatch v",
          "signature",
          e
        );
    }
    t.r == null || !ri(t.r)
      ? xs.throwArgumentError("signature missing or invalid r", "signature", e)
      : (t.r = io(t.r, 32)),
      t.s == null || !ri(t.s)
        ? xs.throwArgumentError(
            "signature missing or invalid s",
            "signature",
            e
          )
        : (t.s = io(t.s, 32));
    const n = Nn(t.s);
    n[0] >= 128 &&
      xs.throwArgumentError("signature s out of range", "signature", e),
      t.recoveryParam && (n[0] |= 128);
    const r = vn(n);
    t._vs &&
      (ri(t._vs) ||
        xs.throwArgumentError("signature invalid _vs", "signature", e),
      (t._vs = io(t._vs, 32))),
      t._vs == null
        ? (t._vs = r)
        : t._vs !== r &&
          xs.throwArgumentError(
            "signature _vs mismatch v and s",
            "signature",
            e
          );
  }
  return (
    (t.yParityAndS = t._vs), (t.compact = t.r + t.yParityAndS.substring(2)), t
  );
}
const _Ie = "bignumber/5.7.0";
var V5 = sn.BN;
const Sf = new $e(_Ie),
  PC = {},
  Ez = 9007199254740991;
let Az = !1;
class Ut {
  constructor(t, n) {
    t !== PC &&
      Sf.throwError(
        "cannot call constructor directly; use BigNumber.from",
        $e.errors.UNSUPPORTED_OPERATION,
        { operation: "new (BigNumber)" }
      ),
      (this._hex = n),
      (this._isBigNumber = !0),
      Object.freeze(this);
  }
  fromTwos(t) {
    return Wa(_r(this).fromTwos(t));
  }
  toTwos(t) {
    return Wa(_r(this).toTwos(t));
  }
  abs() {
    return this._hex[0] === "-" ? Ut.from(this._hex.substring(1)) : this;
  }
  add(t) {
    return Wa(_r(this).add(_r(t)));
  }
  sub(t) {
    return Wa(_r(this).sub(_r(t)));
  }
  div(t) {
    return (
      Ut.from(t).isZero() && lc("division-by-zero", "div"),
      Wa(_r(this).div(_r(t)))
    );
  }
  mul(t) {
    return Wa(_r(this).mul(_r(t)));
  }
  mod(t) {
    const n = _r(t);
    return n.isNeg() && lc("division-by-zero", "mod"), Wa(_r(this).umod(n));
  }
  pow(t) {
    const n = _r(t);
    return n.isNeg() && lc("negative-power", "pow"), Wa(_r(this).pow(n));
  }
  and(t) {
    const n = _r(t);
    return (
      (this.isNegative() || n.isNeg()) && lc("unbound-bitwise-result", "and"),
      Wa(_r(this).and(n))
    );
  }
  or(t) {
    const n = _r(t);
    return (
      (this.isNegative() || n.isNeg()) && lc("unbound-bitwise-result", "or"),
      Wa(_r(this).or(n))
    );
  }
  xor(t) {
    const n = _r(t);
    return (
      (this.isNegative() || n.isNeg()) && lc("unbound-bitwise-result", "xor"),
      Wa(_r(this).xor(n))
    );
  }
  mask(t) {
    return (
      (this.isNegative() || t < 0) && lc("negative-width", "mask"),
      Wa(_r(this).maskn(t))
    );
  }
  shl(t) {
    return (
      (this.isNegative() || t < 0) && lc("negative-width", "shl"),
      Wa(_r(this).shln(t))
    );
  }
  shr(t) {
    return (
      (this.isNegative() || t < 0) && lc("negative-width", "shr"),
      Wa(_r(this).shrn(t))
    );
  }
  eq(t) {
    return _r(this).eq(_r(t));
  }
  lt(t) {
    return _r(this).lt(_r(t));
  }
  lte(t) {
    return _r(this).lte(_r(t));
  }
  gt(t) {
    return _r(this).gt(_r(t));
  }
  gte(t) {
    return _r(this).gte(_r(t));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return _r(this).isZero();
  }
  toNumber() {
    try {
      return _r(this).toNumber();
    } catch {
      lc("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch {}
    return Sf.throwError(
      "this platform does not support BigInt",
      $e.errors.UNSUPPORTED_OPERATION,
      { value: this.toString() }
    );
  }
  toString() {
    return (
      arguments.length > 0 &&
        (arguments[0] === 10
          ? Az ||
            ((Az = !0),
            Sf.warn(
              "BigNumber.toString does not accept any parameters; base-10 is assumed"
            ))
          : arguments[0] === 16
          ? Sf.throwError(
              "BigNumber.toString does not accept any parameters; use bigNumber.toHexString()",
              $e.errors.UNEXPECTED_ARGUMENT,
              {}
            )
          : Sf.throwError(
              "BigNumber.toString does not accept parameters",
              $e.errors.UNEXPECTED_ARGUMENT,
              {}
            )),
      _r(this).toString(10)
    );
  }
  toHexString() {
    return this._hex;
  }
  toJSON(t) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(t) {
    if (t instanceof Ut) return t;
    if (typeof t == "string")
      return t.match(/^-?0x[0-9a-f]+$/i)
        ? new Ut(PC, Tb(t))
        : t.match(/^-?[0-9]+$/)
        ? new Ut(PC, Tb(new V5(t)))
        : Sf.throwArgumentError("invalid BigNumber string", "value", t);
    if (typeof t == "number")
      return (
        t % 1 && lc("underflow", "BigNumber.from", t),
        (t >= Ez || t <= -Ez) && lc("overflow", "BigNumber.from", t),
        Ut.from(String(t))
      );
    const n = t;
    if (typeof n == "bigint") return Ut.from(n.toString());
    if (G8(n)) return Ut.from(vn(n));
    if (n)
      if (n.toHexString) {
        const r = n.toHexString();
        if (typeof r == "string") return Ut.from(r);
      } else {
        let r = n._hex;
        if (
          (r == null && n.type === "BigNumber" && (r = n.hex),
          typeof r == "string" &&
            (ri(r) || (r[0] === "-" && ri(r.substring(1)))))
        )
          return Ut.from(r);
      }
    return Sf.throwArgumentError("invalid BigNumber value", "value", t);
  }
  static isBigNumber(t) {
    return !!(t && t._isBigNumber);
  }
}
function Tb(e) {
  if (typeof e != "string") return Tb(e.toString(16));
  if (e[0] === "-")
    return (
      (e = e.substring(1)),
      e[0] === "-" && Sf.throwArgumentError("invalid hex", "value", e),
      (e = Tb(e)),
      e === "0x00" ? e : "-" + e
    );
  if ((e.substring(0, 2) !== "0x" && (e = "0x" + e), e === "0x")) return "0x00";
  for (
    e.length % 2 && (e = "0x0" + e.substring(2));
    e.length > 4 && e.substring(0, 4) === "0x00";

  )
    e = "0x" + e.substring(4);
  return e;
}
function Wa(e) {
  return Ut.from(Tb(e));
}
function _r(e) {
  const t = Ut.from(e).toHexString();
  return t[0] === "-"
    ? new V5("-" + t.substring(3), 16)
    : new V5(t.substring(2), 16);
}
function lc(e, t, n) {
  const r = { fault: e, operation: t };
  return (
    n != null && (r.value = n), Sf.throwError(e, $e.errors.NUMERIC_FAULT, r)
  );
}
function SIe(e) {
  return new V5(e, 36).toString(16);
}
const EIe = "properties/5.7.0";
var AIe = function (e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(u) {
      try {
        c(r.next(u));
      } catch (d) {
        o(d);
      }
    }
    function l(u) {
      try {
        c(r.throw(u));
      } catch (d) {
        o(d);
      }
    }
    function c(u) {
      u.done ? s(u.value) : i(u.value).then(a, l);
    }
    c((r = r.apply(e, t || [])).next());
  });
};
const G5 = new $e(EIe);
function dt(e, t, n) {
  Object.defineProperty(e, t, { enumerable: !0, value: n, writable: !1 });
}
function md(e, t) {
  for (let n = 0; n < 32; n++) {
    if (e[t]) return e[t];
    if (!e.prototype || typeof e.prototype != "object") break;
    e = Object.getPrototypeOf(e.prototype).constructor;
  }
  return null;
}
function Us(e) {
  return AIe(this, void 0, void 0, function* () {
    const t = Object.keys(e).map((r) => {
      const i = e[r];
      return Promise.resolve(i).then((s) => ({ key: r, value: s }));
    });
    return (yield Promise.all(t)).reduce(
      (r, i) => ((r[i.key] = i.value), r),
      {}
    );
  });
}
function CIe(e, t) {
  (!e || typeof e != "object") &&
    G5.throwArgumentError("invalid object", "object", e),
    Object.keys(e).forEach((n) => {
      t[n] ||
        G5.throwArgumentError(
          "invalid object key - " + n,
          "transaction:" + n,
          e
        );
    });
}
function fa(e) {
  const t = {};
  for (const n in e) t[n] = e[n];
  return t;
}
const kIe = { bigint: !0, boolean: !0, function: !0, number: !0, string: !0 };
function Qee(e) {
  if (e == null || kIe[typeof e]) return !0;
  if (Array.isArray(e) || typeof e == "object") {
    if (!Object.isFrozen(e)) return !1;
    const t = Object.keys(e);
    for (let n = 0; n < t.length; n++) {
      let r = null;
      try {
        r = e[t[n]];
      } catch {
        continue;
      }
      if (!Qee(r)) return !1;
    }
    return !0;
  }
  return G5.throwArgumentError(`Cannot deepCopy ${typeof e}`, "object", e);
}
function TIe(e) {
  if (Qee(e)) return e;
  if (Array.isArray(e)) return Object.freeze(e.map((t) => dh(t)));
  if (typeof e == "object") {
    const t = {};
    for (const n in e) {
      const r = e[n];
      r !== void 0 && dt(t, n, dh(r));
    }
    return t;
  }
  return G5.throwArgumentError(`Cannot deepCopy ${typeof e}`, "object", e);
}
function dh(e) {
  return TIe(e);
}
class Hx {
  constructor(t) {
    for (const n in t) this[n] = dh(t[n]);
  }
}
const Vx = "abi/5.4.0",
  Ir = new $e(Vx),
  Jm = {};
let Cz = { calldata: !0, memory: !0, storage: !0 },
  MIe = { calldata: !0, memory: !0 };
function F_(e, t) {
  if (e === "bytes" || e === "string") {
    if (Cz[t]) return !0;
  } else if (e === "address") {
    if (t === "payable") return !0;
  } else if ((e.indexOf("[") >= 0 || e === "tuple") && MIe[t]) return !0;
  return (
    (Cz[t] || t === "payable") &&
      Ir.throwArgumentError("invalid modifier", "name", t),
    !1
  );
}
function IIe(e, t) {
  let n = e;
  function r(a) {
    Ir.throwArgumentError(`unexpected character at position ${a}`, "param", e);
  }
  e = e.replace(/\s/g, " ");
  function i(a) {
    let l = { type: "", name: "", parent: a, state: { allowType: !0 } };
    return t && (l.indexed = !1), l;
  }
  let s = { type: "", name: "", state: { allowType: !0 } },
    o = s;
  for (let a = 0; a < e.length; a++) {
    let l = e[a];
    switch (l) {
      case "(":
        o.state.allowType && o.type === ""
          ? (o.type = "tuple")
          : o.state.allowParams || r(a),
          (o.state.allowType = !1),
          (o.type = og(o.type)),
          (o.components = [i(o)]),
          (o = o.components[0]);
        break;
      case ")":
        delete o.state,
          o.name === "indexed" && (t || r(a), (o.indexed = !0), (o.name = "")),
          F_(o.type, o.name) && (o.name = ""),
          (o.type = og(o.type));
        let c = o;
        (o = o.parent),
          o || r(a),
          delete c.parent,
          (o.state.allowParams = !1),
          (o.state.allowName = !0),
          (o.state.allowArray = !0);
        break;
      case ",":
        delete o.state,
          o.name === "indexed" && (t || r(a), (o.indexed = !0), (o.name = "")),
          F_(o.type, o.name) && (o.name = ""),
          (o.type = og(o.type));
        let u = i(o.parent);
        o.parent.components.push(u), delete o.parent, (o = u);
        break;
      case " ":
        o.state.allowType &&
          o.type !== "" &&
          ((o.type = og(o.type)),
          delete o.state.allowType,
          (o.state.allowName = !0),
          (o.state.allowParams = !0)),
          o.state.allowName &&
            o.name !== "" &&
            (o.name === "indexed"
              ? (t || r(a), o.indexed && r(a), (o.indexed = !0), (o.name = ""))
              : F_(o.type, o.name)
              ? (o.name = "")
              : (o.state.allowName = !1));
        break;
      case "[":
        o.state.allowArray || r(a),
          (o.type += l),
          (o.state.allowArray = !1),
          (o.state.allowName = !1),
          (o.state.readArray = !0);
        break;
      case "]":
        o.state.readArray || r(a),
          (o.type += l),
          (o.state.readArray = !1),
          (o.state.allowArray = !0),
          (o.state.allowName = !0);
        break;
      default:
        o.state.allowType
          ? ((o.type += l),
            (o.state.allowParams = !0),
            (o.state.allowArray = !0))
          : o.state.allowName
          ? ((o.name += l), delete o.state.allowArray)
          : o.state.readArray
          ? (o.type += l)
          : r(a);
    }
  }
  return (
    o.parent && Ir.throwArgumentError("unexpected eof", "param", e),
    delete s.state,
    o.name === "indexed"
      ? (t || r(n.length - 7),
        o.indexed && r(n.length - 7),
        (o.indexed = !0),
        (o.name = ""))
      : F_(o.type, o.name) && (o.name = ""),
    (s.type = og(s.type)),
    s
  );
}
function G4(e, t) {
  for (let n in t) dt(e, n, t[n]);
}
const Gr = Object.freeze({
    sighash: "sighash",
    minimal: "minimal",
    full: "full",
    json: "json",
  }),
  NIe = new RegExp(/^(.*)\[([0-9]*)\]$/);
class vo {
  constructor(t, n) {
    t !== Jm &&
      Ir.throwError("use fromString", $e.errors.UNSUPPORTED_OPERATION, {
        operation: "new ParamType()",
      }),
      G4(this, n);
    let r = this.type.match(NIe);
    r
      ? G4(this, {
          arrayLength: parseInt(r[2] || "-1"),
          arrayChildren: vo.fromObject({
            type: r[1],
            components: this.components,
          }),
          baseType: "array",
        })
      : G4(this, {
          arrayLength: null,
          arrayChildren: null,
          baseType: this.components != null ? "tuple" : this.type,
        }),
      (this._isParamType = !0),
      Object.freeze(this);
  }
  format(t) {
    if (
      (t || (t = Gr.sighash),
      Gr[t] || Ir.throwArgumentError("invalid format type", "format", t),
      t === Gr.json)
    ) {
      let r = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: this.name || void 0,
      };
      return (
        typeof this.indexed == "boolean" && (r.indexed = this.indexed),
        this.components &&
          (r.components = this.components.map((i) => JSON.parse(i.format(t)))),
        JSON.stringify(r)
      );
    }
    let n = "";
    return (
      this.baseType === "array"
        ? ((n += this.arrayChildren.format(t)),
          (n +=
            "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]"))
        : this.baseType === "tuple"
        ? (t !== Gr.sighash && (n += this.type),
          (n +=
            "(" +
            this.components
              .map((r) => r.format(t))
              .join(t === Gr.full ? ", " : ",") +
            ")"))
        : (n += this.type),
      t !== Gr.sighash &&
        (this.indexed === !0 && (n += " indexed"),
        t === Gr.full && this.name && (n += " " + this.name)),
      n
    );
  }
  static from(t, n) {
    return typeof t == "string" ? vo.fromString(t, n) : vo.fromObject(t);
  }
  static fromObject(t) {
    return vo.isParamType(t)
      ? t
      : new vo(Jm, {
          name: t.name || null,
          type: og(t.type),
          indexed: t.indexed == null ? null : !!t.indexed,
          components: t.components ? t.components.map(vo.fromObject) : null,
        });
  }
  static fromString(t, n) {
    function r(i) {
      return vo.fromObject({
        name: i.name,
        type: i.type,
        indexed: i.indexed,
        components: i.components,
      });
    }
    return r(IIe(t, !!n));
  }
  static isParamType(t) {
    return !!(t != null && t._isParamType);
  }
}
function Mb(e, t) {
  return OIe(e).map((n) => vo.fromString(n, t));
}
class zf {
  constructor(t, n) {
    t !== Jm &&
      Ir.throwError(
        "use a static from method",
        $e.errors.UNSUPPORTED_OPERATION,
        { operation: "new Fragment()" }
      ),
      G4(this, n),
      (this._isFragment = !0),
      Object.freeze(this);
  }
  static from(t) {
    return zf.isFragment(t)
      ? t
      : typeof t == "string"
      ? zf.fromString(t)
      : zf.fromObject(t);
  }
  static fromObject(t) {
    if (zf.isFragment(t)) return t;
    switch (t.type) {
      case "function":
        return ad.fromObject(t);
      case "event":
        return Pf.fromObject(t);
      case "constructor":
        return od.fromObject(t);
      case "error":
        return gp.fromObject(t);
      case "fallback":
      case "receive":
        return null;
    }
    return Ir.throwArgumentError("invalid fragment object", "value", t);
  }
  static fromString(t) {
    return (
      (t = t.replace(/\s/g, " ")),
      (t = t.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ")),
      (t = t.trim()),
      t.split(" ")[0] === "event"
        ? Pf.fromString(t.substring(5).trim())
        : t.split(" ")[0] === "function"
        ? ad.fromString(t.substring(8).trim())
        : t.split("(")[0].trim() === "constructor"
        ? od.fromString(t.trim())
        : t.split(" ")[0] === "error"
        ? gp.fromString(t.substring(5).trim())
        : Ir.throwArgumentError("unsupported fragment", "value", t)
    );
  }
  static isFragment(t) {
    return !!(t && t._isFragment);
  }
}
class Pf extends zf {
  format(t) {
    if (
      (t || (t = Gr.sighash),
      Gr[t] || Ir.throwArgumentError("invalid format type", "format", t),
      t === Gr.json)
    )
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((r) => JSON.parse(r.format(t))),
      });
    let n = "";
    return (
      t !== Gr.sighash && (n += "event "),
      (n +=
        this.name +
        "(" +
        this.inputs.map((r) => r.format(t)).join(t === Gr.full ? ", " : ",") +
        ") "),
      t !== Gr.sighash && this.anonymous && (n += "anonymous "),
      n.trim()
    );
  }
  static from(t) {
    return typeof t == "string" ? Pf.fromString(t) : Pf.fromObject(t);
  }
  static fromObject(t) {
    if (Pf.isEventFragment(t)) return t;
    t.type !== "event" &&
      Ir.throwArgumentError("invalid event object", "value", t);
    const n = {
      name: Ib(t.name),
      anonymous: t.anonymous,
      inputs: t.inputs ? t.inputs.map(vo.fromObject) : [],
      type: "event",
    };
    return new Pf(Jm, n);
  }
  static fromString(t) {
    let n = t.match(Nb);
    n || Ir.throwArgumentError("invalid event string", "value", t);
    let r = !1;
    return (
      n[3].split(" ").forEach((i) => {
        switch (i.trim()) {
          case "anonymous":
            r = !0;
            break;
          case "":
            break;
          default:
            Ir.warn("unknown modifier: " + i);
        }
      }),
      Pf.fromObject({
        name: n[1].trim(),
        anonymous: r,
        inputs: Mb(n[2], !0),
        type: "event",
      })
    );
  }
  static isEventFragment(t) {
    return t && t._isFragment && t.type === "event";
  }
}
function Xee(e, t) {
  t.gas = null;
  let n = e.split("@");
  return n.length !== 1
    ? (n.length > 2 &&
        Ir.throwArgumentError(
          "invalid human-readable ABI signature",
          "value",
          e
        ),
      n[1].match(/^[0-9]+$/) ||
        Ir.throwArgumentError(
          "invalid human-readable ABI signature gas",
          "value",
          e
        ),
      (t.gas = Ut.from(n[1])),
      n[0])
    : e;
}
function Jee(e, t) {
  (t.constant = !1),
    (t.payable = !1),
    (t.stateMutability = "nonpayable"),
    e.split(" ").forEach((n) => {
      switch (n.trim()) {
        case "constant":
          t.constant = !0;
          break;
        case "payable":
          (t.payable = !0), (t.stateMutability = "payable");
          break;
        case "nonpayable":
          (t.payable = !1), (t.stateMutability = "nonpayable");
          break;
        case "pure":
          (t.constant = !0), (t.stateMutability = "pure");
          break;
        case "view":
          (t.constant = !0), (t.stateMutability = "view");
          break;
        case "external":
        case "public":
        case "":
          break;
        default:
          console.log("unknown modifier: " + n);
      }
    });
}
function ete(e) {
  let t = { constant: !1, payable: !0, stateMutability: "payable" };
  return (
    e.stateMutability != null
      ? ((t.stateMutability = e.stateMutability),
        (t.constant =
          t.stateMutability === "view" || t.stateMutability === "pure"),
        e.constant != null &&
          !!e.constant !== t.constant &&
          Ir.throwArgumentError(
            "cannot have constant function with mutability " +
              t.stateMutability,
            "value",
            e
          ),
        (t.payable = t.stateMutability === "payable"),
        e.payable != null &&
          !!e.payable !== t.payable &&
          Ir.throwArgumentError(
            "cannot have payable function with mutability " + t.stateMutability,
            "value",
            e
          ))
      : e.payable != null
      ? ((t.payable = !!e.payable),
        e.constant == null &&
          !t.payable &&
          e.type !== "constructor" &&
          Ir.throwArgumentError(
            "unable to determine stateMutability",
            "value",
            e
          ),
        (t.constant = !!e.constant),
        t.constant
          ? (t.stateMutability = "view")
          : (t.stateMutability = t.payable ? "payable" : "nonpayable"),
        t.payable &&
          t.constant &&
          Ir.throwArgumentError(
            "cannot have constant payable function",
            "value",
            e
          ))
      : e.constant != null
      ? ((t.constant = !!e.constant),
        (t.payable = !t.constant),
        (t.stateMutability = t.constant ? "view" : "payable"))
      : e.type !== "constructor" &&
        Ir.throwArgumentError(
          "unable to determine stateMutability",
          "value",
          e
        ),
    t
  );
}
class od extends zf {
  format(t) {
    if (
      (t || (t = Gr.sighash),
      Gr[t] || Ir.throwArgumentError("invalid format type", "format", t),
      t === Gr.json)
    )
      return JSON.stringify({
        type: "constructor",
        stateMutability:
          this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((r) => JSON.parse(r.format(t))),
      });
    t === Gr.sighash &&
      Ir.throwError(
        "cannot format a constructor for sighash",
        $e.errors.UNSUPPORTED_OPERATION,
        { operation: "format(sighash)" }
      );
    let n =
      "constructor(" +
      this.inputs.map((r) => r.format(t)).join(t === Gr.full ? ", " : ",") +
      ") ";
    return (
      this.stateMutability &&
        this.stateMutability !== "nonpayable" &&
        (n += this.stateMutability + " "),
      n.trim()
    );
  }
  static from(t) {
    return typeof t == "string" ? od.fromString(t) : od.fromObject(t);
  }
  static fromObject(t) {
    if (od.isConstructorFragment(t)) return t;
    t.type !== "constructor" &&
      Ir.throwArgumentError("invalid constructor object", "value", t);
    let n = ete(t);
    n.constant &&
      Ir.throwArgumentError("constructor cannot be constant", "value", t);
    const r = {
      name: null,
      type: t.type,
      inputs: t.inputs ? t.inputs.map(vo.fromObject) : [],
      payable: n.payable,
      stateMutability: n.stateMutability,
      gas: t.gas ? Ut.from(t.gas) : null,
    };
    return new od(Jm, r);
  }
  static fromString(t) {
    let n = { type: "constructor" };
    t = Xee(t, n);
    let r = t.match(Nb);
    return (
      (!r || r[1].trim() !== "constructor") &&
        Ir.throwArgumentError("invalid constructor string", "value", t),
      (n.inputs = Mb(r[2].trim(), !1)),
      Jee(r[3].trim(), n),
      od.fromObject(n)
    );
  }
  static isConstructorFragment(t) {
    return t && t._isFragment && t.type === "constructor";
  }
}
class ad extends od {
  format(t) {
    if (
      (t || (t = Gr.sighash),
      Gr[t] || Ir.throwArgumentError("invalid format type", "format", t),
      t === Gr.json)
    )
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability:
          this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((r) => JSON.parse(r.format(t))),
        outputs: this.outputs.map((r) => JSON.parse(r.format(t))),
      });
    let n = "";
    return (
      t !== Gr.sighash && (n += "function "),
      (n +=
        this.name +
        "(" +
        this.inputs.map((r) => r.format(t)).join(t === Gr.full ? ", " : ",") +
        ") "),
      t !== Gr.sighash &&
        (this.stateMutability
          ? this.stateMutability !== "nonpayable" &&
            (n += this.stateMutability + " ")
          : this.constant && (n += "view "),
        this.outputs &&
          this.outputs.length &&
          (n +=
            "returns (" +
            this.outputs.map((r) => r.format(t)).join(", ") +
            ") "),
        this.gas != null && (n += "@" + this.gas.toString() + " ")),
      n.trim()
    );
  }
  static from(t) {
    return typeof t == "string" ? ad.fromString(t) : ad.fromObject(t);
  }
  static fromObject(t) {
    if (ad.isFunctionFragment(t)) return t;
    t.type !== "function" &&
      Ir.throwArgumentError("invalid function object", "value", t);
    let n = ete(t);
    const r = {
      type: t.type,
      name: Ib(t.name),
      constant: n.constant,
      inputs: t.inputs ? t.inputs.map(vo.fromObject) : [],
      outputs: t.outputs ? t.outputs.map(vo.fromObject) : [],
      payable: n.payable,
      stateMutability: n.stateMutability,
      gas: t.gas ? Ut.from(t.gas) : null,
    };
    return new ad(Jm, r);
  }
  static fromString(t) {
    let n = { type: "function" };
    t = Xee(t, n);
    let r = t.split(" returns ");
    r.length > 2 &&
      Ir.throwArgumentError("invalid function string", "value", t);
    let i = r[0].match(Nb);
    if (
      (i || Ir.throwArgumentError("invalid function signature", "value", t),
      (n.name = i[1].trim()),
      n.name && Ib(n.name),
      (n.inputs = Mb(i[2], !1)),
      Jee(i[3].trim(), n),
      r.length > 1)
    ) {
      let s = r[1].match(Nb);
      (s[1].trim() != "" || s[3].trim() != "") &&
        Ir.throwArgumentError("unexpected tokens", "value", t),
        (n.outputs = Mb(s[2], !1));
    } else n.outputs = [];
    return ad.fromObject(n);
  }
  static isFunctionFragment(t) {
    return t && t._isFragment && t.type === "function";
  }
}
function kz(e) {
  const t = e.format();
  return (
    (t === "Error(string)" || t === "Panic(uint256)") &&
      Ir.throwArgumentError(
        `cannot specify user defined ${t} error`,
        "fragment",
        e
      ),
    e
  );
}
class gp extends zf {
  format(t) {
    if (
      (t || (t = Gr.sighash),
      Gr[t] || Ir.throwArgumentError("invalid format type", "format", t),
      t === Gr.json)
    )
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((r) => JSON.parse(r.format(t))),
      });
    let n = "";
    return (
      t !== Gr.sighash && (n += "error "),
      (n +=
        this.name +
        "(" +
        this.inputs.map((r) => r.format(t)).join(t === Gr.full ? ", " : ",") +
        ") "),
      n.trim()
    );
  }
  static from(t) {
    return typeof t == "string" ? gp.fromString(t) : gp.fromObject(t);
  }
  static fromObject(t) {
    if (gp.isErrorFragment(t)) return t;
    t.type !== "error" &&
      Ir.throwArgumentError("invalid error object", "value", t);
    const n = {
      type: t.type,
      name: Ib(t.name),
      inputs: t.inputs ? t.inputs.map(vo.fromObject) : [],
    };
    return kz(new gp(Jm, n));
  }
  static fromString(t) {
    let n = { type: "error" },
      r = t.match(Nb);
    return (
      r || Ir.throwArgumentError("invalid error signature", "value", t),
      (n.name = r[1].trim()),
      n.name && Ib(n.name),
      (n.inputs = Mb(r[2], !1)),
      kz(gp.fromObject(n))
    );
  }
  static isErrorFragment(t) {
    return t && t._isFragment && t.type === "error";
  }
}
function og(e) {
  return (
    e.match(/^uint($|[^1-9])/)
      ? (e = "uint256" + e.substring(4))
      : e.match(/^int($|[^1-9])/) && (e = "int256" + e.substring(3)),
    e
  );
}
const RIe = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
function Ib(e) {
  return (
    (!e || !e.match(RIe)) &&
      Ir.throwArgumentError(`invalid identifier "${e}"`, "value", e),
    e
  );
}
const Nb = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
function OIe(e) {
  e = e.trim();
  let t = [],
    n = "",
    r = 0;
  for (let i = 0; i < e.length; i++) {
    let s = e[i];
    s === "," && r === 0
      ? (t.push(n), (n = ""))
      : ((n += s),
        s === "("
          ? r++
          : s === ")" &&
            (r--,
            r === -1 &&
              Ir.throwArgumentError("unbalanced parenthesis", "value", e)));
  }
  return n && t.push(n), t;
}
const DO = new $e(Vx);
function PIe(e) {
  const t = [],
    n = function (r, i) {
      if (Array.isArray(i))
        for (let s in i) {
          const o = r.slice();
          o.push(s);
          try {
            n(o, i[s]);
          } catch (a) {
            t.push({ path: o, error: a });
          }
        }
    };
  return n([], e), t;
}
class Sh {
  constructor(t, n, r, i) {
    (this.name = t), (this.type = n), (this.localName = r), (this.dynamic = i);
  }
  _throwError(t, n) {
    DO.throwArgumentError(t, this.localName, n);
  }
}
class sM {
  constructor(t) {
    dt(this, "wordSize", t || 32),
      (this._data = []),
      (this._dataLength = 0),
      (this._padding = new Uint8Array(t));
  }
  get data() {
    return Up(this._data);
  }
  get length() {
    return this._dataLength;
  }
  _writeData(t) {
    return this._data.push(t), (this._dataLength += t.length), t.length;
  }
  appendWriter(t) {
    return this._writeData(Ec(t._data));
  }
  writeBytes(t) {
    let n = Nn(t);
    const r = n.length % this.wordSize;
    return r && (n = Ec([n, this._padding.slice(r)])), this._writeData(n);
  }
  _getValue(t) {
    let n = Nn(Ut.from(t));
    return (
      n.length > this.wordSize &&
        DO.throwError("value out-of-bounds", $e.errors.BUFFER_OVERRUN, {
          length: this.wordSize,
          offset: n.length,
        }),
      n.length % this.wordSize &&
        (n = Ec([this._padding.slice(n.length % this.wordSize), n])),
      n
    );
  }
  writeValue(t) {
    return this._writeData(this._getValue(t));
  }
  writeUpdatableValue() {
    const t = this._data.length;
    return (
      this._data.push(this._padding),
      (this._dataLength += this.wordSize),
      (n) => {
        this._data[t] = this._getValue(n);
      }
    );
  }
}
class q5 {
  constructor(t, n, r, i) {
    dt(this, "_data", Nn(t)),
      dt(this, "wordSize", n || 32),
      dt(this, "_coerceFunc", r),
      dt(this, "allowLoose", i),
      (this._offset = 0);
  }
  get data() {
    return vn(this._data);
  }
  get consumed() {
    return this._offset;
  }
  static coerce(t, n) {
    let r = t.match("^u?int([0-9]+)$");
    return r && parseInt(r[1]) <= 48 && (n = n.toNumber()), n;
  }
  coerce(t, n) {
    return this._coerceFunc ? this._coerceFunc(t, n) : q5.coerce(t, n);
  }
  _peekBytes(t, n, r) {
    let i = Math.ceil(n / this.wordSize) * this.wordSize;
    return (
      this._offset + i > this._data.length &&
        (this.allowLoose && r && this._offset + n <= this._data.length
          ? (i = n)
          : DO.throwError("data out-of-bounds", $e.errors.BUFFER_OVERRUN, {
              length: this._data.length,
              offset: this._offset + i,
            })),
      this._data.slice(this._offset, this._offset + i)
    );
  }
  subReader(t) {
    return new q5(
      this._data.slice(this._offset + t),
      this.wordSize,
      this._coerceFunc,
      this.allowLoose
    );
  }
  readBytes(t, n) {
    let r = this._peekBytes(0, t, !!n);
    return (this._offset += r.length), r.slice(0, t);
  }
  readValue() {
    return Ut.from(this.readBytes(this.wordSize));
  }
}
var tte = { exports: {} };
(function (e) {
  (function () {
    var t = "input is invalid type",
      n = "finalize already called",
      r = typeof window == "object",
      i = r ? window : {};
    i.JS_SHA3_NO_WINDOW && (r = !1);
    var s = !r && typeof self == "object",
      o =
        !i.JS_SHA3_NO_NODE_JS &&
        typeof Hs == "object" &&
        Hs.versions &&
        Hs.versions.node;
    o ? (i = Bn) : s && (i = self);
    var a = !i.JS_SHA3_NO_COMMON_JS && !0 && e.exports,
      l = !i.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u",
      c = "0123456789abcdef".split(""),
      u = [31, 7936, 2031616, 520093696],
      d = [4, 1024, 262144, 67108864],
      f = [1, 256, 65536, 16777216],
      h = [6, 1536, 393216, 100663296],
      p = [0, 8, 16, 24],
      g = [
        1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0,
        2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136,
        0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905,
        2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648,
        32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896,
        2147483648, 2147483649, 0, 2147516424, 2147483648,
      ],
      b = [224, 256, 384, 512],
      v = [128, 256],
      w = ["hex", "buffer", "arrayBuffer", "array", "digest"],
      x = { 128: 168, 256: 136 };
    (i.JS_SHA3_NO_NODE_JS || !Array.isArray) &&
      (Array.isArray = function (G) {
        return Object.prototype.toString.call(G) === "[object Array]";
      }),
      l &&
        (i.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) &&
        (ArrayBuffer.isView = function (G) {
          return (
            typeof G == "object" &&
            G.buffer &&
            G.buffer.constructor === ArrayBuffer
          );
        });
    for (
      var S = function (G, ne, ae) {
          return function (le) {
            return new $(G, ne, G).update(le)[ae]();
          };
        },
        R = function (G, ne, ae) {
          return function (le, ge) {
            return new $(G, ne, ge).update(le)[ae]();
          };
        },
        O = function (G, ne, ae) {
          return function (le, ge, Oe, _e) {
            return _["cshake" + G].update(le, ge, Oe, _e)[ae]();
          };
        },
        B = function (G, ne, ae) {
          return function (le, ge, Oe, _e) {
            return _["kmac" + G].update(le, ge, Oe, _e)[ae]();
          };
        },
        C = function (G, ne, ae, le) {
          for (var ge = 0; ge < w.length; ++ge) {
            var Oe = w[ge];
            G[Oe] = ne(ae, le, Oe);
          }
          return G;
        },
        I = function (G, ne) {
          var ae = S(G, ne, "hex");
          return (
            (ae.create = function () {
              return new $(G, ne, G);
            }),
            (ae.update = function (le) {
              return ae.create().update(le);
            }),
            C(ae, S, G, ne)
          );
        },
        P = function (G, ne) {
          var ae = R(G, ne, "hex");
          return (
            (ae.create = function (le) {
              return new $(G, ne, le);
            }),
            (ae.update = function (le, ge) {
              return ae.create(ge).update(le);
            }),
            C(ae, R, G, ne)
          );
        },
        M = function (G, ne) {
          var ae = x[G],
            le = O(G, ne, "hex");
          return (
            (le.create = function (ge, Oe, _e) {
              return !Oe && !_e
                ? _["shake" + G].create(ge)
                : new $(G, ne, ge).bytepad([Oe, _e], ae);
            }),
            (le.update = function (ge, Oe, _e, Ee) {
              return le.create(Oe, _e, Ee).update(ge);
            }),
            C(le, O, G, ne)
          );
        },
        k = function (G, ne) {
          var ae = x[G],
            le = B(G, ne, "hex");
          return (
            (le.create = function (ge, Oe, _e) {
              return new K(G, ne, Oe)
                .bytepad(["KMAC", _e], ae)
                .bytepad([ge], ae);
            }),
            (le.update = function (ge, Oe, _e, Ee) {
              return le.create(ge, _e, Ee).update(Oe);
            }),
            C(le, B, G, ne)
          );
        },
        T = [
          { name: "keccak", padding: f, bits: b, createMethod: I },
          { name: "sha3", padding: h, bits: b, createMethod: I },
          { name: "shake", padding: u, bits: v, createMethod: P },
          { name: "cshake", padding: d, bits: v, createMethod: M },
          { name: "kmac", padding: d, bits: v, createMethod: k },
        ],
        _ = {},
        A = [],
        N = 0;
      N < T.length;
      ++N
    )
      for (var L = T[N], F = L.bits, D = 0; D < F.length; ++D) {
        var j = L.name + "_" + F[D];
        if (
          (A.push(j),
          (_[j] = L.createMethod(F[D], L.padding)),
          L.name !== "sha3")
        ) {
          var z = L.name + F[D];
          A.push(z), (_[z] = _[j]);
        }
      }
    function $(G, ne, ae) {
      (this.blocks = []),
        (this.s = []),
        (this.padding = ne),
        (this.outputBits = ae),
        (this.reset = !0),
        (this.finalized = !1),
        (this.block = 0),
        (this.start = 0),
        (this.blockCount = (1600 - (G << 1)) >> 5),
        (this.byteCount = this.blockCount << 2),
        (this.outputBlocks = ae >> 5),
        (this.extraBytes = (ae & 31) >> 3);
      for (var le = 0; le < 50; ++le) this.s[le] = 0;
    }
    ($.prototype.update = function (G) {
      if (this.finalized) throw new Error(n);
      var ne,
        ae = typeof G;
      if (ae !== "string") {
        if (ae === "object") {
          if (G === null) throw new Error(t);
          if (l && G.constructor === ArrayBuffer) G = new Uint8Array(G);
          else if (!Array.isArray(G) && (!l || !ArrayBuffer.isView(G)))
            throw new Error(t);
        } else throw new Error(t);
        ne = !0;
      }
      for (
        var le = this.blocks,
          ge = this.byteCount,
          Oe = G.length,
          _e = this.blockCount,
          Ee = 0,
          He = this.s,
          je,
          Be;
        Ee < Oe;

      ) {
        if (this.reset)
          for (this.reset = !1, le[0] = this.block, je = 1; je < _e + 1; ++je)
            le[je] = 0;
        if (ne)
          for (je = this.start; Ee < Oe && je < ge; ++Ee)
            le[je >> 2] |= G[Ee] << p[je++ & 3];
        else
          for (je = this.start; Ee < Oe && je < ge; ++Ee)
            (Be = G.charCodeAt(Ee)),
              Be < 128
                ? (le[je >> 2] |= Be << p[je++ & 3])
                : Be < 2048
                ? ((le[je >> 2] |= (192 | (Be >> 6)) << p[je++ & 3]),
                  (le[je >> 2] |= (128 | (Be & 63)) << p[je++ & 3]))
                : Be < 55296 || Be >= 57344
                ? ((le[je >> 2] |= (224 | (Be >> 12)) << p[je++ & 3]),
                  (le[je >> 2] |= (128 | ((Be >> 6) & 63)) << p[je++ & 3]),
                  (le[je >> 2] |= (128 | (Be & 63)) << p[je++ & 3]))
                : ((Be =
                    65536 +
                    (((Be & 1023) << 10) | (G.charCodeAt(++Ee) & 1023))),
                  (le[je >> 2] |= (240 | (Be >> 18)) << p[je++ & 3]),
                  (le[je >> 2] |= (128 | ((Be >> 12) & 63)) << p[je++ & 3]),
                  (le[je >> 2] |= (128 | ((Be >> 6) & 63)) << p[je++ & 3]),
                  (le[je >> 2] |= (128 | (Be & 63)) << p[je++ & 3]));
        if (((this.lastByteIndex = je), je >= ge)) {
          for (this.start = je - ge, this.block = le[_e], je = 0; je < _e; ++je)
            He[je] ^= le[je];
          re(He), (this.reset = !0);
        } else this.start = je;
      }
      return this;
    }),
      ($.prototype.encode = function (G, ne) {
        var ae = G & 255,
          le = 1,
          ge = [ae];
        for (G = G >> 8, ae = G & 255; ae > 0; )
          ge.unshift(ae), (G = G >> 8), (ae = G & 255), ++le;
        return ne ? ge.push(le) : ge.unshift(le), this.update(ge), ge.length;
      }),
      ($.prototype.encodeString = function (G) {
        var ne,
          ae = typeof G;
        if (ae !== "string") {
          if (ae === "object") {
            if (G === null) throw new Error(t);
            if (l && G.constructor === ArrayBuffer) G = new Uint8Array(G);
            else if (!Array.isArray(G) && (!l || !ArrayBuffer.isView(G)))
              throw new Error(t);
          } else throw new Error(t);
          ne = !0;
        }
        var le = 0,
          ge = G.length;
        if (ne) le = ge;
        else
          for (var Oe = 0; Oe < G.length; ++Oe) {
            var _e = G.charCodeAt(Oe);
            _e < 128
              ? (le += 1)
              : _e < 2048
              ? (le += 2)
              : _e < 55296 || _e >= 57344
              ? (le += 3)
              : ((_e =
                  65536 + (((_e & 1023) << 10) | (G.charCodeAt(++Oe) & 1023))),
                (le += 4));
          }
        return (le += this.encode(le * 8)), this.update(G), le;
      }),
      ($.prototype.bytepad = function (G, ne) {
        for (var ae = this.encode(ne), le = 0; le < G.length; ++le)
          ae += this.encodeString(G[le]);
        var ge = ne - (ae % ne),
          Oe = [];
        return (Oe.length = ge), this.update(Oe), this;
      }),
      ($.prototype.finalize = function () {
        if (!this.finalized) {
          this.finalized = !0;
          var G = this.blocks,
            ne = this.lastByteIndex,
            ae = this.blockCount,
            le = this.s;
          if (
            ((G[ne >> 2] |= this.padding[ne & 3]),
            this.lastByteIndex === this.byteCount)
          )
            for (G[0] = G[ae], ne = 1; ne < ae + 1; ++ne) G[ne] = 0;
          for (G[ae - 1] |= 2147483648, ne = 0; ne < ae; ++ne) le[ne] ^= G[ne];
          re(le);
        }
      }),
      ($.prototype.toString = $.prototype.hex =
        function () {
          this.finalize();
          for (
            var G = this.blockCount,
              ne = this.s,
              ae = this.outputBlocks,
              le = this.extraBytes,
              ge = 0,
              Oe = 0,
              _e = "",
              Ee;
            Oe < ae;

          ) {
            for (ge = 0; ge < G && Oe < ae; ++ge, ++Oe)
              (Ee = ne[ge]),
                (_e +=
                  c[(Ee >> 4) & 15] +
                  c[Ee & 15] +
                  c[(Ee >> 12) & 15] +
                  c[(Ee >> 8) & 15] +
                  c[(Ee >> 20) & 15] +
                  c[(Ee >> 16) & 15] +
                  c[(Ee >> 28) & 15] +
                  c[(Ee >> 24) & 15]);
            Oe % G === 0 && (re(ne), (ge = 0));
          }
          return (
            le &&
              ((Ee = ne[ge]),
              (_e += c[(Ee >> 4) & 15] + c[Ee & 15]),
              le > 1 && (_e += c[(Ee >> 12) & 15] + c[(Ee >> 8) & 15]),
              le > 2 && (_e += c[(Ee >> 20) & 15] + c[(Ee >> 16) & 15])),
            _e
          );
        }),
      ($.prototype.arrayBuffer = function () {
        this.finalize();
        var G = this.blockCount,
          ne = this.s,
          ae = this.outputBlocks,
          le = this.extraBytes,
          ge = 0,
          Oe = 0,
          _e = this.outputBits >> 3,
          Ee;
        le ? (Ee = new ArrayBuffer((ae + 1) << 2)) : (Ee = new ArrayBuffer(_e));
        for (var He = new Uint32Array(Ee); Oe < ae; ) {
          for (ge = 0; ge < G && Oe < ae; ++ge, ++Oe) He[Oe] = ne[ge];
          Oe % G === 0 && re(ne);
        }
        return le && ((He[ge] = ne[ge]), (Ee = Ee.slice(0, _e))), Ee;
      }),
      ($.prototype.buffer = $.prototype.arrayBuffer),
      ($.prototype.digest = $.prototype.array =
        function () {
          this.finalize();
          for (
            var G = this.blockCount,
              ne = this.s,
              ae = this.outputBlocks,
              le = this.extraBytes,
              ge = 0,
              Oe = 0,
              _e = [],
              Ee,
              He;
            Oe < ae;

          ) {
            for (ge = 0; ge < G && Oe < ae; ++ge, ++Oe)
              (Ee = Oe << 2),
                (He = ne[ge]),
                (_e[Ee] = He & 255),
                (_e[Ee + 1] = (He >> 8) & 255),
                (_e[Ee + 2] = (He >> 16) & 255),
                (_e[Ee + 3] = (He >> 24) & 255);
            Oe % G === 0 && re(ne);
          }
          return (
            le &&
              ((Ee = Oe << 2),
              (He = ne[ge]),
              (_e[Ee] = He & 255),
              le > 1 && (_e[Ee + 1] = (He >> 8) & 255),
              le > 2 && (_e[Ee + 2] = (He >> 16) & 255)),
            _e
          );
        });
    function K(G, ne, ae) {
      $.call(this, G, ne, ae);
    }
    (K.prototype = new $()),
      (K.prototype.finalize = function () {
        return (
          this.encode(this.outputBits, !0), $.prototype.finalize.call(this)
        );
      });
    var re = function (G) {
      var ne,
        ae,
        le,
        ge,
        Oe,
        _e,
        Ee,
        He,
        je,
        Be,
        rn,
        Wt,
        Mt,
        an,
        kt,
        Qe,
        Vt,
        Rt,
        mt,
        Pt,
        wn,
        xt,
        Tt,
        _n,
        Q,
        H,
        q,
        ee,
        ce,
        pe,
        we,
        ht,
        vt,
        ct,
        Lt,
        wt,
        Ht,
        mn,
        jn,
        Gt,
        Cn,
        cn,
        Yt,
        ln,
        oe,
        de,
        be,
        Me,
        Fe,
        it,
        ft,
        ze,
        nt,
        Xe,
        Ve,
        bt,
        gt,
        un,
        Rn,
        bn,
        Sn,
        Si,
        vr;
      for (le = 0; le < 48; le += 2)
        (ge = G[0] ^ G[10] ^ G[20] ^ G[30] ^ G[40]),
          (Oe = G[1] ^ G[11] ^ G[21] ^ G[31] ^ G[41]),
          (_e = G[2] ^ G[12] ^ G[22] ^ G[32] ^ G[42]),
          (Ee = G[3] ^ G[13] ^ G[23] ^ G[33] ^ G[43]),
          (He = G[4] ^ G[14] ^ G[24] ^ G[34] ^ G[44]),
          (je = G[5] ^ G[15] ^ G[25] ^ G[35] ^ G[45]),
          (Be = G[6] ^ G[16] ^ G[26] ^ G[36] ^ G[46]),
          (rn = G[7] ^ G[17] ^ G[27] ^ G[37] ^ G[47]),
          (Wt = G[8] ^ G[18] ^ G[28] ^ G[38] ^ G[48]),
          (Mt = G[9] ^ G[19] ^ G[29] ^ G[39] ^ G[49]),
          (ne = Wt ^ ((_e << 1) | (Ee >>> 31))),
          (ae = Mt ^ ((Ee << 1) | (_e >>> 31))),
          (G[0] ^= ne),
          (G[1] ^= ae),
          (G[10] ^= ne),
          (G[11] ^= ae),
          (G[20] ^= ne),
          (G[21] ^= ae),
          (G[30] ^= ne),
          (G[31] ^= ae),
          (G[40] ^= ne),
          (G[41] ^= ae),
          (ne = ge ^ ((He << 1) | (je >>> 31))),
          (ae = Oe ^ ((je << 1) | (He >>> 31))),
          (G[2] ^= ne),
          (G[3] ^= ae),
          (G[12] ^= ne),
          (G[13] ^= ae),
          (G[22] ^= ne),
          (G[23] ^= ae),
          (G[32] ^= ne),
          (G[33] ^= ae),
          (G[42] ^= ne),
          (G[43] ^= ae),
          (ne = _e ^ ((Be << 1) | (rn >>> 31))),
          (ae = Ee ^ ((rn << 1) | (Be >>> 31))),
          (G[4] ^= ne),
          (G[5] ^= ae),
          (G[14] ^= ne),
          (G[15] ^= ae),
          (G[24] ^= ne),
          (G[25] ^= ae),
          (G[34] ^= ne),
          (G[35] ^= ae),
          (G[44] ^= ne),
          (G[45] ^= ae),
          (ne = He ^ ((Wt << 1) | (Mt >>> 31))),
          (ae = je ^ ((Mt << 1) | (Wt >>> 31))),
          (G[6] ^= ne),
          (G[7] ^= ae),
          (G[16] ^= ne),
          (G[17] ^= ae),
          (G[26] ^= ne),
          (G[27] ^= ae),
          (G[36] ^= ne),
          (G[37] ^= ae),
          (G[46] ^= ne),
          (G[47] ^= ae),
          (ne = Be ^ ((ge << 1) | (Oe >>> 31))),
          (ae = rn ^ ((Oe << 1) | (ge >>> 31))),
          (G[8] ^= ne),
          (G[9] ^= ae),
          (G[18] ^= ne),
          (G[19] ^= ae),
          (G[28] ^= ne),
          (G[29] ^= ae),
          (G[38] ^= ne),
          (G[39] ^= ae),
          (G[48] ^= ne),
          (G[49] ^= ae),
          (an = G[0]),
          (kt = G[1]),
          (de = (G[11] << 4) | (G[10] >>> 28)),
          (be = (G[10] << 4) | (G[11] >>> 28)),
          (ee = (G[20] << 3) | (G[21] >>> 29)),
          (ce = (G[21] << 3) | (G[20] >>> 29)),
          (bn = (G[31] << 9) | (G[30] >>> 23)),
          (Sn = (G[30] << 9) | (G[31] >>> 23)),
          (cn = (G[40] << 18) | (G[41] >>> 14)),
          (Yt = (G[41] << 18) | (G[40] >>> 14)),
          (ct = (G[2] << 1) | (G[3] >>> 31)),
          (Lt = (G[3] << 1) | (G[2] >>> 31)),
          (Qe = (G[13] << 12) | (G[12] >>> 20)),
          (Vt = (G[12] << 12) | (G[13] >>> 20)),
          (Me = (G[22] << 10) | (G[23] >>> 22)),
          (Fe = (G[23] << 10) | (G[22] >>> 22)),
          (pe = (G[33] << 13) | (G[32] >>> 19)),
          (we = (G[32] << 13) | (G[33] >>> 19)),
          (Si = (G[42] << 2) | (G[43] >>> 30)),
          (vr = (G[43] << 2) | (G[42] >>> 30)),
          (Xe = (G[5] << 30) | (G[4] >>> 2)),
          (Ve = (G[4] << 30) | (G[5] >>> 2)),
          (wt = (G[14] << 6) | (G[15] >>> 26)),
          (Ht = (G[15] << 6) | (G[14] >>> 26)),
          (Rt = (G[25] << 11) | (G[24] >>> 21)),
          (mt = (G[24] << 11) | (G[25] >>> 21)),
          (it = (G[34] << 15) | (G[35] >>> 17)),
          (ft = (G[35] << 15) | (G[34] >>> 17)),
          (ht = (G[45] << 29) | (G[44] >>> 3)),
          (vt = (G[44] << 29) | (G[45] >>> 3)),
          (_n = (G[6] << 28) | (G[7] >>> 4)),
          (Q = (G[7] << 28) | (G[6] >>> 4)),
          (bt = (G[17] << 23) | (G[16] >>> 9)),
          (gt = (G[16] << 23) | (G[17] >>> 9)),
          (mn = (G[26] << 25) | (G[27] >>> 7)),
          (jn = (G[27] << 25) | (G[26] >>> 7)),
          (Pt = (G[36] << 21) | (G[37] >>> 11)),
          (wn = (G[37] << 21) | (G[36] >>> 11)),
          (ze = (G[47] << 24) | (G[46] >>> 8)),
          (nt = (G[46] << 24) | (G[47] >>> 8)),
          (ln = (G[8] << 27) | (G[9] >>> 5)),
          (oe = (G[9] << 27) | (G[8] >>> 5)),
          (H = (G[18] << 20) | (G[19] >>> 12)),
          (q = (G[19] << 20) | (G[18] >>> 12)),
          (un = (G[29] << 7) | (G[28] >>> 25)),
          (Rn = (G[28] << 7) | (G[29] >>> 25)),
          (Gt = (G[38] << 8) | (G[39] >>> 24)),
          (Cn = (G[39] << 8) | (G[38] >>> 24)),
          (xt = (G[48] << 14) | (G[49] >>> 18)),
          (Tt = (G[49] << 14) | (G[48] >>> 18)),
          (G[0] = an ^ (~Qe & Rt)),
          (G[1] = kt ^ (~Vt & mt)),
          (G[10] = _n ^ (~H & ee)),
          (G[11] = Q ^ (~q & ce)),
          (G[20] = ct ^ (~wt & mn)),
          (G[21] = Lt ^ (~Ht & jn)),
          (G[30] = ln ^ (~de & Me)),
          (G[31] = oe ^ (~be & Fe)),
          (G[40] = Xe ^ (~bt & un)),
          (G[41] = Ve ^ (~gt & Rn)),
          (G[2] = Qe ^ (~Rt & Pt)),
          (G[3] = Vt ^ (~mt & wn)),
          (G[12] = H ^ (~ee & pe)),
          (G[13] = q ^ (~ce & we)),
          (G[22] = wt ^ (~mn & Gt)),
          (G[23] = Ht ^ (~jn & Cn)),
          (G[32] = de ^ (~Me & it)),
          (G[33] = be ^ (~Fe & ft)),
          (G[42] = bt ^ (~un & bn)),
          (G[43] = gt ^ (~Rn & Sn)),
          (G[4] = Rt ^ (~Pt & xt)),
          (G[5] = mt ^ (~wn & Tt)),
          (G[14] = ee ^ (~pe & ht)),
          (G[15] = ce ^ (~we & vt)),
          (G[24] = mn ^ (~Gt & cn)),
          (G[25] = jn ^ (~Cn & Yt)),
          (G[34] = Me ^ (~it & ze)),
          (G[35] = Fe ^ (~ft & nt)),
          (G[44] = un ^ (~bn & Si)),
          (G[45] = Rn ^ (~Sn & vr)),
          (G[6] = Pt ^ (~xt & an)),
          (G[7] = wn ^ (~Tt & kt)),
          (G[16] = pe ^ (~ht & _n)),
          (G[17] = we ^ (~vt & Q)),
          (G[26] = Gt ^ (~cn & ct)),
          (G[27] = Cn ^ (~Yt & Lt)),
          (G[36] = it ^ (~ze & ln)),
          (G[37] = ft ^ (~nt & oe)),
          (G[46] = bn ^ (~Si & Xe)),
          (G[47] = Sn ^ (~vr & Ve)),
          (G[8] = xt ^ (~an & Qe)),
          (G[9] = Tt ^ (~kt & Vt)),
          (G[18] = ht ^ (~_n & H)),
          (G[19] = vt ^ (~Q & q)),
          (G[28] = cn ^ (~ct & wt)),
          (G[29] = Yt ^ (~Lt & Ht)),
          (G[38] = ze ^ (~ln & de)),
          (G[39] = nt ^ (~oe & be)),
          (G[48] = Si ^ (~Xe & bt)),
          (G[49] = vr ^ (~Ve & gt)),
          (G[0] ^= g[le]),
          (G[1] ^= g[le + 1]);
    };
    if (a) e.exports = _;
    else for (N = 0; N < A.length; ++N) i[A[N]] = _[A[N]];
  })();
})(tte);
var LIe = tte.exports;
const jIe = Gi(LIe);
function eo(e) {
  return "0x" + jIe.keccak_256(Nn(e));
}
const DIe = "rlp/5.7.0",
  Xu = new $e(DIe);
function Tz(e) {
  const t = [];
  for (; e; ) t.unshift(e & 255), (e >>= 8);
  return t;
}
function Mz(e, t, n) {
  let r = 0;
  for (let i = 0; i < n; i++) r = r * 256 + e[t + i];
  return r;
}
function nte(e) {
  if (Array.isArray(e)) {
    let r = [];
    if (
      (e.forEach(function (s) {
        r = r.concat(nte(s));
      }),
      r.length <= 55)
    )
      return r.unshift(192 + r.length), r;
    const i = Tz(r.length);
    return i.unshift(247 + i.length), i.concat(r);
  }
  LO(e) || Xu.throwArgumentError("RLP object must be BytesLike", "object", e);
  const t = Array.prototype.slice.call(Nn(e));
  if (t.length === 1 && t[0] <= 127) return t;
  if (t.length <= 55) return t.unshift(128 + t.length), t;
  const n = Tz(t.length);
  return n.unshift(183 + n.length), n.concat(t);
}
function K8(e) {
  return vn(nte(e));
}
function Iz(e, t, n, r) {
  const i = [];
  for (; n < t + 1 + r; ) {
    const s = rte(e, n);
    i.push(s.result),
      (n += s.consumed),
      n > t + 1 + r &&
        Xu.throwError("child data too short", $e.errors.BUFFER_OVERRUN, {});
  }
  return { consumed: 1 + r, result: i };
}
function rte(e, t) {
  if (
    (e.length === 0 &&
      Xu.throwError("data too short", $e.errors.BUFFER_OVERRUN, {}),
    e[t] >= 248)
  ) {
    const n = e[t] - 247;
    t + 1 + n > e.length &&
      Xu.throwError(
        "data short segment too short",
        $e.errors.BUFFER_OVERRUN,
        {}
      );
    const r = Mz(e, t + 1, n);
    return (
      t + 1 + n + r > e.length &&
        Xu.throwError(
          "data long segment too short",
          $e.errors.BUFFER_OVERRUN,
          {}
        ),
      Iz(e, t, t + 1 + n, n + r)
    );
  } else if (e[t] >= 192) {
    const n = e[t] - 192;
    return (
      t + 1 + n > e.length &&
        Xu.throwError("data array too short", $e.errors.BUFFER_OVERRUN, {}),
      Iz(e, t, t + 1, n)
    );
  } else if (e[t] >= 184) {
    const n = e[t] - 183;
    t + 1 + n > e.length &&
      Xu.throwError("data array too short", $e.errors.BUFFER_OVERRUN, {});
    const r = Mz(e, t + 1, n);
    t + 1 + n + r > e.length &&
      Xu.throwError("data array too short", $e.errors.BUFFER_OVERRUN, {});
    const i = vn(e.slice(t + 1 + n, t + 1 + n + r));
    return { consumed: 1 + n + r, result: i };
  } else if (e[t] >= 128) {
    const n = e[t] - 128;
    t + 1 + n > e.length &&
      Xu.throwError("data too short", $e.errors.BUFFER_OVERRUN, {});
    const r = vn(e.slice(t + 1, t + 1 + n));
    return { consumed: 1 + n, result: r };
  }
  return { consumed: 1, result: vn(e[t]) };
}
function BO(e) {
  const t = Nn(e),
    n = rte(t, 0);
  return (
    n.consumed !== t.length &&
      Xu.throwArgumentError("invalid rlp data", "data", e),
    n.result
  );
}
const BIe = "address/5.7.0",
  kg = new $e(BIe);
function Nz(e) {
  ri(e, 20) || kg.throwArgumentError("invalid address", "address", e),
    (e = e.toLowerCase());
  const t = e.substring(2).split(""),
    n = new Uint8Array(40);
  for (let i = 0; i < 40; i++) n[i] = t[i].charCodeAt(0);
  const r = Nn(eo(n));
  for (let i = 0; i < 40; i += 2)
    r[i >> 1] >> 4 >= 8 && (t[i] = t[i].toUpperCase()),
      (r[i >> 1] & 15) >= 8 && (t[i + 1] = t[i + 1].toUpperCase());
  return "0x" + t.join("");
}
const FIe = 9007199254740991;
function UIe(e) {
  return Math.log10 ? Math.log10(e) : Math.log(e) / Math.LN10;
}
const FO = {};
for (let e = 0; e < 10; e++) FO[String(e)] = String(e);
for (let e = 0; e < 26; e++) FO[String.fromCharCode(65 + e)] = String(10 + e);
const Rz = Math.floor(UIe(FIe));
function $Ie(e) {
  (e = e.toUpperCase()), (e = e.substring(4) + e.substring(0, 2) + "00");
  let t = e
    .split("")
    .map((r) => FO[r])
    .join("");
  for (; t.length >= Rz; ) {
    let r = t.substring(0, Rz);
    t = (parseInt(r, 10) % 97) + t.substring(r.length);
  }
  let n = String(98 - (parseInt(t, 10) % 97));
  for (; n.length < 2; ) n = "0" + n;
  return n;
}
function zo(e) {
  let t = null;
  if (
    (typeof e != "string" &&
      kg.throwArgumentError("invalid address", "address", e),
    e.match(/^(0x)?[0-9a-fA-F]{40}$/))
  )
    e.substring(0, 2) !== "0x" && (e = "0x" + e),
      (t = Nz(e)),
      e.match(/([A-F].*[a-f])|([a-f].*[A-F])/) &&
        t !== e &&
        kg.throwArgumentError("bad address checksum", "address", e);
  else if (e.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    for (
      e.substring(2, 4) !== $Ie(e) &&
        kg.throwArgumentError("bad icap checksum", "address", e),
        t = SIe(e.substring(4));
      t.length < 40;

    )
      t = "0" + t;
    t = Nz("0x" + t);
  } else kg.throwArgumentError("invalid address", "address", e);
  return t;
}
function ite(e) {
  let t = null;
  try {
    t = zo(e.from);
  } catch {
    kg.throwArgumentError("missing from address", "transaction", e);
  }
  const n = $y(Nn(Ut.from(e.nonce).toHexString()));
  return zo(Qf(eo(K8([t, n])), 12));
}
class zIe extends Sh {
  constructor(t) {
    super("address", "address", t, !1);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(t, n) {
    try {
      zo(n);
    } catch (r) {
      this._throwError(r.message, n);
    }
    return t.writeValue(n);
  }
  decode(t) {
    return zo(io(t.readValue().toHexString(), 20));
  }
}
class WIe extends Sh {
  constructor(t) {
    super(t.name, t.type, void 0, t.dynamic), (this.coder = t);
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(t, n) {
    return this.coder.encode(t, n);
  }
  decode(t) {
    return this.coder.decode(t);
  }
}
const Tg = new $e(Vx);
function ste(e, t, n) {
  let r = null;
  if (Array.isArray(n)) r = n;
  else if (n && typeof n == "object") {
    let l = {};
    r = t.map((c) => {
      const u = c.localName;
      return (
        u ||
          Tg.throwError(
            "cannot encode object for signature with missing names",
            $e.errors.INVALID_ARGUMENT,
            { argument: "values", coder: c, value: n }
          ),
        l[u] &&
          Tg.throwError(
            "cannot encode object for signature with duplicate names",
            $e.errors.INVALID_ARGUMENT,
            { argument: "values", coder: c, value: n }
          ),
        (l[u] = !0),
        n[u]
      );
    });
  } else Tg.throwArgumentError("invalid tuple value", "tuple", n);
  t.length !== r.length &&
    Tg.throwArgumentError("types/value length mismatch", "tuple", n);
  let i = new sM(e.wordSize),
    s = new sM(e.wordSize),
    o = [];
  t.forEach((l, c) => {
    let u = r[c];
    if (l.dynamic) {
      let d = s.length;
      l.encode(s, u);
      let f = i.writeUpdatableValue();
      o.push((h) => {
        f(h + d);
      });
    } else l.encode(i, u);
  }),
    o.forEach((l) => {
      l(i.length);
    });
  let a = e.appendWriter(i);
  return (a += e.appendWriter(s)), a;
}
function ote(e, t) {
  let n = [],
    r = e.subReader(0);
  t.forEach((s) => {
    let o = null;
    if (s.dynamic) {
      let a = e.readValue(),
        l = r.subReader(a.toNumber());
      try {
        o = s.decode(l);
      } catch (c) {
        if (c.code === $e.errors.BUFFER_OVERRUN) throw c;
        (o = c),
          (o.baseType = s.name),
          (o.name = s.localName),
          (o.type = s.type);
      }
    } else
      try {
        o = s.decode(e);
      } catch (a) {
        if (a.code === $e.errors.BUFFER_OVERRUN) throw a;
        (o = a),
          (o.baseType = s.name),
          (o.name = s.localName),
          (o.type = s.type);
      }
    o != null && n.push(o);
  });
  const i = t.reduce((s, o) => {
    const a = o.localName;
    return a && (s[a] || (s[a] = 0), s[a]++), s;
  }, {});
  t.forEach((s, o) => {
    let a = s.localName;
    if (!a || i[a] !== 1 || (a === "length" && (a = "_length"), n[a] != null))
      return;
    const l = n[o];
    l instanceof Error
      ? Object.defineProperty(n, a, {
          get: () => {
            throw l;
          },
        })
      : (n[a] = l);
  });
  for (let s = 0; s < n.length; s++) {
    const o = n[s];
    o instanceof Error &&
      Object.defineProperty(n, s, {
        get: () => {
          throw o;
        },
      });
  }
  return Object.freeze(n);
}
class HIe extends Sh {
  constructor(t, n, r) {
    const i = t.type + "[" + (n >= 0 ? n : "") + "]",
      s = n === -1 || t.dynamic;
    super("array", i, r, s), (this.coder = t), (this.length = n);
  }
  defaultValue() {
    const t = this.coder.defaultValue(),
      n = [];
    for (let r = 0; r < this.length; r++) n.push(t);
    return n;
  }
  encode(t, n) {
    Array.isArray(n) || this._throwError("expected array value", n);
    let r = this.length;
    r === -1 && ((r = n.length), t.writeValue(n.length)),
      Tg.checkArgumentCount(
        n.length,
        r,
        "coder array" + (this.localName ? " " + this.localName : "")
      );
    let i = [];
    for (let s = 0; s < n.length; s++) i.push(this.coder);
    return ste(t, i, n);
  }
  decode(t) {
    let n = this.length;
    n === -1 &&
      ((n = t.readValue().toNumber()),
      n * 32 > t._data.length &&
        Tg.throwError("insufficient data length", $e.errors.BUFFER_OVERRUN, {
          length: t._data.length,
          count: n,
        }));
    let r = [];
    for (let i = 0; i < n; i++) r.push(new WIe(this.coder));
    return t.coerce(this.name, ote(t, r));
  }
}
class VIe extends Sh {
  constructor(t) {
    super("bool", "bool", t, !1);
  }
  defaultValue() {
    return !1;
  }
  encode(t, n) {
    return t.writeValue(n ? 1 : 0);
  }
  decode(t) {
    return t.coerce(this.type, !t.readValue().isZero());
  }
}
class ate extends Sh {
  constructor(t, n) {
    super(t, t, n, !0);
  }
  defaultValue() {
    return "0x";
  }
  encode(t, n) {
    n = Nn(n);
    let r = t.writeValue(n.length);
    return (r += t.writeBytes(n)), r;
  }
  decode(t) {
    return t.readBytes(t.readValue().toNumber(), !0);
  }
}
class GIe extends ate {
  constructor(t) {
    super("bytes", t);
  }
  decode(t) {
    return t.coerce(this.name, vn(super.decode(t)));
  }
}
class qIe extends Sh {
  constructor(t, n) {
    let r = "bytes" + String(t);
    super(r, r, n, !1), (this.size = t);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(
      0,
      2 + this.size * 2
    );
  }
  encode(t, n) {
    let r = Nn(n);
    return (
      r.length !== this.size && this._throwError("incorrect data length", n),
      t.writeBytes(r)
    );
  }
  decode(t) {
    return t.coerce(this.name, vn(t.readBytes(this.size)));
  }
}
class KIe extends Sh {
  constructor(t) {
    super("null", "", t, !1);
  }
  defaultValue() {
    return null;
  }
  encode(t, n) {
    return n != null && this._throwError("not null", n), t.writeBytes([]);
  }
  decode(t) {
    return t.readBytes(0), t.coerce(this.name, null);
  }
}
const YIe = "0x0000000000000000000000000000000000000000",
  ZIe = Ut.from(-1),
  lte = Ut.from(0),
  QIe = Ut.from(1),
  XIe = Ut.from(
    "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
  ),
  JIe = "0x0000000000000000000000000000000000000000000000000000000000000000";
class eNe extends Sh {
  constructor(t, n, r) {
    const i = (n ? "int" : "uint") + t * 8;
    super(i, i, r, !1), (this.size = t), (this.signed = n);
  }
  defaultValue() {
    return 0;
  }
  encode(t, n) {
    let r = Ut.from(n),
      i = XIe.mask(t.wordSize * 8);
    if (this.signed) {
      let s = i.mask(this.size * 8 - 1);
      (r.gt(s) || r.lt(s.add(QIe).mul(ZIe))) &&
        this._throwError("value out-of-bounds", n);
    } else
      (r.lt(lte) || r.gt(i.mask(this.size * 8))) &&
        this._throwError("value out-of-bounds", n);
    return (
      (r = r.toTwos(this.size * 8).mask(this.size * 8)),
      this.signed && (r = r.fromTwos(this.size * 8).toTwos(8 * t.wordSize)),
      t.writeValue(r)
    );
  }
  decode(t) {
    let n = t.readValue().mask(this.size * 8);
    return (
      this.signed && (n = n.fromTwos(this.size * 8)), t.coerce(this.name, n)
    );
  }
}
const tNe = "strings/5.7.0",
  cte = new $e(tNe);
var Rb;
(function (e) {
  (e.current = ""),
    (e.NFC = "NFC"),
    (e.NFD = "NFD"),
    (e.NFKC = "NFKC"),
    (e.NFKD = "NFKD");
})(Rb || (Rb = {}));
var Il;
(function (e) {
  (e.UNEXPECTED_CONTINUE = "unexpected continuation byte"),
    (e.BAD_PREFIX = "bad codepoint prefix"),
    (e.OVERRUN = "string overrun"),
    (e.MISSING_CONTINUE = "missing continuation byte"),
    (e.OUT_OF_RANGE = "out of UTF-8 range"),
    (e.UTF16_SURROGATE = "UTF-16 surrogate"),
    (e.OVERLONG = "overlong representation");
})(Il || (Il = {}));
function nNe(e, t, n, r, i) {
  return cte.throwArgumentError(
    `invalid codepoint at offset ${t}; ${e}`,
    "bytes",
    n
  );
}
function ute(e, t, n, r, i) {
  if (e === Il.BAD_PREFIX || e === Il.UNEXPECTED_CONTINUE) {
    let s = 0;
    for (let o = t + 1; o < n.length && n[o] >> 6 === 2; o++) s++;
    return s;
  }
  return e === Il.OVERRUN ? n.length - t - 1 : 0;
}
function rNe(e, t, n, r, i) {
  return e === Il.OVERLONG ? (r.push(i), 0) : (r.push(65533), ute(e, t, n));
}
const iNe = Object.freeze({ error: nNe, ignore: ute, replace: rNe });
function dte(e, t) {
  t == null && (t = iNe.error), (e = Nn(e));
  const n = [];
  let r = 0;
  for (; r < e.length; ) {
    const i = e[r++];
    if (!(i >> 7)) {
      n.push(i);
      continue;
    }
    let s = null,
      o = null;
    if ((i & 224) === 192) (s = 1), (o = 127);
    else if ((i & 240) === 224) (s = 2), (o = 2047);
    else if ((i & 248) === 240) (s = 3), (o = 65535);
    else {
      (i & 192) === 128
        ? (r += t(Il.UNEXPECTED_CONTINUE, r - 1, e, n))
        : (r += t(Il.BAD_PREFIX, r - 1, e, n));
      continue;
    }
    if (r - 1 + s >= e.length) {
      r += t(Il.OVERRUN, r - 1, e, n);
      continue;
    }
    let a = i & ((1 << (8 - s - 1)) - 1);
    for (let l = 0; l < s; l++) {
      let c = e[r];
      if ((c & 192) != 128) {
        (r += t(Il.MISSING_CONTINUE, r, e, n)), (a = null);
        break;
      }
      (a = (a << 6) | (c & 63)), r++;
    }
    if (a !== null) {
      if (a > 1114111) {
        r += t(Il.OUT_OF_RANGE, r - 1 - s, e, n, a);
        continue;
      }
      if (a >= 55296 && a <= 57343) {
        r += t(Il.UTF16_SURROGATE, r - 1 - s, e, n, a);
        continue;
      }
      if (a <= o) {
        r += t(Il.OVERLONG, r - 1 - s, e, n, a);
        continue;
      }
      n.push(a);
    }
  }
  return n;
}
function Eh(e, t = Rb.current) {
  t != Rb.current && (cte.checkNormalize(), (e = e.normalize(t)));
  let n = [];
  for (let r = 0; r < e.length; r++) {
    const i = e.charCodeAt(r);
    if (i < 128) n.push(i);
    else if (i < 2048) n.push((i >> 6) | 192), n.push((i & 63) | 128);
    else if ((i & 64512) == 55296) {
      r++;
      const s = e.charCodeAt(r);
      if (r >= e.length || (s & 64512) !== 56320)
        throw new Error("invalid utf-8 string");
      const o = 65536 + ((i & 1023) << 10) + (s & 1023);
      n.push((o >> 18) | 240),
        n.push(((o >> 12) & 63) | 128),
        n.push(((o >> 6) & 63) | 128),
        n.push((o & 63) | 128);
    } else
      n.push((i >> 12) | 224),
        n.push(((i >> 6) & 63) | 128),
        n.push((i & 63) | 128);
  }
  return Nn(n);
}
function sNe(e) {
  return e
    .map((t) =>
      t <= 65535
        ? String.fromCharCode(t)
        : ((t -= 65536),
          String.fromCharCode(((t >> 10) & 1023) + 55296, (t & 1023) + 56320))
    )
    .join("");
}
function Gx(e, t) {
  return sNe(dte(e, t));
}
function oNe(e, t = Rb.current) {
  return dte(Eh(e, t));
}
class aNe extends ate {
  constructor(t) {
    super("string", t);
  }
  defaultValue() {
    return "";
  }
  encode(t, n) {
    return super.encode(t, Eh(n));
  }
  decode(t) {
    return Gx(super.decode(t));
  }
}
class U_ extends Sh {
  constructor(t, n) {
    let r = !1;
    const i = [];
    t.forEach((o) => {
      o.dynamic && (r = !0), i.push(o.type);
    });
    const s = "tuple(" + i.join(",") + ")";
    super("tuple", s, n, r), (this.coders = t);
  }
  defaultValue() {
    const t = [];
    this.coders.forEach((r) => {
      t.push(r.defaultValue());
    });
    const n = this.coders.reduce((r, i) => {
      const s = i.localName;
      return s && (r[s] || (r[s] = 0), r[s]++), r;
    }, {});
    return (
      this.coders.forEach((r, i) => {
        let s = r.localName;
        !s ||
          n[s] !== 1 ||
          (s === "length" && (s = "_length"), t[s] == null && (t[s] = t[i]));
      }),
      Object.freeze(t)
    );
  }
  encode(t, n) {
    return ste(t, this.coders, n);
  }
  decode(t) {
    return t.coerce(this.name, ote(t, this.coders));
  }
}
const T2 = new $e(Vx),
  lNe = new RegExp(/^bytes([0-9]*)$/),
  cNe = new RegExp(/^(u?int)([0-9]*)$/);
class UO {
  constructor(t) {
    T2.checkNew(new.target, UO), dt(this, "coerceFunc", t || null);
  }
  _getCoder(t) {
    switch (t.baseType) {
      case "address":
        return new zIe(t.name);
      case "bool":
        return new VIe(t.name);
      case "string":
        return new aNe(t.name);
      case "bytes":
        return new GIe(t.name);
      case "array":
        return new HIe(this._getCoder(t.arrayChildren), t.arrayLength, t.name);
      case "tuple":
        return new U_(
          (t.components || []).map((r) => this._getCoder(r)),
          t.name
        );
      case "":
        return new KIe(t.name);
    }
    let n = t.type.match(cNe);
    if (n) {
      let r = parseInt(n[2] || "256");
      return (
        (r === 0 || r > 256 || r % 8 !== 0) &&
          T2.throwArgumentError("invalid " + n[1] + " bit length", "param", t),
        new eNe(r / 8, n[1] === "int", t.name)
      );
    }
    if (((n = t.type.match(lNe)), n)) {
      let r = parseInt(n[1]);
      return (
        (r === 0 || r > 32) &&
          T2.throwArgumentError("invalid bytes length", "param", t),
        new qIe(r, t.name)
      );
    }
    return T2.throwArgumentError("invalid type", "type", t.type);
  }
  _getWordSize() {
    return 32;
  }
  _getReader(t, n) {
    return new q5(t, this._getWordSize(), this.coerceFunc, n);
  }
  _getWriter() {
    return new sM(this._getWordSize());
  }
  getDefaultValue(t) {
    const n = t.map((i) => this._getCoder(vo.from(i)));
    return new U_(n, "_").defaultValue();
  }
  encode(t, n) {
    t.length !== n.length &&
      T2.throwError(
        "types/values length mismatch",
        $e.errors.INVALID_ARGUMENT,
        {
          count: { types: t.length, values: n.length },
          value: { types: t, values: n },
        }
      );
    const r = t.map((o) => this._getCoder(vo.from(o))),
      i = new U_(r, "_"),
      s = this._getWriter();
    return i.encode(s, n), s.data;
  }
  decode(t, n, r) {
    const i = t.map((o) => this._getCoder(vo.from(o)));
    return new U_(i, "_").decode(this._getReader(Nn(n), r));
  }
}
const uNe = new UO();
function Mg(e) {
  return eo(Eh(e));
}
const fte = "hash/5.7.0";
function hte(e) {
  e = atob(e);
  const t = [];
  for (let n = 0; n < e.length; n++) t.push(e.charCodeAt(n));
  return Nn(t);
}
function dNe(e) {
  e = Nn(e);
  let t = "";
  for (let n = 0; n < e.length; n++) t += String.fromCharCode(e[n]);
  return btoa(t);
}
function pte(e, t) {
  t == null && (t = 1);
  const n = [],
    r = n.forEach,
    i = function (s, o) {
      r.call(s, function (a) {
        o > 0 && Array.isArray(a) ? i(a, o - 1) : n.push(a);
      });
    };
  return i(e, t), n;
}
function fNe(e) {
  const t = {};
  for (let n = 0; n < e.length; n++) {
    const r = e[n];
    t[r[0]] = r[1];
  }
  return t;
}
function hNe(e) {
  let t = 0;
  function n() {
    return (e[t++] << 8) | e[t++];
  }
  let r = n(),
    i = 1,
    s = [0, 1];
  for (let R = 1; R < r; R++) s.push((i += n()));
  let o = n(),
    a = t;
  t += o;
  let l = 0,
    c = 0;
  function u() {
    return l == 0 && ((c = (c << 8) | e[t++]), (l = 8)), (c >> --l) & 1;
  }
  const d = 31,
    f = Math.pow(2, d),
    h = f >>> 1,
    p = h >> 1,
    g = f - 1;
  let b = 0;
  for (let R = 0; R < d; R++) b = (b << 1) | u();
  let v = [],
    w = 0,
    x = f;
  for (;;) {
    let R = Math.floor(((b - w + 1) * i - 1) / x),
      O = 0,
      B = r;
    for (; B - O > 1; ) {
      let P = (O + B) >>> 1;
      R < s[P] ? (B = P) : (O = P);
    }
    if (O == 0) break;
    v.push(O);
    let C = w + Math.floor((x * s[O]) / i),
      I = w + Math.floor((x * s[O + 1]) / i) - 1;
    for (; !((C ^ I) & h); )
      (b = ((b << 1) & g) | u()), (C = (C << 1) & g), (I = ((I << 1) & g) | 1);
    for (; C & ~I & p; )
      (b = (b & h) | ((b << 1) & (g >>> 1)) | u()),
        (C = (C << 1) ^ h),
        (I = ((I ^ h) << 1) | h | 1);
    (w = C), (x = 1 + I - C);
  }
  let S = r - 4;
  return v.map((R) => {
    switch (R - S) {
      case 3:
        return S + 65792 + ((e[a++] << 16) | (e[a++] << 8) | e[a++]);
      case 2:
        return S + 256 + ((e[a++] << 8) | e[a++]);
      case 1:
        return S + e[a++];
      default:
        return R - 1;
    }
  });
}
function pNe(e) {
  let t = 0;
  return () => e[t++];
}
function mNe(e) {
  return pNe(hNe(e));
}
function gNe(e) {
  return e & 1 ? ~e >> 1 : e >> 1;
}
function yNe(e, t) {
  let n = Array(e);
  for (let r = 0; r < e; r++) n[r] = 1 + t();
  return n;
}
function Oz(e, t) {
  let n = Array(e);
  for (let r = 0, i = -1; r < e; r++) n[r] = i += 1 + t();
  return n;
}
function vNe(e, t) {
  let n = Array(e);
  for (let r = 0, i = 0; r < e; r++) n[r] = i += gNe(t());
  return n;
}
function K5(e, t) {
  let n = Oz(e(), e),
    r = e(),
    i = Oz(r, e),
    s = yNe(r, e);
  for (let o = 0; o < r; o++) for (let a = 0; a < s[o]; a++) n.push(i[o] + a);
  return t ? n.map((o) => t[o]) : n;
}
function wNe(e) {
  let t = [];
  for (;;) {
    let n = e();
    if (n == 0) break;
    t.push(xNe(n, e));
  }
  for (;;) {
    let n = e() - 1;
    if (n < 0) break;
    t.push(_Ne(n, e));
  }
  return fNe(pte(t));
}
function bNe(e) {
  let t = [];
  for (;;) {
    let n = e();
    if (n == 0) break;
    t.push(n);
  }
  return t;
}
function mte(e, t, n) {
  let r = Array(e)
    .fill(void 0)
    .map(() => []);
  for (let i = 0; i < t; i++) vNe(e, n).forEach((s, o) => r[o].push(s));
  return r;
}
function xNe(e, t) {
  let n = 1 + t(),
    r = t(),
    i = bNe(t),
    s = mte(i.length, 1 + e, t);
  return pte(
    s.map((o, a) => {
      const l = o[0],
        c = o.slice(1);
      return Array(i[a])
        .fill(void 0)
        .map((u, d) => {
          let f = d * r;
          return [l + d * n, c.map((h) => h + f)];
        });
    })
  );
}
function _Ne(e, t) {
  let n = 1 + t();
  return mte(n, 1 + e, t).map((i) => [i[0], i.slice(1)]);
}
function SNe(e) {
  let t = K5(e).sort((r, i) => r - i);
  return n();
  function n() {
    let r = [];
    for (;;) {
      let c = K5(e, t);
      if (c.length == 0) break;
      r.push({ set: new Set(c), node: n() });
    }
    r.sort((c, u) => u.set.size - c.set.size);
    let i = e(),
      s = i % 3;
    i = (i / 3) | 0;
    let o = !!(i & 1);
    i >>= 1;
    let a = i == 1,
      l = i == 2;
    return { branches: r, valid: s, fe0f: o, save: a, check: l };
  }
}
function ENe() {
  return mNe(
    hte(
      "AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA=="
    )
  );
}
const Y8 = ENe(),
  ANe = new Set(K5(Y8)),
  CNe = new Set(K5(Y8)),
  kNe = wNe(Y8),
  TNe = SNe(Y8),
  Pz = 45,
  Lz = 95;
function gte(e) {
  return oNe(e);
}
function MNe(e) {
  return e.filter((t) => t != 65039);
}
function yte(e) {
  for (let t of e.split(".")) {
    let n = gte(t);
    try {
      for (let r = n.lastIndexOf(Lz) - 1; r >= 0; r--)
        if (n[r] !== Lz) throw new Error("underscore only allowed at start");
      if (
        n.length >= 4 &&
        n.every((r) => r < 128) &&
        n[2] === Pz &&
        n[3] === Pz
      )
        throw new Error("invalid label extension");
    } catch (r) {
      throw new Error(`Invalid label "${t}": ${r.message}`);
    }
  }
  return e;
}
function INe(e) {
  return yte(NNe(e, MNe));
}
function NNe(e, t) {
  let n = gte(e).reverse(),
    r = [];
  for (; n.length; ) {
    let i = ONe(n);
    if (i) {
      r.push(...t(i));
      continue;
    }
    let s = n.pop();
    if (ANe.has(s)) {
      r.push(s);
      continue;
    }
    if (CNe.has(s)) continue;
    let o = kNe[s];
    if (o) {
      r.push(...o);
      continue;
    }
    throw new Error(`Disallowed codepoint: 0x${s.toString(16).toUpperCase()}`);
  }
  return yte(RNe(String.fromCodePoint(...r)));
}
function RNe(e) {
  return e.normalize("NFC");
}
function ONe(e, t) {
  var n;
  let r = TNe,
    i,
    s,
    o = [],
    a = e.length;
  for (; a; ) {
    let l = e[--a];
    if (
      ((r =
        (n = r.branches.find((c) => c.set.has(l))) === null || n === void 0
          ? void 0
          : n.node),
      !r)
    )
      break;
    if (r.save) s = l;
    else if (r.check && l === s) break;
    o.push(l),
      r.fe0f && (o.push(65039), a > 0 && e[a - 1] == 65039 && a--),
      r.valid &&
        ((i = o.slice()), r.valid == 2 && i.splice(1, 1), (e.length = a));
  }
  return i;
}
const PNe = new $e(fte),
  vte = new Uint8Array(32);
vte.fill(0);
function jz(e) {
  if (e.length === 0) throw new Error("invalid ENS name; empty component");
  return e;
}
function LNe(e) {
  const t = Eh(INe(e)),
    n = [];
  if (e.length === 0) return n;
  let r = 0;
  for (let i = 0; i < t.length; i++)
    t[i] === 46 && (n.push(jz(t.slice(r, i))), (r = i + 1));
  if (r >= t.length) throw new Error("invalid ENS name; empty component");
  return n.push(jz(t.slice(r))), n;
}
function Y5(e) {
  typeof e != "string" &&
    PNe.throwArgumentError("invalid ENS name; not a string", "name", e);
  let t = vte;
  const n = LNe(e);
  for (; n.length; ) t = eo(Ec([t, eo(n.pop())]));
  return vn(t);
}
var jNe = function (e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(u) {
      try {
        c(r.next(u));
      } catch (d) {
        o(d);
      }
    }
    function l(u) {
      try {
        c(r.throw(u));
      } catch (d) {
        o(d);
      }
    }
    function c(u) {
      u.done ? s(u.value) : i(u.value).then(a, l);
    }
    c((r = r.apply(e, t || [])).next());
  });
};
const ls = new $e(fte),
  wte = new Uint8Array(32);
wte.fill(0);
const DNe = Ut.from(-1),
  bte = Ut.from(0),
  xte = Ut.from(1),
  BNe = Ut.from(
    "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
  );
function FNe(e) {
  const t = Nn(e),
    n = t.length % 32;
  return n ? Up([t, wte.slice(n)]) : vn(t);
}
const UNe = io(xte.toHexString(), 32),
  $Ne = io(bte.toHexString(), 32),
  Dz = {
    name: "string",
    version: "string",
    chainId: "uint256",
    verifyingContract: "address",
    salt: "bytes32",
  },
  LC = ["name", "version", "chainId", "verifyingContract", "salt"];
function Bz(e) {
  return function (t) {
    return (
      typeof t != "string" &&
        ls.throwArgumentError(
          `invalid domain value for ${JSON.stringify(e)}`,
          `domain.${e}`,
          t
        ),
      t
    );
  };
}
const zNe = {
  name: Bz("name"),
  version: Bz("version"),
  chainId: function (e) {
    try {
      return Ut.from(e).toString();
    } catch {}
    return ls.throwArgumentError(
      'invalid domain value for "chainId"',
      "domain.chainId",
      e
    );
  },
  verifyingContract: function (e) {
    try {
      return zo(e).toLowerCase();
    } catch {}
    return ls.throwArgumentError(
      'invalid domain value "verifyingContract"',
      "domain.verifyingContract",
      e
    );
  },
  salt: function (e) {
    try {
      const t = Nn(e);
      if (t.length !== 32) throw new Error("bad length");
      return vn(t);
    } catch {}
    return ls.throwArgumentError(
      'invalid domain value "salt"',
      "domain.salt",
      e
    );
  },
};
function jC(e) {
  {
    const t = e.match(/^(u?)int(\d*)$/);
    if (t) {
      const n = t[1] === "",
        r = parseInt(t[2] || "256");
      (r % 8 !== 0 || r > 256 || (t[2] && t[2] !== String(r))) &&
        ls.throwArgumentError("invalid numeric width", "type", e);
      const i = BNe.mask(n ? r - 1 : r),
        s = n ? i.add(xte).mul(DNe) : bte;
      return function (o) {
        const a = Ut.from(o);
        return (
          (a.lt(s) || a.gt(i)) &&
            ls.throwArgumentError(`value out-of-bounds for ${e}`, "value", o),
          io(a.toTwos(256).toHexString(), 32)
        );
      };
    }
  }
  {
    const t = e.match(/^bytes(\d+)$/);
    if (t) {
      const n = parseInt(t[1]);
      return (
        (n === 0 || n > 32 || t[1] !== String(n)) &&
          ls.throwArgumentError("invalid bytes width", "type", e),
        function (r) {
          return (
            Nn(r).length !== n &&
              ls.throwArgumentError(`invalid length for ${e}`, "value", r),
            FNe(r)
          );
        }
      );
    }
  }
  switch (e) {
    case "address":
      return function (t) {
        return io(zo(t), 32);
      };
    case "bool":
      return function (t) {
        return t ? UNe : $Ne;
      };
    case "bytes":
      return function (t) {
        return eo(t);
      };
    case "string":
      return function (t) {
        return Mg(t);
      };
  }
  return null;
}
function Fz(e, t) {
  return `${e}(${t.map(({ name: n, type: r }) => r + " " + n).join(",")})`;
}
class _l {
  constructor(t) {
    dt(this, "types", Object.freeze(dh(t))),
      dt(this, "_encoderCache", {}),
      dt(this, "_types", {});
    const n = {},
      r = {},
      i = {};
    Object.keys(t).forEach((a) => {
      (n[a] = {}), (r[a] = []), (i[a] = {});
    });
    for (const a in t) {
      const l = {};
      t[a].forEach((c) => {
        l[c.name] &&
          ls.throwArgumentError(
            `duplicate variable name ${JSON.stringify(
              c.name
            )} in ${JSON.stringify(a)}`,
            "types",
            t
          ),
          (l[c.name] = !0);
        const u = c.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
        u === a &&
          ls.throwArgumentError(
            `circular type reference to ${JSON.stringify(u)}`,
            "types",
            t
          ),
          !jC(u) &&
            (r[u] ||
              ls.throwArgumentError(
                `unknown type ${JSON.stringify(u)}`,
                "types",
                t
              ),
            r[u].push(a),
            (n[a][u] = !0));
      });
    }
    const s = Object.keys(r).filter((a) => r[a].length === 0);
    s.length === 0
      ? ls.throwArgumentError("missing primary type", "types", t)
      : s.length > 1 &&
        ls.throwArgumentError(
          `ambiguous primary types or unused types: ${s
            .map((a) => JSON.stringify(a))
            .join(", ")}`,
          "types",
          t
        ),
      dt(this, "primaryType", s[0]);
    function o(a, l) {
      l[a] &&
        ls.throwArgumentError(
          `circular type reference to ${JSON.stringify(a)}`,
          "types",
          t
        ),
        (l[a] = !0),
        Object.keys(n[a]).forEach((c) => {
          r[c] &&
            (o(c, l),
            Object.keys(l).forEach((u) => {
              i[u][c] = !0;
            }));
        }),
        delete l[a];
    }
    o(this.primaryType, {});
    for (const a in i) {
      const l = Object.keys(i[a]);
      l.sort(),
        (this._types[a] = Fz(a, t[a]) + l.map((c) => Fz(c, t[c])).join(""));
    }
  }
  getEncoder(t) {
    let n = this._encoderCache[t];
    return n || (n = this._encoderCache[t] = this._getEncoder(t)), n;
  }
  _getEncoder(t) {
    {
      const i = jC(t);
      if (i) return i;
    }
    const n = t.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (n) {
      const i = n[1],
        s = this.getEncoder(i),
        o = parseInt(n[3]);
      return (a) => {
        o >= 0 &&
          a.length !== o &&
          ls.throwArgumentError(
            "array length mismatch; expected length ${ arrayLength }",
            "value",
            a
          );
        let l = a.map(s);
        return this._types[i] && (l = l.map(eo)), eo(Up(l));
      };
    }
    const r = this.types[t];
    if (r) {
      const i = Mg(this._types[t]);
      return (s) => {
        const o = r.map(({ name: a, type: l }) => {
          const c = this.getEncoder(l)(s[a]);
          return this._types[l] ? eo(c) : c;
        });
        return o.unshift(i), Up(o);
      };
    }
    return ls.throwArgumentError(`unknown type: ${t}`, "type", t);
  }
  encodeType(t) {
    const n = this._types[t];
    return (
      n ||
        ls.throwArgumentError(`unknown type: ${JSON.stringify(t)}`, "name", t),
      n
    );
  }
  encodeData(t, n) {
    return this.getEncoder(t)(n);
  }
  hashStruct(t, n) {
    return eo(this.encodeData(t, n));
  }
  encode(t) {
    return this.encodeData(this.primaryType, t);
  }
  hash(t) {
    return this.hashStruct(this.primaryType, t);
  }
  _visit(t, n, r) {
    if (jC(t)) return r(t, n);
    const i = t.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (i) {
      const o = i[1],
        a = parseInt(i[3]);
      return (
        a >= 0 &&
          n.length !== a &&
          ls.throwArgumentError(
            "array length mismatch; expected length ${ arrayLength }",
            "value",
            n
          ),
        n.map((l) => this._visit(o, l, r))
      );
    }
    const s = this.types[t];
    return s
      ? s.reduce(
          (o, { name: a, type: l }) => ((o[a] = this._visit(l, n[a], r)), o),
          {}
        )
      : ls.throwArgumentError(`unknown type: ${t}`, "type", t);
  }
  visit(t, n) {
    return this._visit(this.primaryType, t, n);
  }
  static from(t) {
    return new _l(t);
  }
  static getPrimaryType(t) {
    return _l.from(t).primaryType;
  }
  static hashStruct(t, n, r) {
    return _l.from(n).hashStruct(t, r);
  }
  static hashDomain(t) {
    const n = [];
    for (const r in t) {
      const i = Dz[r];
      i ||
        ls.throwArgumentError(
          `invalid typed-data domain key: ${JSON.stringify(r)}`,
          "domain",
          t
        ),
        n.push({ name: r, type: i });
    }
    return (
      n.sort((r, i) => LC.indexOf(r.name) - LC.indexOf(i.name)),
      _l.hashStruct("EIP712Domain", { EIP712Domain: n }, t)
    );
  }
  static encode(t, n, r) {
    return Up(["0x1901", _l.hashDomain(t), _l.from(n).hash(r)]);
  }
  static hash(t, n, r) {
    return eo(_l.encode(t, n, r));
  }
  static resolveNames(t, n, r, i) {
    return jNe(this, void 0, void 0, function* () {
      t = fa(t);
      const s = {};
      t.verifyingContract &&
        !ri(t.verifyingContract, 20) &&
        (s[t.verifyingContract] = "0x");
      const o = _l.from(n);
      o.visit(r, (a, l) => (a === "address" && !ri(l, 20) && (s[l] = "0x"), l));
      for (const a in s) s[a] = yield i(a);
      return (
        t.verifyingContract &&
          s[t.verifyingContract] &&
          (t.verifyingContract = s[t.verifyingContract]),
        (r = o.visit(r, (a, l) => (a === "address" && s[l] ? s[l] : l))),
        { domain: t, value: r }
      );
    });
  }
  static getPayload(t, n, r) {
    _l.hashDomain(t);
    const i = {},
      s = [];
    LC.forEach((l) => {
      const c = t[l];
      c != null && ((i[l] = zNe[l](c)), s.push({ name: l, type: Dz[l] }));
    });
    const o = _l.from(n),
      a = fa(n);
    return (
      a.EIP712Domain
        ? ls.throwArgumentError(
            "types must not contain EIP712Domain type",
            "types.EIP712Domain",
            n
          )
        : (a.EIP712Domain = s),
      o.encode(r),
      {
        types: a,
        domain: i,
        primaryType: o.primaryType,
        message: o.visit(r, (l, c) => {
          if (l.match(/^bytes(\d*)/)) return vn(Nn(c));
          if (l.match(/^u?int/)) return Ut.from(c).toString();
          switch (l) {
            case "address":
              return c.toLowerCase();
            case "bool":
              return !!c;
            case "string":
              return (
                typeof c != "string" &&
                  ls.throwArgumentError("invalid string", "value", c),
                c
              );
          }
          return ls.throwArgumentError("unsupported type", "type", l);
        }),
      }
    );
  }
}
const Zi = new $e(Vx);
class WNe extends Hx {}
class HNe extends Hx {}
class VNe extends Hx {}
class oM extends Hx {
  static isIndexed(t) {
    return !!(t && t._isIndexed);
  }
}
const GNe = {
  "0x08c379a0": {
    signature: "Error(string)",
    name: "Error",
    inputs: ["string"],
    reason: !0,
  },
  "0x4e487b71": {
    signature: "Panic(uint256)",
    name: "Panic",
    inputs: ["uint256"],
  },
};
function Uz(e, t) {
  const n = new Error(
    `deferred error during ABI decoding triggered accessing ${e}`
  );
  return (n.error = t), n;
}
let e1 = class _te {
  constructor(t) {
    Zi.checkNew(new.target, _te);
    let n = [];
    typeof t == "string" ? (n = JSON.parse(t)) : (n = t),
      dt(
        this,
        "fragments",
        n.map((r) => zf.from(r)).filter((r) => r != null)
      ),
      dt(this, "_abiCoder", md(new.target, "getAbiCoder")()),
      dt(this, "functions", {}),
      dt(this, "errors", {}),
      dt(this, "events", {}),
      dt(this, "structs", {}),
      this.fragments.forEach((r) => {
        let i = null;
        switch (r.type) {
          case "constructor":
            if (this.deploy) {
              Zi.warn("duplicate definition - constructor");
              return;
            }
            dt(this, "deploy", r);
            return;
          case "function":
            i = this.functions;
            break;
          case "event":
            i = this.events;
            break;
          case "error":
            i = this.errors;
            break;
          default:
            return;
        }
        let s = r.format();
        if (i[s]) {
          Zi.warn("duplicate definition - " + s);
          return;
        }
        i[s] = r;
      }),
      this.deploy ||
        dt(this, "deploy", od.from({ payable: !1, type: "constructor" })),
      dt(this, "_isInterface", !0);
  }
  format(t) {
    t || (t = Gr.full),
      t === Gr.sighash &&
        Zi.throwArgumentError(
          "interface does not support formatting sighash",
          "format",
          t
        );
    const n = this.fragments.map((r) => r.format(t));
    return t === Gr.json ? JSON.stringify(n.map((r) => JSON.parse(r))) : n;
  }
  static getAbiCoder() {
    return uNe;
  }
  static getAddress(t) {
    return zo(t);
  }
  static getSighash(t) {
    return Qf(Mg(t.format()), 0, 4);
  }
  static getEventTopic(t) {
    return Mg(t.format());
  }
  getFunction(t) {
    if (ri(t)) {
      for (const r in this.functions)
        if (t === this.getSighash(r)) return this.functions[r];
      Zi.throwArgumentError("no matching function", "sighash", t);
    }
    if (t.indexOf("(") === -1) {
      const r = t.trim(),
        i = Object.keys(this.functions).filter((s) => s.split("(")[0] === r);
      return (
        i.length === 0
          ? Zi.throwArgumentError("no matching function", "name", r)
          : i.length > 1 &&
            Zi.throwArgumentError("multiple matching functions", "name", r),
        this.functions[i[0]]
      );
    }
    const n = this.functions[ad.fromString(t).format()];
    return (
      n || Zi.throwArgumentError("no matching function", "signature", t), n
    );
  }
  getEvent(t) {
    if (ri(t)) {
      const r = t.toLowerCase();
      for (const i in this.events)
        if (r === this.getEventTopic(i)) return this.events[i];
      Zi.throwArgumentError("no matching event", "topichash", r);
    }
    if (t.indexOf("(") === -1) {
      const r = t.trim(),
        i = Object.keys(this.events).filter((s) => s.split("(")[0] === r);
      return (
        i.length === 0
          ? Zi.throwArgumentError("no matching event", "name", r)
          : i.length > 1 &&
            Zi.throwArgumentError("multiple matching events", "name", r),
        this.events[i[0]]
      );
    }
    const n = this.events[Pf.fromString(t).format()];
    return n || Zi.throwArgumentError("no matching event", "signature", t), n;
  }
  getError(t) {
    if (ri(t)) {
      const r = md(this.constructor, "getSighash");
      for (const i in this.errors) {
        const s = this.errors[i];
        if (t === r(s)) return this.errors[i];
      }
      Zi.throwArgumentError("no matching error", "sighash", t);
    }
    if (t.indexOf("(") === -1) {
      const r = t.trim(),
        i = Object.keys(this.errors).filter((s) => s.split("(")[0] === r);
      return (
        i.length === 0
          ? Zi.throwArgumentError("no matching error", "name", r)
          : i.length > 1 &&
            Zi.throwArgumentError("multiple matching errors", "name", r),
        this.errors[i[0]]
      );
    }
    const n = this.errors[ad.fromString(t).format()];
    return n || Zi.throwArgumentError("no matching error", "signature", t), n;
  }
  getSighash(t) {
    if (typeof t == "string")
      try {
        t = this.getFunction(t);
      } catch (n) {
        try {
          t = this.getError(t);
        } catch {
          throw n;
        }
      }
    return md(this.constructor, "getSighash")(t);
  }
  getEventTopic(t) {
    return (
      typeof t == "string" && (t = this.getEvent(t)),
      md(this.constructor, "getEventTopic")(t)
    );
  }
  _decodeParams(t, n) {
    return this._abiCoder.decode(t, n);
  }
  _encodeParams(t, n) {
    return this._abiCoder.encode(t, n);
  }
  encodeDeploy(t) {
    return this._encodeParams(this.deploy.inputs, t || []);
  }
  decodeErrorResult(t, n) {
    typeof t == "string" && (t = this.getError(t));
    const r = Nn(n);
    return (
      vn(r.slice(0, 4)) !== this.getSighash(t) &&
        Zi.throwArgumentError(
          `data signature does not match error ${t.name}.`,
          "data",
          vn(r)
        ),
      this._decodeParams(t.inputs, r.slice(4))
    );
  }
  encodeErrorResult(t, n) {
    return (
      typeof t == "string" && (t = this.getError(t)),
      vn(Ec([this.getSighash(t), this._encodeParams(t.inputs, n || [])]))
    );
  }
  decodeFunctionData(t, n) {
    typeof t == "string" && (t = this.getFunction(t));
    const r = Nn(n);
    return (
      vn(r.slice(0, 4)) !== this.getSighash(t) &&
        Zi.throwArgumentError(
          `data signature does not match function ${t.name}.`,
          "data",
          vn(r)
        ),
      this._decodeParams(t.inputs, r.slice(4))
    );
  }
  encodeFunctionData(t, n) {
    return (
      typeof t == "string" && (t = this.getFunction(t)),
      vn(Ec([this.getSighash(t), this._encodeParams(t.inputs, n || [])]))
    );
  }
  decodeFunctionResult(t, n) {
    typeof t == "string" && (t = this.getFunction(t));
    let r = Nn(n),
      i = null,
      s = null,
      o = null,
      a = null;
    switch (r.length % this._abiCoder._getWordSize()) {
      case 0:
        try {
          return this._abiCoder.decode(t.outputs, r);
        } catch {}
        break;
      case 4: {
        const l = vn(r.slice(0, 4)),
          c = GNe[l];
        if (c)
          (s = this._abiCoder.decode(c.inputs, r.slice(4))),
            (o = c.name),
            (a = c.signature),
            c.reason && (i = s[0]);
        else
          try {
            const u = this.getError(l);
            (s = this._abiCoder.decode(u.inputs, r.slice(4))),
              (o = u.name),
              (a = u.format());
          } catch (u) {
            console.log(u);
          }
        break;
      }
    }
    return Zi.throwError("call revert exception", $e.errors.CALL_EXCEPTION, {
      method: t.format(),
      errorArgs: s,
      errorName: o,
      errorSignature: a,
      reason: i,
    });
  }
  encodeFunctionResult(t, n) {
    return (
      typeof t == "string" && (t = this.getFunction(t)),
      vn(this._abiCoder.encode(t.outputs, n || []))
    );
  }
  encodeFilterTopics(t, n) {
    typeof t == "string" && (t = this.getEvent(t)),
      n.length > t.inputs.length &&
        Zi.throwError(
          "too many arguments for " + t.format(),
          $e.errors.UNEXPECTED_ARGUMENT,
          { argument: "values", value: n }
        );
    let r = [];
    t.anonymous || r.push(this.getEventTopic(t));
    const i = (s, o) =>
      s.type === "string"
        ? Mg(o)
        : s.type === "bytes"
        ? eo(vn(o))
        : (s.type === "address" && this._abiCoder.encode(["address"], [o]),
          io(vn(o), 32));
    for (
      n.forEach((s, o) => {
        let a = t.inputs[o];
        if (!a.indexed) {
          s != null &&
            Zi.throwArgumentError(
              "cannot filter non-indexed parameters; must be null",
              "contract." + a.name,
              s
            );
          return;
        }
        s == null
          ? r.push(null)
          : a.baseType === "array" || a.baseType === "tuple"
          ? Zi.throwArgumentError(
              "filtering with tuples or arrays not supported",
              "contract." + a.name,
              s
            )
          : Array.isArray(s)
          ? r.push(s.map((l) => i(a, l)))
          : r.push(i(a, s));
      });
      r.length && r[r.length - 1] === null;

    )
      r.pop();
    return r;
  }
  encodeEventLog(t, n) {
    typeof t == "string" && (t = this.getEvent(t));
    const r = [],
      i = [],
      s = [];
    return (
      t.anonymous || r.push(this.getEventTopic(t)),
      n.length !== t.inputs.length &&
        Zi.throwArgumentError("event arguments/values mismatch", "values", n),
      t.inputs.forEach((o, a) => {
        const l = n[a];
        if (o.indexed)
          if (o.type === "string") r.push(Mg(l));
          else if (o.type === "bytes") r.push(eo(l));
          else {
            if (o.baseType === "tuple" || o.baseType === "array")
              throw new Error("not implemented");
            r.push(this._abiCoder.encode([o.type], [l]));
          }
        else i.push(o), s.push(l);
      }),
      { data: this._abiCoder.encode(i, s), topics: r }
    );
  }
  decodeEventLog(t, n, r) {
    if (
      (typeof t == "string" && (t = this.getEvent(t)),
      r != null && !t.anonymous)
    ) {
      let f = this.getEventTopic(t);
      (!ri(r[0], 32) || r[0].toLowerCase() !== f) &&
        Zi.throwError("fragment/topic mismatch", $e.errors.INVALID_ARGUMENT, {
          argument: "topics[0]",
          expected: f,
          value: r[0],
        }),
        (r = r.slice(1));
    }
    let i = [],
      s = [],
      o = [];
    t.inputs.forEach((f, h) => {
      f.indexed
        ? f.type === "string" ||
          f.type === "bytes" ||
          f.baseType === "tuple" ||
          f.baseType === "array"
          ? (i.push(vo.fromObject({ type: "bytes32", name: f.name })),
            o.push(!0))
          : (i.push(f), o.push(!1))
        : (s.push(f), o.push(!1));
    });
    let a = r != null ? this._abiCoder.decode(i, Ec(r)) : null,
      l = this._abiCoder.decode(s, n, !0),
      c = [],
      u = 0,
      d = 0;
    t.inputs.forEach((f, h) => {
      if (f.indexed)
        if (a == null) c[h] = new oM({ _isIndexed: !0, hash: null });
        else if (o[h]) c[h] = new oM({ _isIndexed: !0, hash: a[d++] });
        else
          try {
            c[h] = a[d++];
          } catch (p) {
            c[h] = p;
          }
      else
        try {
          c[h] = l[u++];
        } catch (p) {
          c[h] = p;
        }
      if (f.name && c[f.name] == null) {
        const p = c[h];
        p instanceof Error
          ? Object.defineProperty(c, f.name, {
              get: () => {
                throw Uz(`property ${JSON.stringify(f.name)}`, p);
              },
            })
          : (c[f.name] = p);
      }
    });
    for (let f = 0; f < c.length; f++) {
      const h = c[f];
      h instanceof Error &&
        Object.defineProperty(c, f, {
          get: () => {
            throw Uz(`index ${f}`, h);
          },
        });
    }
    return Object.freeze(c);
  }
  parseTransaction(t) {
    let n = this.getFunction(t.data.substring(0, 10).toLowerCase());
    return n
      ? new HNe({
          args: this._abiCoder.decode(n.inputs, "0x" + t.data.substring(10)),
          functionFragment: n,
          name: n.name,
          signature: n.format(),
          sighash: this.getSighash(n),
          value: Ut.from(t.value || "0"),
        })
      : null;
  }
  parseLog(t) {
    let n = this.getEvent(t.topics[0]);
    return !n || n.anonymous
      ? null
      : new WNe({
          eventFragment: n,
          name: n.name,
          signature: n.format(),
          topic: this.getEventTopic(n),
          args: this.decodeEventLog(n, t.data, t.topics),
        });
  }
  parseError(t) {
    const n = vn(t);
    let r = this.getError(n.substring(0, 10).toLowerCase());
    return r
      ? new VNe({
          args: this._abiCoder.decode(r.inputs, "0x" + n.substring(10)),
          errorFragment: r,
          name: r.name,
          signature: r.format(),
          sighash: this.getSighash(r),
        })
      : null;
  }
  static isInterface(t) {
    return !!(t && t._isInterface);
  }
};
const qNe = "abstract-provider/5.7.0";
var KNe = function (e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(u) {
      try {
        c(r.next(u));
      } catch (d) {
        o(d);
      }
    }
    function l(u) {
      try {
        c(r.throw(u));
      } catch (d) {
        o(d);
      }
    }
    function c(u) {
      u.done ? s(u.value) : i(u.value).then(a, l);
    }
    c((r = r.apply(e, t || [])).next());
  });
};
const YNe = new $e(qNe);
class ZNe extends Hx {
  static isForkEvent(t) {
    return !!(t && t._isForkEvent);
  }
}
class Ob {
  constructor() {
    YNe.checkAbstract(new.target, Ob), dt(this, "_isProvider", !0);
  }
  getFeeData() {
    return KNe(this, void 0, void 0, function* () {
      const { block: t, gasPrice: n } = yield Us({
        block: this.getBlock("latest"),
        gasPrice: this.getGasPrice().catch((o) => null),
      });
      let r = null,
        i = null,
        s = null;
      return (
        t &&
          t.baseFeePerGas &&
          ((r = t.baseFeePerGas),
          (s = Ut.from("1500000000")),
          (i = t.baseFeePerGas.mul(2).add(s))),
        {
          lastBaseFeePerGas: r,
          maxFeePerGas: i,
          maxPriorityFeePerGas: s,
          gasPrice: n,
        }
      );
    });
  }
  addListener(t, n) {
    return this.on(t, n);
  }
  removeListener(t, n) {
    return this.off(t, n);
  }
  static isProvider(t) {
    return !!(t && t._isProvider);
  }
}
const QNe = "abstract-signer/5.7.0";
var ru = function (e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(u) {
      try {
        c(r.next(u));
      } catch (d) {
        o(d);
      }
    }
    function l(u) {
      try {
        c(r.throw(u));
      } catch (d) {
        o(d);
      }
    }
    function c(u) {
      u.done ? s(u.value) : i(u.value).then(a, l);
    }
    c((r = r.apply(e, t || [])).next());
  });
};
const fc = new $e(QNe),
  XNe = [
    "accessList",
    "ccipReadEnabled",
    "chainId",
    "customData",
    "data",
    "from",
    "gasLimit",
    "gasPrice",
    "maxFeePerGas",
    "maxPriorityFeePerGas",
    "nonce",
    "to",
    "type",
    "value",
  ],
  JNe = [
    $e.errors.INSUFFICIENT_FUNDS,
    $e.errors.NONCE_EXPIRED,
    $e.errors.REPLACEMENT_UNDERPRICED,
  ];
class qx {
  constructor() {
    fc.checkAbstract(new.target, qx), dt(this, "_isSigner", !0);
  }
  getBalance(t) {
    return ru(this, void 0, void 0, function* () {
      return (
        this._checkProvider("getBalance"),
        yield this.provider.getBalance(this.getAddress(), t)
      );
    });
  }
  getTransactionCount(t) {
    return ru(this, void 0, void 0, function* () {
      return (
        this._checkProvider("getTransactionCount"),
        yield this.provider.getTransactionCount(this.getAddress(), t)
      );
    });
  }
  estimateGas(t) {
    return ru(this, void 0, void 0, function* () {
      this._checkProvider("estimateGas");
      const n = yield Us(this.checkTransaction(t));
      return yield this.provider.estimateGas(n);
    });
  }
  call(t, n) {
    return ru(this, void 0, void 0, function* () {
      this._checkProvider("call");
      const r = yield Us(this.checkTransaction(t));
      return yield this.provider.call(r, n);
    });
  }
  sendTransaction(t) {
    return ru(this, void 0, void 0, function* () {
      this._checkProvider("sendTransaction");
      const n = yield this.populateTransaction(t),
        r = yield this.signTransaction(n);
      return yield this.provider.sendTransaction(r);
    });
  }
  getChainId() {
    return ru(this, void 0, void 0, function* () {
      return (
        this._checkProvider("getChainId"),
        (yield this.provider.getNetwork()).chainId
      );
    });
  }
  getGasPrice() {
    return ru(this, void 0, void 0, function* () {
      return (
        this._checkProvider("getGasPrice"), yield this.provider.getGasPrice()
      );
    });
  }
  getFeeData() {
    return ru(this, void 0, void 0, function* () {
      return (
        this._checkProvider("getFeeData"), yield this.provider.getFeeData()
      );
    });
  }
  resolveName(t) {
    return ru(this, void 0, void 0, function* () {
      return (
        this._checkProvider("resolveName"), yield this.provider.resolveName(t)
      );
    });
  }
  checkTransaction(t) {
    for (const r in t)
      XNe.indexOf(r) === -1 &&
        fc.throwArgumentError(
          "invalid transaction key: " + r,
          "transaction",
          t
        );
    const n = fa(t);
    return (
      n.from == null
        ? (n.from = this.getAddress())
        : (n.from = Promise.all([
            Promise.resolve(n.from),
            this.getAddress(),
          ]).then(
            (r) => (
              r[0].toLowerCase() !== r[1].toLowerCase() &&
                fc.throwArgumentError(
                  "from address mismatch",
                  "transaction",
                  t
                ),
              r[0]
            )
          )),
      n
    );
  }
  populateTransaction(t) {
    return ru(this, void 0, void 0, function* () {
      const n = yield Us(this.checkTransaction(t));
      n.to != null &&
        ((n.to = Promise.resolve(n.to).then((i) =>
          ru(this, void 0, void 0, function* () {
            if (i == null) return null;
            const s = yield this.resolveName(i);
            return (
              s == null &&
                fc.throwArgumentError(
                  "provided ENS name resolves to null",
                  "tx.to",
                  i
                ),
              s
            );
          })
        )),
        n.to.catch((i) => {}));
      const r = n.maxFeePerGas != null || n.maxPriorityFeePerGas != null;
      if (
        (n.gasPrice != null && (n.type === 2 || r)
          ? fc.throwArgumentError(
              "eip-1559 transaction do not support gasPrice",
              "transaction",
              t
            )
          : (n.type === 0 || n.type === 1) &&
            r &&
            fc.throwArgumentError(
              "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas",
              "transaction",
              t
            ),
        (n.type === 2 || n.type == null) &&
          n.maxFeePerGas != null &&
          n.maxPriorityFeePerGas != null)
      )
        n.type = 2;
      else if (n.type === 0 || n.type === 1)
        n.gasPrice == null && (n.gasPrice = this.getGasPrice());
      else {
        const i = yield this.getFeeData();
        if (n.type == null)
          if (i.maxFeePerGas != null && i.maxPriorityFeePerGas != null)
            if (((n.type = 2), n.gasPrice != null)) {
              const s = n.gasPrice;
              delete n.gasPrice,
                (n.maxFeePerGas = s),
                (n.maxPriorityFeePerGas = s);
            } else
              n.maxFeePerGas == null && (n.maxFeePerGas = i.maxFeePerGas),
                n.maxPriorityFeePerGas == null &&
                  (n.maxPriorityFeePerGas = i.maxPriorityFeePerGas);
          else
            i.gasPrice != null
              ? (r &&
                  fc.throwError(
                    "network does not support EIP-1559",
                    $e.errors.UNSUPPORTED_OPERATION,
                    { operation: "populateTransaction" }
                  ),
                n.gasPrice == null && (n.gasPrice = i.gasPrice),
                (n.type = 0))
              : fc.throwError(
                  "failed to get consistent fee data",
                  $e.errors.UNSUPPORTED_OPERATION,
                  { operation: "signer.getFeeData" }
                );
        else
          n.type === 2 &&
            (n.maxFeePerGas == null && (n.maxFeePerGas = i.maxFeePerGas),
            n.maxPriorityFeePerGas == null &&
              (n.maxPriorityFeePerGas = i.maxPriorityFeePerGas));
      }
      return (
        n.nonce == null && (n.nonce = this.getTransactionCount("pending")),
        n.gasLimit == null &&
          (n.gasLimit = this.estimateGas(n).catch((i) => {
            if (JNe.indexOf(i.code) >= 0) throw i;
            return fc.throwError(
              "cannot estimate gas; transaction may fail or may require manual gas limit",
              $e.errors.UNPREDICTABLE_GAS_LIMIT,
              { error: i, tx: n }
            );
          })),
        n.chainId == null
          ? (n.chainId = this.getChainId())
          : (n.chainId = Promise.all([
              Promise.resolve(n.chainId),
              this.getChainId(),
            ]).then(
              (i) => (
                i[1] !== 0 &&
                  i[0] !== i[1] &&
                  fc.throwArgumentError(
                    "chainId address mismatch",
                    "transaction",
                    t
                  ),
                i[0]
              )
            )),
        yield Us(n)
      );
    });
  }
  _checkProvider(t) {
    this.provider ||
      fc.throwError("missing provider", $e.errors.UNSUPPORTED_OPERATION, {
        operation: t || "_checkProvider",
      });
  }
  static isSigner(t) {
    return !!(t && t._isSigner);
  }
}
class $O extends qx {
  constructor(t, n) {
    super(), dt(this, "address", t), dt(this, "provider", n || null);
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  _fail(t, n) {
    return Promise.resolve().then(() => {
      fc.throwError(t, $e.errors.UNSUPPORTED_OPERATION, { operation: n });
    });
  }
  signMessage(t) {
    return this._fail("VoidSigner cannot sign messages", "signMessage");
  }
  signTransaction(t) {
    return this._fail("VoidSigner cannot sign transactions", "signTransaction");
  }
  _signTypedData(t, n, r) {
    return this._fail("VoidSigner cannot sign typed data", "signTypedData");
  }
  connect(t) {
    return new $O(this.address, t);
  }
}
var Ste = {},
  Ar = {},
  Kx = Ete;
function Ete(e, t) {
  if (!e) throw new Error(t || "Assertion failed");
}
Ete.equal = function (t, n, r) {
  if (t != n) throw new Error(r || "Assertion failed: " + t + " != " + n);
};
var aM = { exports: {} };
typeof Object.create == "function"
  ? (aM.exports = function (t, n) {
      n &&
        ((t.super_ = n),
        (t.prototype = Object.create(n.prototype, {
          constructor: {
            value: t,
            enumerable: !1,
            writable: !0,
            configurable: !0,
          },
        })));
    })
  : (aM.exports = function (t, n) {
      if (n) {
        t.super_ = n;
        var r = function () {};
        (r.prototype = n.prototype),
          (t.prototype = new r()),
          (t.prototype.constructor = t);
      }
    });
var eRe = aM.exports,
  tRe = Kx,
  nRe = eRe;
Ar.inherits = nRe;
function rRe(e, t) {
  return (e.charCodeAt(t) & 64512) !== 55296 || t < 0 || t + 1 >= e.length
    ? !1
    : (e.charCodeAt(t + 1) & 64512) === 56320;
}
function iRe(e, t) {
  if (Array.isArray(e)) return e.slice();
  if (!e) return [];
  var n = [];
  if (typeof e == "string")
    if (t) {
      if (t === "hex")
        for (
          e = e.replace(/[^a-z0-9]+/gi, ""),
            e.length % 2 !== 0 && (e = "0" + e),
            i = 0;
          i < e.length;
          i += 2
        )
          n.push(parseInt(e[i] + e[i + 1], 16));
    } else
      for (var r = 0, i = 0; i < e.length; i++) {
        var s = e.charCodeAt(i);
        s < 128
          ? (n[r++] = s)
          : s < 2048
          ? ((n[r++] = (s >> 6) | 192), (n[r++] = (s & 63) | 128))
          : rRe(e, i)
          ? ((s = 65536 + ((s & 1023) << 10) + (e.charCodeAt(++i) & 1023)),
            (n[r++] = (s >> 18) | 240),
            (n[r++] = ((s >> 12) & 63) | 128),
            (n[r++] = ((s >> 6) & 63) | 128),
            (n[r++] = (s & 63) | 128))
          : ((n[r++] = (s >> 12) | 224),
            (n[r++] = ((s >> 6) & 63) | 128),
            (n[r++] = (s & 63) | 128));
      }
  else for (i = 0; i < e.length; i++) n[i] = e[i] | 0;
  return n;
}
Ar.toArray = iRe;
function sRe(e) {
  for (var t = "", n = 0; n < e.length; n++) t += Cte(e[n].toString(16));
  return t;
}
Ar.toHex = sRe;
function Ate(e) {
  var t =
    (e >>> 24) |
    ((e >>> 8) & 65280) |
    ((e << 8) & 16711680) |
    ((e & 255) << 24);
  return t >>> 0;
}
Ar.htonl = Ate;
function oRe(e, t) {
  for (var n = "", r = 0; r < e.length; r++) {
    var i = e[r];
    t === "little" && (i = Ate(i)), (n += kte(i.toString(16)));
  }
  return n;
}
Ar.toHex32 = oRe;
function Cte(e) {
  return e.length === 1 ? "0" + e : e;
}
Ar.zero2 = Cte;
function kte(e) {
  return e.length === 7
    ? "0" + e
    : e.length === 6
    ? "00" + e
    : e.length === 5
    ? "000" + e
    : e.length === 4
    ? "0000" + e
    : e.length === 3
    ? "00000" + e
    : e.length === 2
    ? "000000" + e
    : e.length === 1
    ? "0000000" + e
    : e;
}
Ar.zero8 = kte;
function aRe(e, t, n, r) {
  var i = n - t;
  tRe(i % 4 === 0);
  for (var s = new Array(i / 4), o = 0, a = t; o < s.length; o++, a += 4) {
    var l;
    r === "big"
      ? (l = (e[a] << 24) | (e[a + 1] << 16) | (e[a + 2] << 8) | e[a + 3])
      : (l = (e[a + 3] << 24) | (e[a + 2] << 16) | (e[a + 1] << 8) | e[a]),
      (s[o] = l >>> 0);
  }
  return s;
}
Ar.join32 = aRe;
function lRe(e, t) {
  for (
    var n = new Array(e.length * 4), r = 0, i = 0;
    r < e.length;
    r++, i += 4
  ) {
    var s = e[r];
    t === "big"
      ? ((n[i] = s >>> 24),
        (n[i + 1] = (s >>> 16) & 255),
        (n[i + 2] = (s >>> 8) & 255),
        (n[i + 3] = s & 255))
      : ((n[i + 3] = s >>> 24),
        (n[i + 2] = (s >>> 16) & 255),
        (n[i + 1] = (s >>> 8) & 255),
        (n[i] = s & 255));
  }
  return n;
}
Ar.split32 = lRe;
function cRe(e, t) {
  return (e >>> t) | (e << (32 - t));
}
Ar.rotr32 = cRe;
function uRe(e, t) {
  return (e << t) | (e >>> (32 - t));
}
Ar.rotl32 = uRe;
function dRe(e, t) {
  return (e + t) >>> 0;
}
Ar.sum32 = dRe;
function fRe(e, t, n) {
  return (e + t + n) >>> 0;
}
Ar.sum32_3 = fRe;
function hRe(e, t, n, r) {
  return (e + t + n + r) >>> 0;
}
Ar.sum32_4 = hRe;
function pRe(e, t, n, r, i) {
  return (e + t + n + r + i) >>> 0;
}
Ar.sum32_5 = pRe;
function mRe(e, t, n, r) {
  var i = e[t],
    s = e[t + 1],
    o = (r + s) >>> 0,
    a = (o < r ? 1 : 0) + n + i;
  (e[t] = a >>> 0), (e[t + 1] = o);
}
Ar.sum64 = mRe;
function gRe(e, t, n, r) {
  var i = (t + r) >>> 0,
    s = (i < t ? 1 : 0) + e + n;
  return s >>> 0;
}
Ar.sum64_hi = gRe;
function yRe(e, t, n, r) {
  var i = t + r;
  return i >>> 0;
}
Ar.sum64_lo = yRe;
function vRe(e, t, n, r, i, s, o, a) {
  var l = 0,
    c = t;
  (c = (c + r) >>> 0),
    (l += c < t ? 1 : 0),
    (c = (c + s) >>> 0),
    (l += c < s ? 1 : 0),
    (c = (c + a) >>> 0),
    (l += c < a ? 1 : 0);
  var u = e + n + i + o + l;
  return u >>> 0;
}
Ar.sum64_4_hi = vRe;
function wRe(e, t, n, r, i, s, o, a) {
  var l = t + r + s + a;
  return l >>> 0;
}
Ar.sum64_4_lo = wRe;
function bRe(e, t, n, r, i, s, o, a, l, c) {
  var u = 0,
    d = t;
  (d = (d + r) >>> 0),
    (u += d < t ? 1 : 0),
    (d = (d + s) >>> 0),
    (u += d < s ? 1 : 0),
    (d = (d + a) >>> 0),
    (u += d < a ? 1 : 0),
    (d = (d + c) >>> 0),
    (u += d < c ? 1 : 0);
  var f = e + n + i + o + l + u;
  return f >>> 0;
}
Ar.sum64_5_hi = bRe;
function xRe(e, t, n, r, i, s, o, a, l, c) {
  var u = t + r + s + a + c;
  return u >>> 0;
}
Ar.sum64_5_lo = xRe;
function _Re(e, t, n) {
  var r = (t << (32 - n)) | (e >>> n);
  return r >>> 0;
}
Ar.rotr64_hi = _Re;
function SRe(e, t, n) {
  var r = (e << (32 - n)) | (t >>> n);
  return r >>> 0;
}
Ar.rotr64_lo = SRe;
function ERe(e, t, n) {
  return e >>> n;
}
Ar.shr64_hi = ERe;
function ARe(e, t, n) {
  var r = (e << (32 - n)) | (t >>> n);
  return r >>> 0;
}
Ar.shr64_lo = ARe;
var Sv = {},
  $z = Ar,
  CRe = Kx;
function Z8() {
  (this.pending = null),
    (this.pendingTotal = 0),
    (this.blockSize = this.constructor.blockSize),
    (this.outSize = this.constructor.outSize),
    (this.hmacStrength = this.constructor.hmacStrength),
    (this.padLength = this.constructor.padLength / 8),
    (this.endian = "big"),
    (this._delta8 = this.blockSize / 8),
    (this._delta32 = this.blockSize / 32);
}
Sv.BlockHash = Z8;
Z8.prototype.update = function (t, n) {
  if (
    ((t = $z.toArray(t, n)),
    this.pending ? (this.pending = this.pending.concat(t)) : (this.pending = t),
    (this.pendingTotal += t.length),
    this.pending.length >= this._delta8)
  ) {
    t = this.pending;
    var r = t.length % this._delta8;
    (this.pending = t.slice(t.length - r, t.length)),
      this.pending.length === 0 && (this.pending = null),
      (t = $z.join32(t, 0, t.length - r, this.endian));
    for (var i = 0; i < t.length; i += this._delta32)
      this._update(t, i, i + this._delta32);
  }
  return this;
};
Z8.prototype.digest = function (t) {
  return this.update(this._pad()), CRe(this.pending === null), this._digest(t);
};
Z8.prototype._pad = function () {
  var t = this.pendingTotal,
    n = this._delta8,
    r = n - ((t + this.padLength) % n),
    i = new Array(r + this.padLength);
  i[0] = 128;
  for (var s = 1; s < r; s++) i[s] = 0;
  if (((t <<= 3), this.endian === "big")) {
    for (var o = 8; o < this.padLength; o++) i[s++] = 0;
    (i[s++] = 0),
      (i[s++] = 0),
      (i[s++] = 0),
      (i[s++] = 0),
      (i[s++] = (t >>> 24) & 255),
      (i[s++] = (t >>> 16) & 255),
      (i[s++] = (t >>> 8) & 255),
      (i[s++] = t & 255);
  } else
    for (
      i[s++] = t & 255,
        i[s++] = (t >>> 8) & 255,
        i[s++] = (t >>> 16) & 255,
        i[s++] = (t >>> 24) & 255,
        i[s++] = 0,
        i[s++] = 0,
        i[s++] = 0,
        i[s++] = 0,
        o = 8;
      o < this.padLength;
      o++
    )
      i[s++] = 0;
  return i;
};
var Ev = {},
  Vd = {},
  kRe = Ar,
  _d = kRe.rotr32;
function TRe(e, t, n, r) {
  if (e === 0) return Tte(t, n, r);
  if (e === 1 || e === 3) return Ite(t, n, r);
  if (e === 2) return Mte(t, n, r);
}
Vd.ft_1 = TRe;
function Tte(e, t, n) {
  return (e & t) ^ (~e & n);
}
Vd.ch32 = Tte;
function Mte(e, t, n) {
  return (e & t) ^ (e & n) ^ (t & n);
}
Vd.maj32 = Mte;
function Ite(e, t, n) {
  return e ^ t ^ n;
}
Vd.p32 = Ite;
function MRe(e) {
  return _d(e, 2) ^ _d(e, 13) ^ _d(e, 22);
}
Vd.s0_256 = MRe;
function IRe(e) {
  return _d(e, 6) ^ _d(e, 11) ^ _d(e, 25);
}
Vd.s1_256 = IRe;
function NRe(e) {
  return _d(e, 7) ^ _d(e, 18) ^ (e >>> 3);
}
Vd.g0_256 = NRe;
function RRe(e) {
  return _d(e, 17) ^ _d(e, 19) ^ (e >>> 10);
}
Vd.g1_256 = RRe;
var zy = Ar,
  ORe = Sv,
  PRe = Vd,
  DC = zy.rotl32,
  M2 = zy.sum32,
  LRe = zy.sum32_5,
  jRe = PRe.ft_1,
  Nte = ORe.BlockHash,
  DRe = [1518500249, 1859775393, 2400959708, 3395469782];
function Pd() {
  if (!(this instanceof Pd)) return new Pd();
  Nte.call(this),
    (this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520]),
    (this.W = new Array(80));
}
zy.inherits(Pd, Nte);
var BRe = Pd;
Pd.blockSize = 512;
Pd.outSize = 160;
Pd.hmacStrength = 80;
Pd.padLength = 64;
Pd.prototype._update = function (t, n) {
  for (var r = this.W, i = 0; i < 16; i++) r[i] = t[n + i];
  for (; i < r.length; i++)
    r[i] = DC(r[i - 3] ^ r[i - 8] ^ r[i - 14] ^ r[i - 16], 1);
  var s = this.h[0],
    o = this.h[1],
    a = this.h[2],
    l = this.h[3],
    c = this.h[4];
  for (i = 0; i < r.length; i++) {
    var u = ~~(i / 20),
      d = LRe(DC(s, 5), jRe(u, o, a, l), c, r[i], DRe[u]);
    (c = l), (l = a), (a = DC(o, 30)), (o = s), (s = d);
  }
  (this.h[0] = M2(this.h[0], s)),
    (this.h[1] = M2(this.h[1], o)),
    (this.h[2] = M2(this.h[2], a)),
    (this.h[3] = M2(this.h[3], l)),
    (this.h[4] = M2(this.h[4], c));
};
Pd.prototype._digest = function (t) {
  return t === "hex" ? zy.toHex32(this.h, "big") : zy.split32(this.h, "big");
};
var Wy = Ar,
  FRe = Sv,
  Av = Vd,
  URe = Kx,
  iu = Wy.sum32,
  $Re = Wy.sum32_4,
  zRe = Wy.sum32_5,
  WRe = Av.ch32,
  HRe = Av.maj32,
  VRe = Av.s0_256,
  GRe = Av.s1_256,
  qRe = Av.g0_256,
  KRe = Av.g1_256,
  Rte = FRe.BlockHash,
  YRe = [
    1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
    2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
    1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774,
    264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
    2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711,
    113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
    1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
    3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
    430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
    1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424,
    2428436474, 2756734187, 3204031479, 3329325298,
  ];
function Ld() {
  if (!(this instanceof Ld)) return new Ld();
  Rte.call(this),
    (this.h = [
      1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924,
      528734635, 1541459225,
    ]),
    (this.k = YRe),
    (this.W = new Array(64));
}
Wy.inherits(Ld, Rte);
var Ote = Ld;
Ld.blockSize = 512;
Ld.outSize = 256;
Ld.hmacStrength = 192;
Ld.padLength = 64;
Ld.prototype._update = function (t, n) {
  for (var r = this.W, i = 0; i < 16; i++) r[i] = t[n + i];
  for (; i < r.length; i++)
    r[i] = $Re(KRe(r[i - 2]), r[i - 7], qRe(r[i - 15]), r[i - 16]);
  var s = this.h[0],
    o = this.h[1],
    a = this.h[2],
    l = this.h[3],
    c = this.h[4],
    u = this.h[5],
    d = this.h[6],
    f = this.h[7];
  for (URe(this.k.length === r.length), i = 0; i < r.length; i++) {
    var h = zRe(f, GRe(c), WRe(c, u, d), this.k[i], r[i]),
      p = iu(VRe(s), HRe(s, o, a));
    (f = d),
      (d = u),
      (u = c),
      (c = iu(l, h)),
      (l = a),
      (a = o),
      (o = s),
      (s = iu(h, p));
  }
  (this.h[0] = iu(this.h[0], s)),
    (this.h[1] = iu(this.h[1], o)),
    (this.h[2] = iu(this.h[2], a)),
    (this.h[3] = iu(this.h[3], l)),
    (this.h[4] = iu(this.h[4], c)),
    (this.h[5] = iu(this.h[5], u)),
    (this.h[6] = iu(this.h[6], d)),
    (this.h[7] = iu(this.h[7], f));
};
Ld.prototype._digest = function (t) {
  return t === "hex" ? Wy.toHex32(this.h, "big") : Wy.split32(this.h, "big");
};
var lM = Ar,
  Pte = Ote;
function fh() {
  if (!(this instanceof fh)) return new fh();
  Pte.call(this),
    (this.h = [
      3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025,
      1694076839, 3204075428,
    ]);
}
lM.inherits(fh, Pte);
var ZRe = fh;
fh.blockSize = 512;
fh.outSize = 224;
fh.hmacStrength = 192;
fh.padLength = 64;
fh.prototype._digest = function (t) {
  return t === "hex"
    ? lM.toHex32(this.h.slice(0, 7), "big")
    : lM.split32(this.h.slice(0, 7), "big");
};
var cl = Ar,
  QRe = Sv,
  XRe = Kx,
  Sd = cl.rotr64_hi,
  Ed = cl.rotr64_lo,
  Lte = cl.shr64_hi,
  jte = cl.shr64_lo,
  Jh = cl.sum64,
  BC = cl.sum64_hi,
  FC = cl.sum64_lo,
  JRe = cl.sum64_4_hi,
  eOe = cl.sum64_4_lo,
  tOe = cl.sum64_5_hi,
  nOe = cl.sum64_5_lo,
  Dte = QRe.BlockHash,
  rOe = [
    1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399,
    3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265,
    2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394,
    310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994,
    1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317,
    3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139,
    264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901,
    1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837,
    2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879,
    3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901,
    113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964,
    773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823,
    1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142,
    2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273,
    3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344,
    3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720,
    430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593,
    883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403,
    1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012,
    2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044,
    2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573,
    3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711,
    3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554,
    174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315,
    685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100,
    1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866,
    1607167915, 987167468, 1816402316, 1246189591,
  ];
function Mu() {
  if (!(this instanceof Mu)) return new Mu();
  Dte.call(this),
    (this.h = [
      1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723,
      2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199,
      528734635, 4215389547, 1541459225, 327033209,
    ]),
    (this.k = rOe),
    (this.W = new Array(160));
}
cl.inherits(Mu, Dte);
var Bte = Mu;
Mu.blockSize = 1024;
Mu.outSize = 512;
Mu.hmacStrength = 192;
Mu.padLength = 128;
Mu.prototype._prepareBlock = function (t, n) {
  for (var r = this.W, i = 0; i < 32; i++) r[i] = t[n + i];
  for (; i < r.length; i += 2) {
    var s = pOe(r[i - 4], r[i - 3]),
      o = mOe(r[i - 4], r[i - 3]),
      a = r[i - 14],
      l = r[i - 13],
      c = fOe(r[i - 30], r[i - 29]),
      u = hOe(r[i - 30], r[i - 29]),
      d = r[i - 32],
      f = r[i - 31];
    (r[i] = JRe(s, o, a, l, c, u, d, f)),
      (r[i + 1] = eOe(s, o, a, l, c, u, d, f));
  }
};
Mu.prototype._update = function (t, n) {
  this._prepareBlock(t, n);
  var r = this.W,
    i = this.h[0],
    s = this.h[1],
    o = this.h[2],
    a = this.h[3],
    l = this.h[4],
    c = this.h[5],
    u = this.h[6],
    d = this.h[7],
    f = this.h[8],
    h = this.h[9],
    p = this.h[10],
    g = this.h[11],
    b = this.h[12],
    v = this.h[13],
    w = this.h[14],
    x = this.h[15];
  XRe(this.k.length === r.length);
  for (var S = 0; S < r.length; S += 2) {
    var R = w,
      O = x,
      B = uOe(f, h),
      C = dOe(f, h),
      I = iOe(f, h, p, g, b),
      P = sOe(f, h, p, g, b, v),
      M = this.k[S],
      k = this.k[S + 1],
      T = r[S],
      _ = r[S + 1],
      A = tOe(R, O, B, C, I, P, M, k, T, _),
      N = nOe(R, O, B, C, I, P, M, k, T, _);
    (R = lOe(i, s)),
      (O = cOe(i, s)),
      (B = oOe(i, s, o, a, l)),
      (C = aOe(i, s, o, a, l, c));
    var L = BC(R, O, B, C),
      F = FC(R, O, B, C);
    (w = b),
      (x = v),
      (b = p),
      (v = g),
      (p = f),
      (g = h),
      (f = BC(u, d, A, N)),
      (h = FC(d, d, A, N)),
      (u = l),
      (d = c),
      (l = o),
      (c = a),
      (o = i),
      (a = s),
      (i = BC(A, N, L, F)),
      (s = FC(A, N, L, F));
  }
  Jh(this.h, 0, i, s),
    Jh(this.h, 2, o, a),
    Jh(this.h, 4, l, c),
    Jh(this.h, 6, u, d),
    Jh(this.h, 8, f, h),
    Jh(this.h, 10, p, g),
    Jh(this.h, 12, b, v),
    Jh(this.h, 14, w, x);
};
Mu.prototype._digest = function (t) {
  return t === "hex" ? cl.toHex32(this.h, "big") : cl.split32(this.h, "big");
};
function iOe(e, t, n, r, i) {
  var s = (e & n) ^ (~e & i);
  return s < 0 && (s += 4294967296), s;
}
function sOe(e, t, n, r, i, s) {
  var o = (t & r) ^ (~t & s);
  return o < 0 && (o += 4294967296), o;
}
function oOe(e, t, n, r, i) {
  var s = (e & n) ^ (e & i) ^ (n & i);
  return s < 0 && (s += 4294967296), s;
}
function aOe(e, t, n, r, i, s) {
  var o = (t & r) ^ (t & s) ^ (r & s);
  return o < 0 && (o += 4294967296), o;
}
function lOe(e, t) {
  var n = Sd(e, t, 28),
    r = Sd(t, e, 2),
    i = Sd(t, e, 7),
    s = n ^ r ^ i;
  return s < 0 && (s += 4294967296), s;
}
function cOe(e, t) {
  var n = Ed(e, t, 28),
    r = Ed(t, e, 2),
    i = Ed(t, e, 7),
    s = n ^ r ^ i;
  return s < 0 && (s += 4294967296), s;
}
function uOe(e, t) {
  var n = Sd(e, t, 14),
    r = Sd(e, t, 18),
    i = Sd(t, e, 9),
    s = n ^ r ^ i;
  return s < 0 && (s += 4294967296), s;
}
function dOe(e, t) {
  var n = Ed(e, t, 14),
    r = Ed(e, t, 18),
    i = Ed(t, e, 9),
    s = n ^ r ^ i;
  return s < 0 && (s += 4294967296), s;
}
function fOe(e, t) {
  var n = Sd(e, t, 1),
    r = Sd(e, t, 8),
    i = Lte(e, t, 7),
    s = n ^ r ^ i;
  return s < 0 && (s += 4294967296), s;
}
function hOe(e, t) {
  var n = Ed(e, t, 1),
    r = Ed(e, t, 8),
    i = jte(e, t, 7),
    s = n ^ r ^ i;
  return s < 0 && (s += 4294967296), s;
}
function pOe(e, t) {
  var n = Sd(e, t, 19),
    r = Sd(t, e, 29),
    i = Lte(e, t, 6),
    s = n ^ r ^ i;
  return s < 0 && (s += 4294967296), s;
}
function mOe(e, t) {
  var n = Ed(e, t, 19),
    r = Ed(t, e, 29),
    i = jte(e, t, 6),
    s = n ^ r ^ i;
  return s < 0 && (s += 4294967296), s;
}
var cM = Ar,
  Fte = Bte;
function hh() {
  if (!(this instanceof hh)) return new hh();
  Fte.call(this),
    (this.h = [
      3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999,
      355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025,
      3675008525, 1694076839, 1203062813, 3204075428,
    ]);
}
cM.inherits(hh, Fte);
var gOe = hh;
hh.blockSize = 1024;
hh.outSize = 384;
hh.hmacStrength = 192;
hh.padLength = 128;
hh.prototype._digest = function (t) {
  return t === "hex"
    ? cM.toHex32(this.h.slice(0, 12), "big")
    : cM.split32(this.h.slice(0, 12), "big");
};
Ev.sha1 = BRe;
Ev.sha224 = ZRe;
Ev.sha256 = Ote;
Ev.sha384 = gOe;
Ev.sha512 = Bte;
var Ute = {},
  t1 = Ar,
  yOe = Sv,
  $_ = t1.rotl32,
  zz = t1.sum32,
  I2 = t1.sum32_3,
  Wz = t1.sum32_4,
  $te = yOe.BlockHash;
function jd() {
  if (!(this instanceof jd)) return new jd();
  $te.call(this),
    (this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520]),
    (this.endian = "little");
}
t1.inherits(jd, $te);
Ute.ripemd160 = jd;
jd.blockSize = 512;
jd.outSize = 160;
jd.hmacStrength = 192;
jd.padLength = 64;
jd.prototype._update = function (t, n) {
  for (
    var r = this.h[0],
      i = this.h[1],
      s = this.h[2],
      o = this.h[3],
      a = this.h[4],
      l = r,
      c = i,
      u = s,
      d = o,
      f = a,
      h = 0;
    h < 80;
    h++
  ) {
    var p = zz($_(Wz(r, Hz(h, i, s, o), t[bOe[h] + n], vOe(h)), _Oe[h]), a);
    (r = a),
      (a = o),
      (o = $_(s, 10)),
      (s = i),
      (i = p),
      (p = zz(
        $_(Wz(l, Hz(79 - h, c, u, d), t[xOe[h] + n], wOe(h)), SOe[h]),
        f
      )),
      (l = f),
      (f = d),
      (d = $_(u, 10)),
      (u = c),
      (c = p);
  }
  (p = I2(this.h[1], s, d)),
    (this.h[1] = I2(this.h[2], o, f)),
    (this.h[2] = I2(this.h[3], a, l)),
    (this.h[3] = I2(this.h[4], r, c)),
    (this.h[4] = I2(this.h[0], i, u)),
    (this.h[0] = p);
};
jd.prototype._digest = function (t) {
  return t === "hex"
    ? t1.toHex32(this.h, "little")
    : t1.split32(this.h, "little");
};
function Hz(e, t, n, r) {
  return e <= 15
    ? t ^ n ^ r
    : e <= 31
    ? (t & n) | (~t & r)
    : e <= 47
    ? (t | ~n) ^ r
    : e <= 63
    ? (t & r) | (n & ~r)
    : t ^ (n | ~r);
}
function vOe(e) {
  return e <= 15
    ? 0
    : e <= 31
    ? 1518500249
    : e <= 47
    ? 1859775393
    : e <= 63
    ? 2400959708
    : 2840853838;
}
function wOe(e) {
  return e <= 15
    ? 1352829926
    : e <= 31
    ? 1548603684
    : e <= 47
    ? 1836072691
    : e <= 63
    ? 2053994217
    : 0;
}
var bOe = [
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6,
    15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13,
    11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9,
    7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13,
  ],
  xOe = [
    5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5,
    10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10,
    0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10,
    4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11,
  ],
  _Oe = [
    11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9,
    7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13,
    6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9,
    15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6,
  ],
  SOe = [
    8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8,
    9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14,
    13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5,
    12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11,
  ],
  EOe = Ar,
  AOe = Kx;
function Hy(e, t, n) {
  if (!(this instanceof Hy)) return new Hy(e, t, n);
  (this.Hash = e),
    (this.blockSize = e.blockSize / 8),
    (this.outSize = e.outSize / 8),
    (this.inner = null),
    (this.outer = null),
    this._init(EOe.toArray(t, n));
}
var COe = Hy;
Hy.prototype._init = function (t) {
  t.length > this.blockSize && (t = new this.Hash().update(t).digest()),
    AOe(t.length <= this.blockSize);
  for (var n = t.length; n < this.blockSize; n++) t.push(0);
  for (n = 0; n < t.length; n++) t[n] ^= 54;
  for (this.inner = new this.Hash().update(t), n = 0; n < t.length; n++)
    t[n] ^= 106;
  this.outer = new this.Hash().update(t);
};
Hy.prototype.update = function (t, n) {
  return this.inner.update(t, n), this;
};
Hy.prototype.digest = function (t) {
  return this.outer.update(this.inner.digest()), this.outer.digest(t);
};
(function (e) {
  var t = e;
  (t.utils = Ar),
    (t.common = Sv),
    (t.sha = Ev),
    (t.ripemd = Ute),
    (t.hmac = COe),
    (t.sha1 = t.sha.sha1),
    (t.sha256 = t.sha.sha256),
    (t.sha224 = t.sha.sha224),
    (t.sha384 = t.sha.sha384),
    (t.sha512 = t.sha.sha512),
    (t.ripemd160 = t.ripemd.ripemd160);
})(Ste);
const Yu = Gi(Ste);
function Cv(e, t, n) {
  return (
    (n = {
      path: t,
      exports: {},
      require: function (r, i) {
        return kOe(r, i ?? n.path);
      },
    }),
    e(n, n.exports),
    n.exports
  );
}
function kOe() {
  throw new Error(
    "Dynamic requires are not currently supported by @rollup/plugin-commonjs"
  );
}
var zO = zte;
function zte(e, t) {
  if (!e) throw new Error(t || "Assertion failed");
}
zte.equal = function (t, n, r) {
  if (t != n) throw new Error(r || "Assertion failed: " + t + " != " + n);
};
var gu = Cv(function (e, t) {
    var n = t;
    function r(o, a) {
      if (Array.isArray(o)) return o.slice();
      if (!o) return [];
      var l = [];
      if (typeof o != "string") {
        for (var c = 0; c < o.length; c++) l[c] = o[c] | 0;
        return l;
      }
      if (a === "hex") {
        (o = o.replace(/[^a-z0-9]+/gi, "")),
          o.length % 2 !== 0 && (o = "0" + o);
        for (var c = 0; c < o.length; c += 2)
          l.push(parseInt(o[c] + o[c + 1], 16));
      } else
        for (var c = 0; c < o.length; c++) {
          var u = o.charCodeAt(c),
            d = u >> 8,
            f = u & 255;
          d ? l.push(d, f) : l.push(f);
        }
      return l;
    }
    n.toArray = r;
    function i(o) {
      return o.length === 1 ? "0" + o : o;
    }
    n.zero2 = i;
    function s(o) {
      for (var a = "", l = 0; l < o.length; l++) a += i(o[l].toString(16));
      return a;
    }
    (n.toHex = s),
      (n.encode = function (a, l) {
        return l === "hex" ? s(a) : a;
      });
  }),
  ql = Cv(function (e, t) {
    var n = t;
    (n.assert = zO),
      (n.toArray = gu.toArray),
      (n.zero2 = gu.zero2),
      (n.toHex = gu.toHex),
      (n.encode = gu.encode);
    function r(l, c, u) {
      var d = new Array(Math.max(l.bitLength(), u) + 1);
      d.fill(0);
      for (var f = 1 << (c + 1), h = l.clone(), p = 0; p < d.length; p++) {
        var g,
          b = h.andln(f - 1);
        h.isOdd()
          ? (b > (f >> 1) - 1 ? (g = (f >> 1) - b) : (g = b), h.isubn(g))
          : (g = 0),
          (d[p] = g),
          h.iushrn(1);
      }
      return d;
    }
    n.getNAF = r;
    function i(l, c) {
      var u = [[], []];
      (l = l.clone()), (c = c.clone());
      for (var d = 0, f = 0, h; l.cmpn(-d) > 0 || c.cmpn(-f) > 0; ) {
        var p = (l.andln(3) + d) & 3,
          g = (c.andln(3) + f) & 3;
        p === 3 && (p = -1), g === 3 && (g = -1);
        var b;
        p & 1
          ? ((h = (l.andln(7) + d) & 7),
            (h === 3 || h === 5) && g === 2 ? (b = -p) : (b = p))
          : (b = 0),
          u[0].push(b);
        var v;
        g & 1
          ? ((h = (c.andln(7) + f) & 7),
            (h === 3 || h === 5) && p === 2 ? (v = -g) : (v = g))
          : (v = 0),
          u[1].push(v),
          2 * d === b + 1 && (d = 1 - d),
          2 * f === v + 1 && (f = 1 - f),
          l.iushrn(1),
          c.iushrn(1);
      }
      return u;
    }
    n.getJSF = i;
    function s(l, c, u) {
      var d = "_" + c;
      l.prototype[c] = function () {
        return this[d] !== void 0 ? this[d] : (this[d] = u.call(this));
      };
    }
    n.cachedProperty = s;
    function o(l) {
      return typeof l == "string" ? n.toArray(l, "hex") : l;
    }
    n.parseBytes = o;
    function a(l) {
      return new sn(l, "hex", "le");
    }
    n.intFromLE = a;
  }),
  Z5 = ql.getNAF,
  TOe = ql.getJSF,
  Q5 = ql.assert;
function g0(e, t) {
  (this.type = e),
    (this.p = new sn(t.p, 16)),
    (this.red = t.prime ? sn.red(t.prime) : sn.mont(this.p)),
    (this.zero = new sn(0).toRed(this.red)),
    (this.one = new sn(1).toRed(this.red)),
    (this.two = new sn(2).toRed(this.red)),
    (this.n = t.n && new sn(t.n, 16)),
    (this.g = t.g && this.pointFromJSON(t.g, t.gRed)),
    (this._wnafT1 = new Array(4)),
    (this._wnafT2 = new Array(4)),
    (this._wnafT3 = new Array(4)),
    (this._wnafT4 = new Array(4)),
    (this._bitLength = this.n ? this.n.bitLength() : 0);
  var n = this.n && this.p.div(this.n);
  !n || n.cmpn(100) > 0
    ? (this.redN = null)
    : ((this._maxwellTrick = !0), (this.redN = this.n.toRed(this.red)));
}
var x1 = g0;
g0.prototype.point = function () {
  throw new Error("Not implemented");
};
g0.prototype.validate = function () {
  throw new Error("Not implemented");
};
g0.prototype._fixedNafMul = function (t, n) {
  Q5(t.precomputed);
  var r = t._getDoubles(),
    i = Z5(n, 1, this._bitLength),
    s = (1 << (r.step + 1)) - (r.step % 2 === 0 ? 2 : 1);
  s /= 3;
  var o = [],
    a,
    l;
  for (a = 0; a < i.length; a += r.step) {
    l = 0;
    for (var c = a + r.step - 1; c >= a; c--) l = (l << 1) + i[c];
    o.push(l);
  }
  for (
    var u = this.jpoint(null, null, null),
      d = this.jpoint(null, null, null),
      f = s;
    f > 0;
    f--
  ) {
    for (a = 0; a < o.length; a++)
      (l = o[a]),
        l === f
          ? (d = d.mixedAdd(r.points[a]))
          : l === -f && (d = d.mixedAdd(r.points[a].neg()));
    u = u.add(d);
  }
  return u.toP();
};
g0.prototype._wnafMul = function (t, n) {
  var r = 4,
    i = t._getNAFPoints(r);
  r = i.wnd;
  for (
    var s = i.points,
      o = Z5(n, r, this._bitLength),
      a = this.jpoint(null, null, null),
      l = o.length - 1;
    l >= 0;
    l--
  ) {
    for (var c = 0; l >= 0 && o[l] === 0; l--) c++;
    if ((l >= 0 && c++, (a = a.dblp(c)), l < 0)) break;
    var u = o[l];
    Q5(u !== 0),
      t.type === "affine"
        ? u > 0
          ? (a = a.mixedAdd(s[(u - 1) >> 1]))
          : (a = a.mixedAdd(s[(-u - 1) >> 1].neg()))
        : u > 0
        ? (a = a.add(s[(u - 1) >> 1]))
        : (a = a.add(s[(-u - 1) >> 1].neg()));
  }
  return t.type === "affine" ? a.toP() : a;
};
g0.prototype._wnafMulAdd = function (t, n, r, i, s) {
  var o = this._wnafT1,
    a = this._wnafT2,
    l = this._wnafT3,
    c = 0,
    u,
    d,
    f;
  for (u = 0; u < i; u++) {
    f = n[u];
    var h = f._getNAFPoints(t);
    (o[u] = h.wnd), (a[u] = h.points);
  }
  for (u = i - 1; u >= 1; u -= 2) {
    var p = u - 1,
      g = u;
    if (o[p] !== 1 || o[g] !== 1) {
      (l[p] = Z5(r[p], o[p], this._bitLength)),
        (l[g] = Z5(r[g], o[g], this._bitLength)),
        (c = Math.max(l[p].length, c)),
        (c = Math.max(l[g].length, c));
      continue;
    }
    var b = [n[p], null, null, n[g]];
    n[p].y.cmp(n[g].y) === 0
      ? ((b[1] = n[p].add(n[g])), (b[2] = n[p].toJ().mixedAdd(n[g].neg())))
      : n[p].y.cmp(n[g].y.redNeg()) === 0
      ? ((b[1] = n[p].toJ().mixedAdd(n[g])), (b[2] = n[p].add(n[g].neg())))
      : ((b[1] = n[p].toJ().mixedAdd(n[g])),
        (b[2] = n[p].toJ().mixedAdd(n[g].neg())));
    var v = [-3, -1, -5, -7, 0, 7, 5, 1, 3],
      w = TOe(r[p], r[g]);
    for (
      c = Math.max(w[0].length, c),
        l[p] = new Array(c),
        l[g] = new Array(c),
        d = 0;
      d < c;
      d++
    ) {
      var x = w[0][d] | 0,
        S = w[1][d] | 0;
      (l[p][d] = v[(x + 1) * 3 + (S + 1)]), (l[g][d] = 0), (a[p] = b);
    }
  }
  var R = this.jpoint(null, null, null),
    O = this._wnafT4;
  for (u = c; u >= 0; u--) {
    for (var B = 0; u >= 0; ) {
      var C = !0;
      for (d = 0; d < i; d++) (O[d] = l[d][u] | 0), O[d] !== 0 && (C = !1);
      if (!C) break;
      B++, u--;
    }
    if ((u >= 0 && B++, (R = R.dblp(B)), u < 0)) break;
    for (d = 0; d < i; d++) {
      var I = O[d];
      I !== 0 &&
        (I > 0
          ? (f = a[d][(I - 1) >> 1])
          : I < 0 && (f = a[d][(-I - 1) >> 1].neg()),
        f.type === "affine" ? (R = R.mixedAdd(f)) : (R = R.add(f)));
    }
  }
  for (u = 0; u < i; u++) a[u] = null;
  return s ? R : R.toP();
};
function Uc(e, t) {
  (this.curve = e), (this.type = t), (this.precomputed = null);
}
g0.BasePoint = Uc;
Uc.prototype.eq = function () {
  throw new Error("Not implemented");
};
Uc.prototype.validate = function () {
  return this.curve.validate(this);
};
g0.prototype.decodePoint = function (t, n) {
  t = ql.toArray(t, n);
  var r = this.p.byteLength();
  if ((t[0] === 4 || t[0] === 6 || t[0] === 7) && t.length - 1 === 2 * r) {
    t[0] === 6
      ? Q5(t[t.length - 1] % 2 === 0)
      : t[0] === 7 && Q5(t[t.length - 1] % 2 === 1);
    var i = this.point(t.slice(1, 1 + r), t.slice(1 + r, 1 + 2 * r));
    return i;
  } else if ((t[0] === 2 || t[0] === 3) && t.length - 1 === r)
    return this.pointFromX(t.slice(1, 1 + r), t[0] === 3);
  throw new Error("Unknown point format");
};
Uc.prototype.encodeCompressed = function (t) {
  return this.encode(t, !0);
};
Uc.prototype._encode = function (t) {
  var n = this.curve.p.byteLength(),
    r = this.getX().toArray("be", n);
  return t
    ? [this.getY().isEven() ? 2 : 3].concat(r)
    : [4].concat(r, this.getY().toArray("be", n));
};
Uc.prototype.encode = function (t, n) {
  return ql.encode(this._encode(n), t);
};
Uc.prototype.precompute = function (t) {
  if (this.precomputed) return this;
  var n = { doubles: null, naf: null, beta: null };
  return (
    (n.naf = this._getNAFPoints(8)),
    (n.doubles = this._getDoubles(4, t)),
    (n.beta = this._getBeta()),
    (this.precomputed = n),
    this
  );
};
Uc.prototype._hasDoubles = function (t) {
  if (!this.precomputed) return !1;
  var n = this.precomputed.doubles;
  return n ? n.points.length >= Math.ceil((t.bitLength() + 1) / n.step) : !1;
};
Uc.prototype._getDoubles = function (t, n) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var r = [this], i = this, s = 0; s < n; s += t) {
    for (var o = 0; o < t; o++) i = i.dbl();
    r.push(i);
  }
  return { step: t, points: r };
};
Uc.prototype._getNAFPoints = function (t) {
  if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
  for (
    var n = [this], r = (1 << t) - 1, i = r === 1 ? null : this.dbl(), s = 1;
    s < r;
    s++
  )
    n[s] = n[s - 1].add(i);
  return { wnd: t, points: n };
};
Uc.prototype._getBeta = function () {
  return null;
};
Uc.prototype.dblp = function (t) {
  for (var n = this, r = 0; r < t; r++) n = n.dbl();
  return n;
};
var WO = Cv(function (e) {
    typeof Object.create == "function"
      ? (e.exports = function (n, r) {
          r &&
            ((n.super_ = r),
            (n.prototype = Object.create(r.prototype, {
              constructor: {
                value: n,
                enumerable: !1,
                writable: !0,
                configurable: !0,
              },
            })));
        })
      : (e.exports = function (n, r) {
          if (r) {
            n.super_ = r;
            var i = function () {};
            (i.prototype = r.prototype),
              (n.prototype = new i()),
              (n.prototype.constructor = n);
          }
        });
  }),
  MOe = ql.assert;
function $c(e) {
  x1.call(this, "short", e),
    (this.a = new sn(e.a, 16).toRed(this.red)),
    (this.b = new sn(e.b, 16).toRed(this.red)),
    (this.tinv = this.two.redInvm()),
    (this.zeroA = this.a.fromRed().cmpn(0) === 0),
    (this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0),
    (this.endo = this._getEndomorphism(e)),
    (this._endoWnafT1 = new Array(4)),
    (this._endoWnafT2 = new Array(4));
}
WO($c, x1);
var IOe = $c;
$c.prototype._getEndomorphism = function (t) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var n, r;
    if (t.beta) n = new sn(t.beta, 16).toRed(this.red);
    else {
      var i = this._getEndoRoots(this.p);
      (n = i[0].cmp(i[1]) < 0 ? i[0] : i[1]), (n = n.toRed(this.red));
    }
    if (t.lambda) r = new sn(t.lambda, 16);
    else {
      var s = this._getEndoRoots(this.n);
      this.g.mul(s[0]).x.cmp(this.g.x.redMul(n)) === 0
        ? (r = s[0])
        : ((r = s[1]), MOe(this.g.mul(r).x.cmp(this.g.x.redMul(n)) === 0));
    }
    var o;
    return (
      t.basis
        ? (o = t.basis.map(function (a) {
            return { a: new sn(a.a, 16), b: new sn(a.b, 16) };
          }))
        : (o = this._getEndoBasis(r)),
      { beta: n, lambda: r, basis: o }
    );
  }
};
$c.prototype._getEndoRoots = function (t) {
  var n = t === this.p ? this.red : sn.mont(t),
    r = new sn(2).toRed(n).redInvm(),
    i = r.redNeg(),
    s = new sn(3).toRed(n).redNeg().redSqrt().redMul(r),
    o = i.redAdd(s).fromRed(),
    a = i.redSub(s).fromRed();
  return [o, a];
};
$c.prototype._getEndoBasis = function (t) {
  for (
    var n = this.n.ushrn(Math.floor(this.n.bitLength() / 2)),
      r = t,
      i = this.n.clone(),
      s = new sn(1),
      o = new sn(0),
      a = new sn(0),
      l = new sn(1),
      c,
      u,
      d,
      f,
      h,
      p,
      g,
      b = 0,
      v,
      w;
    r.cmpn(0) !== 0;

  ) {
    var x = i.div(r);
    (v = i.sub(x.mul(r))), (w = a.sub(x.mul(s)));
    var S = l.sub(x.mul(o));
    if (!d && v.cmp(n) < 0) (c = g.neg()), (u = s), (d = v.neg()), (f = w);
    else if (d && ++b === 2) break;
    (g = v), (i = r), (r = v), (a = s), (s = w), (l = o), (o = S);
  }
  (h = v.neg()), (p = w);
  var R = d.sqr().add(f.sqr()),
    O = h.sqr().add(p.sqr());
  return (
    O.cmp(R) >= 0 && ((h = c), (p = u)),
    d.negative && ((d = d.neg()), (f = f.neg())),
    h.negative && ((h = h.neg()), (p = p.neg())),
    [
      { a: d, b: f },
      { a: h, b: p },
    ]
  );
};
$c.prototype._endoSplit = function (t) {
  var n = this.endo.basis,
    r = n[0],
    i = n[1],
    s = i.b.mul(t).divRound(this.n),
    o = r.b.neg().mul(t).divRound(this.n),
    a = s.mul(r.a),
    l = o.mul(i.a),
    c = s.mul(r.b),
    u = o.mul(i.b),
    d = t.sub(a).sub(l),
    f = c.add(u).neg();
  return { k1: d, k2: f };
};
$c.prototype.pointFromX = function (t, n) {
  (t = new sn(t, 16)), t.red || (t = t.toRed(this.red));
  var r = t.redSqr().redMul(t).redIAdd(t.redMul(this.a)).redIAdd(this.b),
    i = r.redSqrt();
  if (i.redSqr().redSub(r).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var s = i.fromRed().isOdd();
  return ((n && !s) || (!n && s)) && (i = i.redNeg()), this.point(t, i);
};
$c.prototype.validate = function (t) {
  if (t.inf) return !0;
  var n = t.x,
    r = t.y,
    i = this.a.redMul(n),
    s = n.redSqr().redMul(n).redIAdd(i).redIAdd(this.b);
  return r.redSqr().redISub(s).cmpn(0) === 0;
};
$c.prototype._endoWnafMulAdd = function (t, n, r) {
  for (
    var i = this._endoWnafT1, s = this._endoWnafT2, o = 0;
    o < t.length;
    o++
  ) {
    var a = this._endoSplit(n[o]),
      l = t[o],
      c = l._getBeta();
    a.k1.negative && (a.k1.ineg(), (l = l.neg(!0))),
      a.k2.negative && (a.k2.ineg(), (c = c.neg(!0))),
      (i[o * 2] = l),
      (i[o * 2 + 1] = c),
      (s[o * 2] = a.k1),
      (s[o * 2 + 1] = a.k2);
  }
  for (var u = this._wnafMulAdd(1, i, s, o * 2, r), d = 0; d < o * 2; d++)
    (i[d] = null), (s[d] = null);
  return u;
};
function Ao(e, t, n, r) {
  x1.BasePoint.call(this, e, "affine"),
    t === null && n === null
      ? ((this.x = null), (this.y = null), (this.inf = !0))
      : ((this.x = new sn(t, 16)),
        (this.y = new sn(n, 16)),
        r && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)),
        this.x.red || (this.x = this.x.toRed(this.curve.red)),
        this.y.red || (this.y = this.y.toRed(this.curve.red)),
        (this.inf = !1));
}
WO(Ao, x1.BasePoint);
$c.prototype.point = function (t, n, r) {
  return new Ao(this, t, n, r);
};
$c.prototype.pointFromJSON = function (t, n) {
  return Ao.fromJSON(this, t, n);
};
Ao.prototype._getBeta = function () {
  if (this.curve.endo) {
    var t = this.precomputed;
    if (t && t.beta) return t.beta;
    var n = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (t) {
      var r = this.curve,
        i = function (s) {
          return r.point(s.x.redMul(r.endo.beta), s.y);
        };
      (t.beta = n),
        (n.precomputed = {
          beta: null,
          naf: t.naf && { wnd: t.naf.wnd, points: t.naf.points.map(i) },
          doubles: t.doubles && {
            step: t.doubles.step,
            points: t.doubles.points.map(i),
          },
        });
    }
    return n;
  }
};
Ao.prototype.toJSON = function () {
  return this.precomputed
    ? [
        this.x,
        this.y,
        this.precomputed && {
          doubles: this.precomputed.doubles && {
            step: this.precomputed.doubles.step,
            points: this.precomputed.doubles.points.slice(1),
          },
          naf: this.precomputed.naf && {
            wnd: this.precomputed.naf.wnd,
            points: this.precomputed.naf.points.slice(1),
          },
        },
      ]
    : [this.x, this.y];
};
Ao.fromJSON = function (t, n, r) {
  typeof n == "string" && (n = JSON.parse(n));
  var i = t.point(n[0], n[1], r);
  if (!n[2]) return i;
  function s(a) {
    return t.point(a[0], a[1], r);
  }
  var o = n[2];
  return (
    (i.precomputed = {
      beta: null,
      doubles: o.doubles && {
        step: o.doubles.step,
        points: [i].concat(o.doubles.points.map(s)),
      },
      naf: o.naf && { wnd: o.naf.wnd, points: [i].concat(o.naf.points.map(s)) },
    }),
    i
  );
};
Ao.prototype.inspect = function () {
  return this.isInfinity()
    ? "<EC Point Infinity>"
    : "<EC Point x: " +
        this.x.fromRed().toString(16, 2) +
        " y: " +
        this.y.fromRed().toString(16, 2) +
        ">";
};
Ao.prototype.isInfinity = function () {
  return this.inf;
};
Ao.prototype.add = function (t) {
  if (this.inf) return t;
  if (t.inf) return this;
  if (this.eq(t)) return this.dbl();
  if (this.neg().eq(t)) return this.curve.point(null, null);
  if (this.x.cmp(t.x) === 0) return this.curve.point(null, null);
  var n = this.y.redSub(t.y);
  n.cmpn(0) !== 0 && (n = n.redMul(this.x.redSub(t.x).redInvm()));
  var r = n.redSqr().redISub(this.x).redISub(t.x),
    i = n.redMul(this.x.redSub(r)).redISub(this.y);
  return this.curve.point(r, i);
};
Ao.prototype.dbl = function () {
  if (this.inf) return this;
  var t = this.y.redAdd(this.y);
  if (t.cmpn(0) === 0) return this.curve.point(null, null);
  var n = this.curve.a,
    r = this.x.redSqr(),
    i = t.redInvm(),
    s = r.redAdd(r).redIAdd(r).redIAdd(n).redMul(i),
    o = s.redSqr().redISub(this.x.redAdd(this.x)),
    a = s.redMul(this.x.redSub(o)).redISub(this.y);
  return this.curve.point(o, a);
};
Ao.prototype.getX = function () {
  return this.x.fromRed();
};
Ao.prototype.getY = function () {
  return this.y.fromRed();
};
Ao.prototype.mul = function (t) {
  return (
    (t = new sn(t, 16)),
    this.isInfinity()
      ? this
      : this._hasDoubles(t)
      ? this.curve._fixedNafMul(this, t)
      : this.curve.endo
      ? this.curve._endoWnafMulAdd([this], [t])
      : this.curve._wnafMul(this, t)
  );
};
Ao.prototype.mulAdd = function (t, n, r) {
  var i = [this, n],
    s = [t, r];
  return this.curve.endo
    ? this.curve._endoWnafMulAdd(i, s)
    : this.curve._wnafMulAdd(1, i, s, 2);
};
Ao.prototype.jmulAdd = function (t, n, r) {
  var i = [this, n],
    s = [t, r];
  return this.curve.endo
    ? this.curve._endoWnafMulAdd(i, s, !0)
    : this.curve._wnafMulAdd(1, i, s, 2, !0);
};
Ao.prototype.eq = function (t) {
  return (
    this === t ||
    (this.inf === t.inf &&
      (this.inf || (this.x.cmp(t.x) === 0 && this.y.cmp(t.y) === 0)))
  );
};
Ao.prototype.neg = function (t) {
  if (this.inf) return this;
  var n = this.curve.point(this.x, this.y.redNeg());
  if (t && this.precomputed) {
    var r = this.precomputed,
      i = function (s) {
        return s.neg();
      };
    n.precomputed = {
      naf: r.naf && { wnd: r.naf.wnd, points: r.naf.points.map(i) },
      doubles: r.doubles && {
        step: r.doubles.step,
        points: r.doubles.points.map(i),
      },
    };
  }
  return n;
};
Ao.prototype.toJ = function () {
  if (this.inf) return this.curve.jpoint(null, null, null);
  var t = this.curve.jpoint(this.x, this.y, this.curve.one);
  return t;
};
function Vo(e, t, n, r) {
  x1.BasePoint.call(this, e, "jacobian"),
    t === null && n === null && r === null
      ? ((this.x = this.curve.one),
        (this.y = this.curve.one),
        (this.z = new sn(0)))
      : ((this.x = new sn(t, 16)),
        (this.y = new sn(n, 16)),
        (this.z = new sn(r, 16))),
    this.x.red || (this.x = this.x.toRed(this.curve.red)),
    this.y.red || (this.y = this.y.toRed(this.curve.red)),
    this.z.red || (this.z = this.z.toRed(this.curve.red)),
    (this.zOne = this.z === this.curve.one);
}
WO(Vo, x1.BasePoint);
$c.prototype.jpoint = function (t, n, r) {
  return new Vo(this, t, n, r);
};
Vo.prototype.toP = function () {
  if (this.isInfinity()) return this.curve.point(null, null);
  var t = this.z.redInvm(),
    n = t.redSqr(),
    r = this.x.redMul(n),
    i = this.y.redMul(n).redMul(t);
  return this.curve.point(r, i);
};
Vo.prototype.neg = function () {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
Vo.prototype.add = function (t) {
  if (this.isInfinity()) return t;
  if (t.isInfinity()) return this;
  var n = t.z.redSqr(),
    r = this.z.redSqr(),
    i = this.x.redMul(n),
    s = t.x.redMul(r),
    o = this.y.redMul(n.redMul(t.z)),
    a = t.y.redMul(r.redMul(this.z)),
    l = i.redSub(s),
    c = o.redSub(a);
  if (l.cmpn(0) === 0)
    return c.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var u = l.redSqr(),
    d = u.redMul(l),
    f = i.redMul(u),
    h = c.redSqr().redIAdd(d).redISub(f).redISub(f),
    p = c.redMul(f.redISub(h)).redISub(o.redMul(d)),
    g = this.z.redMul(t.z).redMul(l);
  return this.curve.jpoint(h, p, g);
};
Vo.prototype.mixedAdd = function (t) {
  if (this.isInfinity()) return t.toJ();
  if (t.isInfinity()) return this;
  var n = this.z.redSqr(),
    r = this.x,
    i = t.x.redMul(n),
    s = this.y,
    o = t.y.redMul(n).redMul(this.z),
    a = r.redSub(i),
    l = s.redSub(o);
  if (a.cmpn(0) === 0)
    return l.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var c = a.redSqr(),
    u = c.redMul(a),
    d = r.redMul(c),
    f = l.redSqr().redIAdd(u).redISub(d).redISub(d),
    h = l.redMul(d.redISub(f)).redISub(s.redMul(u)),
    p = this.z.redMul(a);
  return this.curve.jpoint(f, h, p);
};
Vo.prototype.dblp = function (t) {
  if (t === 0) return this;
  if (this.isInfinity()) return this;
  if (!t) return this.dbl();
  var n;
  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (n = 0; n < t; n++) r = r.dbl();
    return r;
  }
  var i = this.curve.a,
    s = this.curve.tinv,
    o = this.x,
    a = this.y,
    l = this.z,
    c = l.redSqr().redSqr(),
    u = a.redAdd(a);
  for (n = 0; n < t; n++) {
    var d = o.redSqr(),
      f = u.redSqr(),
    